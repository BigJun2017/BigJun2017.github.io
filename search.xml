<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>MYSQL线上审核规范</title>
      <link href="/2019/06/02/shu-ju-ku/bei-guan-suo-he-le-guan-suo-xue-xi/"/>
      <url>/2019/06/02/shu-ju-ku/bei-guan-suo-he-le-guan-suo-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>最近线上数据库出现了慢查询的问题，因此研究下了下数据库锁相关的东西,参考的比较好的文章如下，方便后面查看。</p><p><a href="https://blog.csdn.net/L_BestCoder/article/details/79298417" target="_blank" rel="noopener">最通俗易懂的乐观锁与悲观锁原理及实现</a><br><a href="https://www.cnblogs.com/goody9807/p/6512468.html" target="_blank" rel="noopener">一分钟教你知道乐观锁和悲观锁的区别</a><br><a href="https://blog.csdn.net/qq_34337272/article/details/81072874" target="_blank" rel="noopener">乐观锁与悲观锁</a><br><a href="https://www.cnblogs.com/itcomputer/articles/5133254.html" target="_blank" rel="noopener">不可重复读和幻读的区别</a><br><a href="https://www.cnblogs.com/Andya/p/7426436.html" target="_blank" rel="noopener">数据库四大特性和事务隔离级别</a><br><a href="https://blog.csdn.net/qq_42743933/article/details/81236658" target="_blank" rel="noopener">数据库中的共享锁和排他锁</a><br><a href="https://blog.csdn.net/cbjcry/article/details/84920174" target="_blank" rel="noopener">MYSQL数据库死锁的原因和解决方法</a><br><a href="https://www.cnblogs.com/frankyou/p/9603784.html" target="_blank" rel="noopener">ySQL在默认事务下各SQL语句使用的锁分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带权重的随机数算法的实现</title>
      <link href="/2019/05/19/hou-duan/java/dai-quan-chong-de-sui-ji-shu-suan-fa-de-shi-xian/"/>
      <url>/2019/05/19/hou-duan/java/dai-quan-chong-de-sui-ji-shu-suan-fa-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>在做一个银行的网页游戏的时候，涉及到一个随机抽奖的模块。具体的需求是：当用户的积分可以抽奖的时候，点击抽奖则消耗指定的积分随机抽取奖品，各种奖品的概率如下：笔记本（10%），手机（20%），充值卡（30%），积分（40%）。因为，奖品的概率是可以设置的，因此考虑Java容器中的TreeMap集合实现该算法。<br><strong>核心逻辑：</strong></p><blockquote><p>累加每个物品的权重笔记本(10%)-手机(30%)-充值卡(60%)-积分(100%)，则4个物品的的权重有效长度区间分别为（0,10]、(10,30]、(30,60]、(60,100]。然后随机出一个[0,10)之间的随机数。落在哪个区间，则该区间之后的元素即为按权重命中的元素。</p></blockquote><p><strong>为什么用TreeMap？</strong></p><blockquote><p> 因为TreeMap底层用红黑树实现，TreeMap中的key是唯一且有序的，因此TreeMap提供了如下方法：</p></blockquote><pre><code>NavigableMap&lt;K,V&gt;    tailMap(K fromKey, boolean inclusive)              返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。K    lastKey()             返回映射中当前最后一个（最高）键。K    firstKey()           返回此映射中当前第一个（最低）键。</code></pre><blockquote><p>试想，当我们用普通的不可动态扩展的方法如if/switch方法实现时，必然是产生一个随机数，然后判断该随机数在哪个概率区间。TreeMap因为有序，因此刚好提供了两个方法tailMap，firstKey用于实现落点区间判断的逻辑，简洁又高效，并且方便动态扩展。<br>具体的代码实现：</p></blockquote><pre><code>package icerno.com.weightRandom;import java.util.ArrayList;import java.util.List;import java.util.SortedMap;import java.util.TreeMap;import org.apache.commons.math3.util.Pair;import com.cookingfox.guava_preconditions.Preconditions;public class WeightRandom&lt;K,V extends Number&gt; {    private TreeMap&lt;Double, K&gt; weightMap = new TreeMap&lt;Double, K&gt;();    public WeightRandom(List&lt;Pair&lt;K, V&gt;&gt; list) {        Preconditions.checkNotNull(list, &quot;list can NOT be null!&quot;);        for (Pair&lt;K, V&gt; pair : list) {            double lastWeight = this.weightMap.size() == 0 ? 0 : this.weightMap.lastKey().doubleValue();//统一转为double            this.weightMap.put(pair.getValue().doubleValue() + lastWeight, pair.getKey());//权重累加        }        System.out.println(&quot;------Tree init OK!--------&quot;);    }    public K random() {        double randomWeight = this.weightMap.lastKey() * Math.random();        SortedMap&lt;Double, K&gt; tailMap = this.weightMap.tailMap(randomWeight, true);        return this.weightMap.get(tailMap.firstKey());    }    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })    public static void main(String[] args)    {        List&lt;Pair&lt;String,Double&gt;&gt; list = new ArrayList&lt;Pair&lt;String,Double&gt;&gt;();        list.add(new Pair&lt;String,Double&gt;(&quot;A&quot;,0.20));        list.add(new Pair&lt;String,Double&gt;(&quot;C&quot;,0.50));        list.add(new Pair&lt;String,Double&gt;(&quot;B&quot;,0.30));        WeightRandom weightRandom = new WeightRandom(list);        Object random = weightRandom.random();        System.out.println(&quot;----Key----&quot;+random);    }}</code></pre><p>注意：TreeMap为异步的非线程安全的，因此在并发要求高时，可以使用如下代码加锁。</p><pre><code>public static Map&lt;Double, K&gt; treemap = Collections.synchronizedMap(new TreeMap&lt;Double, K&gt;());</code></pre><p>参考文章：<br>          <a href="https://www.cnblogs.com/waterystone/p/5708063.html" target="_blank" rel="noopener">权重随机算法的java实现</a><br>         <a href="https://blog.csdn.net/x_i_y_u_e/article/details/46372023" target="_blank" rel="noopener">Java TreeMap 介绍和使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Springboot拦截器无法注入redisTemplate操作工具类问题</title>
      <link href="/2019/05/14/hou-duan/fen-bu-shi-kuang-jia/springboot-lan-jie-qi-wu-fa-zhu-ru-redistemplate-cao-zuo-gong-ju-lei-wen-ti/"/>
      <url>/2019/05/14/hou-duan/fen-bu-shi-kuang-jia/springboot-lan-jie-qi-wu-fa-zhu-ru-redistemplate-cao-zuo-gong-ju-lei-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>最近在做微服务间用户权限打通的时候，由于当初设计的问题，用户的信息没有存在Redis中，而是由请求头携带的，因此需要在用户首次访问的时候缓存用户信息到Redis中，但是redisTemplate却无法注入到拦截其中，核心代码如下所示：<br>SessionInterceptor.java</p><pre><code>package cn.lz.conf.auth;import java.util.concurrent.TimeUnit;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import cn.hutool.json.JSONUtil;import cn.lz.dh.common.utils.effi.PipelineUtil;import cn.lz.dh.feign.dragon.dto.User;/** * * Copyright: Copyright (c) 2019 Jun_Zhou* * @ClassName: SessionInterceptor.java* @Description: Session拦截器，当用户首次访问的时候，*                 根据用户名或者Id查询用户详情并缓存于Redis中[k（用户Id）-&gt;V(用户详情)];* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2019年5月14日 上午10:25:38 */public class SessionInterceptor implements HandlerInterceptor{    @Autowired    RedisTemplate&lt;String, String&gt;    redisTemplate;    //设置默认的额过期时间为15分钟;    private Long                    timeout                = (long) (15 * 60);    //缓存空间名称;    private static final String        CACHE_NAME_SPACE    = &quot;efffi:user:&quot;;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception    {        //当前服务不存在登陆请求，因此不用考虑登陆请求造成的死循环问题;        String userId = request.getHeader(&quot;userid&quot;);        String userName = request.getHeader(&quot;userName&quot;);        Boolean hadCachedCurrentUserInfo = hadCachedCurrentUserInfo(userName, userId);        if (!hadCachedCurrentUserInfo)        {            //当没有缓存当前用户详情的时候调用第三方服务查询用户详情;            User userDetail = PipelineUtil.parseUserInfoFromResEntity(userId);            ValueOperations&lt;String, String&gt; opsForValue = getValueOperations();            if (userDetail != null)            {                String jsonPrettyStr = JSONUtil.toJsonPrettyStr(userDetail);                //缓存用户信息到redis中;                opsForValue.set(CACHE_NAME_SPACE + userId, jsonPrettyStr, timeout, TimeUnit.SECONDS);            }        }        return true;    }    /**     * 该方法将在Controller执行之后，返回视图之前执行，modelAndView表示请求Controller处理之后返回的Model和View对象，所以可以在     * 这个方法中修改modelAndView的属性，从而达到改变返回的模型和视图的效果。     */    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception    {}    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception    {}    /**     *  判断当前用户信息是否被缓存,用于加快访问效率;     * @param userName:用户名;     * @param userid : 用户Id;     * @return:用户信息是否被缓存的标志【true/false】;     */    public Boolean hadCachedCurrentUserInfo(String userName, String userid)    {        Boolean hadCachedCurrentUserInfo = true;        //从Redis中获取指定key的值;        ValueOperations&lt;String, String&gt; opsForValue = getValueOperations();        Object object = opsForValue.get(CACHE_NAME_SPACE + userid);        //根据请求头信息中的用户信息判断session中是否存在有效的用户信息;        if (null == object)        {            hadCachedCurrentUserInfo = false;        }        return hadCachedCurrentUserInfo;    }    /**     * 获取redis中的对象操作句柄;     * @return     */    public ValueOperations&lt;String, String&gt; getValueOperations()    {        ValueOperations&lt;String, String&gt; opsForValue = redisTemplate.opsForValue();        return opsForValue;    }}</code></pre><p>SessionConfiguration.java</p><pre><code>package cn.lz.conf.auth;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;/** * * Copyright: Copyright (c) 2019 Jun_Zhou* * @ClassName: SessionConfiguration.java* @Description: 用户信息Redis缓存相关的配置类;* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2019年5月14日 下午12:38:53*/@Configurationpublic class SessionConfiguration extends WebMvcConfigurerAdapter{  【--&gt;        @Bean        public SessionInterceptor getSessionInterceptor()        {            return new SessionInterceptor();        }    &lt;--】    @Override    public void addInterceptors(InterceptorRegistry registry)    {        registry.addInterceptor(getSessionInterceptor()).addPathPatterns(&quot;/**&quot;);    }}</code></pre><p>最终调试发现，由于拦截器加载的时间点在springcontext之前，所以在拦截器中注入自然为null 。<br>因此解决方法在配置拦截器链的类中先注入这个拦截器，代码如下：</p><pre><code>【--&gt;        @Bean        public SessionInterceptor getSessionInterceptor()        {            return new SessionInterceptor();        }    &lt;--】</code></pre><p>这样，就相当于将当前拦截器交给了Spring的IOC容器管理，因此拦截器中的属性注入自然就不会发生问题了。</p><p>参考文章：<br><a href="https://blog.csdn.net/weixin_34192732/article/details/88476602" target="_blank" rel="noopener">记录解决一个springboot拦截器无法注入redisTemplate操作工具类问题</a><br>                  <a href="https://blog.csdn.net/liuyang1835189/article/details/81056162" target="_blank" rel="noopener">Spring boot整合redis过程中，发现自定义的拦截器注入不了redis接口service。</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件开发中会用到的图</title>
      <link href="/2019/04/14/bian-cheng-zhi-dao/ruan-jian-kai-fa-zhong-hui-yong-dao-de-tu/"/>
      <url>/2019/04/14/bian-cheng-zhi-dao/ruan-jian-kai-fa-zhong-hui-yong-dao-de-tu/</url>
      
        <content type="html"><![CDATA[<p><em><a href="https://www.cnblogs.com/Zachary-Fan/p/developdiagram.html" target="_blank" rel="noopener">转载</a></em></p><p><div class="post"><br>        <h1 class="postTitle"><br>            <a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/Zachary-Fan/p/developdiagram.html" target="_blank" rel="noopener">软件开发中会用到的图</a><br>        </h1><br>        <div class="clear"></div><br>        <div class="postBody"><br>            <div id="cnblogs_post_body" class="blogpost-body"><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><strong style="margin: 0px; padding: 0px;">阅读目录</strong></p></div></div></div></p><p><ul style="margin: 0px 0px 1em 40px; padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"></ul></p><p><li style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style-type: disc;"><a href="#_label0">背景</a></li></p><p><li style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style-type: disc;"><a href="#_label1">图为了解决什么问题</a></li></p><p><li style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style-type: disc;"><a href="#_label2">不同流程中适合运用的图</a></li></p><p><li style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style-type: disc;"><a href="#_label3">实际的运用</a></li></p><p><li style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style-type: disc;"><a href="#_label4">结语</a></li><br></p><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><a style="margin: 0px; padding: 0px;" name="_label0"></a></p><br><h2 style="margin: 20px 0px; padding: 0px; font-size: 21px; line-height: 1.5; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">一、背景</h2><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　大家应该在从事软件开发领域工作时间有一段时间之后，就开始有画图的意识，不管是懵懂的学别人还是想更好的让其它人理解自己的一个观点。所谓“一图胜千言”，我们身处于软件开发这个<strong>水很深且要求精确<strong>的复杂</strong>领域</strong>里，要想把事情做好，最基本的是要把事情想明白，其次还要让相关的人能够明白你要说的东西，进行协作。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　特别对于一位架构师来说，能否画得一手好图尤其重要，因为相关的干系人数较多，要让不同领域的人能够达成一个统一的认识，是一件不太容易但也是必须要做好的事情。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><a style="margin: 0px; padding: 0px;" name="_label1"></a></p><br><h2 style="margin: 20px 0px; padding: 0px; font-size: 21px; line-height: 1.5; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">二、图为了解决什么问题</h2><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　软件开发涉及的流程是：需求 –&gt; 开发 –&gt; 测试 –&gt; 发布上线。作图本身是个设计的工作，是个前期工作。那么从软件开发的整个生命周期来说，用到的图的地方是在前期的需求、开发阶段较多。在软件开发这个非常抽象的领域，只要涉及到多人协作，那么通过文字来进行交流叙述是非常晦涩难懂的，需要沟通好几遍才能理解达成一致也是比较常见的情况。那么我们画图，就是为了把不适合用言语表述的内容通过作图的方式呈现出来，让相关协作者有一个共同的具象的参照物。这个参照物可以有它的额外价值，是对软件长期价值的延伸，一份一致、清晰的设计图，可以给后续的软件迭代提供非常有帮助的决策依据。当然保证设计图与系统的一致本身也是件费精力的事情。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><a style="margin: 0px; padding: 0px;" name="_label2"></a></p><br><h2 style="margin: 20px 0px; padding: 0px; font-size: 21px; line-height: 1.5; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">三、不同流程中适合运用的图</h2><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　1.用例图</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><img src="https://user-images.githubusercontent.com/25767073/56207832-4ddf3700-6082-11e9-82fb-9ff62c65f1f0.png" alt=""></p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　用例图是UML交互图中的一种，是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。用例图（User Case）是外部用户（被称为参与者，一般为软件的面向用户）所能观察到的系统功能的模型图。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　适用场景：当新做一个产品或者功能的时候，首先需要明确核心方向，用例图就是整理这个核心方向的工具。它用来说明的是谁要使用系统，以及他们使用该系统可以做些什么。可以理解为是MVP思想的写照，去除画龙点睛的功能，这些就是基础、核心。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　缺点：仅仅描述的是提供什么功能，不能表达非功能需求，如可靠性、性能等非功能需求。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　</p><br><p>　　2.鲁棒图（Robustness Diagram）</p><br><p>　　<img src="https://user-images.githubusercontent.com/25767073/56207768-2e480e80-6082-11e9-99aa-5de5c9300cd3.png" alt=""></p><br><p>　　可能英文名Robustness Diagram更为常见一些，用于衔接用例图之后的设计，识别出系统在用例图中的各种职责，对后续的细节设计提供基础。算是对用例图的一种延伸。</p><br><p>　　适用场景：在确立用户场景之后，如果需要将关键功能设计出来，那么就需要它了。作图过程中最关键的2个点，发现职责，和梳理各个职责之间的关系。</p><br><p>　　缺点：和用例图是一样缺点，唯一的变化是，其有了粗粒度的实现层面的内容。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　3.思维导图</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　<img src="https://user-images.githubusercontent.com/25767073/56207862-618a9d80-6082-11e9-8426-ccfa1a93ac0d.png" alt="" width="875" height="519"></p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　思维导图是一个很厉害的发明，他将我们的思考过程具象化了，完美展示了由点到面不断发散的过程。但是它最大的价值，反而不是最终呈现出来的这个图，而是促进了思考的过程。并且需要注意的是，一定要把一条分支走到尽头，再回过头来走其它的分支，把思想榨干。&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　适用场景：在一个事情刚开始的萌芽期，不知如何下手；或者陷入一个困境的时候。利用思维导图来活跃大脑，进行发散思维。这时候如果结合头脑风暴，效果更佳。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　缺点：它是一种树状的信息分层可视化展视，结构比较固定，不适合分支间互相交互比较复杂的信息展示。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　</p><br><p>　　4.DFD（Data Flow Diagram）图</p><br><p><img src="https://user-images.githubusercontent.com/25767073/56093811-7985e400-5eff-11e9-8199-9926d45662cc.png" alt="" width="890" height="657"></p><br><p>　　DFD图是从数据传递和加工角度，以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。</p><br><p>　　适用场景：在将思维导图得出的东西进行整合、梳理形成一个粗粒度的流程。这个其实类似与DDD中的上下文映射图，是在需求分析过程中做宏观设计的一种方式。</p><br><p>　　缺点：反映系统“做什么”，不反映“如何做”，粒度算是中等，需要其它更细粒度的图来对细节做支撑。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　5.流程图</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><img src="https://user-images.githubusercontent.com/25767073/56207842-58013580-6082-11e9-8969-54f2f162c64a.png" alt=""></p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><img src="https://images2017.cnblogs.com/blog/397048/201709/397048-20170915164646625-1510099749.jpg" alt=""></p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　</p><br><p>　　上面贴了2张图都是流程图，流程图有时也称作输入-输出图。该图直观地描述一个工作过程的具体步骤，各种操作一目了然，不会产生“歧义性”，便于理解，算法出错时容易发现。流程图对准确了解事情是如何进行的，以及决定应如何改进过程极有帮助。大到系统级别、小到某个操作背后的运转逻辑都可以使用流程图来画，我个人认为这应该是被最多人认识的图，没有之一。</p><br><p>　　适用场景：正如上面所说这个适用场景比较广，日常工作中小到算法逻辑，大到战略层面的执行落地都需要它。主要用它来将背后的流程可视化，辅助做决策去（如改进等）。</p><br><p>　　缺点：所占篇幅较大，由于允许使用流程线，过于灵活，不受约束，使用者可使流程任意转向，从而造成程序阅读和修改上的困难，不利于结构化程序的设计。　　</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;　　</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　6.UML类图</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　<img src="https://user-images.githubusercontent.com/25767073/56207795-3acc6700-6082-11e9-8f58-9c2487131dc4.png" alt="" width="863" height="446"></p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　UML类图是UML交互图中的一种，也是我们较常见的一种。类图是描述系统中的类，以及各个类之间的关系的静态视图。它不但是设计人员关心的核心，更是实现人员关注的核心。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　适用场景：一般作为编码前做的最后一步，将设计转为相应的模型。也可以使用Code First的方式直接在项目中建模，现在的VS也支持直接从代码中生成UML类图。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　缺点：缺点就是画起来太费时间了，但反过来其表达的粒度更细致，是代码实现级别的内容。由于现在有比较多的工具可以从代码生成UML类图，甚至在大部分提倡使用Code First的场景下，我们画UML类图的机会是越来越少了。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p>　　7.状态图</p><br><p>　　<img src="https://user-images.githubusercontent.com/25767073/56207879-6f402300-6082-11e9-92a4-4e22716f031b.png" alt=""></p><br><p>　　状态图是对类图的补充。描述类的对象所有可能的状态，以及事件发生时状态的转移条件。可以捕获对象、子系统和系统的生命周期。他们可以告知一个对象可以拥有的状态，并且事件(如消息的接收、时间的流逝、错误、条件变为真等)会怎么随着时间的推移来影响这些状态。一个状态图应该连接到所有具有清晰的可标识状态和复杂行为的类；该图可以确定类的行为，以及该行为如何根据当前的状态变化，也可以展示哪些事件将会改变类的对象的状态。</p><br><p>　　适用场景：当有一个对象拥有多个状态的时候，想要表达清楚状态之间的演变关系（也就是这个对象的生命周期）。比如通过什么条件触发状态变动的，到达某个状态之后会做什么动作等。这也是基于事件驱动设计的良好可视化图。</p><br><p>　　缺点：仅能表达行为/事件与状态之间的演变关系，不适用于其它领域。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　8.E-R图</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　<img src="https://user-images.githubusercontent.com/25767073/56207744-18d2e480-6082-11e9-9884-72488fae77a9.png" alt=""></p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　E-R图提供了表示实体型(Entity)、属性(Attribute)和联系(Relationship)的方法。其中最核心的还属联系(Relationship)的表示。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　适用场景：虽然在UML类图中，也可以体现出聚合、依赖等关系。但是如果相关联的模型数量巨大的话，你会发现看起来特别费劲，要缩的很小才能看清全貌。这时候你需要E-R图出场了。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　缺点：相对类图来说，E-R图无法定义类/实体的行为。它更面向数据库而不是代码。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　9.UML时序图</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><img src="https://user-images.githubusercontent.com/25767073/56207818-4455cf00-6082-11e9-80ec-4edb84bacba2.png" alt=""></p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　时序图也是UML交互图中的一种，是描述对象是如何交互的，并且将重点放在消息序列上。也就是说，描述消息是如何在对象间发送和接收的。时序图有两个坐标轴：纵坐标轴显示时间，横坐标轴显示对象。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　适用场景：一般当我们想反映一个包含顺序的交互流程，比如http请求的生命周期、页面上某个按钮背后流转细节等情况时，就需要它了。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　缺点：一个时序图仅能面向一个Case，同时画起来比较费时间。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><a style="margin: 0px; padding: 0px;" name="_label3"></a></p><br><h2 style="margin: 20px 0px; padding: 0px; font-size: 21px; line-height: 1.5; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">四、实际的运用</h2><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　其实上一节中图的顺序就是按照由层次从高到底，粒度从粗到细规划的。我们可以用用例图来确定用户核心需求，再用Robustness Diagram定义好关键功能，随后在关键功能的实现上通过思维导图进行发散，然后用DFD图把粗粒度的内容串起来，至此大体的设计工作算是完成了。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　然后再通过流程图、UML类图、状态图、E-R图、时序图在不同的场景确定细节实现。最终就是Coding的事情了。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　至于每个图绘画的规范网上资料比较多，这里就不赘述了。如果大家有什么疑问继续交流。　　</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><a style="margin: 0px; padding: 0px;" name="_label4"></a></p><br><h2 style="margin: 20px 0px; padding: 0px; font-size: 21px; line-height: 1.5; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">五、结语</h2><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　其实最好的图是手稿，不但画起来快，还能让你的思维专注到构思上，用什么颜色之类的问题不会对你产生干扰。另外我们不要为了画图而画图，结合实际的情况把握好尺度，一般情况下，时间上不太会允许我们把图画的面面俱到，能覆盖到核心甚至80%就很好了。</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　本文中部分内容引用自如下地址，感谢分享：</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　1.<a href="https://www.zhihu.com/question/22253854" target="_blank">https://www.zhihu.com/question/22253854</a> &nbsp;匿名用户</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　2.<a href="https://www.zhihu.com/question/31998535/answer/54270159" target="_blank">https://www.zhihu.com/question/31998535/answer/54270159</a>&nbsp;&nbsp;<span style="color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">张恂老师</span></p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">　　3.<a href="http://blog.csdn.net/t131452n/article/details/41381393" target="_blank">http://blog.csdn.net/t131452n/article/details/41381393</a>&nbsp;&nbsp;<span style="color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;"><br></span></p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">作者：<a style="margin: 0px; padding: 0px; color: #000000;" href="http://www.cnblogs.com/Zachary-Fan" target="_blank">Zachary_Fan</a><br style="margin: 0px; padding: 0px;">出处：<a href="http://www.cnblogs.com/Zachary-Fan/p/developdiagram.html" target="_blank">http://www.cnblogs.com/Zachary-Fan/p/developdiagram.html</a></p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p><br><p style="padding: 0px; color: #333333; font-family: Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot中使用@Async实现异步调用</title>
      <link href="/2019/03/24/hou-duan/java/spring-boot-zhong-shi-yong-async-shi-xian-yi-bu-diao-yong/"/>
      <url>/2019/03/24/hou-duan/java/spring-boot-zhong-shi-yong-async-shi-xian-yi-bu-diao-yong/</url>
      
        <content type="html"><![CDATA[<p>参考文章：<br><a href="http://blog.didispace.com/springbootasync/" target="_blank" rel="noopener">Spring Boot中使用@Async实现异步调用</a><br>                  <a href="http://blog.didispace.com/springbootasync-2/" target="_blank" rel="noopener">Spring Boot使用@Async实现异步调用：自定义线程池</a><br>                  <a href="http://blog.didispace.com/springbootasync-3/" target="_blank" rel="noopener">Spring Boot使用@Async实现异步调用：ThreadPoolTaskScheduler线程池的优雅关闭</a><br>                  <a href="http://blog.didispace.com/springbootasync-4/" target="_blank" rel="noopener">Spring Boot使用@Async实现异步调用：使用Future以及定义超时</a></p><pre><code>注意事项：web服务作为主程序，一般不会停止，因此通过@Async标记的子线程相当于在后台执行，和在main函数中测试执行的有所区别。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>纯Java后台实现区分数据的新增、修改、删除操作</title>
      <link href="/2019/03/23/hou-duan/java/chun-java-hou-tai-shi-xian-qu-fen-shu-ju-de-xin-zeng-xiu-gai-shan-chu-cao-zuo/"/>
      <url>/2019/03/23/hou-duan/java/chun-java-hou-tai-shi-xian-qu-fen-shu-ju-de-xin-zeng-xiu-gai-shan-chu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>近期遇到一个问题，就是当 添加、修改、删除 三个业务，都写入controller(控制层)同一个方法时，该怎么区分呢？虽然前端可以加上操作类型，但是后台还得做遍历，效率不高而且比较麻烦。于是乎，我就想了一个方法，在这里跟大家分享一下。</p><ol><li>原理：</li></ol><pre><code>a、添加的数据一般uuid为空;  b、修改的数据拥有uuid;  c、不变的数据toString()结果是相同的;  因此,又以上a、b、c三项可以得出如下公式：</code></pre><blockquote><p> 伪新增的数据 【包含修改的数据】= 新数据 - （新数据 ∩老数据）；<br> 伪删除的数据 【包含修改的数据】= 老数据 - (老数据 ∩新数据)；<br>  更新的数据  = 伪新增数据 ∩ 伪删除数据；<br>  新增的数据 =  伪新增数据  - 更新数据；<br>  删除的数据 =  伪删除的数据  - 更新数据；</p></blockquote><p>2、代码实现<br>    A、OperationAides.java</p><pre><code>package com.cerno.opration_helper.base;/** * * Copyright: Copyright (c) 2019 Jun_Zhou* * @ClassName: OperationAides.java* @Description: 描述操作助手的抽象类,当对象需要实现操作辨别帮助的时候需要集成该类;* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2019年3月23日 下午1:57:31 */public abstract class OperationAides{        /**       * 定义未发生变更的数据;     * @param obj     * @return     */    public abstract boolean equals4Fixed(Object obj);    /**       * 定义发生修改的数据;     * @param obj     * @return     */    public abstract boolean equals4Updated(Object obj);}</code></pre><p>B、OperationHelper.java</p><pre><code>package com.cerno.opration_helper.base;import java.util.List;public interface OperationHelper&lt;T&gt;{    /**     * 获取两个list中的公共部分;     */    List&lt;T&gt; remainAll(List&lt;T&gt; sourceDataList, List&lt;T&gt; targetDataList);    /**     * 从源集合中移除指定的集合;     * @param sourceDataList:源集合;     * @param targetDataList:目标集合[被移除的集合];     * @return     */    List&lt;T&gt; removeAll(List&lt;T&gt; sourceDataList, List&lt;T&gt; targetDataList);    /**     *   从源集合中移除所有被更新的集合;     * @param sourceDataList:源集合;     * @param targetDataList:目标集合[被移除的集合];     * @return     */    List&lt;T&gt; removeAllUpdated(List&lt;T&gt; sourceDataList, List&lt;T&gt; targetDataList);    /**     * 获取伪新增数据,包含修改部分;     * @return     */    List&lt;T&gt; getFakeAddPart();    /**     * 获取伪删除部分数据，包含修改部分;     * @return     */    List&lt;T&gt; getFakeDelPart();    /**      * 获取发生修改的数据集合;     * @return     */    List&lt;T&gt; getUpdatedPart();    /**     * 获取新数据中的新增部分;     * @param oldList:老数据;     * @param newList:最新数据;     * @return :数据中的新增部分;     *                       新增部分 = 新数据 - (新数据∩老数据)                 */    List&lt;T&gt; getAddPart();    /**     * 获取老数据中的删除部分;     * @param oldList:老数据;     * @param newList:最新数据;     * @return :数据中的新增部分;     *                      删除部分 = 新数据 - (新数据∩老数据)     */    List&lt;T&gt; getDelPart();}</code></pre><p>C、ComplexOperationHelper.java</p><pre><code>package com.cerno.opration_helper;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;import com.cerno.opration_helper.base.OperationAides;import com.cerno.opration_helper.base.OperationHelper;/** * * Copyright: Copyright (c) 2019 Jun_Zhou* * @ClassName: ComplexOperationHelper.java* @Description: 复杂操作助手类;* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2019年3月23日 下午1:49:09 */public class ComplexOperationHelper&lt;T extends OperationAides&gt; implements OperationHelper&lt;T&gt;{    //老数据;    protected List&lt;T&gt;    oldDataList    = new ArrayList&lt;T&gt;();    //新数据;    protected List&lt;T&gt;    newDataList    = new ArrayList&lt;T&gt;();    /**     * 构造函数;     * @param oldDataList:老数据;     * @param newDataList:新数据;     */    public ComplexOperationHelper(List&lt;T&gt; oldDataList, List&lt;T&gt; newDataList)    {        this.oldDataList = oldDataList;        this.newDataList = newDataList;    }    public List&lt;T&gt; remainAll(List&lt;T&gt; sourceDataList, List&lt;T&gt; targetDataList)    {        //执行数据的深度复制;        List&lt;T&gt; sourceList = new ArrayList&lt;T&gt;(sourceDataList);        List&lt;T&gt; targetList = new ArrayList&lt;T&gt;(targetDataList);        //执行逻辑运算;        List&lt;T&gt; remainedList = sourceList.stream().filter(sourceEle -&gt; {            boolean isUpdated = false;            for (T t : targetList)            {                if (sourceEle.equals4Updated(t))                {                    isUpdated = true;                    break;                }            }            return isUpdated;        }).collect(Collectors.toList());        return remainedList;    }    @Override    public List&lt;T&gt; removeAll(List&lt;T&gt; sourceDataList, List&lt;T&gt; targetDataList)    {        //执行数据的深度复制;        List&lt;T&gt; sourceList = new ArrayList&lt;T&gt;(sourceDataList);        List&lt;T&gt; targetList = new ArrayList&lt;T&gt;(targetDataList);        //执行逻辑运算;        sourceList.removeIf(sourceEle -&gt; {            for (T t : targetList)            {                if (sourceEle.equals4Fixed(t)) { return true; } //equals4OpHelperFakeCD=&gt;定义未发生变化的数据;            }            return false;        });        List&lt;T&gt; listAfterRemoved = new ArrayList&lt;T&gt;(sourceList);        return listAfterRemoved;    }    @Override    public List&lt;T&gt; removeAllUpdated(List&lt;T&gt; sourceDataList, List&lt;T&gt; targetDataList)    {        //执行数据的深度复制;        List&lt;T&gt; sourceList = new ArrayList&lt;T&gt;(sourceDataList);        List&lt;T&gt; targetList = new ArrayList&lt;T&gt;(targetDataList);        //执行逻辑运算;        sourceList.removeIf(sourceEle -&gt; {            for (T t : targetList)            {                if (sourceEle.equals4Updated(t)) { return true; }            }            return false;        });        List&lt;T&gt; listAfterRemoved = new ArrayList&lt;T&gt;(sourceList);        return listAfterRemoved;    }    @Override    public List&lt;T&gt; getFakeAddPart()    {        //执行数据的深度复制;        List&lt;T&gt; oldDataListCopy = new ArrayList&lt;T&gt;(this.oldDataList);        List&lt;T&gt; newDataListCopy = new ArrayList&lt;T&gt;(this.newDataList);        //获取伪新增的集合;        List&lt;T&gt; fakeAddPart = this.removeAll(newDataListCopy, oldDataListCopy);        return fakeAddPart;    }    @Override    public List&lt;T&gt; getFakeDelPart()    {        //执行数据的深度复制;        List&lt;T&gt; oldDataListCopy = new ArrayList&lt;T&gt;(this.oldDataList);        List&lt;T&gt; newDataListCopy = new ArrayList&lt;T&gt;(this.newDataList);        //获取伪删除的集合;        List&lt;T&gt; fakeDelPart = this.removeAll(oldDataListCopy, newDataListCopy);        return fakeDelPart;    }    @Override    public List&lt;T&gt; getAddPart()    {        //执行数据的深度复制;        List&lt;T&gt; fakeAddPartCopy = new ArrayList&lt;T&gt;(this.getFakeAddPart());        List&lt;T&gt; updatePartCopy = new ArrayList&lt;T&gt;(this.getUpdatedPart());        //获取新增数据的集合;        List&lt;T&gt; addPart = this.removeAllUpdated(fakeAddPartCopy, updatePartCopy);        return addPart;    }    @Override    public List&lt;T&gt; getDelPart()    {        //执行数据的深度复制;        List&lt;T&gt; fakeDelPartCopy = new ArrayList&lt;T&gt;(this.getFakeDelPart());        List&lt;T&gt; updatePartCopy = new ArrayList&lt;T&gt;(this.getUpdatedPart());        //获取被删除的集合数据;        List&lt;T&gt; delPart = this.removeAllUpdated(fakeDelPartCopy, updatePartCopy);        return delPart;    }    @Override    public List&lt;T&gt; getUpdatedPart()    {        //执行数据的深度复制;        List&lt;T&gt; fakeAddPart = new ArrayList&lt;T&gt;(this.getFakeAddPart());        List&lt;T&gt; fakeDelPart = new ArrayList&lt;T&gt;(this.getFakeDelPart());        //获取被更新的数据的集合;        List&lt;T&gt; remainedList = this.remainAll(fakeAddPart, fakeDelPart);        return remainedList;    }}</code></pre><p>D、模拟数据<br>Simulation.java</p><pre><code>package com.cerno.data;import java.util.ArrayList;import java.util.List;import com.cerno.model.People;/** * * Copyright: Copyright (c) 2019 Jun_Zhou* * @ClassName: Simulation.java* @Description: 模拟数据;* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2019年3月20日 下午9:56:13 */public class Simulation{      /**     * 获取新的模拟数据;     * @return     */    public static List&lt;People&gt; getNewSimulationDatas() {        List&lt;People&gt; PeopleList = new ArrayList&lt;People&gt;();        People People1 = new People(&quot;1&quot;, &quot;People12&quot;, &quot;1&quot;, &quot;tinghua1&quot;, &quot;man1&quot;);        People People2 = new People(&quot;2&quot;, &quot;People2&quot;, &quot;2&quot;, &quot;tinghua2&quot;, &quot;man2&quot;);        People People3 = new People(&quot;3&quot;, &quot;People3&quot;, &quot;3&quot;, &quot;tinghua3&quot;, &quot;man3&quot;);        People People4 = new People(&quot;4&quot;, &quot;People4&quot;, &quot;4&quot;, &quot;tinghua4&quot;, &quot;man4&quot;);        People People5 = new People(&quot;5&quot;, &quot;People5&quot;, &quot;5&quot;, &quot;tinghua65&quot;, &quot;man5&quot;);        //People People6 = new People(&quot;6&quot;, &quot;People6&quot;, &quot;6&quot;, &quot;tinghua6&quot;, &quot;man6&quot;);        //People People7 = new People(&quot;7&quot;, &quot;People7&quot;, &quot;7&quot;, &quot;tinghua7&quot;, &quot;man7&quot;);        //People People8 = new People(&quot;8&quot;, &quot;People8&quot;, &quot;8&quot;, &quot;tinghua8&quot;, &quot;man8&quot;);        People People9 = new People(&quot;9&quot;, &quot;People9&quot;, &quot;9&quot;, &quot;tinghua9&quot;, &quot;man9&quot;);        People People10 = new People(&quot;10&quot;, &quot;People10&quot;, &quot;10&quot;, &quot;tinghua10&quot;, &quot;man10&quot;);        People People11 = new People(&quot;11&quot;, &quot;People11&quot;, &quot;11&quot;, &quot;tinghua11&quot;, &quot;man11&quot;);        People People12 = new People(&quot;&quot;, &quot;People12&quot;, &quot;12&quot;, &quot;tinghua12&quot;, &quot;man12&quot;);        People People13 = new People(&quot;&quot;, &quot;People13&quot;, &quot;13&quot;, &quot;tinghua13&quot;, &quot;man13&quot;);        People People14 = new People(&quot;&quot;, &quot;People14&quot;, &quot;14&quot;, &quot;tinghua14&quot;, &quot;man14&quot;);        PeopleList.add(People10);        PeopleList.add(People9);        //PeopleList.add(People8);        //PeopleList.add(People7);        //PeopleList.add(People6);        PeopleList.add(People5);        PeopleList.add(People4);        PeopleList.add(People3);        PeopleList.add(People2);        PeopleList.add(People1);        PeopleList.add(People11);        PeopleList.add(People12);        PeopleList.add(People13);        PeopleList.add(People14);        return PeopleList;    }    /**     * 获取老的模拟数据;     * @return     */    public static List&lt;People&gt; getOldSimulationDatas() {        List&lt;People&gt; PeopleList = new ArrayList&lt;People&gt;();        People People1 = new People(&quot;1&quot;, &quot;People1&quot;, &quot;1&quot;, &quot;tinghua1&quot;, &quot;man1&quot;);        People People2 = new People(&quot;2&quot;, &quot;People2&quot;, &quot;2&quot;, &quot;tinghua2&quot;, &quot;man2&quot;);        People People3 = new People(&quot;3&quot;, &quot;People3&quot;, &quot;3&quot;, &quot;tinghua3&quot;, &quot;man3&quot;);        People People4 = new People(&quot;4&quot;, &quot;People4&quot;, &quot;4&quot;, &quot;tinghua4&quot;, &quot;man4&quot;);        People People5 = new People(&quot;5&quot;, &quot;People5&quot;, &quot;5&quot;, &quot;tinghua5&quot;, &quot;man5&quot;);        People People6 = new People(&quot;6&quot;, &quot;People6&quot;, &quot;6&quot;, &quot;tinghua6&quot;, &quot;man6&quot;);        People People7 = new People(&quot;7&quot;, &quot;People7&quot;, &quot;7&quot;, &quot;tinghua7&quot;, &quot;man7&quot;);        People People8 = new People(&quot;8&quot;, &quot;People8&quot;, &quot;8&quot;, &quot;tinghua8&quot;, &quot;man8&quot;);        People People9 = new People(&quot;9&quot;, &quot;People9&quot;, &quot;9&quot;, &quot;tinghua9&quot;, &quot;man9&quot;);        People People10 = new People(&quot;10&quot;, &quot;People10&quot;, &quot;10&quot;, &quot;tinghua10&quot;, &quot;man10&quot;);        PeopleList.add(People10);        PeopleList.add(People9);        PeopleList.add(People8);        PeopleList.add(People7);        PeopleList.add(People6);        PeopleList.add(People5);        PeopleList.add(People4);        PeopleList.add(People3);        PeopleList.add(People2);        PeopleList.add(People1);        return PeopleList;    }}</code></pre><p>E、测试实体<br>People.java</p><pre><code>package com.cerno.model;import com.cerno.opration_helper.base.OperationAides;/** * * Copyright: Copyright (c) 2019 Jun_Zhou* * @ClassName: people.java* @Description: 描述人员的实体类;* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2019年3月23日 下午2:00:23 */public class People extends OperationAides{    private String    uuid;    private String    name;    private String    age;    private String    school;    private String    sex;    public People(String uuid, String name, String age, String school, String sex)    {        this.uuid = uuid;        this.name = name;        this.age = age;        this.school = school;        this.sex = sex;    }    public String getUuid()    {        return uuid;    }    public void setUuid(String uuid)    {        this.uuid = uuid;    }    public String getName()    {        return name;    }    public void setName(String name)    {        this.name = name;    }    public String getAge()    {        return age;    }    public void setAge(String age)    {        this.age = age;    }    public String getSchool()    {        return school;    }    public void setSchool(String school)    {        this.school = school;    }    public String getSex()    {        return sex;    }    public void setSex(String sex)    {        this.sex = sex;    }    @Override    public boolean equals4Fixed(Object obj)    {        People object = (People) obj;        return this.toString().equals(object.toString());    }    @Override    public boolean equals4Updated(Object obj)    {        People object = (People) obj;        String objectUuid = object.getUuid();        String currentUuid = this.uuid;        if (((!&quot;&quot;.equals(objectUuid)) &amp;&amp; (objectUuid != null)) &amp;&amp; ((!&quot;&quot;.equals(currentUuid)) &amp;&amp; (currentUuid != null)))        {            if (objectUuid.equals(currentUuid)) { return true; }        }        return false;    }    @Override    public String toString()    {        return &quot;Person [uuid=&quot; + uuid + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;, school=&quot; + school + &quot;, sex=&quot; + sex + &quot;]&quot;;    }}</code></pre><p>F、测试客户端<br>TestClient.java</p><pre><code>package com.cerno.test;import java.util.List;import com.cerno.data.Simulation;import com.cerno.model.People;import com.cerno.opration_helper.ComplexOperationHelper;/** * * Copyright: Copyright (c) 2019 Jun_Zhou* * @ClassName: TestClient.java* @Description: 测试客户端;* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2019年3月20日 下午9:48:04 */public class TestClient{    public static void main(String[] args)    {        //原始数据的集合;        List&lt;People&gt; oldPeopleList = Simulation.getOldSimulationDatas();        //最新数据的集合;        List&lt;People&gt; newPeopleList = Simulation.getNewSimulationDatas();        ComplexOperationHelper&lt;People&gt; complexOperationHelper = new ComplexOperationHelper&lt;People&gt;(oldPeopleList, newPeopleList);        //获取新增部分【修改+真新增】;        List&lt;People&gt; addPart = complexOperationHelper.getAddPart();        //获取删除部分【修改+真删除】;        List&lt;People&gt; delPart = complexOperationHelper.getDelPart();        //获取更新部分;        List&lt;People&gt; updatedPart = complexOperationHelper.getUpdatedPart();        System.out.println(&quot;---------------Add-Part--------------&quot;);        addPart.forEach(oldEle -&gt; {            System.out.println(oldEle.getUuid() + &quot;------&gt;&quot; + oldEle.getName());        });        System.out.println(&quot;---------------Del-Part--------------&quot;);        delPart.forEach(oldEle -&gt; {            System.out.println(oldEle.getUuid() + &quot;------&gt;&quot; + oldEle.getName());        });        System.out.println(&quot;---------------Update-Part--------------&quot;);        updatedPart.forEach(oldEle -&gt; {            System.out.println(oldEle.getUuid() + &quot;------&gt;&quot; + oldEle.getName());        });    }}</code></pre><p>3、使用步骤</p><blockquote><p>1、实体类继承OperationAides类，并重写equals4Fixed和equals4Updated以及生成对象的toString()方法;<br>2、使用助手工具类获取增加、修改、删除部分的数据集合;</p></blockquote><pre><code>       //原始数据的集合;        List&lt;People&gt; oldPeopleList = Simulation.getOldSimulationDatas();        //最新数据的集合;        List&lt;People&gt; newPeopleList = Simulation.getNewSimulationDatas();        ComplexOperationHelper&lt;People&gt; complexOperationHelper = new ComplexOperationHelper&lt;People&gt;(oldPeopleList, newPeopleList);        //获取新增部分【修改+真新增】;        List&lt;People&gt; addPart = complexOperationHelper.getAddPart();        //获取删除部分【修改+真删除】;        List&lt;People&gt; delPart = complexOperationHelper.getDelPart();        //获取更新部分;        List&lt;People&gt; updatedPart = complexOperationHelper.getUpdatedPart();</code></pre><p>开源地址：<a href="https://github.com/JunZhou2016/ComplexOprationHelper.git" target="_blank" rel="noopener">https://github.com/JunZhou2016/ComplexOprationHelper.git</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker的概念和相关属性</title>
      <link href="/2019/02/28/ruan-jian-gong-ju/docker/docker-de-gai-nian-he-xiang-guan-shu-xing/"/>
      <url>/2019/02/28/ruan-jian-gong-ju/docker/docker-de-gai-nian-he-xiang-guan-shu-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-Docker的核心概念"><a href="#第一章-Docker的核心概念" class="headerlink" title="第一章 Docker的核心概念"></a>第一章 Docker的核心概念</h2><blockquote><p>1.1Docker镜像 Docker镜像类似于虚拟机镜像，可以将其理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统【Ubuntu、Centos、Alpine、BusyBox】环境，里面仅安装了Jenkins应用程序，那么这个文件就可以被称为Jenkins镜像。<br>镜像是创建Docker容器的基础，通过版本管理和增量的文件系统控制，用户可以十分方便的获取Docker镜像.<br>1.2Docker容器 Docker容器是Docker镜像运行的实例。Docker容器类似Linux系统环境（包括root用户权限、进程空间、用户空间和网络等）。</p></blockquote><h2 id="第二章-镜像的基本属性"><a href="#第二章-镜像的基本属性" class="headerlink" title="第二章 镜像的基本属性"></a>第二章 镜像的基本属性</h2><blockquote><p>2.1 Docker镜像的基本属性 Docker镜像包含五个基本属性和一个不常用的属性。</p><ol><li>REPOSITORY:描述当前镜像来自于那个镜像仓库;</li><li>TAG：镜像的标签信息，比如14.04、latest用来标注不同的版本信息。    TAG信息用来标记来自同一个仓库的不同镜像，例如ubuntu仓库中有多个镜像，可以通过TAG信息来区分发行版本。</li><li>IMAGE ID：镜像的ID(镜像的唯一标识)；</li><li>CREATED:镜像的创建时间;</li><li>SIZE：镜像的大小</li><li>DIGEST:镜像的数字摘要信息，用来判断镜像是否变更[非常见属性]。 图1、镜像的基本属性</li></ol><p>图2、镜像TAG属性图示</p><p>Docker镜像的详细信息如文本所示：<br>参照文章：<a href="http://www.ityouknow.com/docker/2018/03/15/docker-dockerfile-command-introduction.html" target="_blank" rel="noopener">http://www.ityouknow.com/docker/2018/03/15/docker-dockerfile-command-introduction.html</a></p></blockquote><h2 id="第三章-容器的基本属性"><a href="#第三章-容器的基本属性" class="headerlink" title="第三章 容器的基本属性"></a>第三章 容器的基本属性</h2><blockquote><p>Docker镜像包含五个基本属性和一个不常用的属性。</p><ol><li>CONTAINER_ID：表示容器ID;</li><li>IMAGE：表示镜像名称。</li><li>COMMAND：表示启动容器时运行的命令。</li><li>CREATED：表示容器的创建时间。</li><li>STATUS：表示容器运行的状态。Up表示运行中，Exited表示已停止。</li><li>表示容器对外的端口号。</li><li>NAMES：表示容器名称。该名称默认由Docker自动生成，也可使用docker run命令的–name选项自行指定。</li></ol></blockquote><p> <a href="https://pan.baidu.com/s/19BjgIeAB3IogzDmwrl23rw" target="_blank" rel="noopener">配套文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker学习笔记（二）基本软件的Docker安装【基本安装，可能不适用于生产环境】</title>
      <link href="/2019/02/24/ruan-jian-gong-ju/docker/docker-xue-xi-bi-ji-er-ji-ben-ruan-jian-de-docker-an-zhuang-ji-ben-an-zhuang-ke-neng-bu-gua-yong-yu-sheng-chan-huan-jing/"/>
      <url>/2019/02/24/ruan-jian-gong-ju/docker/docker-xue-xi-bi-ji-er-ji-ben-ruan-jian-de-docker-an-zhuang-ji-ben-an-zhuang-ke-neng-bu-gua-yong-yu-sheng-chan-huan-jing/</url>
      
        <content type="html"><![CDATA[<p>通过Docker安装常用软件，包产Mysql、Redis等。。。。。。</p><ol><li>Mysql安装</li></ol><pre><code>docker run --name mysql_server -e MYSQL_ROOT_PASSWORD=123 -d mysql:latestQA:http://www.hellojava.com/a/59120.html</code></pre><p> 2.Mongo安装</p><pre><code>docker run --name mongo_db_server -d -p 27017:27017 mongo</code></pre><p>3.Redis安装</p><pre><code>docker run --name redis_db_server -d -p 6379:6379  redis</code></pre><p>4.Jenkins安装</p><pre><code>docker run -p 8080:8080 -p 50000:50000 jenkins</code></pre><p>5.Gitlab安装 </p><pre><code>docker run --detach \--hostname gitlab.example.com \--publish 443:443 --publish 80:80 --publish 23:23 \--name gitlab \--restart always \--volume /root/Documents/config:/etc/gitlab  \--volume  /root/Documents/logs:/var/log/gitlab \--volume /root/Documents/data:/var/opt/gitlab \gitlab/gitlab-ce:latest</code></pre><h2 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h2><p><a href="http://www.itmuch.com/docker/02-docker-install/" target="_blank" rel="noopener">a.docker安装</a><br><a href="http://www.itmuch.com/docker/03-docker-mirror/" target="_blank" rel="noopener">b.配置镜像加速</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker学习笔记（一）什么是docker？</title>
      <link href="/2019/02/24/ruan-jian-gong-ju/docker/docker-xue-xi-bi-ji-yi-shi-me-shi-docker/"/>
      <url>/2019/02/24/ruan-jian-gong-ju/docker/docker-xue-xi-bi-ji-yi-shi-me-shi-docker/</url>
      
        <content type="html"><![CDATA[<p>什么是Docker?<br>       理解Docker首先需要理解Docker的三大核心概念。</p><pre><code>   1、镜像【Image】   </code></pre><blockquote><p> Docker镜像类似于虚拟机镜像，可以将其理解为一个只读的模板。例如一个镜像中可以包含Mysql、JDK并进行了合理的配置。而这些配置和软件的下载则是通过Docker执行Dockerfile中定义的固定格式的脚本实现的。</p></blockquote><pre><code>   2、容器【Container】</code></pre><blockquote><p> Docker容器是Docker镜像运行的产物，当用户通过Docker执行build命令时，Docker会定义一个基本的虚拟机定义文件，即Docker镜像文件，里面包含了Dockerfile中定义的各种软件和配置以及基本的操作系统，当通过Docker执行Run命令的时候，相关的进程则会根据镜像文件中的定义真正的划分资源。</p></blockquote><pre><code>   3、仓库【Repository】</code></pre><blockquote><p> Docker仓库类似于代码仓库Github或者Gitlab，它是Docker集中存放镜像文件的场所。</p><p>综上所述：Docker是一款类似VMWare的软件，它掌管者Docker镜像的构建以及镜像文件的激活运行。并且Docker镜像的本质就是小型操作系统的镜像，里面有用户自定义的各种软件和配置。而容器则是镜像运行的产物【容器的本质就是高性能的小型虚拟机】，就像操作系统时系统镜像运行的产物一样。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用github+hexo搭建个人博客并创建图床【带视频教程】</title>
      <link href="/2019/02/17/ruan-jian-gong-ju/git/li-yong-github-hexo-da-jian-ge-ren-bo-ke-bing-chuang-jian-tu-chuang-dai-shi-pin-jiao-cheng/"/>
      <url>/2019/02/17/ruan-jian-gong-ju/git/li-yong-github-hexo-da-jian-ge-ren-bo-ke-bing-chuang-jian-tu-chuang-dai-shi-pin-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-hexo-搭建个人博客的步骤和要点"><a href="#Git-hexo-搭建个人博客的步骤和要点" class="headerlink" title="Git+hexo 搭建个人博客的步骤和要点"></a>Git+hexo 搭建个人博客的步骤和要点</h2><p>步骤：<br>1、    安装nodejs+git+tortoisegit<br>2、    注册github账号，并创建个人独立主页仓库，就是那个username.github.io仓库;<br>3、    安装和初始化hexo博客脚手架;<br>4、    去hexo选择适合自己的博客主题;<br>5、    发布本地博客到github；<br>6、    创建github图床【有自己图片服务器的可以不用，建议不要使用七牛】；<br>建议：<br>    个人书写.md文件的博客不太好控制样式，建议利用csdn的markdow编辑器。</p><p>参考文章：<br>    <a href="https://www.cnblogs.com/trista222/p/8017300.html" target="_blank" rel="noopener">https://www.cnblogs.com/trista222/p/8017300.html</a><br>    <a href="https://blog.csdn.net/zj20142213/article/details/87557548" target="_blank" rel="noopener">https://blog.csdn.net/zj20142213/article/details/87557548</a><br>视频教程：<br>   <a href="https://pan.baidu.com/s/120YMAMaqmVFtr6_WD6rYDQ" target="_blank" rel="noopener">https://pan.baidu.com/s/120YMAMaqmVFtr6_WD6rYDQ</a><br>安装工具：<br>   <a href="https://pan.baidu.com/s/1aivdaM1V6yZGYeS6r_iP3A" target="_blank" rel="noopener">https://pan.baidu.com/s/1aivdaM1V6yZGYeS6r_iP3A</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apollo配置中心和SpringCloud中Zuul结合使用创建配置网关</title>
      <link href="/2019/01/03/hou-duan/fen-bu-shi-kuang-jia/apollo-pei-zhi-zhong-xin-he-springcloud-zhong-zuul-jie-he-shi-yong-chuang-jian-pei-zhi-wang-guan/"/>
      <url>/2019/01/03/hou-duan/fen-bu-shi-kuang-jia/apollo-pei-zhi-zhong-xin-he-springcloud-zhong-zuul-jie-he-shi-yong-chuang-jian-pei-zhi-wang-guan/</url>
      
        <content type="html"><![CDATA[<p>当配置中心要求高可用的时候，集群是一种不错的解决办法。当配置中心进行集群的时候，Zuul就派上了用场。并且Apollo和SpringCloud中zuul结合非常的方便，此处只解释在结合网关中路由刷新的部分原理：</p><p>  前提：在Apollo的Portal的某个项目下存在公共的路由配置命名空间。如下图：<br>  <img src="https://user-images.githubusercontent.com/25767073/50639692-51e8bc80-0f9d-11e9-9203-ccec1b250503.png" alt="在这里插入图片描述"></p><p>核心代码：</p><pre><code>package cn.springcloud.book.zuul.config;import com.ctrip.framework.apollo.model.ConfigChangeEvent;import com.ctrip.framework.apollo.spring.annotation.ApolloConfigChangeListener;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.BeansException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.context.environment.EnvironmentChangeEvent;import org.springframework.cloud.netflix.zuul.RoutesRefreshedEvent;import org.springframework.cloud.netflix.zuul.filters.RouteLocator;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;@Componentpublic class ZuulPropertiesRefresher implements ApplicationContextAware {  private static final Logger logger = LoggerFactory.getLogger(ZuulPropertiesRefresher.class);  private ApplicationContext applicationContext;  @Autowired  private RouteLocator routeLocator;  @ApolloConfigChangeListener(value = &quot;TEST1.zuul-config&quot;)  public void onChange(ConfigChangeEvent changeEvent) {    boolean zuulPropertiesChanged = false;    for (String changedKey : changeEvent.changedKeys()) {      if (changedKey.startsWith(&quot;zuul.&quot;)) {        zuulPropertiesChanged = true;        break;      }    }    if (zuulPropertiesChanged) {      refreshZuulProperties(changeEvent);    }  }  private void refreshZuulProperties(ConfigChangeEvent changeEvent) {    logger.info(&quot;Refreshing zuul properties!&quot;);    /**     * rebind configuration beans, e.g. ZuulProperties     * @see org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder#onApplicationEvent     */     //核心代码一；    this.applicationContext.publishEvent(new EnvironmentChangeEvent(changeEvent.changedKeys()));    /**     * refresh routes     * @see org.springframework.cloud.netflix.zuul.ZuulServerAutoConfiguration.ZuulRefreshListener#onApplicationEvent     */       //核心代码二；    this.applicationContext.publishEvent(new RoutesRefreshedEvent(routeLocator));    logger.info(&quot;Zuul properties refreshed!&quot;);  }  @Override  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {    this.applicationContext = applicationContext;  }}</code></pre><p>如上配置路由刷新的核心代码实际上是采用我们常说的观察者，或者发布-订阅模型来实现的，上面的核心代码一和核心代码二实际上就是时间发布者。</p><p>如核心代码以对应的监听者如下：</p><pre><code>/* * Copyright 2013-2014 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.cloud.context.properties;import java.util.HashSet;import java.util.Map;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import org.springframework.aop.framework.Advised;import org.springframework.aop.support.AopUtils;import org.springframework.beans.BeansException;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.cloud.context.environment.EnvironmentChangeEvent;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.context.ApplicationListener;import org.springframework.core.env.Environment;import org.springframework.jmx.export.annotation.ManagedAttribute;import org.springframework.jmx.export.annotation.ManagedOperation;import org.springframework.jmx.export.annotation.ManagedResource;import org.springframework.stereotype.Component;/** * Listens for {@link EnvironmentChangeEvent} and rebinds beans that were bound to the * {@link Environment} using {@link ConfigurationProperties * &lt;code&gt;@ConfigurationProperties&lt;/code&gt;}. When these beans are re-bound and * re-initialized the changes are available immediately to any component that is using the * &lt;code&gt;@ConfigurationProperties&lt;/code&gt; bean. * * @see RefreshScope for a deeper and optionally more focused refresh of bean components * * @author Dave Syer * */@Component@ManagedResourcepublic class ConfigurationPropertiesRebinder        implements ApplicationContextAware, ApplicationListener&lt;EnvironmentChangeEvent&gt; {    private ConfigurationPropertiesBeans beans;    private ApplicationContext applicationContext;    private Map&lt;String, Exception&gt; errors = new ConcurrentHashMap&lt;&gt;();    public ConfigurationPropertiesRebinder(ConfigurationPropertiesBeans beans) {        this.beans = beans;    }    @Override    public void setApplicationContext(ApplicationContext applicationContext)            throws BeansException {        this.applicationContext = applicationContext;    }    /**     * A map of bean name to errors when instantiating the bean.     *     * @return the errors accumulated since the latest destroy     */    public Map&lt;String, Exception&gt; getErrors() {        return this.errors;    }    @ManagedOperation    public void rebind() {        this.errors.clear();        for (String name : this.beans.getBeanNames()) {            rebind(name);        }    }    @ManagedOperation    public boolean rebind(String name) {        if (!this.beans.getBeanNames().contains(name)) {            return false;        }        if (this.applicationContext != null) {            try {                Object bean = this.applicationContext.getBean(name);                if (AopUtils.isAopProxy(bean)) {                    bean = getTargetObject(bean);                }                if (bean != null) {                    this.applicationContext.getAutowireCapableBeanFactory().destroyBean(bean);                    this.applicationContext.getAutowireCapableBeanFactory()                            .initializeBean(bean, name);                    return true;                }            }            catch (RuntimeException e) {                this.errors.put(name, e);                throw e;            }            catch (Exception e) {                this.errors.put(name, e);                throw new IllegalStateException(&quot;Cannot rebind to &quot; + name, e);            }        }        return false;    }    @SuppressWarnings(&quot;unchecked&quot;)    private static &lt;T&gt; T getTargetObject(Object candidate) {        try {            if (AopUtils.isAopProxy(candidate) &amp;&amp; (candidate instanceof Advised)) {                return (T) ((Advised) candidate).getTargetSource().getTarget();            }        }        catch (Exception ex) {            throw new IllegalStateException(&quot;Failed to unwrap proxied object&quot;, ex);        }        return (T) candidate;    }    @ManagedAttribute    public Set&lt;String&gt; getBeanNames() {        return new HashSet&lt;String&gt;(this.beans.getBeanNames());    }   //这段代码即上述核心代码一所发布事件的的监听方法。    @Override    public void onApplicationEvent(EnvironmentChangeEvent event) {        if (this.applicationContext.equals(event.getSource())                // Backwards compatible                || event.getKeys().equals(event.getSource())) {            rebind();        }    }}</code></pre><p>参考文章：<br><a href="https://blog.csdn.net/tuzongxun/article/details/53637159" target="_blank" rel="noopener">spring中自定义Event事件的使用和浅析</a></p><p><a href="https://xls9577087.iteye.com/blog/2121752" target="_blank" rel="noopener">spring事件机制</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Apollo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中内存数据流的使用</title>
      <link href="/2018/12/29/hou-duan/java/java-zhong-nei-cun-shu-ju-liu-de-shi-yong/"/>
      <url>/2018/12/29/hou-duan/java/java-zhong-nei-cun-shu-ju-liu-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p><strong>内存流存在的意义：</strong></p><pre><code>    当我们不需要持久化存储数据，而仅仅是需要进行数据中转的时候，就可以使用内存流。</code></pre><p><strong>内存流的使用场景：</strong></p><pre><code>         1.代码中需要交换的数据，读写的数据，仅仅是代码之间需要交换，就没必要    内存 ==》 磁盘   磁盘 ==》内存 【可以在内存读写上提高了效率】          2.好处：提高了读写的效率，即数据处理的效率 。</code></pre><p><strong>内存流的具体实现类：</strong></p><blockquote><p> <em>ByteArrayInputStream</em> ：<code>ByteArrayInputStream extends InputStream</code>，包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪 read 方法要提供的下一个字节。</p></blockquote><blockquote><p> *<em>ByteArrayOutputStream</em> ：<code>ByteArrayOutputStream extends OutputStream</code>， 此类实现了一个输出流，其中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。</p></blockquote><blockquote><p> <em>CharArrayReader:</em> <code>CharArrayReader extends Reader</code>，此类实现一个可用作字符输入流的字符缓冲区。 </p></blockquote><blockquote><p> <em>CharArrayWriter</em>：<code>CharArrayWriter extends Writer</code>，此类实现一个可用作 Writer 的字符缓冲区。缓冲区会随向流中写入数据而自动增长。可使用 toCharArray() 和 toString() 获取数据。</p></blockquote><p> 测试代码：<br> StrRes.java</p><pre><code>package com.icerno.cloud.model;/** * * Copyright: Copyright (c) 2018 Jun_Zhou* * @ClassName: StrRes.java* @Description: 字符串数据源;* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2018年12月28日 上午11:30:54 */public class StrRes{    public static String resStr = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\r\n&quot; +             &quot;&lt;project xmlns=\&quot;http://maven.apache.org/POM/4.0.0\&quot;\r\n&quot; +             &quot;    xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot;\r\n&quot; +             &quot;    xsi:schemaLocation=\&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\&quot;&gt;\r\n&quot; +             &quot;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\r\n&quot; +             &quot;    &lt;parent&gt;\r\n&quot; +             &quot;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n&quot; +             &quot;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\r\n&quot; +             &quot;        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;\r\n&quot; +             &quot;        &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;\r\n&quot; +             &quot;    &lt;/parent&gt;\r\n&quot; +             &quot;    &lt;groupId&gt;com.icerno&lt;/groupId&gt;\r\n&quot; +             &quot;    &lt;artifactId&gt;SpringCloudUtils&lt;/artifactId&gt;\r\n&quot; +             &quot;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\r\n&quot; +             &quot;    &lt;name&gt;SpringCloudUtils&lt;/name&gt;\r\n&quot; +             &quot;    &lt;description&gt;Utils for Spring Cloud&lt;/description&gt;\r\n&quot; +             &quot;\r\n&quot; +             &quot;    &lt;properties&gt;\r\n&quot; +             &quot;        &lt;java.version&gt;1.8&lt;/java.version&gt;\r\n&quot; +             &quot;    &lt;/properties&gt;\r\n&quot; +             &quot;\r\n&quot; +             &quot;    &lt;dependencies&gt;\r\n&quot; +             &quot;        &lt;dependency&gt;\r\n&quot; +             &quot;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n&quot; +             &quot;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\r\n&quot; +             &quot;        &lt;/dependency&gt;\r\n&quot; +             &quot;\r\n&quot; +             &quot;        &lt;dependency&gt;\r\n&quot; +             &quot;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n&quot; +             &quot;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\r\n&quot; +             &quot;            &lt;scope&gt;test&lt;/scope&gt;\r\n&quot; +             &quot;        &lt;/dependency&gt;\r\n&quot; +             &quot;\r\n&quot; +             &quot;        &lt;!-- jgit相关的依赖 --&gt;\r\n&quot; +             &quot;        &lt;dependency&gt;\r\n&quot; +             &quot;            &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;\r\n&quot; +             &quot;            &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;\r\n&quot; +             &quot;            &lt;version&gt;4.8.0.201706111038-r&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$ --&gt;\r\n&quot; +             &quot;        &lt;/dependency&gt;\r\n&quot; +             &quot;        &lt;!-- gitLab4j相关的依赖 --&gt;\r\n&quot; +             &quot;        &lt;dependency&gt;\r\n&quot; +             &quot;            &lt;groupId&gt;org.gitlab4j&lt;/groupId&gt;\r\n&quot; +             &quot;            &lt;artifactId&gt;gitlab4j-api&lt;/artifactId&gt;\r\n&quot; +             &quot;            &lt;version&gt;4.8.7&lt;/version&gt;\r\n&quot; +             &quot;        &lt;/dependency&gt;\r\n&quot; +             &quot;        &lt;!-- HuTool相关的依赖 --&gt;\r\n&quot; +             &quot;        &lt;dependency&gt;\r\n&quot; +             &quot;            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;\r\n&quot; +             &quot;            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;\r\n&quot; +             &quot;            &lt;version&gt;4.1.19&lt;/version&gt;\r\n&quot; +             &quot;        &lt;/dependency&gt;\r\n&quot; +             &quot;        &lt;!-- Json-Web——Token相关的依赖 --&gt;\r\n&quot; +             &quot;        &lt;dependency&gt;\r\n&quot; +             &quot;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\r\n&quot; +             &quot;            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;\r\n&quot; +             &quot;            &lt;version&gt;0.7.0&lt;/version&gt;\r\n&quot; +             &quot;        &lt;/dependency&gt;\r\n&quot; +             &quot;        &lt;!-- 文本比较的工具类 --&gt;\r\n&quot; +             &quot;        &lt;dependency&gt;\r\n&quot; +             &quot;            &lt;groupId&gt;com.googlecode.java-diff-utils&lt;/groupId&gt;\r\n&quot; +             &quot;            &lt;artifactId&gt;diffutils&lt;/artifactId&gt;\r\n&quot; +             &quot;            &lt;version&gt;1.2.1&lt;/version&gt;\r\n&quot; +             &quot;        &lt;/dependency&gt;\r\n&quot; +             &quot;        &lt;!-- https://mvnrepository.com/artifact/org.apache.directory.studio/org.apache.commons.io --&gt;\r\n&quot; +             &quot;        &lt;dependency&gt;\r\n&quot; +             &quot;            &lt;groupId&gt;org.apache.directory.studio&lt;/groupId&gt;\r\n&quot; +             &quot;            &lt;artifactId&gt;org.apache.commons.io&lt;/artifactId&gt;\r\n&quot; +             &quot;            &lt;version&gt;2.4&lt;/version&gt;\r\n&quot; +             &quot;        &lt;/dependency&gt;\r\n&quot; +             &quot;        &lt;!-- \r\n&quot; +             &quot;        &lt;dependency&gt;\r\n&quot; +             &quot;            &lt;groupId&gt;com.googlecode.java-diff-utils&lt;/groupId&gt;\r\n&quot; +             &quot;            &lt;artifactId&gt;diffutils&lt;/artifactId&gt;\r\n&quot; +             &quot;            &lt;version&gt;1.3.0&lt;/version&gt;\r\n&quot; +             &quot;        &lt;/dependency&gt; --&gt;\r\n&quot; +             &quot;        &lt;!-- 工具类 --&gt;\r\n&quot; +             &quot;        &lt;dependency&gt;\r\n&quot; +             &quot;            &lt;groupId&gt;lz.cloud&lt;/groupId&gt;\r\n&quot; +             &quot;            &lt;artifactId&gt;lz-common-tools&lt;/artifactId&gt;\r\n&quot; +             &quot;            &lt;version&gt;1.0.0&lt;/version&gt;\r\n&quot; +             &quot;            &lt;exclusions&gt;\r\n&quot; +             &quot;                &lt;exclusion&gt;\r\n&quot; +             &quot;                    &lt;groupId&gt;QRCode&lt;/groupId&gt;\r\n&quot; +             &quot;                    &lt;artifactId&gt;QRCode&lt;/artifactId&gt;\r\n&quot; +             &quot;                &lt;/exclusion&gt;\r\n&quot; +             &quot;                &lt;exclusion&gt;\r\n&quot; +             &quot;                    &lt;groupId&gt;javax.mail&lt;/groupId&gt;\r\n&quot; +             &quot;                    &lt;artifactId&gt;mail&lt;/artifactId&gt;\r\n&quot; +             &quot;                &lt;/exclusion&gt;\r\n&quot; +             &quot;                &lt;exclusion&gt;\r\n&quot; +             &quot;                    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\r\n&quot; +             &quot;                    &lt;artifactId&gt;poi&lt;/artifactId&gt;\r\n&quot; +             &quot;                &lt;/exclusion&gt;\r\n&quot; +             &quot;                &lt;exclusion&gt;\r\n&quot; +             &quot;                    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\r\n&quot; +             &quot;                    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;\r\n&quot; +             &quot;                &lt;/exclusion&gt;\r\n&quot; +             &quot;            &lt;/exclusions&gt;\r\n&quot; +             &quot;        &lt;/dependency&gt;\r\n&quot; +             &quot;    &lt;/dependencies&gt;\r\n&quot; +             &quot;\r\n&quot; +             &quot;    &lt;build&gt;\r\n&quot; +             &quot;        &lt;plugins&gt;\r\n&quot; +             &quot;            &lt;plugin&gt;\r\n&quot; +             &quot;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n&quot; +             &quot;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\r\n&quot; +             &quot;            &lt;/plugin&gt;\r\n&quot; +             &quot;        &lt;/plugins&gt;\r\n&quot; +             &quot;    &lt;/build&gt;\r\n&quot; +             &quot;\r\n&quot; +             &quot;&lt;/project&gt;\r\n&quot; +             &quot;&quot;;}</code></pre><p>MemoryStreamDemo.java</p><pre><code>package com.icerno.cloud.test;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.CharArrayReader;import java.io.CharArrayWriter;import java.io.IOException;import java.io.LineNumberReader;import com.icerno.cloud.model.StrRes;/** Copyright: Copyright (c) 2018 Jun_Zhou @ClassName: MemoryStreamDemo.java @Description: 该类的功能描述 @version: v1.0.0 @author: JunZhou @Email: 1769676159@qq.com @Site: CERNO @date: 2018年12月29日 下午8:53:20 */public class MemoryStreamDemo{    public static void main(String[] args) throws IOException    {        //内存字节流=====================================================================        ByteArrayOutputStream baos = new ByteArrayOutputStream();//不需要路径，写入内存，跟磁盘无需关联        baos.write(&quot;这是要写入内存流的数据&quot;.getBytes());//将字符串变成字节数组，写入内存        baos.close();//此处关闭内存流无效 下面的数据也可写入        baos.write(&quot;helloworld&quot;.getBytes());//注意：之前的IO流都是跟磁盘文件建立了连接，需要关闭连接即关闭流！ 而关闭内存流跟连接无关        byte[] byteArray = baos.toByteArray();//获取内存中存数据的数组        //使用内存输入流 读取获得内存中的保存数据的数组        ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);//ByteArrayInputStream(byte[] buf):创建一个 ByteArrayInputStream，使用 buf 作为其缓冲区数组。        //读        int len;        byte[] b = new byte[1024];        while ((len = bais.read(b)) != -1)        {            System.out.println(new String(b, 0, len));        }        //内存字符流============================================================================        CharArrayWriter caw = new CharArrayWriter();        caw.write(StrRes.resStr);        char[] ch = caw.toCharArray();        //使用内存输入流 读取获得内存中的保存数据的数组        CharArrayReader car = new CharArrayReader(ch);        //读        int len2;        char[] c = new char[10];        while ((len2 = car.read(c)) != -1)        {            System.out.print(new String(c, 0, len2));        }        //因为CharArrayReader extends Reader 因此可以很方便的将其转化为LineNumberReader、BufferedReader;        LineNumberReader propFileBr = new LineNumberReader(car);        String lineProp = null;        while ((lineProp = propFileBr.readLine()) != null)        {            String propKeyValuePair = lineProp.trim();            System.out.println(propFileBr.getLineNumber() + &quot;------\t&quot; + propKeyValuePair + &quot;\t------&quot;);        }    }}</code></pre><p>执行结果如下所示：<br><img src="https://user-images.githubusercontent.com/25767073/50538652-58e28a00-0bad-11e9-87c9-e6fc00643200.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springboot中使用@Value读取配置文件，通过静态变量实现非侵入式集中管理</title>
      <link href="/2018/12/19/hou-duan/fen-bu-shi-kuang-jia/springboot-zhong-shi-yong-value-du-qu-pei-zhi-wen-jian-tong-guo-jing-tai-bian-liang-shi-xian-fei-qin-ru-shi-ji-zhong-guan-li/"/>
      <url>/2018/12/19/hou-duan/fen-bu-shi-kuang-jia/springboot-zhong-shi-yong-value-du-qu-pei-zhi-wen-jian-tong-guo-jing-tai-bian-liang-shi-xian-fei-qin-ru-shi-ji-zhong-guan-li/</url>
      
        <content type="html"><![CDATA[<p>在SpringBoot中读取XXX.properties等配置文件有许多方法，常见的方法有：@ConfigurationProperties方式、使用@Value注解方式、使用Environment、以及使用PropertiesLoaderUtils这四种方式。本文中主要讲述通过@Value注解方式读取配置文件进行静态变量初始化，从而进行集中式配置文件管理。</p><p>一般的，使用@Value注解方式需要在使用的地方进行侵入式编码,即哪里使用需要属性值就要在哪里使用该注解，从SpringCloud配置中心中取值也是如此，一旦变量名发生了变化，则需要进行多处调整，如：</p><pre><code>package com.icerno.spring.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * * Copyright: Copyright (c) 2018 Jun_Zhou* * @ClassName: PropertyController.java* @Description: 属性文件控制类;* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2018年12月19日 下午9:38:28*  */@RestController@RequestMapping(&quot;/property/&quot;)public class PropertyController{       @Value(&quot;${my.name}&quot;)    public String myName;//侵入式编码,倘若使用较多，则不便更新；    @RequestMapping(&quot;getStaticProperty&quot;)    public String getStaticProperty() {        return myName;    }}</code></pre><p>为了解决侵入式编码带来的不便，建议使用静态变量统一管理配置属性，如：</p><p>application.properties</p><pre><code>server.port=9090my.name=j......ugitlab.gitLabUrl=http://10.10.10.101gitlab.serverIP = 10.10.10.101gitlab.passWord=z......2017gitlab.adminToken=iJ......BV72y</code></pre><p>GitlabConfig.java</p><pre><code>package com.icerno.spring.utils;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Configuration;/** Copyright: Copyright (c) 2018 Jun_Zhou *  * @ClassName: GitlabConfig.java * @Description: gitlab相关的配置信息; * @version: v1.0.0 * @author: JunZhou * @Email: 1769676159@qq.com * @Site: CERNO * @date: 2018年11月6日 下午3:32:54 */@Configurationpublic class GitlabConfig{       public static String        SERVER_IP;//gitlab服务器的Ip;    @Value(&quot;${gitlab.serverIP}&quot;)    public  void setSERVER_IP(String sERVER_IP)    {        GitlabConfig.SERVER_IP = sERVER_IP;    }    public static String        GITLAB_URL;//gitlab服务器的URL;    @Value(&quot;${gitlab.gitLabUrl}&quot;)    public  void setGITLAB_URL(String gITLAB_URL)    {        GitlabConfig.GITLAB_URL = gITLAB_URL;    }    public static String        GITLAB_PSW;// gitlab密码;    @Value(&quot;${gitlab.passWord}&quot;)    public  void setGITLAB_PSW(String gITLAB_PSW)    {        GitlabConfig.GITLAB_PSW = gITLAB_PSW;    }    public static String        GITLAB_ADMIN_TOKEN;//gitlab管理员的token信息;    @Value(&quot;${gitlab.adminToken}&quot;)    public  void setGITLAB_ADMIN_TOKEN(String gITLAB_ADMIN_TOKEN)    {        GitlabConfig.GITLAB_ADMIN_TOKEN = gITLAB_ADMIN_TOKEN;    }}</code></pre><p><strong>在使用@Value注解给静态变量注入属性值的时候需要注意：</strong></p><p>1、为静态变量注入属性值和非静态变量不同，需要提供setXXX方法，该方法有参，且类型和属性类型一致，必须为非静态，在方法体内为静态属性变量赋值；</p><p>2、@Value必须添加在setXXX的方法上;</p><p>3、静态属性所在类必须使用@Component注解或者@Configuration修饰;</p><p>4、setXXX方法的方法名和静态属性变量无必要联系，但是在方法体内必须进行变量的赋值操作。</p><p>否则将注入失败，取值为空;</p><p>参考代码如下：</p><pre><code>package com.icerno.spring.utils;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Configuration;/** Copyright: Copyright (c) 2018 Jun_Zhou *  * @ClassName: GitlabConfig.java * @Description: gitlab相关的配置信息; * @version: v1.0.0 * @author: JunZhou * @Email: 1769676159@qq.com * @Site: CERNO * @date: 2018年11月6日 下午3:32:54 */@Configurationpublic class GitlabConfig{       public static String        SERVER_IP;//gitlab服务器的Ip;    @Value(&quot;${gitlab.serverIP}&quot;)    public  void setSERVER_IP(String sERVER_IP)    {        GitlabConfig.SERVER_IP = sERVER_IP;//方法的方法名和静态属性变量无必要联系，但是在方法体内必须进行变量的赋值操作。    }    public static String        GITLAB_URL;//gitlab服务器的URL;    @Value(&quot;${gitlab.gitLabUrl}&quot;)    public  void setGITLAB_URL(String gITLAB_URL)    {        GitlabConfig.GITLAB_URL = gITLAB_URL;    }    public static String        GITLAB_PSW;// gitlab密码;    @Value(&quot;${gitlab.passWord}&quot;)    public  void setGITLAB_PSW(String gITLAB_PSW)    {        GitlabConfig.GITLAB_PSW = gITLAB_PSW;    }    public static String        GITLAB_ADMIN_TOKEN;//gitlab管理员的token信息;    @Value(&quot;${gitlab.adminToken}&quot;)    public  void setGITLAB_ADMIN_TOKEN(String gITLAB_ADMIN_TOKEN)    {        GitlabConfig.GITLAB_ADMIN_TOKEN = gITLAB_ADMIN_TOKEN;    }}</code></pre><p>参考文章:<br><a href="https://blog.csdn.net/thc1987/article/details/78789426" target="_blank" rel="noopener">SpringBoot四种读取properties文件的方式</a> </p><p><a href="https://blog.csdn.net/mononoke111/article/details/81088472" target="_blank" rel="noopener">SpringBoot使用@Value给静态变量注入值</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RestTemplate工具类的使用</title>
      <link href="/2018/12/18/hou-duan/java/resttemplate-gong-ju-lei-de-shi-yong/"/>
      <url>/2018/12/18/hou-duan/java/resttemplate-gong-ju-lei-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p> Rest,即 Representtational state Transfer,翻译为:“表现层状态转化”.</p><p>常用HTTP动词如下：</p><blockquote><p>GET（SELECT）：从服务器取出资源（一项或多项）。<br>POST（CREATE）：在服务器新建一个资源。<br>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。<br>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。<br>DELETE（DELETE）：从服务器删除资源。</p></blockquote><pre><code>还有两个不常用的HTTP动词。HEAD：获取资源的元数据。OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的</code></pre><hr><p> rest详解参考文章：<br> <a href="https://blog.csdn.net/itguangit/article/details/80198895" target="_blank" rel="noopener">Restful API 设计指南</a></p><p>简单的使用示例子：</p><pre><code>package cn.lz.platform.dh_pipeline_task.utils;import org.springframework.web.client.RestTemplate;/** * * Copyright: Copyright (c) 2018 Jun_Zhou* * @ClassName: GitlabApiTest.java* @Description: RestTemplate使用的小例子；* * Attention:建议使用URL直接编码参数的方式执行请求，采用媒介例如Map等在特定第三方资源服务其上可能会响应错误;* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2018年12月18日 */public class GitlabApiTest{     static RestTemplate restTemplate = new RestTemplate();    public static void main(String[] args) throws Exception    {            //发送post请求,删除指定的分支;        /*1、 delete        String url = &quot;http://gitlab.example.com/api/v4/projects/797/repository/branches/branch4?private_token=currentUserPrivateToken&quot;;        restTemplate.delete(url);//发送delete请求;         */                //发送post请求创建指定的分支;        //2、post        /*        String url = &quot;http://gitlab.example.com/api/v4/projects/797/repository/branches?branch=branch7&amp;ref=master&amp;private_token=currentUserPrivateToken&quot;;        String request = null;        Object postForObject = restTemplate.postForObject(url, request, String.class);        System.out.println(&quot;postForObject---------&gt;&quot;+postForObject);        */        //3、get        /*        String url = &quot;http://gitlab.example.com/api/v4/projects/797/repository/branches?branch=branch8&amp;ref=master&amp;private_token=currentUserPrivateToken&quot;;        Object postForObject = restTemplate.getForObject(url,String.class);        System.out.println(&quot;postForObject---------&gt;&quot;+postForObject);        */        //4、put        /*String url = &quot;http://gitlab.example.com/api/v4/projects/797/repository/branches/branch7/protect?developers_can_push=true&amp;developers_can_merge=true&amp;private_token=currentUserPrivateToken&quot;;        restTemplate.put(url, null);*/    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我还没强到可以掌控自己命运，何去何从？唯有不负韶华</title>
      <link href="/2018/12/16/xiang-ce/wo-huan-mei-qiang-dao-ke-yi-zhang-kong-zi-ji-ming-yun-he-qu-he-cong-wei-you-bu-fu-shao-hua/"/>
      <url>/2018/12/16/xiang-ce/wo-huan-mei-qiang-dao-ke-yi-zhang-kong-zi-ji-ming-yun-he-qu-he-cong-wei-you-bu-fu-shao-hua/</url>
      
        <content type="html"><![CDATA[<p>朋友半年前一个人来到无锡，稍后就要离开了。感觉有点小失落，不知道何时才能再见面，预祝他一番风顺。何去何从，我们现在还不能做主，唯有不负韶华，好好努力吧。<br><img src="https://user-images.githubusercontent.com/25767073/50051344-10f24a80-014b-11e9-8de4-e10352609160.jpg" alt="在这里插入图片描述"></p><p>——有时，友情是真正存在的，抛开所谓的情商不谈。有些人，遇见或许就是缘分。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用nativefier将web打包为WebApp</title>
      <link href="/2018/12/09/ruan-jian-gong-ju/nodejs/shi-yong-nativefier-jiang-web-da-bao-wei-webapp/"/>
      <url>/2018/12/09/ruan-jian-gong-ju/nodejs/shi-yong-nativefier-jiang-web-da-bao-wei-webapp/</url>
      
        <content type="html"><![CDATA[<p>在github上浪的时候发现一款开源库，可以直接将任意的网站打包为webapp。具体的操作步骤如下：</p><ol><li>安装node.js环境</li><li>使用npm安装nativefier库；</li></ol><pre><code>npm install nativefier -g</code></pre><p>3.使用nativefier将你的网站封装为webapp。</p><pre><code>nativefier &quot;https://bigjun2017.github.io/&quot;</code></pre><p><a href="https://github.com/jiahaog/nativefier" target="_blank" rel="noopener">nativefier的github地址</a></p><p>4.最终的执行成果如下：<br><img src="https://user-images.githubusercontent.com/25767073/49694824-51dae400-fbcc-11e8-81d4-f13db2424120.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Alibaba开源组件-分布式流量控制框架sentinel初探</title>
      <link href="/2018/12/09/hou-duan/fen-bu-shi-kuang-jia/alibaba-kai-yuan-zu-jian-fen-bu-shi-liu-liang-kong-zhi-kuang-jia-sentinel-chu-tan/"/>
      <url>/2018/12/09/hou-duan/fen-bu-shi-kuang-jia/alibaba-kai-yuan-zu-jian-fen-bu-shi-liu-liang-kong-zhi-kuang-jia-sentinel-chu-tan/</url>
      
        <content type="html"><![CDATA[<p>Sentinel 是什么？<br>还是皮一下吧详细的介绍在Alibaba已经介绍的很详细了。</p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">Sentinel: 分布式系统的流量防卫兵</a></p><p>如何使用：<br>   其实也就三个步骤：<br>    <strong>1、添加依赖</strong><br>目前的最新的版本是0.2</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;    &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;    &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>2、初始化资源</strong><br>需要使用如下的代码块将 你自己的代码块给包围起来。</p><pre><code>Entry entry = null;try {    entry = SphU.entry(resource);    //我的代码块    doSomething();  } catch (BlockException e1) {    //怎么处理那些被阻塞的请求} finally {    if (entry != null) {        entry.exit();    }}</code></pre><p>在Sentinel中，对那些被阻塞的请求，都是用catch到BlockException异常的方式进行处理的。</p><p>3、定义流量控制规则</p><p>Sentinel定义了三种规则对象，分别是：</p><pre><code>FlowRule：流量控制规则DegradeRule：熔断降级规则SystemRule：系统负载规则</code></pre><p>我们需要定义的规则的参数都是对应这些类的属性。这三个规则分别对应者三个RuleManager来加载规则。比如对于流量控制规则，使用FlowRuleManager.loadRules(List rules)来加载定义好的流控规则，从API可以看出，定义的规则可以不止一个。</p><p>定义流量控制规则一个demo如下：</p><pre><code>publicp  static void initFlowRules(String resource){        List rules = new ArrayList();        FlowRule rule = new FlowRule();        rule.setResource(resource); //资源名        rule.setGrade(RuleConstant.FLOW_GRADE_QPS); //限流阈值类型，此处为    qps类型        rule.setCount(5);   //限流阈值，表示每秒钟通过5次请求        rules.add(rule);    //将定义好的rule放在List中        FlowRuleManager.loadRules(rules);    }</code></pre><p><strong><em>详细demo如下：</em></strong></p><pre><code>package com.alibaba.alibabaSentinel.test;/** * * Copyright: Copyright (c) 2018 Jun_Zhou* * @ClassName: SentinelTest.java* @Description: 分布式流量框架sentinel测试程序;* * @version: v1.0.0* @author: JunZhou* @Email: 1769676159@qq.com* @Site: CERNO* @date: 2018年12月9日 下午5:57:51 */import java.util.ArrayList;import java.util.List;import org.junit.Test;import com.alibaba.csp.sentinel.Entry;import com.alibaba.csp.sentinel.SphU;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.alibaba.csp.sentinel.slots.block.RuleConstant;import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;import com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;public class SentinelTest{    static int executedNumber = 0;    @Test    public void test01()    {        String resourceName = &quot;qpsSentinel&quot;;        initFlowRules(resourceName);    //上面定义的规则        for (int i = 0; i &lt; 10; i++)        {            Entry entry = null;            try            {                entry = SphU.entry(resourceName);                //我的代码块                doSomething();            }            catch (BlockException e1)            {                e1.printStackTrace();   //直接将异常打出来            }            finally            {                if (entry != null)                {                    entry.exit();                }            }        }    }    public static void doSomething()    {        // TODO Auto-generated method stub        executedNumber++;        System.out.print(&quot;-------CurrentExecutedNumber-------&quot; + executedNumber);    }    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })    static void initFlowRules(String resource)    {        List rules = new ArrayList();        FlowRule rule = new FlowRule();        rule.setResource(resource); //资源名        rule.setGrade(RuleConstant.FLOW_GRADE_QPS); //限流阈值类型，此处为qps类型        rule.setCount(5);   //限流阈值，表示每秒钟通过5次请求        rules.add(rule);    //将定义好的rule放在List中        FlowRuleManager.loadRules(rules);    }}</code></pre><p>  运行结果：<br>  <img src="https://user-images.githubusercontent.com/25767073/49696055-2f05fb00-fbdf-11e8-9d07-567b342f8dd4.gif" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MYSQL线上审核规范</title>
      <link href="/2018/12/09/shu-ju-ku/mysql-xian-shang-shen-he-gui-fan/"/>
      <url>/2018/12/09/shu-ju-ku/mysql-xian-shang-shen-he-gui-fan/</url>
      
        <content type="html"><![CDATA[<p><strong>命名规范</strong><br>Ø库名、表名、字段名，使用小写字母</p><p>Ø库名、表名、字段名，不要超过30个字符</p><p>Ø库名、表名、字段名，尽量见名知意，使用下划线分割</p><p>Ø库名、表名、字段名，禁止使用MySQL保留字</p><p>Ø临时库、表名，必须以tmp为前缀，以日期为后缀，例如tmp_product_20151229</p><p>Ø备份表、表名，必须以日期为后缀，例如produce_bak_20151229</p><p><strong>库表设计</strong><br>Ø表必须有主键，使用bigint unsigned类型auto_increment属性</p><p>Ø除主键外的其他字段都必须有注释，所有表都必须有说明</p><p>Ø最多更改和查询的字段放在基础表内，方便完整载入内存</p><p>Ø访问频率低的或大字段放到扩展表里，分离冷热数据</p><p>Ø多张关联表之间，适当的冗余字段，可以减少JOIN查询</p><p>Ø如果预计数据量较大，预先制定分表策略，如按日期拆分或按某键值取模分表</p><p>Ø尽量不用分区表，如需使用请与DBA沟通</p><p><strong>字段设计</strong><br>Ø只有主键使用UNSIGNED属性，其他数值列不要使用，因为计算出现负数时会报错</p><p>Ø当字符串较短，或数据频繁更新时，可以使用CHAR(N)，N表示字符数而非字节数</p><p>Ø当字符串长度可预见时，可以使用VARCHAR(N)，N表示字符数而非字节数</p><p>Ø使用DECIMAL代替FLOAT和DOUBLE，以存储精确浮点数，例如支付相关数据</p><p>Ø使用INT系类型代替ENUM类型，前者只要自己定义，后者却要修改表</p><p>Ø使用INT UNSIGNED存储IPV4，inet_aton()和inet_ntoa()用于IPV4与INT互转</p><p>Ø尽可能不使用TEXT类型，禁止使用BLOB类型</p><p>Ø所有字段必须定义为NOT NULL，定义为default 0或default ‘’，NULL可能在计数(count)和匹配(is null)时引起歧义</p><p><strong>索引设计</strong><br>Ø如多个字段组合有唯一性需要，可以创建唯一索引</p><p>Ø不在低基数(低筛选度)的列上建立索引，例如“性别”</p><p>Ø一条SQL只会用到一个索引，无用的索引越多，写入性能越差</p><p>Ø禁止冗余索引，如已有(a,b)索引，可以删除(a)索引</p><p>Ø合理创建组合索引，(a,b,c)相当于(a)、(a,b)、(a,b,c)</p><p>Ø组合索引的组成字段数尽量不超过3个</p><p>Ø组合索引中，区分度大(高筛选度)的字段放在最前</p><p>Ø尽可能利用索引完成排序，即排序的字段在索引里，且不使用降序排序</p><p>Ø适度将组合索引提升为覆盖索引，避免回表，减少IO</p><p>Ø对较长字符串可使用前缀索引，前缀索引长度由数据区分度确定</p><p>Ø禁止使用外键，防止死锁，避免隐藏的数据逻辑</p><p>Ø数据扫描过多，如所有索引的过虑性不佳，会放弃使用索引</p><p>Ø仅使用最有效的过滤条件，索引不是越长越好，where条件并不是越多越好</p><p>Ø普通索引按照“idx_表名_字段名称”进行命名，例如idx_table1_name</p><p>Ø唯一索引按照“uniq_表名_字段名称”进行命名，例如uniq_table1_name</p><p>Ø索引名必须全部使用小写，过长的字段名可以采⽤缩写形式，例如idx_t1_name_age<br><strong>SQL编写</strong></p><p>Ø尽量使用主键，且不要修改主键的值</p><p>Ø只select需要的字段，禁止使用select *</p><p>Ø分批获取大量数据时，禁止大偏移量的limit M,N语句，使用主键游标 where PK&gt;… limit N</p><p>Ø同字段OR条件，用IN代替，包含的值个数应少于300个</p><p>Ø禁止隐式转换，数值类型禁止加引号，字符和日期类型必须加引号</p><p>Ø减少与数据库交互次数，尽量采用批量递交、块插入和缓存(memcache)</p><p>Ø使用prepared statement批量递交语句，可以提升性能，且避免SQL注⼊</p><p>Ø注意UNION ALL和UNION的区别，UNION默认有去重效果</p><p>Ø统计行数时，使用COUNT(*)或COUNT(1)，不要使用count(字段名)，会忽略值为NULL的行</p><p>Ø写入语句中禁止出现结果不确定的函数，如sysdate()、rand()、current_user()等</p><p>ØINSERT语句必须指定字段列表，禁止使用 INSERT INTO xxx values()</p><p>Ø执行频率高的SQL和重要功能的SQL，都必须能有索引可用</p><p>Ø禁止使用左%模糊匹配，例如like ‘%abc’，无法用到索引</p><p>Ø禁止使用反向匹配，例如 not in、!=、not like，无法用到索引</p><p>Ø禁止在SQL中进行算术和函数计算，应放置到应用服务器端</p><p>Ø保证每张表的JOIN列的数据类型相同，并且都建立了索引</p><p>Ø禁止使用order by rand()实现乱序效果，会导致CPU过高</p><p>Ø禁止JOIN和子查询，如无法避免，应尽可能进行优化</p><p>Ø适当增加冗余字段，避免关联JOIN查询</p><p>Ø可以拆分复杂的JOIN为多个小SQL，避免大语句</p><p>Ø尽可能减少Join语句中的循环总次数，就是让驱动表的结果集尽可能的小，永远用小结果集驱动大的结果集</p><p>Ø优先优化内层循环，内层循环是循环中执行次数最多的，每次循环节约很小的资源，在整个循环中就能节约很大的资源</p><p>Ø子查询只允许返回主键和必须的字段，不允许select *</p><p>Ø禁止单条SQL语句同时更新多个表，拆分成多条SQL，放在一个事务里</p><p>Ø程序应有捕获SQL异常的处理机制，必要时通过rollback显式回滚</p><p>Ø严禁大事务，会锁住更多的资源，引发更多的等待和竞争</p><p>Ø不同事务对同一批表的操作，要前后顺序一致</p><p><strong>QA：</strong>Mysql中的联合索引、前缀索引、覆盖索引的区别和联系？<br><a href="https://blog.csdn.net/air_hjj/article/details/70194985" target="_blank" rel="noopener">Mysql中的联合索引、前缀索引、覆盖索引</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>好开心，七牛外链失效的图片找回来了</title>
      <link href="/2018/12/08/sui-bi/hao-kai-xin-qi-niu-wai-lian-shi-xiao-de-tu-pian-zhao-hui-lai-liao/"/>
      <url>/2018/12/08/sui-bi/hao-kai-xin-qi-niu-wai-lian-shi-xiao-de-tu-pian-zhao-hui-lai-liao/</url>
      
        <content type="html"><![CDATA[<p>今天把我存在七牛云上的图片找回来了，好开心。<br><img src="https://user-images.githubusercontent.com/25767073/49684878-eeda4600-fb14-11e8-8ad9-37c556a784f2.jpeg" alt="在这里插入图片描述"></p><p>找回七牛云存储失效文件的思路：<a href="https://blog.csdn.net/lkj345/article/details/83382636" target="_blank" rel="noopener">七牛云测试域名失效导致图片外链失效的解决办法</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端学习之初始化-angular4的学习</title>
      <link href="/2018/12/04/lao-bo-ke/yi-dong-duan-xue-xi-zhi-chu-shi-hua-angular4-de-xue-xi/"/>
      <url>/2018/12/04/lao-bo-ke/yi-dong-duan-xue-xi-zhi-chu-shi-hua-angular4-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>最近在学习angular4感觉也没有那么难啦，好奇移动端到底可以做出啥，继续学习中……<br><img src="http://img.blog.csdn.net/20180107215813837?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>使用七牛上传图片的demo</title>
      <link href="/2018/12/04/lao-bo-ke/shi-yong-qi-niu-shang-chuan-tu-pian-de-demo/"/>
      <url>/2018/12/04/lao-bo-ke/shi-yong-qi-niu-shang-chuan-tu-pian-de-demo/</url>
      
        <content type="html"><![CDATA[<p>七牛是一个很好的第三方的图片服务器,下面介绍一下使用七牛上传图片的demo.<br>1、直接上代码:</p><pre><code>UploadDemo.java----------package com.qiniu.up;import java.io.IOException;import com.qiniu.common.QiniuException;import com.qiniu.common.Zone;import com.qiniu.http.Response;import com.qiniu.storage.UploadManager;import com.qiniu.util.Auth;public class UploadDemo {    // 设置好账号的ACCESS_KEY和SECRET_KEY    String ACCESS_KEY = &quot;lEZ6Ht3bp××××××b1Hn-aNpwH&quot;; // 这两个登录七牛                                                                    // 账号里面可以找到    String SECRET_KEY = &quot;DKJKiwHNy××××××nTTl6D89is_gNSEzohpDYOKk&quot;;    // 要上传的空间    String bucketname = &quot;storage××××××4zj&quot;; // 填写新建的那个存储空间对象的名称    // 上传到七牛后保存的文件名    String key = &quot;00002.jpg&quot;;    // 上传文件的路径    String FilePath = &quot;d:\\01.jpg&quot;; // 本地要上传文件路径    // 密钥配置    Auth auth = Auth.create(ACCESS_KEY, SECRET_KEY);    // 创建上传对象    UploadManager uploadManager = new UploadManager();    // 简单上传，使用默认策略，只需要设置上传的空间名就可以了    public String getUpToken() {        return auth.uploadToken(bucketname);    }    // 普通上传    public void upload() throws IOException {        try {            // 调用put方法上传            Response res = uploadManager.put(FilePath, key, getUpToken());            // 打印返回的信息            System.out.println(res.isOK());            System.out.println(res.bodyString());        } catch (QiniuException e) {            Response r = e.response;            // 请求失败时打印的异常的信息            System.out.println(r.toString());            try {                // 响应的文本信息                System.out.println(r.bodyString());            } catch (QiniuException e1) {                // ignore            }        }    }    public static void main(String args[]) throws IOException {        new UploadDemo().upload();    }}</code></pre><p>2、相关的依赖<br><a href="http://download.csdn.net/download/zj20142213/10234305" target="_blank" rel="noopener">Demo依赖的jar包</a><br>3、引用文章<br><a href="https://developer.qiniu.com/kodo/sdk/1239/java" target="_blank" rel="noopener">Java SDK</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>使用XShell部署SpringBoot的jar文件到Linux服务器上</title>
      <link href="/2018/12/04/lao-bo-ke/shi-yong-xshell-bu-shu-springboot-de-jar-wen-jian-dao-linux-fu-wu-qi-shang/"/>
      <url>/2018/12/04/lao-bo-ke/shi-yong-xshell-bu-shu-springboot-de-jar-wen-jian-dao-linux-fu-wu-qi-shang/</url>
      
        <content type="html"><![CDATA[<p>最近师傅教我了通过jenkins发布项目，但是发现公司的Maven出了点问题，因此就用XShell进行项目的发布操作。发布的步骤如下：</p><ol><li>在eclipse中通过Maven命令Clean–&gt;Install生成jar文件；<br>clean:清楚tartget目录下的文件;<br>install:编译项目并生成jar文件存储于target文件夹下【默认的额编译输出路径】；</li><li>通过XSheel上传jar文件到指定的服务器；<br>上传命令有两个：<br>rz:上传文件，当有重复文件的时候不执行覆盖；<br>ra -y 上传并覆盖；</li><li>进行醒目发布的前期处理操作；<br>每次发布都必须关闭原有服务，因此可以执行如下脚本：<br><code>`</code><br>ps -ef|grep -v grep|grep gooflow|awk ‘$2~/[0-9]+/ {print $2}’/xargs   kill -s 9<br>cd /home/d5000/server rz -y</li></ol><pre><code> 4.执行发布脚本，发布项目；</code></pre><p> cd bin<br> sh lz-gooflow-service.sh</p><pre><code>其实发布项目执行一个脚本就好了，我们只需要在上传窗口打开的时候选择文件上传就好了。综合脚本如下：</code></pre><p> ps -ef|grep -v grep|grep gooflow|awk ‘$2~/[0-9]+/ {print $2}’/xargs kill -s 9<br> cd /home/d5000/server rz -y<br> cd bin<br> sh lz-gooflow-service.sh</p><pre><code>发布脚本里的内容也没啥，就是执行在后台执行【nohup】java -jar xxx.jar命令，并把执行中相应级别的输出信息【&#39;2&gt;&amp;1 &#39;:1、标准输出信息；2、error输出信息】的信息写入日志就好了。</code></pre><p>nohup java -jar ../lz-gooflow-service-0.0.1-SNAPSHOT.jar &gt; /home/d5000/logs/lz-gooflow-service 2&gt;&amp;1 &amp;</p><p><code>`</code></p><p>参考文章：</p><ol><li><a href="https://zhidao.baidu.com/question/446932678.html" target="_blank" rel="noopener">linux命令ps -ef | grep httpd 是啥意思</a></li><li><a href="https://blog.csdn.net/kingo0/article/details/38036957" target="_blank" rel="noopener">linux获得进程id号并迅速杀死进程</a></li><li><a href="http://www.jb51.net/LINUXjishu/351683.html" target="_blank" rel="noopener">Linux中Kill掉进程的10种方法</a></li><li>r<a href="https://segmentfault.com/q/1010000005793523" target="_blank" rel="noopener">z 能否强制覆盖掉文件?</a></li><li><a href="http://blog.51cto.com/oldboy/588592" target="_blank" rel="noopener">Linux系统上传下载命令rz和sz</a></li><li><a href="https://www.cnblogs.com/sos-blue/p/6798810.html" target="_blank" rel="noopener">bash中 2&gt;&amp;1 &amp; 的解释</a></li><li><a href="https://junzhou2016.github.io/2017/09/05/linux%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">我的个人Linux笔记。</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>使用JSOUP爬取国家统计局的地理位置数据</title>
      <link href="/2018/12/04/lao-bo-ke/shi-yong-jsoup-pa-qu-guo-jia-tong-ji-ju-de-di-li-wei-zhi-shu-ju/"/>
      <url>/2018/12/04/lao-bo-ke/shi-yong-jsoup-pa-qu-guo-jia-tong-ji-ju-de-di-li-wei-zhi-shu-ju/</url>
      
        <content type="html"><![CDATA[<p>最近因工作需要，我需要爬取国家统计局的最新统计数据。因此参照网上的例子使用JSOUP爬取了国家统计局的省、市、县、镇、村的数据。因为要爬取的数据较多，因此在里面使用了多线程的相关技术。下面首先讲解下多线程相关的东西。</p><hr><blockquote><p> 首先理解下什么是线程池？<br>             因为创建和销毁线程是一件非常耗费时间的工作，因此，如果线程可以再一定程度上复用，那么肯定可以再节省不少的时间。线程池的作用可以类比MYSQL中的连接池理解。<br>             参考文章：<a href="https://www.jianshu.com/p/ae67972d1156" target="_blank" rel="noopener">Java常用四大线程池用法以及ThreadPoolExecutor详解</a></p></blockquote><hr><blockquote><p>  其次是多线程中的Future模式。<br>  因为爬取的省份较多，因此需要多个线程并发执行，但是必须保证在IO操作的写操作执行前，所有的数据都已经爬取完毕。因此，必须使用多线程的Future模式，Future模式可以保证多个线程并发执行，并且可以通过future.get()方法在适当的地方进行线程堵塞，保证在结果输出前各个子线程已经执行结束。因为在调用到某个子线程的future.get()方法之前，各个子线程会继续并发执行，因此，调用future.get()方法阻塞主线程消耗的时间会非常的少，因此可以再一定的程度上节省时间开销。</p></blockquote><pre><code>        /**         * 等待所有的子线程执行完毕         */        for (Future future : futureList) {            future.get();        }</code></pre><blockquote><p>Future模式的参考文章：<a href="https://www.jianshu.com/p/949d44f3d9e3" target="_blank" rel="noopener">Java多线程 - Future模式</a></p></blockquote><hr><blockquote><p>最后讲述下说说Runnable与Callable的区别：<br>  二者的实际异同为以下几点：<br>     相同点：<br>    1、 两者都是接口；（废话）<br>    2、两者都可用来编写多线程程序；<br>    3、两者都需要调用Thread.start()启动线程；<br>    不同点：<br>    1、两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；<br>    2、Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；<br>    注意点：<br>    Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！</p></blockquote><p>参考文章：<a href="https://www.cnblogs.com/frinder6/p/5507082.html" target="_blank" rel="noopener">说说Runnable与Callable</a></p><hr><p>下面是使用Jsoup爬取国家统计局数据的具体代码：<br><img src="http://ouuy81imh.bkt.clouddn.com/tjsu.png" alt="这里写图片描述"></p><p>源码：<a href="https://download.csdn.net/download/zj20142213/10641389" target="_blank" rel="noopener">Jsoup爬取国家统计局的数据</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>使用Jenkins配置Git+Maven的自动化构建</title>
      <link href="/2018/12/04/lao-bo-ke/shi-yong-jenkins-pei-zhi-git-maven-de-zi-dong-hua-gou-jian/"/>
      <url>/2018/12/04/lao-bo-ke/shi-yong-jenkins-pei-zhi-git-maven-de-zi-dong-hua-gou-jian/</url>
      
        <content type="html"><![CDATA[<hr><p>最近安装Jenkins，参照网上的各种资料进行尝试，折腾了好久，但是查找了这么多资料，相似度在90%以上！！！，相同的安装过程，测试了几台机器，未曾成功，不得不感慨自己能力有限，最终慢慢摸索，形成思路，现分享给大家，希望大家在安装的时候少走弯路。</p><p>PS：本人很痛恨那种粘贴复制，毫无思考的博主，本想着拿着解决问题的心态，但结果还是一样，不但浪费了大家的时间，还浪费了大家的感情，所以，我把我遇到的问题和解决的方式记录下来和大家分享。</p><p>转载链接:亲测可行：</p><pre><code>http://blog.csdn.net/xlgen157387/article/details/50353317</code></pre><p>配置过程中遇到的一些问题:一：wget命令提示找不到，其实wget和unzip一样，都是linux中的小插件，也就是工具类，提示命令没找到，多半是程序没有安装，安装一下就是了：</p><blockquote><p>  wget插件的安装命令:<br>      yum install wget</p></blockquote><hr><blockquote><p>今天，使用unzip的时候，提示用不了，结果蒙逼。。。，还是问度娘，发现没有安装unzip软件，具体步骤如下：</p><pre><code> #yum list | grep zip/unzip  #yum install zip #yum install unzip 基本完成，如果在编译的时候出现错误：gcc : error trying to exec &#39;cc1plus&#39;: execvp : No sunch file or directory可以用gcc -v/g++ -v 来查看gcc 版本，会发现没有安装。安装如下：#yum list | grep gcc#yum install gcc-c++#yum install unzip</code></pre></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>使用jenkins+github+tomcat实现Springboot半自动化部署</title>
      <link href="/2018/12/04/lao-bo-ke/shi-yong-jenkins-github-tomcat-shi-xian-springboot-ban-zi-dong-hua-bu-shu/"/>
      <url>/2018/12/04/lao-bo-ke/shi-yong-jenkins-github-tomcat-shi-xian-springboot-ban-zi-dong-hua-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>本文讲解的是使用jenkins+github+tomcat实现springboot项目的半自动化部署，为啥叫做半自动化部署？因为我没钱买服务器，webhook又无法访问本地服务器，因此没有使用webhook进行全自动的部署演示，并且我本人认为，全自动的部署是没有必要的，因为这可能影响项目的测试进度。<br>下面演示具体的配置步骤。<br>1、去<a href="https://jenkins.io/" target="_blank" rel="noopener">jenkins官网</a>下载jenkinds.war,用于jenkins的部署与启动。<br>2、添加jenkins.war到tomcat的webapps下，启动tomcat将自动解压，访问<a href="http://localhost:8080/jenkins即可访问jenkins页面；" target="_blank" rel="noopener">http://localhost:8080/jenkins即可访问jenkins页面；</a><br>3、跟着提示的步骤走，安装必要的插件并设置登录密码和用户名。<br>4、全局插件配置(Global Tool Configuration)【次数只介绍maven的相关配置】<br>5、新建一个自由风格的项目。<br>【<a href="https://www.cc520.me/article/35" target="_blank" rel="noopener">三四步的详细步骤可以参考文章</a>】<br>6、需要注意的地方<br>(1、)源码管理中Credentials配置添加的是你的github的账户，用于提供便利给jenkins,方便jenkins自动从github上抓取提交的代码。<br>A、<br><img src="http://img.blog.csdn.net/20180205204125423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>B、<br><img src="http://img.blog.csdn.net/20180205204254158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(2、)因为springboot项目嵌入了内置的web容器，因此springboot项目的发布和普通的j2ee项目略有不同。<br>A、首先执行maven的clean install命令；<br>B、执行windows批处理命令<code>cd C:\Users\xdsm\.jenkins\workspace\JenkinsTestDemo3\targetjava -jar JekinsTestDemo3-0.0.1-SNAPSHOT.jar</code>，这段脚本的命令是跳转至xxx.jar的根目录，并启动执行jar,和在windows上执行springboot打包后的项目并无差异。<br>【此处需要安装一个插件：    SSH plugin】<br><img src="http://img.blog.csdn.net/20180205205159881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>7、测试<br>构建项目，在项目启动成功后访问项目如：</p><pre><code>http://localhost:9008/demo/test?data=xiangxiang</code></pre><p>即可。<br>8、参考文章<br><a href="https://www.cc520.me/article/35" target="_blank" rel="noopener">使用Jenkins启动maven作为项目构建管理工具的web项目</a></p><p><a href="http://blog.csdn.net/lynnos/article/details/78154753" target="_blank" rel="noopener">Jenkins+Github+webhook step by step【结合webhook实现自动化部署】</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>hexo+github搭建个人博客</title>
      <link href="/2018/12/04/lao-bo-ke/shi-yong-hexo-github-da-jian-ge-ren-wei-bo/"/>
      <url>/2018/12/04/lao-bo-ke/shi-yong-hexo-github-da-jian-ge-ren-wei-bo/</url>
      
        <content type="html"><![CDATA[<p>   <strong>使用hexo+github搭建博客的步骤为：</strong><br>       1.软件的安装；<br>                 (1.)安装Node；<br>                 (2.)安装Hexo;<br>                 (3.)安装Git;<br>                 (4.)安装主题；<br>       2.内容的发布;<br>                 使用hexo插件发布博客内容;<br>      <em>详细步骤如下：</em>    </p><hr><p><strong>前提条件</strong><br>需要有个github账号。<br>一般做为一个开发人员，github肯定是访问过的，相信绝大多数开发人员会注册拥有一个github账号，因为这是全球知名的代码托管网站。全世界均可访问到它。若还没有可以到Github注册。</p><p>基本软件NodeJS，Git，Hexo<br>在机子上需要使用到NodeJS进行部署，安装插件等。下载NodeJs。<br>安装Git，进入Git下载页面选择合适的版本进行下载。<br>如果不清楚Hexo是什么？？她是一个快速，简介，高效的博客框架。更多详情可以到Hexo官网读下这个文档就知道了。</p><p>安装完成Git及NodeJs后，那么就可以开始准备安装Hexo了。<br>打开GitBash，使用npm命令来安装Hexo程序。</p><p>安装Hexo</p><hr><p>在命令行输入如下命令:<br>$ npm install -g hexo-cli<br>由于众所周知的原因,可能你执行这条命令会报错，如果你不会调整姿势上网，可以使用淘宝 npm 镜像，执行如下命令即可：<br>$ npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>之后很多 npm 命令可以使用 cnpm 代替。执行下面命令即可安装 Hexo :<br>$ cnpm install -g hexo-cli<br>可能出现一些 WARN ,可以不用理会，然后执行：<br>$ cnpm install hexo –save<br>输入$ hexo -v命令，出现下面所示的版本信息，则说明安装成功</p><p><img src="http://img.blog.csdn.net/20170829093934795?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>这样表示Hexo安装成功了。<br>到此，搭建个人微博需要的3个软件就安装完成了。</p><p>接下来就需要进行相关配置及插件安装了。<br>所有的操作均在GitBash命令行中进行操作。</p><p><strong>建站</strong><br>首先简历一个简单的站，创建初始化一个简单的文件夹。</p><pre><code>$ hexo init myGitPages$ cd myGitPages$ npm install</code></pre><p>这样就可以新建所需要的文件。<br>安装完成后，可以看到如下的几个主要文件。</p><p>   <img src="http://img.blog.csdn.net/20170829094415438?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>其中:<br>_config.xml 可以配置网站信息。可以参考配置<br>package.json 应用程序信息。有默认配置一些组件，可以自己根据需要添加或者移除。<br>scaffolds 模板文件夹。当新建文章时，Hexo会根据scaffold来建立文件。<br>source 资源文件夹，存放用户资源的地方。<br>themes 主题文件夹。Hexo会根据主题来生成静态页面。</p><p><strong>主题</strong></p><hr><p>Hexo可以有很多主题，在Github首页搜索框内输入”hexo theme”，可以搜索到很多主题，目前我使用的是litten的yilia主题。</p><p>可以在进入到建立的站点文件夹下（我的是myGitPages）下，下载yilia主题</p><pre><code>$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></pre><p>下载完成后，打开站点个目录下（myGitPages）的_config.xml文件，修改其中的theme属性成</p><pre><code>theme: yilia</code></pre><p>这样就可以在发布文章的手看到修改的主题，或者通过hexo server进行查看。</p><p><strong>发布</strong></p><hr><p>发布文章前一定要确认已经安装了hexo-deployer-git插件，否则无法正常发文章到git上的。</p><pre><code>$ npm install hexo-deployer-git --save</code></pre><p>来安装git插件。</p><p>到目前基本上需要的从博客站点建立，到发布所需要的软件准备工作都就绪了。</p><p>PS：yilia要显示所有文章还需要进行一个配置，下文会写到。</p><p>在开始写文章发布之前可以，先查本地运行查看Hexo运行情况，运行</p><pre><code>$ hexo server</code></pre><p>在dos窗口的命令为（对应的安装路径下）:hexo s;[启动hexo]</p><p>启动服务器。默认情况下，端口地址是4000。打开浏览器，访问：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>查看效果。若访问出错，没有打开页面，那么可能是端口被占用导致。此时可以使用</p><pre><code>$ hexo server -p 5000</code></pre><p>修改端口，然后重新输入端口号进行查看。<br>若访问成功，默认看到的是hello-wold.md（即source/_post文件夹下的默认创建文件）文件发布后的效果。</p><p><strong>准备工作结束，可以开始写文章发布</strong></p><hr><p>用github+hexo搭建完个人博客后，朋友们应该很想知道怎么在上面写博文吧，这里介绍一个很简单的方法</p><p>你可以使用CSDN网上面提供的MarkDown编辑器 <a href="http://write.blog.csdn.net/mdeditor" target="_blank" rel="noopener">http://write.blog.csdn.net/mdeditor</a> (在csdn博客写新文章的时候能切换到这种编辑器)，写好文章后，找到菜单栏的“导出到本地”选项<br><img src="http://img.blog.csdn.net/20170829100749122?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>以md格式导出到本地，然后copy该md文件，粘贴到你当初建的博客站点文件夹下的source\ _posts目录下，一个md文件对应一篇博客文章。</p><hr><p>在写完文章之后就需要将写的文章部署到GitHub上去了。<br>来看下这个过程。</p><p>由于要发布博客到GitHub实际上使用了GitHub Pages功能，因此可以到这里来查看相关的介绍。其中详细介绍了Pages概念，及如何建立自己的站点。</p><p>一下先简绍下我自己的建立过程。</p><pre><code>建立GitHub仓库</code></pre><p>建立仓库，用以部署Hexo生成的博客。如果还没有GitHub账号就需要注册了。<br>有GitHub账号的小伙伴可以到Github网站创建一个新仓库，如下显示。</p><p><img src="http://img.blog.csdn.net/20170829101340431?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><pre><code>新仓库</code></pre><p>其中仓库名有所讲究，它必须是username.github.io ，这里的username有两种情况，其一是你的用户名即注册时使用的名称，其二是组织名称（此处组织名称并未尝试）。如下图可以看下位置。</p><p><img src="http://img.blog.csdn.net/20170829101515174?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><pre><code>Hexo发布前需要配置_config.xml</code></pre><p>在站点根目录下（myGitPages），找到并编辑_config.xml文件，如下部分。</p><pre><code># Deploymentdeploy:    type: git    repository: git@github.com:yourname/yourname.github.io.git    branch: master</code></pre><p>将新建的仓库信息及分支信息配置到_config.xml，让Hexo知道部署到GitHub的那个仓库。</p><pre><code>发布</code></pre><p>最后，就需要发布了。可以在站点根目录下（myGitPages）下运行一下命令：</p><pre><code>$ hexo clean #清除原有生成的相关文件$ hexo generate #重新生成静态页面$ hexo deploy #进行部署</code></pre><p>在运行部署命令时，会弹出ssh密码输入确认框，输入username.github.io仓库密码，点击OK即可进行顺利发布。</p><p>然后就去访问你的个人站点吧。你会看到发布的文章。</p><p> PS: 不同的主题可能在主题中还需要进行一定的配置，这个看个人喜好使用哪个主题，我使用的是yilia主题，其在初次查看所有文章时会发现展示的不是文章列表。那么按照主题作者提示进行配置后，重新部署就可以了。</p><p>1.nodejs版本大于6.2（最新的nodejs肯定符合）。<br>2.在博客根目录下（不是yilia根目录下）执行如下命令： npm i hexo-<code>generator-json-content --save</code><br>3.在根目录_config.xml文件内配置：</p><h1 id="查看yilia主题下所有文章配置"><a href="#查看yilia主题下所有文章配置" class="headerlink" title="查看yilia主题下所有文章配置"></a>查看yilia主题下所有文章配置</h1><pre><code> jsonContent:       meta: false       pages: false       posts:           title: true           date: true           path: true           text: false           raw: false           content: false           slug: false           updated: false           comments: false           link: false           permalink: false          excerpt: false           categories: false           tags: true</code></pre><p><strong>PS：设置个人头像注意的要点</strong></p><pre><code>1.注意相对路径 绝对路径 根路径 的区别2.注意yilia主题对格式的严格要求，比如空格什么的;</code></pre><p>  具体配置步骤如下：<br>         1.将图片资源放置指定的文件夹下：<br>         <img src="http://img.blog.csdn.net/20170829103613535?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>         2.注意图片路径的格式：<br>         <img src="http://img.blog.csdn.net/20170829103743288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>适配器模式</title>
      <link href="/2018/12/04/lao-bo-ke/she-ji-mo-shi-zhi-gua-pei-qi-mo-shi/"/>
      <url>/2018/12/04/lao-bo-ke/she-ji-mo-shi-zhi-gua-pei-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<pre><code>   适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。适配器模式是一种常用设计模式，适配器模式是对类的增强，例如[在Spring AOP中使用适配器模式将通知封装为对应的方法拦截器。](http://blog.csdn.net/adoocoke/article/details/8286902)</code></pre><p>适配器模式有类适配器模式和对象的适配器模式两种不同的形式。如下图所示，左边是的类的适配器模式（继承），右边是对象的适配器模式（引用）。<br><img src="http://img.blog.csdn.net/20170908175930761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>两种适配器模式中，对象适配器更为灵活，对象适配器可以根据给定的源（adaptee）灵活的适配多个对象，而类适配器适配的对象则是固定的，不利于扩。针对不同的使用场景，两者各有优点。</p><p><strong>类的适配器模式</strong></p><hr><p>类的适配器模式把被适配的类的API转换成目标类的API，其静态结构图如下所示。</p><p><img src="http://img.blog.csdn.net/20170908180737448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>在上图中可以看出，Adaptee类并没有simpleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的。</p><p>模式所涉及的角色有：</p><pre><code>目标（Target）角色：这就是所期待得到的接口。注意，由于这里讨论的是类适配器模式，因此目标不可以是类。源（Adaptee）角色：现有需要配置的接口。适配器（Adapter）角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一叫色不可以是接口，而必须是具体类。</code></pre><p><strong>对象的适配器模式</strong></p><hr><p>与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。对象的适配器模式的静态结构如下图所示。</p><p><img src="http://img.blog.csdn.net/20170908181129175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从上图中可以看出，Adaptee类并没有simpleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装（Wrapper）类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了这个适配器模式是对象的。<br>从上图可以看出，模式所涉及的角色有：</p><blockquote><p> 目标（Target）角色：这就是所期待的接口，目标可以是具体的或抽象的类。<br>    源（Adaptee）角色：现有需要适配的接口。<br>    适配器（Adapter）角色：适配器类是本模式的核心。适配器把源接口转换成目标接口，显然，这一角色必须是具体类。</p></blockquote><pre><code>                               ***代码示例***</code></pre><p>类的适配器模式代码</p><pre><code>public interface Target {    /**     * 这是源类也有的方法simpleOperation1     */    void simpleOperation1();    /**     * 这是源类没有的方法simpleOperation2     */    void simpleOperation2();}</code></pre><p>上面给出的是目标角色的源代码，这个角色是以一个Java接口的形式实现的。可以看出，这个接口声明了两个方法：simpleOperation1()和simpleOperation2()。而<strong>源角色Adatpee是一个具体类</strong>，它有一个simpleOperation1()方法，但是没有simpleOperation2()方法，如下面代码清单所示。</p><pre><code>public class Adaptee {    /**     * 源类含有方法simpleOperation1     */    public void simpleOperation1(){};}</code></pre><p>适配器角色Adapter扩展了Adaptee,同时又实现了目标接口。由于Adaptee没有提供simpleOperation2()方法，而目标接口又要求这个方法，因此适配器角色Adatper实现了这个方法，如下面代码清单所示。</p><pre><code>public class Adapter extends Adaptee implements Target {    /**     * 由于源类没有方法simpleOperation2     * 因此适配器类补充上这个方法     */    @Override    public void simpleOperation2() {    }}</code></pre><p>类的适配器模式的效果：</p><p>   缺点: 使用一个具体类把源（Adaptee）适配到目标（Target）中。这样一来，如果源以及源的子<br>   类都使用此类适配，就行不通了。<br>    由于适配器类是源的子类，因此可以适配器类中之换掉（Override）源的一些方法。<br>    由于只引进了一个适配器类，因此只有一个路线到目标类，使问题得到简化。</p><p><strong>对象的适配器模式代码</strong></p><pre><code>public interface Target {    /**     * 这是源类也有的方法simpleOperation1     */    void simpleOperation1();    /**     * 这是源类没有的方法simpleOperation2     */    void simpleOperation2();}</code></pre><p>上面给出的是目标角色的源代码，这个角色是以一个Java接口的形式实现的。可以看出，这个接口声明了两个方法：simpleOperation1()和simpleOperation2()。而源角色Adapatee是一个具体类，它有一个simpleOperation1()方法，但是没有simpleOperation2()方法，如下面带入清单所示。</p><pre><code>public class Adaptee {    /**     * 源类含有方法simpleOperation1     */    public void simpleOperation1(){};}</code></pre><p>适配器类的源代码如下面代码清单所示。</p><pre><code>public class Adapter implements Target {    private Adaptee adaptee;    public Adapter(Adaptee adaptee) {        super();        this.adaptee = adaptee;    }    /**     * 源类有方法simpleOperation1     * 因此适配器类直接委派即可     */    @Override    public void simpleOperation1() {        adaptee.simpleOperation1();    }    /**     * 源类没有方法simpleOperation2     * 因此适配器类补充上这个方法     */    @Override    public void simpleOperation2() {        //write you code here    }}</code></pre><p>对象的适配器模式的效果：</p><pre><code> **一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。**</code></pre><pre><code>与类的适配器模式相比，要想置换源类的方法就不容易。如果一定要置换掉源类的一个或多个方法，就只好先做一个源类的子类，将源类的方法置换掉，然后再把源类的子类当作真正的源进行适配。虽然想要置换源类的方法不容易，但是要想增加一些新的方法则方便得很，而且新增加的方法可同时适用于所有的源。</code></pre><p>总结</p><p>适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在Spring等开源框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式。</p><ol><li><p>主要优点<br>无论是对象适配器模式还是类适配器模式都具有如下优点：</p><p> 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。<br> 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。<br> 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p></li></ol><p>具体来说，类适配器模式还有如下优点：</p><pre><code>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</code></pre><p>对象适配器模式还有如下优点：</p><pre><code>一个对象适配器可以把多个不同的适配者适配到同一个目标；可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</code></pre><ol start="2"><li><p>主要缺点<br>类适配器模式的缺点如下：</p><p> 对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；<br> 适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；<br> 在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</p></li></ol><p>对象适配器模式的缺点如下：</p><pre><code>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</code></pre><ol start="3"><li><p>适用场景<br>在以下情况下可以考虑使用适配器模式：</p><p> 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。<br> 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。<br> （对对象的适配器模式而言）在设计里，需要改变多个已有的子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器类，而这不太实际。</p></li></ol><p>整理的适配器模式思维导图</p><p><img src="http://img.blog.csdn.net/20170908185218094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>明天就要学转前端了，收集了一些资料放这里了</title>
      <link href="/2018/12/04/lao-bo-ke/ming-tian-jiu-yao-xue-zhuan-qian-duan-liao-shou-ji-liao-yi-xie-zi-liao-fang-zhe-li-liao/"/>
      <url>/2018/12/04/lao-bo-ke/ming-tian-jiu-yao-xue-zhuan-qian-duan-liao-shou-ji-liao-yi-xie-zi-liao-fang-zhe-li-liao/</url>
      
        <content type="html"><![CDATA[<p>#下面是资料的链接，请尊重资料的作者，不要随意转发。</p><hr><p>1.react相关的学习资料<br><a href="http://it-ebooks.flygon.net/" target="_blank" rel="noopener">http://it-ebooks.flygon.net/</a></p><p><img src="http://img.blog.csdn.net/20171203213241122?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>面向对象程序设计原则</title>
      <link href="/2018/12/04/lao-bo-ke/mian-xiang-dui-xiang-cheng-xu-she-ji-liu-da-yuan-ze/"/>
      <url>/2018/12/04/lao-bo-ke/mian-xiang-dui-xiang-cheng-xu-she-ji-liu-da-yuan-ze/</url>
      
        <content type="html"><![CDATA[<p>面向对象程序设计原则</p><pre><code>一、单一职责原则：</code></pre><p>全称：“Single-Responsibility Principle”<br>说明：就一个类而言，应该只专注于做一件事和仅有一个引起它变化的原因。所谓职责，我们可以理解他为功能，就是设计的这个类功能应该只有一个，而不是两个或更多。也可以理解为引用变化的原因，当你发现有两个变化会要求我们修改这个类，那么你就要考虑撤分这个类了。因为职责是变化的一个轴线，当需求变化时，该变化会反映类的职责的变化。<br>使用SRP注意点：<br>1、一个合理的类，应该仅有一个引起它变化的原因，即单一职责；<br>2、在没有变化征兆的情况下应用SRP或其他原则是不明智的；<br>3、在需求实际发生变化时就应该应用SRP等原则来重构代码；<br>4、使用测试驱动开发会迫使我们在设计出现臭味之前分离不合理代码；<br>5、如果测试不能迫使职责分离，僵化性和脆弱性的臭味会变得很强烈，那就应该用Facade或Proxy模式对代码重构；SRP优点：消除耦合，减小因需求变化引起代码僵化。</p><pre><code>二、里氏代换原则</code></pre><p>全称：“Liskov Substitution Principle”<br>说明：子类型必须能够替换它们的基类型。一个软件实体如果使用的是一个基类，那么当把这个基类替换成继承该基类的子类，程序的行为不会发生任何变化。软件实体察觉不出基类对象和子类对象的区别。<br>优点：可以很容易的实现同一父类下各个子类的互换，而客户端可以毫不察觉。</p><pre><code>三、依赖倒置原则</code></pre><p>全称：“Dependence Inversion Principle”<br>说明：<br>1、高层模块不应该依赖低层模块，两者都应该依赖于抽象（抽象类或接口）</p><p>2、抽象（抽象类或接口）不应该依赖于细节（具体实现类）</p><p>3、细节（具体实现类）应该依赖抽象</p><p>抽象：即抽象类或接口，两者是不能够实例化的</p><p>细节：即具体的实现类，实现接口或者继承抽象类所产生的类，两者可以通过关键字new直接被实例化</p><p>而依赖倒置原则的本质骑士就是通过抽象（抽象类或接口）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。但是这个原则也是6个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开发，对修改关闭）也无法实现。</p><pre><code>四、接口隔离原则</code></pre><p>全称：“Interface Segregation Principle”<br>说明：使用多个专一功能的接口比使用一个的总接口总要好。从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小接口上的。过于臃肿的接口是对接口的污染，不应该强迫客户依赖于它们不用的方法。<br>优点：会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。<br>如何实现接口隔离原则<br>不应该强迫用户依赖于他们不用的方法。<br>1、利用委托分离接口。<br>2、利用多继承分离接口。</p><pre><code>五、迪米特原则</code></pre><p>全称：“Law of Demeter”<br>说明：对象与对象之间应该使用尽可能少的方法来关联，避免千丝万缕的关系。<br>如何实现迪米特法则？<br>迪米特法则的主要用意是控制信息的过载，在将其运用到系统设计中应注意以下几点：<br>1) 在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用。<br>2) 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。<br>3) 在类的设计上，只要有可能，一个类应当设计成不变类。<br>4) 在对其它对象的引用上，一个类对其它对象的引用应该降到最低。</p><pre><code>六、开放－封闭原则</code></pre><p>全称：“Open-Closed Principle”<br>说明：所谓开放封闭原则就是软件实体应该对扩展开发，而对修改封闭。开放封闭原则是所有面向对象原则的核心。软件设计本身所追求的目标就是封装变化，降低耦合，而开放封闭原则正是对这一目标的最直接体现。<br>   开放封闭原则主要体现在两个方面：</p><p>   对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p><p>   对修改封闭，意味着类一旦设计完成，就可以独立其工作，而不要对类尽任何修改。</p><p>为什么要用到开放封闭原则呢？</p><p>软件需求总是变化的，世界上没有一个软件的是不变的，因此对软件设计人员来说，必须在不需要对原有系统进行修改的情况下，实现灵活的系统扩展。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>幂等性[或者http幂等性]的理解</title>
      <link href="/2018/12/04/lao-bo-ke/mi-deng-xing-huo-zhe-http-mi-deng-xing-de-li-jie/"/>
      <url>/2018/12/04/lao-bo-ke/mi-deng-xing-huo-zhe-http-mi-deng-xing-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p></p><h2 id="怎么理解幂等性"><a href="#怎么理解幂等性" class="headerlink" title="怎么理解幂等性"><br></a>怎么理解幂等性</h2><br><strong>理解要点</strong><p></p><p>幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, </p><blockquote><p>外部多次调用对系统的影响是一致的</p></blockquote><p>. 声明为幂等的接口会认为外部调用失败是常态, 并且</p><blockquote><p>失败之后必然会有重试.</p></blockquote><hr><p>声明为幂等性的API，多次调用后对调用资源产生影响或作用结果和一次调用产生的结果是相同的，幂等性API强调安全，不会因为多次的重复调用对系统资源产生错误的操作，正在金融业务中尤为重要。</p><hr><p>HTTP幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。</p><br><p>还是以之前的博文的例子为例。</p><br><pre class="prettyprint linenums prettyprinted" style="overflow: auto;"><ol class="linenums"><li class="L0"><span class="pln">GET     </span><span class="pun">/</span><span class="pln">tickets       </span><span class="com"># 获取ticket列表</span></li><li class="L1"><span class="pln">GET     </span><span class="pun">/</span><span class="pln">tickets</span><span class="pun">/</span><span class="lit">12</span><span class="pln">    </span><span class="com"># 查看某个具体的ticket</span></li><li class="L2"><span class="pln">POST    </span><span class="pun">/</span><span class="pln">tickets       </span><span class="com"># 新建一个ticket</span></li><li class="L3"><span class="pln">PUT     </span><span class="pun">/</span><span class="pln">tickets</span><span class="pun">/</span><span class="lit">12</span><span class="pln">    </span><span class="com"># 更新ticket 12</span></li><li class="L4"><span class="pln">PATCH   </span><span class="pun">/</span><span class="pln">tickets</span><span class="pun">/</span><span class="lit">12</span><span class="pln">    </span><span class="com"># 更新ticket 12</span></li><li class="L5"><span class="pln">DELETE  </span><span class="pun">/</span><span class="pln">tickets</span><span class="pun">/</span><span class="lit">12</span><span class="pln">    </span><span class="com"># 删除ticekt 12</span></li></ol></pre><br><br><h3 id="HTTP-GET方法"><a href="#HTTP-GET方法" class="headerlink" title="HTTP GET方法"></a>HTTP GET方法</h3><p>HTTP GET方法，用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。</p><br><pre class="prettyprint linenums prettyprinted" style="overflow: auto;"><ol class="linenums"><li class="L0"><span class="pln">GET     </span><span class="pun">/</span><span class="pln">tickets       </span><span class="com"># 获取ticket列表</span></li><li class="L1"><span class="pln">GET     </span><span class="pun">/</span><span class="pln">tickets</span><span class="pun">/</span><span class="lit">12</span><span class="pln">    </span><span class="com"># 查看某个具体的ticket</span></li></ol></pre><br><br><p>只是查询数据，不会影响到资源的变化，因此我们认为它幂等。</p><br><p>值得注意，幂等性指的是作用于结果而非资源本身。怎么理解呢？例如，这个HTTP GET方法可能会每次得到不同的返回内容，但并不影响资源。</p><br><p>可能你会问有这种情况么？当然有咯。例如，我们有一个接口获取当前时间，我们就应该设计成</p><br><pre class="prettyprint linenums prettyprinted" style="overflow: auto;"><ol class="linenums"><li class="L0"><span class="pln">GET     </span><span class="pun">/</span><span class="pln">service_time </span><span class="com"># 获取服务器当前时间</span></li></ol></pre><br><br><p>它本身不会对资源本身产生影响，因此满足幂等性。</p><br><h3 id="HTTP-POST方法"><a href="#HTTP-POST方法" class="headerlink" title="HTTP POST方法"></a>HTTP POST方法</h3><p>HTTP POST方法是一个非幂等方法，因为调用多次，都将产生新的资源。</p><br><pre class="prettyprint linenums prettyprinted" style="overflow: auto;"><ol class="linenums"><li class="L0"><span class="pln">POST    </span><span class="pun">/</span><span class="pln">tickets       </span><span class="com"># 新建一个ticket</span></li></ol></pre><br><br><p>因为它会对资源本身产生影响，每次调用都会有新的资源产生，因此不满足幂等性。</p><br><h3 id="HTTP-PUT方法"><a href="#HTTP-PUT方法" class="headerlink" title="HTTP PUT方法"></a>HTTP PUT方法</h3><p>HTTP PUT方法是不是幂等的呢？我们来看下</p><br><pre class="prettyprint linenums prettyprinted" style="overflow: auto;"><ol class="linenums"><li class="L0"><span class="pln">PUT     </span><span class="pun">/</span><span class="pln">tickets</span><span class="pun">/</span><span class="lit">12</span><span class="pln">    </span><span class="com"># 更新ticket 12</span></li></ol></pre><br><br><p>因为它直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足幂等性。</p><br><h3 id="HTTP-PATCH方法"><a href="#HTTP-PATCH方法" class="headerlink" title="HTTP PATCH方法"></a>HTTP PATCH方法</h3><p>HTTP PATCH方法是非幂等的。HTTP POST方法和HTTP PUT方法可能比较好理解，但是HTTP PATCH方法只是更新部分资源，怎么是非幂等的呢?</p><br><p>因为，PATCH提供的实体则需要根据程序或其它协议的定义，解析后在服务器上执行，以此来修改服务器上的资源。换句话说，PATCH请求是会执行某个程序的，如果重复提交，程序可能执行多次，对服务器上的资源就可能造成额外的影响，这就可以解释它为什么是非幂等的了。</p><br><p>可能你还不能理解这点。我们举个例子</p><br><pre class="prettyprint linenums prettyprinted" style="overflow: auto;"><ol class="linenums"><li class="L0"><span class="pln">PATCH   </span><span class="pun">/</span><span class="pln">tickets</span><span class="pun">/</span><span class="lit">12</span><span class="pln">    </span><span class="com"># 更新ticket 12</span></li></ol></pre><br><br><p>此时，我们服务端对方法的处理是，当调用一次方法，更新部分字段，将这条ticket记录的操作记录加一，这次，每次调用的资源是不是变了呢，所以它是有可能是非幂等的操作。</p><br><h3 id="HTTP-DELETE方法"><a href="#HTTP-DELETE方法" class="headerlink" title="HTTP DELETE方法"></a>HTTP DELETE方法</h3><p>HTTP DELETE方法用于删除资源，会将资源删除。</p><br><pre class="prettyprint linenums prettyprinted" style="overflow: auto;"><ol class="linenums"><li class="L0"><span class="pln">DELETE  </span><span class="pun">/</span><span class="pln">tickets</span><span class="pun">/</span><span class="lit">12</span><span class="pln">    </span><span class="com"># 删除ticekt 12</span></li></ol></pre><br><br><p>调用一次和多次对资源产生影响是相同的，所以也满足幂等性。</p><br><h2 id="如何设计符合幂等性的高质量RESTful-API"><a href="#如何设计符合幂等性的高质量RESTful-API" class="headerlink" title="如何设计符合幂等性的高质量RESTful API"></a>如何设计符合幂等性的高质量RESTful API</h2><h3 id="HTTP-GET方法-vs-HTTP-POST方法"><a href="#HTTP-GET方法-vs-HTTP-POST方法" class="headerlink" title="HTTP GET方法 vs HTTP POST方法"></a>HTTP GET方法 vs HTTP POST方法</h3><p>也许，你会想起一个面试题。HTTP请求的GET与POST方式有什么区别？你可能会回答到：GET方式通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。但是，我们现在从RESTful的资源角度来看待问题，HTTP GET方法是幂等的，所以它适合作为查询操作，HTTP POST方法是非幂等的，所以用来表示新增操作。</p><br><p>但是，也有例外，我们有的时候可能需要把查询方法改造成HTTP POST方法。比如，超长（1k）的GET URL使用POST方法来替代，因为GET受到URL长度的限制。虽然，它不符合幂等性，但是它是一种折中的方案。</p><br><h3 id="HTTP-POST方法-vs-HTTP-PUT方法"><a href="#HTTP-POST方法-vs-HTTP-PUT方法" class="headerlink" title="HTTP POST方法 vs HTTP PUT方法"></a>HTTP POST方法 vs HTTP PUT方法</h3><p>对于HTTP POST方法和TTP PUT方法，我们一般的理解是POST表示创建资源，PUT表示更新资源。当然，这个是正确的理解。</p><br><p>但是，实际上，两个方法都用于创建资源，更为本质的差别是在幂等性。HTTP POST方法是非幂等，所以用来表示创建资源，HTTP PUT方法是幂等的，因此表示更新资源更加贴切。</p><br><h3 id="HTTP-PUT方法-vs-HTTP-PATCH方法"><a href="#HTTP-PUT方法-vs-HTTP-PATCH方法" class="headerlink" title="HTTP PUT方法 vs HTTP PATCH方法"></a>HTTP PUT方法 vs HTTP PATCH方法</h3><p>此时，你看会有另外一个问题。HTTP PUT方法和HTTP PATCH方法，都是用来表述更新资源，它们之间有什么区别呢？我们一般的理解是PUT表示更新全部资源，PATCH表示更新部分资源。首先，这个是我们遵守的第一准则。根据上面的描述，PATCH方法是非幂等的，因此我们在设计我们服务端的RESTful API的时候，也需要考虑。如果，我们想要明确的告诉调用者我们的资源是幂等的，我的设计更倾向于使用 HTTP PUT 方法。</p><pre><code>    (完)=</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>梦想是一个天真的词，实现梦想是一个残酷的词</title>
      <link href="/2018/12/04/lao-bo-ke/meng-xiang-shi-yi-ge-tian-zhen-de-ci-shi-xian-meng-xiang-shi-yi-ge-can-ku-de-ci/"/>
      <url>/2018/12/04/lao-bo-ke/meng-xiang-shi-yi-ge-tian-zhen-de-ci-shi-xian-meng-xiang-shi-yi-ge-can-ku-de-ci/</url>
      
        <content type="html"><![CDATA[<p>梦想是一个天真的词，实现梦想是一个残酷的词。今天我要探索人工智能啦！<br><img src="http://ouuy81imh.bkt.clouddn.com/20180508092648717.png" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>枚举实现单例的原理</title>
      <link href="/2018/12/04/lao-bo-ke/mei-ju-shi-xian-dan-li-yuan-li/"/>
      <url>/2018/12/04/lao-bo-ke/mei-ju-shi-xian-dan-li-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>最近因为工作需要需要实现单例模式，考虑到单例模式最简单的实现方式是枚举实现，因此研究了下枚举实现单例模式的原理，下面将从原理、详解两个步骤说明：<br>             一：原理<br>        1、单例模式利用了“<clinit>()” 方法在类加载的过程中线程安全的实例化了一个实例；<br>        【 “<clinit>()” 是由编译器自动收集类中的所有类变量（static）的赋值动作和静态语句块（static{}）块中的语句合并产生的。因此，private static Singleton singleton = new Singleton();也会被放入到这个方法中。】<br>        2、枚举类的构造器是private私有的，保障了内存中只有枚举的一个实例；<br>        二：详解<br>        1）、为什么说枚举实例是单例且线程安全的？<br>                        就拿枚举来说，其实Enum就是一个普通的类，它继承自`java.lang.Enum类。</clinit></clinit></p><pre><code>public enum SingletonEnum{                SINGLETON;            }  </code></pre><pre><code> 对Singleton进行反编译可以得到如下java类：</code></pre><pre><code>public final class SingletonEnum extends Enum&lt;SingletonEnum&gt; {      public static final SingletonEnum SINGLETON;      public static SingletonEnum[] values();      public static SingletonEnum valueOf(String s);      static {};}</code></pre><p>由反编译后的代码可知，SINGLETON被声明为 static 的【 public static final SingletonEnum SINGLETON&lt;==&gt;public static final SingletonEnum SINGLETON = New SingletonEnum （）;】，<a href="https://blog.csdn.net/gavin_dyson/article/details/69668946" target="_blank" rel="noopener">根据类加载过程可以知道虚拟机会保证一个类的<clinit>() 方法在多线程环境中被正确的加锁、同步。</clinit></a>所以，枚举实现是在实例化时是线程安全。<br>    2）、如何保证枚举实例的单例？<br>    首先</p><pre><code>public enum SingletonEnum{                SINGLETON;            }  </code></pre><p>的实质是：</p><pre><code>public enum SingletonEnum{                SINGLETON;                ......                private SingletonEnum(){......}            }  </code></pre><p>因此外部无法通过构造器创建枚举类的实例，这也是枚举类通常用来保存常量的一个原因之一。<br>其次，枚举类的实例会在类加载的时候线程安全的进行初始实例化，在类加载的时候，<a href="https://blog.csdn.net/gavin_dyson/article/details/69668946" target="_blank" rel="noopener">JVM会对<clinit>()方法加锁，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法的那条线程退出<clinit>()方法后，其他线程唤醒后不会再次进入<clinit>()方法。同一个类加载器下，一个类型只会初始化一次。</clinit></clinit></clinit></clinit></clinit></a><br>      综上所述，枚举保证了枚举实例的线程安全和单例性;</p><p>参考文章：<br>      <a href="https://blog.csdn.net/huangyuan_xuan/article/details/52193006" target="_blank" rel="noopener">浅谈使用单元素的枚举类型实现单例模式</a><br>      <a href="https://blog.csdn.net/a907691592/article/details/51668440" target="_blank" rel="noopener">java回顾篇—static和非static的区别</a><br>      <a href="http://www.cnblogs.com/dqrcsc/p/4671879.html" target="_blank" rel="noopener">一个简单java程序的运行全过程</a><br>      <a href="https://www.cnblogs.com/dotgua/p/6354151.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">static关键字的四种用法</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>码农进化之Oracle学习篇</title>
      <link href="/2018/12/04/lao-bo-ke/ma-nong-jin-hua-zhi-oracle-xue-xi-pian/"/>
      <url>/2018/12/04/lao-bo-ke/ma-nong-jin-hua-zhi-oracle-xue-xi-pian/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>1.oracle-c/s</code></pre><p>C/S结构：<br>client/server   客户端 服务器<br>特点：客户端程序比较大。<br>优点：服务器的压力比较小。很多计算都是在客户端本地计算的。运行客户端加载会比较快。客户端运行的效果比较好。有单独的客户端运行的程序。</p><p>大版本的更新可能需要重新安装客户端。</p><p>B/S结构：Browser/server  浏览器 服务器<br>特点：客户端很小。服务器压力比较大。很多资源都需要及时的从服务器下载更新。</p><pre><code>2.oracle概念</code></pre><p>全局数据库名</p><p>唯一标识Oracle数据库的名称<br>数据库实例名SID<br>和操作系统交互，Oracle数据库的一个引用<br>每个启动的数据库都对应一个数据库实例，由这个实例来访问和控制数据库<br>为了运行数据库，Oracle系统所运行的所有进程和分配的内存结构的组合体</p><pre><code>3.LAMP</code></pre><p>业内的免费的黄金组合<br>LAMP：<br>L:<br>Linux：服务器的操作系统<br>A：<br>apache：旗下有非常多的产品  tomcat<br>M：<br>mysql<br>P：<br>php：做web开发的。</p><pre><code>4.常用命令</code></pre><p>登录、切换用户<br>conn scott/tiger<br>conn sys/sys as sysdba</p><p>加锁解锁账户<br>alter user scott account lock;<br>alter user scott account unlock;</p><p>显示当前用户<br>show user</p><p>清屏<br>host cls</p><pre><code>5.SQL-1</code></pre><pre><code>--最简单的sql语句select * from emp;select * from dept;select empno,ename,job,sal from emp;--使用算术运算符--需求：将员工的年薪求出select sal from emp;select ename ,sal from emp;select ename, sal*12 from emp;select ename,sal*12,comm from emp;select ename,sal*12 + comm from emp;--如果comm 是空 则当作0来处理--使用字段别名，增加可读性--别名可以使用双引号 as 以及不添加任何内容  如果别名中包含特殊字符  关键字 空格需要使用双引号 表示该部分是一个整体select * from emp;select empno,ename,job,sal,deptno from emp;select empno &quot;员工编号&quot;, ename 姓名,job as 工种,sal as 工资,deptno as &quot;部门 编号&quot; from emp;--|| 连接符--需求：XXX的年薪是XXX，入职时间是 XXXselect ename,sal*12,hiredate from emp;select ename || &#39;的年薪是,&#39; ||  sal * 12  ||&#39;,入职时间是&#39; || hiredate from emp;--去除重复行 distinctselect deptno from emp;select distinct deptno from emp;select deptno ,job from emp;--把distinct 后面的所有的字段的重复的组合去掉select distinct deptno ,job from emp;--按照部门编号的大小排序   order by  默认asc 升序  降序 descselect deptno from emp order by deptno;select distinct deptno from emp order by deptno desc;select distinct deptno,job from emp order by deptno desc;select distinct deptno, job from emp order by deptno desc, job;--多个字段进行先后的排序，使用逗号分割--按照员工的年薪排序select empno,ename,sal*12 from emp;select empno, ename, sal*12 from emp order by sal*12 desc;--可以使用算术表达式排序select empno, ename,sal*12 年薪 from emp order by 年薪;--还可以使用别名排序</code></pre><pre><code>6.SQL-2</code></pre><pre><code>--where 子句 条件查询--职位是MANAGER 全部显示出来select * from emp where job=&#39;MANAGER&#39;;select empno, ename,job,sal from emp where job=&#39;MANAGER&#39;;select * from emp where job=&#39;manager&#39;;--数据的内容大小写敏感SELECT * FROM emp WHERE job = &#39;MANAGER&#39;;--关键字大小写不敏感select * from EMP WHERE JOB=&#39;MANAGER&#39;;--字段名称大小写不敏感--把部门编号大于20的员工信息列出select * from emp where deptno &gt; 20;select * from emp where deptno &lt; 20;select * from emp where deptno &gt;= 20;select * from emp where deptno &lt;= 20;select * from emp where deptno != 20;select * from emp where deptno &lt;&gt; 20;--建议使用这样的形式--将入职时间为1981/9/8之后的员工的信息全部打印--日期比较两种解决方案，一种 使用类型转换 to_date  还有使用日期字符串的默认格式 &#39;DD-MON-RR&#39;select * from emp where hiredate&gt;&#39;1981/9/8&#39;;--类型不匹配 字符串转化为 date to_date() 然后再比较select * from emp where hiredate &gt; &#39;8-9月-81&#39;--使用日期的默认格式比较--查询工资在2000-3000见的员工的信息select * from emp where sal &gt;=2000 and sal&lt;=3000--and 并且的意思select empno,ename,job,sal from emp where sal &gt;2000 and sal &lt; 3000select empno,ename,job,sal from emp where sal between 2000 and 3000--闭区间[]--岗位是分析师ANALYST或者是MANAGER 经理的员工的信息select * from emp where job=&#39;ANALYST&#39; or job=&#39;MANAGER&#39; or job=&#39;SALESMAN&#39;select * from emp where job in (&#39;ANALYST&#39;,&#39;MANAGER&#39;,&#39;SALESMAN&#39;)--模糊查询 % 通配符 _任意一个字符--员工的名字中包含了字母S的员工的信息select * from emp where ename like &#39;%S%&#39;;--%代表任意个字符  %通配符--首字符为Sselect * from emp where ename like &#39;S%&#39;--第一个字符为任意字符，第二个字符为S的员工的信息select * from emp where ename like &#39;_C%&#39;;--第二个字符为下划线的员工的信息  使用escape 指定转义字符select * from emp where ename like &#39;__\_%&#39; escape &#39;\&#39;;</code></pre><pre><code>7.SQL-3</code></pre><pre><code>--需求 将奖金为 空的员工的信息打印  is null select * from emp where comm is null--将将近为非空的员工信息打印 is not nullselect * from emp where comm  is not null;--运算符的优先级 可以通过使用小括号()来达到先计算某一个部分的目的select * from emp where job=&#39;SALESMAN&#39; or job=&#39;CLERK&#39; and sal&gt;=1280;select * from emp where (job=&#39;SALESMAN&#39; or job=&#39;CLERK&#39;) and sal&gt;=1280;select * from emp where job=&#39;SALESMAN&#39; or (job=&#39;CLERK&#39; and sal&gt;=1280);--伪表  字符函数的测试select * from dual;select lower(&#39;ASD&#39;) from dual;select sysdate ,user from dualselect INITCAP (ename),lower(job) from emp;--数值函数测试（自测）--日期函数测试--如何得到系统日期select sysdate from dual--查询所有员工的名字和入职的天数select ename ,sysdate-hiredate from emp;--查询所有员工的名字和入职的月数select ename, months_between(sysdate,hiredate) from emp;--对某个日期加减月份select sysdate , add_months(sysdate,-1) from dual;select sysdate , add_months(sysdate,12) from dual;--下周一的日期select sysdate,next_day(sysdate,&#39;星期一&#39;) from dual;--本月的最后一天的日期select sysdate ,last_day(sysdate) from dual;--函数的嵌套调用    当前时间的下一个星期一的后面的星期二的日期select sysdate,next_day(next_day(sysdate,&#39;星期一&#39;),&#39;星期二&#39;) from dual;--查询所有员工入职的 星期数 和年数 使用别名增加可读性select ename 姓名,sysdate 当前日期 , sysdate-hiredate 入职天数,(sysdate-hiredate)/7 入职星期数,months_between(sysdate,hiredate) 入职月数,months_between(sysdate,hiredate)/12 入职年数from emp;--自动类型转换select &#39;12.5&#39;+30 from dual;---&gt;42.5select &#39;12.5&#39;||30 from dual;----&gt;12.530--转换函数测试 to_char()  to_date()  to_number()--java 中的结果 51select 1+&#39;2&#39; from dual;--数值 ---&gt;字符串  输出的结果保持一个固定的位数  代表一位数字，如果该位没有数字则强制显示0select to_char(1234.123, &#39;L000,000.0000&#39;) from dual;--代表一位数字，如果该位没有数字则不进行显示，但对于小数点后面的部分仍会强制显示select to_char(123456.789 , &#39;$999,999,999.9999&#39;) from dual--字符串到数值   必须提供数值型字符串 不能包含非法字符select to_number(&#39;123&#39;) from dual;--回忆：日期格式化 “yyyy-MM-dd HH:mm:ss”--日期&lt;---&gt;字符串--将当前日期按照指定的格式输出 HH 默认12小时制select sysdate , to_char(sysdate , &#39;YYYY-MON-DD HH24:MI:SS&#39;) from dual;select sysdate, to_char(sysdate , &#39;YY-MM-DD HH12:MI:SS&#39;) from dual;select sysdate , to_char(sysdate,&#39;YYYY-MM-DD&#39;) from dual;--to_date--需求：求指定日子和当前时间的月份差--将指定的字符串按照指定的模式转化为日期select sysdate, months_between(sysdate , to_date(&#39;2017-07-07&#39;,&#39;YYYY-MM-DD&#39;)) from dual;--求出指定是时间点之后入职的员工的信息？？select * from emp where hiredate&gt;to_date(&#39;1981/12/1&#39;,&#39;YYYY/MM/DD&#39;);--求出指定时间区间内入职的员工的信息？？select * from emp where hiredate between to_date(&#39;1980/12/1&#39;,&#39;YYYY/MM/DD&#39;) and to_date(&#39;1981/12/1&#39;,&#39;YYYY/MM/DD&#39;)select * from emp where hiredate &gt;=to_date(&#39;1980/12/1&#39;,&#39;YYYY/MM/DD&#39;) and hiredate &lt;=to_date(&#39;1981/12/1&#39;,&#39;YYYY/MM/DD&#39;)</code></pre><pre><code>8.常用SQL</code></pre><pre><code>--1:查询每个月倒数第三天入职的员工的所有信息select * from emp where last_day(hiredate)-2=hiredate--2:找出早于30年前入职的员工的信息select * from emp where months_between(sysdate,hiredate)/12&gt;30select * from emp where (to_char(sysdate,&#39;YYYY&#39;)-to_char(hiredate,&#39;YYYY&#39;))&gt;30--3:以首字母都是大写的方式显示所有员工的姓名select ename , initcap(ename) from emp--4:显示不带有字符E的员工的姓名select ename from emp where ename not like &#39;%E%&#39;select ename from emp where ename like &#39;%E%&#39;--5 ：显示名字长度为5的员工的名字select ename from emp where length(ename)=5--6:显示所有员工的名字的前三个字符select ename, substr(ename,0,3) sub_name from emp;--7:显示所有的员工的姓名 把所有的‘A’替换为 &#39;a&#39;select ename ,replace(ename,&#39;A&#39;,&#39;a&#39;) re_name from emp--8:显示员工的所有的信息，按照姓名排序select * from emp order by ename asc;select * from emp order by ename desc;--9:显示员工的姓名，加入公司的年份，加入公司的月份，按照受雇日期排序，若月份相同按照年份排序select ename ,hiredate ,to_char(hiredate,&#39;YYYY&#39;) year,to_char(hiredate,&#39;MM&#39;) month from emp order by month,year;--10:显示有所员工的姓名，和受雇日期，根据服务的年限，将最老的员工排在前面select ename,hiredate from emp order by hiredate--11:显示所有的员工的姓名，工作，薪金，按照工作的降序排序，若工作相同，按照薪金排序select ename,job,sal from emp order by job desc,sal asc;--12:找出所有在2月份受雇的员工的信息select * from emp where to_char(hiredate,&#39;MM&#39;)=2--13  将所有的员工加入公司的天数显示select ename,round(sysdate-hiredate) days from emp--14 将“￥123”字符串，显示为numberselect to_number(&#39;￥123&#39;,&#39;L999.99&#39;) from dualselect to_number(&#39;￥123&#39;,&#39;L999.00&#39;) from dualselect to_number(&#39;￥123.12&#39;,&#39;L999.999&#39;) from dualselect to_number(&#39;￥123.12&#39;,&#39;L999.000&#39;) from dualselect to_char(&#39;123.123&#39;,&#39;L999.9999&#39;) from dualselect to_char(&#39;123.123&#39;,&#39;L999.0000&#39;) from dual</code></pre><pre><code>9.通用函数</code></pre><pre><code>--通用函数  其他函数--查询所有员工的姓名，职位，工资，奖金，总收入（工资+奖金）。--任何值和null做运算结果都是nullselect ename,job,sal,comm,sal+comm income from emp;--处理null 的 函数  nvl  nvl2--nvl：两个参数，如果第一个参数为null，则返回第二个参数，如果不为null 返回第一个参数select ename,job,sal ,comm,sal+nvl(comm,0) income from emp--nvl2:三个参数  如果第一个参数为null 则返回第三个参数，如果第一个参数不为null 返回第二个参数--nvl2和java 中的三目运算符 ? : 相似select ename,job,sal,comm,sal+nvl2(comm,comm,0) income from emp--注意事项 nvl nvl2 中的参数的类型必须要一致。select comm,nvl(comm,&#39;没有奖金&#39;) from emp--decode--将所有的职位显示，不能重复select distinct job from emp--需求：将员工的所有的职位用中文表示--类似于java 中的switch case 语句。select distinct job, decode(job,&#39;SALESMAN&#39;,&#39;销售员&#39;,&#39;PRESIDENT&#39;,&#39;CEO&#39;,&#39;MANAGER&#39;,&#39;经理&#39;,&#39;ANALYST&#39;,&#39;分析师&#39;,&#39;CLERK&#39;,&#39;职员&#39;) from emp;select distinct job, decode(job,&#39;SALESMAN&#39;,&#39;销售员&#39;,&#39;PRESIDENT&#39;,&#39;CEO&#39;,&#39;MANAGER&#39;,&#39;经理&#39;,&#39;ANALYST&#39;,&#39;分析师&#39;,&#39;职员&#39;) from emp;</code></pre><pre><code>10.多行函数</code></pre><pre><code>--多行函数：每次可以处理一组 （多条）数据 然后返回一条数据。也成为分组函数。--一共就5个函数--sum()  avg()  max()  min()  count()--需求：查询公司最高工资，最低工资，总工资，平均工资，公司的总人数select max(sal),min(sal),sum(sal),round(avg(sal)),count(ename) from emp; --5个函数可以分为两类--第一类：max,min,count  可以处理任意类型的数据。select max(ename),min(sal) ,count(hiredate) from emp;--第二类 sum  avg  只能处理数值类型。其他类型不可以select sum(sal),avg(sal) from emp--针对null 多行函数如何处理--多行函数处理null 时会直接忽略掉select ename ,comm from emp where comm is not nullselect sum(comm),avg(comm),count(comm),max(comm),min(comm) from emp--求平均奖金，按照总人数计算select sum(comm),avg(nvl(comm,0)),count(comm),max(comm),min(comm) from emp--count()一般是用来统计数据的条数，如果某一个属性的字段有 null 将不能正确的统计真实的数据的条数。--通常使用count(*)来统计数据的条数。--如果一个表中没有任何的数据，那么count(*)返回0  count 函数永远返回的是一个&gt;=零的值，不会返回null。select * from bonusselect count(*) from bonus--统计10部门的员工总数--表中的字段和单行函数不能和分组函数一起使用，除非以该字段分组。select deptno,count(*) from emp where deptno=10--报错</code></pre><pre><code>11.分组查询</code></pre><pre><code>---分组查询 group by--需求：统计每个部门的人数select count(*) from emp where deptno=10 or deptno=20 or deptno=30--group by 为分组查询的关键字，后面跟要按照分组的字段select deptno, count(*) from emp group by deptno--需求：统计各个部门的总人数，总工资，平均工资，最大工资，最小工资select deptno,count(*),sum(sal),avg(sal),max(sal),min(sal) from emp group by deptno order by deptno--需求：统计各个部门的总人数，总工资，，平均工资，最大工资，最小工资，除了10部门select deptno,count(*),sum(sal),avg(sal),max(sal),min(sal) from emp where deptno &lt;&gt; 10 group by deptno order by deptno --sql 中的关键字的顺序是有严格要求的，不能随意排放--顺序：from--&gt;where(行过滤)--&gt;group by(根据什么字段分组)--having(分组条件)--select(显示哪些字段)--order by(对显示的字段进行排序)--order by 必须放在sql 语句的最后面--统计每个部门的人数，平均工资，排除平均工资小于2000的。--where 后不能使用分组函数。  where 是进行行过滤，不能进行分组过滤，having 是进行分组过滤的。--where 子句在 分组之前进行行过滤。然后在进行分组 group by ，分组之后在进行 分组过滤  having--where 后可以使用的所有的条件判断，在having 后都可以使用。select deptno,count(*)，avg(sal)  from emp  group by deptno having avg(sal)&gt;=2000select deptno,count(*)，avg(sal) avg_sal  from emp  group by deptno having avg_sal&gt;=2000--标识符无效 ，having 子句先与select 执行。--统计每个部门的人数和平均工资，排除10部门 和 平局工资小于1000 的部门。select deptno,count(*),avg(sal) from emp where deptno&lt;&gt;10 group by deptno having avg(sal)&gt;=1000 order by deptno--列出工资最小值小于2000的职位--select 后的字段，必须是分组的字段才可以使用。select job,min(sal) from emp group by job having min(sal)&lt;2000--需求，将所有的职员和销售人员的工资列出select job, sal from emp where job=&#39;CLERK&#39; or job=&#39;SALESMAN&#39;--列出平均工资大于1200的部门和工作组合  对多个字段进行分组select deptno,job,avg(sal) from emp group by deptno,job  having avg(sal)&gt;1200--统计人数小于4的部门的平均工资select deptno,count(*),avg(sal) from emp group by deptno having count(*)&lt;6--统计各部门的最高工资，排除最高工资小于3000的部门？？？select deptno,max(sal) from emp group by deptno having max(sal)&gt;=3000</code></pre><pre><code>12.DML</code></pre><pre><code>--DML  增加   修改 删除 --创建一个临时表  使用查询的结果创建一个表create table temp as select * from emp;create table temp1 as select * from emp where deptno=10select * from temp1--drop table temp1--创建表结构create table temp1 as select * from emp where 1=2--插入数据insert into temp1 (empno,ename,job,mgr,hiredate,sal,comm,deptno) values(1234,&#39;张三丰&#39;,&#39;掌门&#39;,null,sysdate,5000,null,10)insert into temp1 (empno,ename,job,mgr,hiredate,sal,comm,deptno) values(2234,&#39;张无忌&#39;,&#39;徒孙&#39;,null,sysdate,1000,null,10)--使用字段名 顺序 无所谓。只要求values 中的值的顺序和 字段的顺序一致即可。insert into temp1 (ename,empno,job,mgr,hiredate,sal,comm,deptno) values(&#39;周芷若&#39;,3343,&#39;徒孙对象&#39;,null,sysdate,1000,null,10)--插入的数据的列 不一定要求是全部的列，插入的列的数量和 values 中的提供的值的数量和顺序一致即可。insert into temp1 (ename,empno,job,hiredate,sal,deptno) values(&#39;赵敏&#39;,1343,&#39;徒孙媳妇&#39;,sysdate,1000,10)-- 如果想省略列需要插入数据的字段，那么在values 中，必须提供全部的表的字段的值，并且顺序和表中字段的顺序一致。insert into temp1 values(1235,&#39;金毛狮王&#39;,&#39;&#39;,null,sysdate,5000,null,20)--将查询的结果集插入表中insert into temp1 (select * from temp)commit--提交rollback--回滚--update --将10部门有的员工的工资都增加20%update temp1 set sal = sal*1.2 where deptno=10--可以同时修改多个字段，使用逗号分割--需求，将comm 为null 的值修改为0，然后将mgr 为null 的值修改为指定的值。update temp1 set mgr=nvl(mgr,7839),comm=nvl(comm,0)--删除 delete  删除表中 的数据。 from 可以省略delete from temp1 where empno&lt;4000--不加任何的条件，就是删除所有的数据delete temp1--如果把表中的数据都删除，一般不用delete --truncate table 效率更高，而且自带提交功能。truncate table temp1;select * from temp1</code></pre><pre><code>13.多表查询</code></pre><pre><code>--多表查询--笛卡尔集（积）select * from emp;select * from dept;--两张表的笛卡尔集 就是一个乘积的关系select * from emp,dept--消除笛卡尔集--等值连接 --需求：查询员工的编号，姓名，部门编号，部门名称。  sql 92标准中，将多个表的连接条件写在where子句中。select empno,ename,emp.deptno,dnamefrom emp,deptwhere emp.deptno=dept.deptno--给表起别名  一旦给表起了别名，那么只能使用表的别名， 表的原始名称将失效。表的别名不能使用asselect e.empno,e.ename,e.deptno,d.dnamefrom emp e,dept dwhere e.deptno=d.deptno--建议，把所有的需要展示的字段，都使用表名为前缀，表示该字段所在哪个表，可读性更强，效率更高，只需要在指定的表内查找该值即可。--如果多个表中存在相同的字段，那么该字段如果展示，必须使用表名指明是哪个表中的字段。--需求：查询所有员工的姓名，职位 薪水，薪水等级--非等值连接select e.ename,e.job,e.sal,s.gradefrom emp e,salgrade swhere e.sal&gt;=s.losal and e.sal&lt;=s.hisal--首先求出笛卡尔集，然后根据条件判断那些数据是有效数据，这个条件就是where 中需要写入的条件。select e.ename,e.job,e.sal,s.gradefrom emp e,salgrade swhere e.sal between s.losal and s.hisal--自连接  一张表看作两张表--将员工的编号，名字，员工的上级的编号 名字 求出select * from empselect e1.empno,e1.ename,e1.mgr,e2.enamefrom emp e1,emp e2where e1.mgr=e2.empnoselect e1.empno,e1.ename,e2.empno,e2.enamefrom emp e1,emp e2where e1.mgr=e2.empno</code></pre><pre><code>14.外连接</code></pre><pre><code>--使用外连接可以看到参与连接的某一方不满足连接条件的记录，而不仅仅是满足连接条件的数据。--如果没有领导那就只显示员工的信息即可--左外连接 ，将(+) 放到连接条件的右边那个表的后面--右外连接，将(+) 放到连接条件的左边那个表的后面select e1.empno,e1.ename,e1.mgr,e2.enamefrom emp e1,emp e2where e1.mgr=e2.empno(+)--查询所有部门的详细信息，以及每个部门的平均工资，包含没有员工的部门--右外连接select d.* ,round(nvl(avg(e.sal),0)) avg_salfrom emp e, dept dwhere e.deptno(+)=d.deptnogroup by d.deptno,d.dname,d.loc--此处不可以使用d.*order by d.deptno--练习三表查询--查询20号部门的员工的编号，姓名，薪水，部门名称，薪水等级select e.deptno,e.empno,e.ename,e.sal,d.dname,s.gradefrom emp e,dept d,salgrade swhere e.deptno=d.deptno and e.sal between s.losal and s.hisal and d.deptno=20--思考：n张表，至少需要几个连接条件n-1个连接条件</code></pre><pre><code>15.多表连接-99</code></pre><pre><code>--sql99 多表连接--1：cross join 和 92标准中的笛卡尔集是一样的效果select * from emp,dept; --92select * from emp cross join dept --99--2：natural join 自然连接  类似于92标准中等值连接select emp.deptno,dept.deptno  --92 --相同的列前必须使用所属表的限定词from emp,deptwhere emp.deptno=dept.deptno;--99 如果想进行自然连接，那么两个表需要有相同的字段。然后连接时会根据两个字段自动进行等值连接。--两个表中相同的字段，进行自然连接的时候，相同的字段前不能再有所属于某个表的限定词--两个表的连接条件在自然连接中 省略了。select deptnofrom emp natural join dept;--两个表没有相同的字段，等同于cross joinselect * from emp natural join salgrade--using 子句后(连接的字段) 用来指定两个表连接的时候使用哪几个字段。用于等值连接--[inner] join 内连接select * from emp join dept using(deptno) --on 子句 后跟连接条件 既可以是等值连接，也可以是非等值连接--查询30部门员工的  编号 姓名  部门名称select e.empno,e.ename,d.dname --92 标准from emp e,dept dwhere e.deptno=d.deptno and d.deptno=30;select e.empno,e.ename,d.dname--sql99 标准from emp e join dept don e.deptno=d.deptno--连接条件使用on 子句where d.deptno=30--过滤条件仍然使用where--查看10部门员工的姓名，薪水 和薪水等级select e.deptno, e.ename,e.sal,s.gradefrom emp e join salgrade son e.sal between s.losal and s.hisalwhere e.deptno=10--自连接--需求：员工编号，员工的名称，领导的编号，领导的名称select e1.empno,e1.ename,e2.empno,e2.enamefrom emp e1 join emp e2on e1.mgr=e2.empno --外连接--左外连接 left [outer] join--右外连接 right [outer] join--全外连接 full [outer] joinselect e1.empno,e1.ename,e2.empno,e2.enamefrom emp e1 left outer join emp e2on e1.mgr=e2.empno select e1.empno,e1.ename,e2.empno,e2.enamefrom emp e1 right outer join emp e2on e1.mgr=e2.empno select e1.empno,e1.ename,e2.empno,e2.enamefrom emp e1 full outer join emp e2on e1.mgr=e2.empno---查询所有部门的详细信息，以及每个部门的平均工资 包含没有员工的部门select d.* ,round(avg(sal)) avg_salfrom emp e right join dept d on e.deptno=d.deptnogroup by d.deptno,d.dname,d.locorder by d.deptno--查询20号部门的员工的编号、姓名，薪水、部门名称、薪水等级select d.deptno,e.empno,e.ename,e.sal,d.dname,s.gradefrom emp e join dept d on e.deptno=d.deptnojoin salgrade s on e.sal between s.losal and s.hisal where d.deptno=20select deptno,e.empno,e.ename,e.sal,d.dname,s.gradefrom emp e join dept d using(deptno) join salgrade son e.sal between s.losal and s.hisalwhere deptno=20select deptno,e.empno,e.ename,e.sal,d.dname,s.gradefrom emp e natural join dept djoin salgrade son e.sal between s.losal and s.hisalwhere deptno=201、内连接(自然连接): 只有两个表相匹配的行才能在结果集中出现 2、外连接: 包括 （1）左外连接(左边的表不加限制) （2）右外连接(右边的表不加限制) （3）全外连接(左右两表都不加限制) 3、自连接(连接发生在一张基表内) </code></pre><pre><code>16.子查询</code></pre><pre><code>--子查询--单行子查询--如何查得所有比“CLARK”工资高的员工的信息--先查clark 的工资select sal from emp where ename=&#39;CLARK&#39;;select * from emp where sal &gt; 2450--子查询，必须放置到一对小括号中。select * from emp where sal &gt; (select sal from emp where ename=&#39;CLARK&#39;);--查询工资高于平均工资的员工的名字 和工资select avg(sal) from empselect ename,sal from emp where sal &gt; (select avg(sal) from emp)--查询和scott 同一个部门而且比他工资低的员工的姓名和工资select deptno from emp where ename=&#39;SCOTT&#39;select sal from emp where ename=&#39;SCOTT&#39;select ename,sal from empwhere deptno=(select deptno from emp where ename=&#39;SCOTT&#39;) and sal&lt;(select sal from emp where ename=&#39;SCOTT&#39;)--查询 职务 和scott 相同 比scott 雇佣时间早的员工的信息select job from emp where ename=&#39;SCOTT&#39;select hiredate from emp where ename =&#39;SCOTT&#39;select * from emp where job=(select job from emp where ename=&#39;SCOTT&#39;) and hiredate&lt;(select hiredate from emp where ename =&#39;SCOTT&#39;)-- 查询工资比scott 高或者雇佣时间比scott 早的员工的编号和名字select sal from emp where ename=&#39;SCOTT&#39;select hiredate from emp where ename =&#39;SCOTT&#39;select empno,ename from emp where sal&gt;(select sal from emp where ename=&#39;SCOTT&#39;) or hiredate &lt;(select hiredate from emp where ename =&#39;SCOTT&#39;)--多行子查询--查询工资低于任意一个 ‘clerk’ 的工资的员工信息--ALL：和所有的查询的数据都比较--ANY:和结果中的任意一个数据比较--IN：等于结果集中某一个数据select sal from emp where job=&#39;CLERK&#39;select * from emp where sal &lt; any(select sal from emp where job=&#39;CLERK&#39;)--查询工资比所有的‘SALESMAN’都高的雇员的编号，姓名  工资select sal from emp where job=&#39;SALESMAN&#39;select empno,ename,sal from emp where sal &gt; all(select sal from emp where job=&#39;SALESMAN&#39;)--查询部门编号为20 中的职务同部门 10 的员工一样的 员工的信息select job from emp where deptno=10select * from emp where deptno=20 and job in(select job from emp where deptno=10)--查询在员工中那些人是领导select distinct mgr  from emp where mgr is not null;select * from emp where empno in(select distinct mgr  from emp where mgr is not null)select * from emp where empno = any(select distinct mgr  from emp where mgr is not null)--找出部门编号为20 的所有员工中收入最高的职员select max(sal) from emp where deptno=20select * from emp where deptno=20 and sal=(select max(sal) from emp where deptno=20)-- 查询每个部门的平均薪水的等级（可以将子查询作为一张表格，实现多表关联查询）--部门平均薪水  作为一张表select deptno,avg(sal) avg_sal from emp group by deptno--最终结果select T.deptno,avg_sal,s.gradefrom (select deptno,avg(sal) avg_sal from emp group by deptno) T join salgrade son avg_sal between s.losal and s.hisal-- 查询部门的详细信息，以及部门平均工资和等级--部门平均薪水  作为一张表select deptno,avg(sal) avg_sal from emp group by deptno--最终结果select d.*,avg_sal,s.gradefrom (select deptno,avg(sal) avg_sal from emp group by deptno) T join dept d on T.deptno=d.deptnojoin salgrade s on avg_sal between s.losal and s.hisal</code></pre><pre><code>17.练习</code></pre><pre><code>-- 1 、列出所有员工的年工资，按年薪从低到高排序。select (sal+nvl(comm,0))*12 income from emp order by income;-- 2 、列出薪金比“ SMITH ”多的所有员工。select * from emp where sal &gt; (select sal from emp where ename=&#39;SMITH&#39;);-- 3 、列出所有员工的姓名及其直接上级的姓名。select e1.ename,e2.ename --sql99from emp e1 join emp e2on e1.mgr= e2.empnoselect e1.ename,e2.ename --sql92from emp e1 , emp e2where e1.mgr= e2.empno-- 4 、列出受雇日期早于其直接上级的所有员工。select e1.* --sql99from emp e1 join emp e2on e1.mgr= e2.empnowhere e1.hiredate&lt;e2.hiredate-- 5 、列出部门名称和这些部门的员工信息，包括那些没有员工的部门。select d.dname,e.*from dept d left join emp eon d.deptno=e.deptno-- 6 、列出所有job 为“ CLERK ”（办事员）的姓名及其部门名称。select e.ename,d.dnamefrom emp e natural join dept dwhere e.job=&#39;CLERK&#39;-- 7 、列出最低薪金大于1500 的各种工作。select job,min(sal)from empgroup by jobhaving min(sal)&gt;1500-- 8 、列出在部门“ SALES ”（销售部）工作的员工的姓名，假定不知道销售部的部门编号。select e.enamefrom dept d join emp eon d.deptno=e.deptnowhere d.dname=&#39;SALES&#39;-- 9 、列出薪金高于公司平均薪金的所有员工。select *from empwhere sal &gt; (select avg(sal) from emp)-- 10 、列出与“ SCOTT ”从事相同工作的所有员工。select *from empwhere job=(select job from emp where ename=&#39;SCOTT&#39;) and ename &lt;&gt; &#39;SCOTT&#39;-- 11 、列出薪金高于在部门 30 工作的所有员工的薪金的员工姓名和薪金。select ename,salfrom empwhere sal &gt; all(select sal from emp where deptno=30)-- 12 、列出在每个部门工作的员工数量、平均工资和平均服务期限（年）。select count(*),avg(sal),avg(to_char(sysdate,&#39;YYYY&#39;)-to_char(hiredate,&#39;YYYY&#39;))from empgroup by deptno-- 13 、列出所有员工的姓名、部门名称和工资。select e.ename,d.dname,e.salfrom emp e join dept don e.deptno=d.deptno-- 14 、列出从事同一种工作但属于不同部门的员工的一种组合。select e1.ename,e1.deptno,e1.job,e2.ename,e2.deptnofrom emp e1 join emp e2on e1.job=e2.job and e1.deptno &lt;&gt; e2.deptno and e1.ename&lt;e2.ename --保证同一个组合不会出现两次，-- 15 、列出所有部门的详细信息和部门人数。select deptno,d.dname,d.loc ,count(*)from dept d join emp eusing(deptno)group by deptno,d.dname,d.loc order by deptno-- 16 、列出各种工作的最低工资。select job,min(sal)from empgroup by job order by min(sal)-- 17 、列出各个部门的 MANAGER （经理）的最低薪金。select deptno, min(sal)from empwhere job=&#39;MANAGER&#39;group by deptno-- 18 、列出至少有一个员工的所有部门。select deptno,d.dname,d.locfrom emp join dept dusing(deptno)group by deptno,d.loc,d.dnamehaving count(*) &gt; 0</code></pre><pre><code>18.关于用户的操作</code></pre><pre><code>--创建用户--同等权限的用户不能相互创建--需要有管理员的权限create user bfmzdx1 identified by bfmzdx1;--授予权限grant connect , resource to bfmzdx;grant dba to bfmzdx;--撤销用户权限revoke dba from bfmzdx;--修改用户的密码alter user bfmzdx identified by 123456;--删除用户drop user bfmzdx1;--建立一张用来存储学生信息的表--字段包含学号、姓名、性别，年龄、入学日期、班级，email等信息--学号是主键--姓名不能为空--性别默认值是男--年龄范围18---30岁--Email唯一create table student(       sno varchar2(10),       sname varchar2(15),       gender char(2) default &#39;女&#39;,       age number(2),       sdate date,       clazz varchar2(20),       email varchar2(30));insert into student values(&#39;100001&#39;,null,&#39;男&#39;,60,sysdate,&#39;406&#39;,&#39;zhangsanfeng@123.com&#39;);select * from student;</code></pre><pre><code>19.关于表的操作</code></pre><pre><code>--关于表的操作 修改表--添加字段alter table student add (score number(5,2));--删除字段alter table student drop column score;--修改字段的名称alter table student rename column newage to age;--修改字段的数据类型  需要修改的字段的数据必须为空alter table student modify (score varchar2(10))--重命名表--sturename s to student;rename stu to student;--删除表  表会被放到回收站drop table student;create table student(       sno varchar2(10),       sname varchar2(15),       gender char(2) default &#39;女&#39;,       age number(2),       sdate date,       clazz varchar2(20),       email varchar2(30));--查看回收站select * from recyclebin;--还原表格--把回收站的表还原flashback table student to before drop;--把回收站的表还原 表格并重命名flashback table student to before drop rename to s;select * from student;--直接不进回收站，直接删除  shift +deldrop table stu purge;--将回收站内的某一张表删除 purge table stu;--清空回收站purge recyclebin;</code></pre><pre><code>20.约束</code></pre><pre><code>---约束select * from empinsert into emp values(7878,&#39;&#39;,&#39;&#39;,7369,sysdate,null,null,40);select * from dept【1】--主键约束  唯一  非空drop table student purge;create table student(       --sno varchar2(10) constraints pk_student primary key,       sno varchar2(10),-- primary key,--列级主键约束       sname varchar2(15),       gender char(2) default &#39;女&#39;,       age number(2),       sdate date,       clazz varchar2(20),       email varchar2(30),       constraints pk_student primary key (sno)--表级别设置主键约束       --primary key (sno)--简化的表级别 使用系统提供的名字);select * from student;insert into student  values(&#39;100001&#39;,&#39;张三丰&#39;,&#39;&#39;,60,sysdate,&#39;406&#39;,&#39;zhangsanfeng@123.com&#39;);--如果多列作为主键 --联合主键  只能使用表级约束。drop table student purge;create table student(       --sno varchar2(10) constraints pk_student primary key,       sno varchar2(10),-- primary key,--列级主键约束       sname varchar2(15),-- primary key,       gender char(2) default &#39;女&#39;,       age number(2),       sdate date,       clazz varchar2(20),       email varchar2(30),       constraints pk_student primary key (sno,sname)--表级别设置主键约束       --primary key (sno,sname)--简化的表级别 使用系统提供的名字);--联合主键，主键的组合唯一即可  任意一个主键的字段都不能为nullinsert into student  values(&#39;100001&#39;,&#39;张三丰&#39;,&#39;&#39;,60,sysdate,&#39;406&#39;,&#39;zhangsanfeng@123.com&#39;);insert into student  values(null,&#39;张无忌&#39;,&#39;&#39;,60,sysdate,&#39;406&#39;,&#39;zhangsanfeng@123.com&#39;);【2】--非空约束drop table student purge;create table student(       sno varchar2(10),       sname varchar2(15) not null,--列级约束       gender char(2) default &#39;女&#39;,       age number(2),       sdate date,       clazz varchar2(20),       email varchar2(30),       constraints pk_student primary key (sno)       --constraints nn_student_sname not null---非空约束只有列级约束，没有表级约束);select * from student;insert into student  values(&#39;100001&#39;,&#39;张三丰&#39;,&#39;&#39;,60,sysdate,&#39;406&#39;,&#39;zhangsanfeng@123.com&#39;);insert into student  values(&#39;100002&#39;,null,&#39;&#39;,60,sysdate,&#39;406&#39;,&#39;zhangsanfeng@123.com&#39;);--【3】唯一约束  唯一约束的列如果不为空，则值必须唯一，该字段的值可以为null， 多行数据，该字段可以有多个null值。 drop table student purge;create table student(       sno varchar2(10),       sname varchar2(15) not null,--列级约束       gender char(2) default &#39;女&#39;,       age number(2),       sdate date,       clazz varchar2(20),       email varchar2(30) ,--unique,  --列级唯一约束       constraints pk_student primary key (sno),       constraints uk_student_email unique (email));--【4】 检查约束 check 学生的年龄为18-30drop table student purge;create table student(       sno varchar2(10),       sname varchar2(15) not null,--列级约束       gender char(2) default &#39;女&#39; check (gender in (&#39;男&#39;,&#39;女&#39;)),       age number(2) ,--check (age between 18 and 30),--check (age &gt;=18 and age &lt;=30), 列级检查约束       sdate date,       clazz varchar2(20),       email varchar2(30) ,--unique,  --列级唯一约束       constraints pk_student primary key (sno),       constraints uk_student_email unique (email),       constraints ck_student_age check (age between 18 and 30)--表级检查约束);select * from student;insert into student  values(&#39;100002&#39;,&#39;张三丰&#39;,&#39;男&#39;,18,sysdate,&#39;406&#39;,&#39;zhangsanfeng1@123.com&#39;);--【5】 外键约束  表的外键只能是主表的 主键列或者是 唯一约束的列。create table clazz(--主表       cno varchar2(10) primary key,       cname varchar2(20) not null,       loc varchar2(40) );insert into clazz values(&#39;101&#39;,&#39;20140405&#39;,&#39;银川西夏区&#39;);insert into clazz values(&#39;102&#39;,&#39;20140405&#39;,&#39;北京西三旗&#39;);insert into clazz values(&#39;103&#39;,&#39;20140405&#39;,&#39;银川金凤区&#39;);insert into clazz values(&#39;104&#39;,&#39;20140405&#39;,&#39;北京亦庄&#39;);insert into clazz values(&#39;105&#39;,&#39;20140405&#39;,&#39;北京东三旗&#39;);select * from clazz;drop table student purge;create table student(--子表 、从表       sno varchar2(10),       sname varchar2(15) not null,--列级约束       gender char(2) default &#39;女&#39; check (gender in (&#39;男&#39;,&#39;女&#39;)),       age number(2) ,--check (age between 18 and 30),--check (age &gt;=18 and age &lt;=30), 列级检查约束       sdate date,       clazz varchar2(20),       email varchar2(30) ,--unique,  --列级唯一约束       cno varchar2(10) ,--references clazz(cno),--外键的列级约束       constraints pk_student primary key (sno),       constraints uk_student_email unique (email),       constraints ck_student_age check (age between 18 and 30),--表级检查约束       constraints fk_student_cno foreign key (cno) references clazz (cno));select * from student;insert into student  values(&#39;100001&#39;,&#39;张三丰&#39;,&#39;男&#39;,18,sysdate,&#39;406&#39;,&#39;zhangsanfeng@123.com&#39;,&#39;105&#39;);insert into student  values(&#39;100003&#39;,&#39;张无忌&#39;,&#39;男&#39;,18,sysdate,&#39;406&#39;,&#39;zhangswuji@123.com&#39;,&#39;101&#39;);</code></pre><pre><code>21.级联删除</code></pre><pre><code>--级联删除  三种情况  默认情况  RESTRICTdelete from clazz where cno=&#39;105&#39;;delete from student where cno=&#39;105&#39;;select * from clazz;--级联删除  CASCADEdrop table student purge;create table student(--子表 、从表       sno varchar2(10),       sname varchar2(15) not null,--列级约束       gender char(2) default &#39;女&#39; check (gender in (&#39;男&#39;,&#39;女&#39;)),       age number(2) ,--check (age between 18 and 30),--check (age &gt;=18 and age &lt;=30), 列级检查约束       sdate date,       clazz varchar2(20),       email varchar2(30) ,--unique,  --列级唯一约束       cno varchar2(10) ,--references clazz(cno),--外键的列级约束       constraints pk_student primary key (sno),       constraints uk_student_email unique (email),       constraints ck_student_age check (age between 18 and 30),--表级检查约束       constraints fk_student_cno foreign key (cno) references clazz (cno) on delete cascade);delete from clazz where cno=&#39;102&#39;;----级联删除  set nulldrop table student purge;create table student(--子表 、从表       sno varchar2(10),       sname varchar2(15) not null,--列级约束       gender char(2) default &#39;女&#39; check (gender in (&#39;男&#39;,&#39;女&#39;)),       age number(2) ,--check (age between 18 and 30),--check (age &gt;=18 and age &lt;=30), 列级检查约束       sdate date,       clazz varchar2(20),       email varchar2(30) ,--unique,  --列级唯一约束       cno varchar2(10) ,--references clazz(cno),--外键的列级约束       constraints pk_student primary key (sno),       constraints uk_student_email unique (email),       constraints ck_student_age check (age between 18 and 30),--表级检查约束       constraints fk_student_cno foreign key (cno) references clazz (cno) on delete set null);delete from clazz where cno=&#39;103&#39;;</code></pre><pre><code>22.表格约束-2</code></pre><pre><code>---先创建表，然后再去添加约束drop table student purge;create table student(       sno varchar2(10),       sname varchar2(15),       gender char(2) default &#39;女&#39;,       age number(2),       sdate date,       clazz varchar2(20),       email varchar2(30),       cno varchar2(20));alter table student add constraints pk_student primary key (sno);alter table student add constraints uk_student_email unique (email);alter table student add constraints ck_student_age check (age between 18 and 30);alter table student add constraints ck_student_gender check (gender in(&#39;男&#39;,&#39;女&#39;));alter table student add constraints fk_student_cno foreign key (cno) references clazz (cno);--删除约束alter table student drop constraints fk_student_cno;--修改  约束不能修改，如果想修改某个约束，只能先删除 然后再添加select * from clazz;select * from student;--删除某一张表  不能直接删除  可以先删除掉外键约束，然后再删除主表drop table clazz;flashback table clazz to before drop;--强制删除  其实走的也是先删除约束，然后再删除相关的表drop table clazz cascade constraints;</code></pre><pre><code>23.序列-索引</code></pre><pre><code>-序列 Sequence oracle 专有的数据库对象--希望主键的列是递增的。--创建默认属性的一个序列  从1开始 递增 1 不循环 create sequence seq_clazz_cno;--创建自定义属性的序列create sequence seq_clazz_cnoincrement by 1start with 100;--maxvalue 9999999999999999insert into clazz values(seq_clazz_cno.nextval,&#39;20170202&#39;,null);--删除序列drop sequence seq_clazz_cno;--获得当前序列的值  currval 必须在nextvalue 使用之后才能生效select seq_student_sno.nextval from dual;--每次访问nextvalue 都会根据自增的数值进行递增。select seq_student_sno.currval from dual;insert into student  values(seq_student_sno.nextval,&#39;张翠山&#39;,&#39;男&#39;,28,sysdate,&#39;406&#39;,&#39;zhangcuishan2@123.com&#39;,&#39;103&#39;);select * from student;select * from clazz;--索引--索引的作用：在数据库中用来加速对表的查询,通过使用快速路径访问方法快速定位数据,减少了磁盘的I/O--索引创建以后，如果根据创建索引的字段进行数据的检索，那么该字段对应的索引会被被动使用。--索引创建--自动: 当在表上定义一个PRIMARY KEY 或者UNIQUE 约束条件时,Oracle数据库自动创建一个对应的唯一索引.--手动: 用户可以创建索引以加速查询--手动创建--删除索引drop index index_student_sname;select sname from student;create index index_student_sname on student (sname desc);select sname from student;select * from student where sname=&#39;张三丰&#39;;--删除索引drop index index_student_sname;-- 授予权限grant dba to bfmzdx;</code></pre><pre><code>24.视图</code></pre><pre><code>--视图  view--视图 view 之所以被称之为虚表  并没有真实的存储任何的数据。其实就是一条sql 语句，是访问的另外的一张表  或者是 视图。--创建视图create or replace view view_student as (select * from student);--访问视图select * from view_student ;--操作视图 DML 操作--将 sno =10 的数据的日期修改  通过视图 可以修改基表的数据update view_student set sdate=to_date(&#39;2017-10-10&#39;,&#39;YYYY-MM-DD&#39;) where sno=10--设置视图只读  设置只读之后，视图只能被查询 不能被DML 操作。select sno,sname,gender,age,sdate from student;create or replace view view_stu as (select sno,sname,gender,age,sdate from student) with read only;--对只有部分字段的视图进行DML 操作insert into view_stu values(&#39;100003&#39;,&#39;卿易富网&#39;,&#39;男&#39;,29,sysdate);--删除视图drop view view_stu;--需求：查询所有班级的详细信息，并统计班级的人数和平均年龄select c.*,count(*),avg(s.age)--92from student s,clazz cwhere s.cno(+) = c.cnogroup by c.cno,c.cname,c.loc--复杂的视图查询操作，一般都设置为只读create or replace view view_sc as(--92  select c.*,count(*) count_clazz ,avg(s.age) avg_age  from student s,clazz c  where s.cno(+) = c.cno  group by c.cno,c.cname,c.loc) with read only;select c.*,count(*) count_sc,avg(s.age) avg_age--SQL99from student s right join clazz con(s.cno=c.cno)group by c.cno,c.cname,c.locselect * from view_sc;select count_clazz,avg_age from view_sc;--通过视图创建视图create or replace view view_1 as (select * from view_sc);select * from view_1;--作用：--1：保护数据 通过设置视图可以访问的字段，和 设置视图为只读 with read only 来达到保护数据的目的。--2：简化查询 如果一个查询是一个比较复杂的查询，可以将查询的结果作为视图使用。下次在进行相应的查询，只需要查询该视图即可--如果视图定义的字段中，缺少了基本表中非空的字段，是否可以进行插入的操作？？？？？</code></pre><pre><code>25.分页查询</code></pre><pre><code>--rowid  rownum--访问rowidselect s.* ,s.rowid from student s ;--rowid 作用：--rowid 程序员是不能操作。rowid 都是由数据库软件自己维护。查找数据都是通过rowid 来完成。直接指向了磁盘上的物理地址。--rownum 并不是真实存在的数据。  是需要显示的时候，将需要的结果查询出来之后，显示的时候，--根据查询的结果对每一条数据赋值一个rownum--rownum 特别指定显示rownumselect rownum,s.* from student s;---其主要的用处是控制查询返回的行数--delete from emp where empno=7878;select * from emp;--需求  把emp 中的前5条数据显示select rownum,e.* from emp e;select rownum ,e.* from emp e where rownum &lt;=5;--需求：把emp 中6-10的数据显示--rownum 从1开始，所有查询到的数据给rownum 赋值，然后判断是否满足条件。满足条件的第一条数据rownum 是1--只能使用：&lt;,&lt;=select rownum ,e.* from emp e where rownum between 5 and 11;-- select 时对rownub 赋值 order by 是最后的select rownum,e.* from emp e order by sal desc;--需求：拿按照工资排序的6-10条数据--总结rownun 赋值的时机select rownum,e.* from emp e order by sal desc;--求的工资中最高的前五数据select rownum,t.* from (select e.* from emp e order by sal desc) t where rownum&lt;=5;--需求：拿按照工资排序的6-10条数据 select rownum,R.*from (     --拿到前10条     select rownum r,t.* from            (select e.* from emp e order by sal desc) t where rownum&lt;=5--page * count) Rwhere  R.r&gt;0 -- and R.r&lt;11;  (page-1)*count-- 一页显示 5条数据  count=5  page 当前页</code></pre><pre><code>26.三大范式</code></pre><pre><code>范式是指导数据设计的规范化理论，可以保证数据库设计质量第一范式：字段不能再分第二范式：不存在局部依赖第三范式：不含传递依赖（间接依赖）使用范式可以减少冗余，但是会降低性能特定表的的设计可以违反第三范式，增加冗余提高性能</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>react-motion动画库</title>
      <link href="/2018/12/04/lao-bo-ke/kuai-su-zhang-wo-react-motion-dong-hua-ku-zhuan-zai/"/>
      <url>/2018/12/04/lao-bo-ke/kuai-su-zhang-wo-react-motion-dong-hua-ku-zhuan-zai/</url>
      
        <content type="html"><![CDATA[<div class="preview"><br>                <div class="show-content"><br>                    <div><b>react-motion</b>是一个强大的react动画库。</div><div><br></div><div>官网：<a href="https://github.com/chenglou/react-motion" target="_blank" rel="noopener">react-motion</a><br></div><div><br></div><div>基于<b>react-motion</b>，写了三个简单的动画来讲解使用方法。</div><div><span style="font-size: 1.8rem;"><br></span></div><div><ol><li><b>方块移动</b></li><li><b>跟随鼠标</b></li><li><b>折叠</b></li></ol></div><div><br></div><div>在开始讲解实例之前，我们先来了解一个重要的函数：<span style="background-color: rgb(248, 248, 248); color: rgb(221, 17, 68); font-family: &quot;Source Code Pro&quot;, Consolas, Menlo, Monaco, &quot;Courier New&quot;, monospace; font-size: 0.85em;">spring()</span><br></div><div><br></div><div>语法：<br></div><div><pre class=" language-hljs http"><p><span class="hljs-attribute"><code class="language-hljs http"><p><span class="hljs-attribute">spring(val</span>: number, config?: SpringHelperConfig)<br></p></code></pre></div><div><ul><li><code class="inline-code">val</code>：number, 终点值</li><li><code class="inline-code">config</code>: 用于生成动画缓动效果的配置</li></ul>    - <code class="inline-code">stiffness</code>：默认值170<br>    - <code class="inline-code">damping</code>：默认值26<br>    - <code class="inline-code">precision</code>： 默认值0.01，用于配置val的精确度，一般不需改动<br></div><div><br></div><div>仅从文字很慢描述，一起来感受一下效果：<br></div><div><a href="http://chenglou.github.io/react-motion/demos/demo5-spring-parameters-chooser" target="_blank">http://chenglou.github.io/react-motion/demos/demo5-spring-parameters-chooser</a></div><div><br>对比下面两个弹簧：<br></div><div><img class="ww-ky-photo" src="http://oumfrpm5j.bkt.clouddn.com/react-motion.jpg" alt=""><br></div><div><br></div><div> 我们可以将设置动画物体想象成弹簧，而<code class="inline-code">stiffness</code>就相当于弹簧的强度，也可理解为弹簧被拉伸的长度（有效范围）；<code class="inline-code">damping</code>就相当于弹簧的硬度。</div><div><ul><li>相同硬度下，你拉的越长，它的回弹速度就越快；</li><li>相同强度下，硬度越大，回弹（缓冲）的次数就越少。</li></ul></div><div><br></div><div>Github：<a href="https://github.com/IronPans/react-motion-demo" target="_blank" rel="noopener">react-motion-demo</a></div><div><br></div><div><b>1. 方块移动</b><br></div><div><br></div><div>方块移动实例使用了Motion组件。<br></div><div><br></div><div><span style="background-color: rgb(248, 248, 248); color: rgb(221, 17, 68); font-family: &quot;Source Code Pro&quot;, Consolas, Menlo, Monaco, &quot;Courier New&quot;, monospace; font-size: 0.85em;">&lt;Motion&gt;</span>适合编写单个组件的形变动画。</div><div><span style="font-size: 1.8rem;"><br></span></div><div><span style="font-size: 1.8rem;">属性：</span></div><div><ul><li><code class="inline-code">style</code>：Object，动画样式</li><li><code class="inline-code">defaultStyle</code>：Object，初始样式</li><li><code class="inline-code">children</code>：子元素</li><li><code class="inline-code">onRest</code>：动画结束时触发回调</li></ul></div><div><br></div><div>实例图：</div><div><img class="ww-ky-photo" src="http://oumfrpm5j.bkt.clouddn.com/react-motion-Motion.gif" alt=""><br></div><div><br></div><div><br></div><div><b>2. 跟随鼠标</b><br></div><div><br></div><div>跟随鼠标实例使用了StaggeredMotion组件。</div><div><br></div><div><span style="background-color: rgb(248, 248, 248); color: rgb(221, 17, 68); font-family: &quot;Source Code Pro&quot;, Consolas, Menlo, Monaco, &quot;Courier New&quot;, monospace; font-size: 0.85em;">&lt;StaggeredMotion&gt;</span>用于编写一串有相互关联关系的实体的动画。<br></div><div><br></div><div>属性：</div><div><ul><li><code class="inline-code">styles</code>：Array，动画样式</li><li><code class="inline-code">defaultStyles</code>：Array，初始样式</li><li><code class="inline-code">children</code>：子元素</li></ul></div><div><br></div><div>实例图：</div><div><img class="ww-ky-photo" src="http://oumfrpm5j.bkt.clouddn.com/react-motion-StaggeredMotion.gif" alt=""><br></div><div><br></div><div><b>3. 折叠</b></div><div><span style="font-size: 1.8rem;"><br></span></div><div><span style="font-size: 1.8rem;">折叠实例使用了TransitionMOtion组件。</span></div><div><span style="font-size: 1.8rem;"><br></span></div><div><span style="background-color: rgb(248, 248, 248); color: rgb(221, 17, 68); font-family: &quot;Source Code Pro&quot;, Consolas, Menlo, Monaco, &quot;Courier New&quot;, monospace; font-size: 0.85em;">&lt;TransitionMotion&gt;</span><span style="font-size: 1.8rem;">则是用来编写组件mount和unmount的动画</span></div><div><span style="font-size: 1.8rem;"><br></span></div><div><span style="font-size: 1.8rem;">属性：</span></div><div><ul><li><code class="inline-code">styles</code>：Array，动画样式</li><li><code class="inline-code">defaultStyles</code>：Array，初始样式</li><li><code class="inline-code">children</code>：子元素</li></ul></div><div><br></div><div>实例图：</div><div><img class="ww-ky-photo" src="http://oumfrpm5j.bkt.clouddn.com/react-motion-TransitionMotion.gif" alt=""><br></div><div><br></div><div><br></div>                </div></div>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>基于Vue2.x的自定义博客</title>
      <link href="/2018/12/04/lao-bo-ke/ji-yu-vue2.x-de-zi-ding-yi-bo-ke/"/>
      <url>/2018/12/04/lao-bo-ke/ji-yu-vue2.x-de-zi-ding-yi-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>最近闲来无事，就用Vue2.x模仿着自己的github博客手撸了一个博客，主要用到的技术有：VueX、Vue2.x、axios、iView、Router。最终的博客成果如下图：<br>      <img src="http://ouuy81imh.bkt.clouddn.com/vue-blog.png" alt="在这里插入图片描述"><br>      <img src="http://ouuy81imh.bkt.clouddn.com/my-blog-by-vue.gif" alt="在这里插入图片描述"></p><p>博客架构图如下：<br>   <img src="http://ouuy81imh.bkt.clouddn.com/my-blog-by-vue-002.png" alt="在这里插入图片描述"></p><p>源码：<a href="https://gitee.com/Super_Jun/BlogDevByVue" target="_blank" rel="noopener">https://gitee.com/Super_Jun/BlogDevByVue</a></p><p>开源说明：<a href="https://gitee.com/Super_Jun/BlogDevByVue/blob/master/README.md" target="_blank" rel="noopener">https://gitee.com/Super_Jun/BlogDevByVue/blob/master/README.md</a></p><p>我的朋友都去上海了，讨厌公司的用人套路，MMP，不开心，我也想去了。。。。。。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>国内优秀npm镜像推荐使用</title>
      <link href="/2018/12/04/lao-bo-ke/guo-nei-you-xiu-npm-jing-xiang-tui-jian-shi-yong/"/>
      <url>/2018/12/04/lao-bo-ke/guo-nei-you-xiu-npm-jing-xiang-tui-jian-shi-yong/</url>
      
        <content type="html"><![CDATA[<p></p><h2 id="国内优秀npm镜像">国内优秀npm镜像</h2><p></p><p><hr></p><p></p><h3 id="淘宝npm镜像">淘宝npm镜像</h3><p></p><p><ul></ul></p><p><li>搜索地址：<a href="http://npm.taobao.org/" target="_blank">http://npm.taobao.org/</a></li></p><p><li>registry地址：<a href="http://registry.npm.taobao.org/" target="_blank">http://registry.npm.taobao.org/</a></li><br></p><p></p><h3 id="cnpmjs镜像">cnpmjs镜像</h3><p></p><p><ul></ul></p><p><li>搜索地址：<a href="http://cnpmjs.org/" target="_blank">http://cnpmjs.org/</a></li></p><p><li>registry地址：<a href="http://r.cnpmjs.org/" target="_blank">http://r.cnpmjs.org/</a></li><br></p><p></p><h2 id="如何使用">如何使用</h2><p></p><p><hr></p><p></p><p>有很多方法来配置<code>npm</code>的registry地址，下面根据不同情境列出几种比较常用的方法。以淘宝<code>npm</code>镜像举例：</p><p></p><p></p><h3 id="1-临时使用">1.临时使用</h3><p></p><p><pre><code>   npm –registry <a href="https://registry" target="_blank" rel="noopener">https://registry</a><span class="preprocessor">.npm</span><span class="preprocessor">.taobao</span><span class="preprocessor">.org</span> install express</code></pre></p><p></p><h3 id="2-持久使用">2.持久使用</h3><p></p><p><pre><code>   npm config <span class="keyword">set</span> registry https:<span class="comment">//registry.npm.taobao.org</span></code></pre></p><p><span class="comment">   // 配置后可通过下面方式来验证是否成功</span><br>   npm config <span class="keyword">get</span> registry<br><span class="comment">   // 或</span><br>   npm info express<br></p><p></p><h3 id="2-持久使用">3.通过cnpm使用</h3><p></p><p><pre><code>   npm install -g cnpm –registry=<a href="https://registry" target="_blank" rel="noopener">https://registry</a><span class="preprocessor">.npm</span><span class="preprocessor">.taobao</span><span class="preprocessor">.org</span></code></pre></p><p>   // 使用<br>   cnpm install express<br>            <!-- .entry-content --></p><pre><code>&lt;footer class=&quot;entry-footer&quot;&gt;        &lt;/footer&gt;&lt;!-- .entry-footer --&gt;</code></pre><p></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>父类和子类的相互转换及父类调用子类的方法</title>
      <link href="/2018/12/04/lao-bo-ke/fu-lei-he-zi-lei-de-xiang-hu-zhuan-huan-ji-fu-lei-diao-yong-zi-lei-de-fang-fa/"/>
      <url>/2018/12/04/lao-bo-ke/fu-lei-he-zi-lei-de-xiang-hu-zhuan-huan-ji-fu-lei-diao-yong-zi-lei-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>父类和子类的相互转换及父类调用子类的方法</strong></p><ol><li>父类转换为子类的前提条件是：<strong>父类引用指向子类</strong>;<br>Parent   p=new   Son()<br>Son   s=(Son)p;  –正确<br>Parent   p=new   Parent()<br>Son   s=(Son)p;  –错误搜索  </li></ol><hr><p>根本原因：因为继承的概念就是<strong>子孙类会越来越比祖先类详细</strong>，所以可以将子孙类强制转换成祖先类，因为祖先有的行为子孙类示例都有了（重新定义的或者是默认的）；但是当将祖先类示例强制转换成子孙类示例的时候，一些<strong>子孙类有的行为祖先是没有的</strong>（即使的是默认的实现也没有）</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>分布式架构学习之如何将session信息存储到数据库中</title>
      <link href="/2018/12/04/lao-bo-ke/fen-bu-shi-jia-gou-xue-xi-zhi-ru-he-jiang-session-xin-xi-cun-chu-dao-shu-ju-ku-zhong/"/>
      <url>/2018/12/04/lao-bo-ke/fen-bu-shi-jia-gou-xue-xi-zhi-ru-he-jiang-session-xin-xi-cun-chu-dao-shu-ju-ku-zhong/</url>
      
        <content type="html"><![CDATA[<p>最近实践了一把SpringCloud集成注册中心、网关、配置中心、微服务，恰好电脑上的redis出现了各种问题，索性不用redis，自己写了个中间件，将存储到了MySQL中。下面是期间遇到的各种问题总结。<br>   手先介绍基实现的本原理。我请教了下师傅，总结出了将Session持久化的几条要点。</p><ol><li>Http是无状态的协议；</li></ol><blockquote><p> 所谓http是无状态协议，言外之意是说http协议没法保存客户机信息，也就没法区分每次请求的不同之处，服务器无法区分通过http发送的请求是来源于甲用户还是来源于乙用户的。关于http无状态阻碍了交互式应用程序的实现。比如记录用户浏览哪些网页、判断用户是否拥有权限访问等。于是，两种用于保持HTTP状态的技术就应运而生了，一个是Cookie，而另一个则是Session。</p></blockquote><p> 2.Fetch是默认不携带cookies的；</p><pre><code>fetch默认是不携带cookie到后台的，想要携带cookie必须添加credentials: &quot;include&quot;这个设置；fetch(url, {              method: &#39;GET&#39;,              headers: myHeaders,              --&gt;credentials: &quot;include&quot;&lt;--            })这个时候服务端确实拿到了cookie，但是数据返回报错：ERROR :Fetch API cannot load http://localhost:8077/sonny/l... The value of the &#39;Access-Control-Allow-Origin&#39; header in the response must not be the wildcard &#39;*&#39; when the request&#39;s credentials mode is &#39;include&#39;. Origin &#39;http://localhost:8080&#39; is therefore not allowed access.这段鸟语翻译过来就是：当请求中的认证模式为‘include’时，响应的头部中的&#39;Access-Control-Allow-Origin&#39;不能设置为通配符“*”，这是因为cookie在设置的时候是不允许跨域的，如何在协达cookie的前后端分离项目中实现类似通配符”*“的功能将在下面讲述。因为报错了，因此得在后端添加：</code></pre><p>response.setHeader(“Access-Control-Allow-Credentials”,”true”);<br>  response.setHeader(“Access-Control-Allow-Origin”, “<a href="http://192.168.0.1&quot;)" target="_blank" rel="noopener">http://192.168.0.1&quot;)</a>;  </p><pre><code>这样就解决了跨域传递session的问题。</code></pre><p>3.Cookis是不允许跨域的；</p><blockquote><p> Cookie一班是不允许跨域传递的，解决方案除了上面那种，还可以通过Nginx；<br> <a href="https://www.cnblogs.com/hujunzheng/p/5744755.html" target="_blank" rel="noopener">解决cookie跨域问题之nginx反向代理</a></p></blockquote><p> 4.浏览器是通过OPTION请求获取服务器对请求的支持信息；</p><blockquote><p>OPTIONS 方法比较少见，该方法用于请求服务器告知其支持哪些其他的功能和方法。通过 OPTIONS 方法，可以询问服务器具体支持哪些方法，或者服务器会使用什么样的方法来处理一些特殊资源。可以说这是一个探测性的方法，客户端通过该方法可以在不访问服务器上实际资源的情况下就知道处理该资源的最优方式。</p></blockquote><p>5.既然比较少见，什么情况下会使用OPTION这个方法呢？</p><blockquote></blockquote><p>当发送的请求为简单请求的时候，服务器会自动在响应的头部添加添加一个Origin字段，其值将被自动设置为对应的请求域，<code>Origin: http://api.bob.com</code>因此可以说，对与简单请求是不存在跨域问题的。</p><blockquote><p>  A）、什么是简单请求呢？<br>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p></blockquote><hr><blockquote><p>只要同时满足以下两大条件，就属于简单请求。<br>（1) 请求方法是以下三种方法之一：<br>HEAD<br>GET<br>POST<br>（2）HTTP的头信息不超出以下几种字段：<br>Accept<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain<br>凡是不同时满足上面两个条件，就属于非简单请求。<br>浏览器对这两种请求的处理，是不一样的。</p></blockquote><hr><blockquote><p>凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。</p></blockquote><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。<br>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p><p> 6.Session是通过Cookies中的信息来识别的；</p><p> 当解决了跨域和cookie携带的问题，以后每次浏览器发送请求就会携带一个cookie的信息，那么Session和JSESessionId是如何产生联系的？</p><blockquote><p>首先我们需要知道Session在何时创建呢？<br><a href="https://www.cnblogs.com/woshimrf/p/5317776.html" target="_blank" rel="noopener">sessionid如何产生？由谁产生？保存在哪里？</a></p></blockquote><hr><blockquote><p>当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法，而在Java中是通过调用HttpServletRequest的getSession方法（使用true作为参数）创建的。在创建了Session的同时，服务器会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上。</p></blockquote><hr><blockquote><p>服务器上为每个用户都保存了一个session，那当用户请求过来的时候是怎么知道某一个用户应该对应哪个session呢？</p></blockquote><hr><blockquote><p>这时jsessionid就派上用场了。每一个session都有一个id来作为标识，这个id会传到客户端，每次客户端请求都会把这个id传到服务器，服务器根据id来匹配这次请求应该使用哪个session。jsessionid就是客户端用来保存sessionid的变量，主要是针对j2ee实现的web容器，没有研究过其他语言是用什么变量来保存的。一般对于web应用来说，客户端变量都会保存在cookie中，jsessionid也不例外。不过与一般的cookie变量不同，jsessionid是保存在内存cookie中的，在一般的cookie文件中是看不到它的影子的。内存cookie在打开一个浏览器窗口的时候会创建，在关闭这个浏览器窗口的时候也同时销毁。这也就解释了为什么session变量不能跨窗口使用，要跨窗口使用就需要手动把jsessionid保存到cookie里面。</p></blockquote><hr><p>下面看代码：</p><pre><code>package com.spring.boot.gp4zj.util;import javax.servlet.http.HttpServletRequest;import org.springframework.context.ApplicationContext;import com.spring.boot.gp4zj.model.UserSession;import com.spring.boot.gp4zj.model.Worker;import com.spring.boot.gp4zj.service.AuthenticationService;import com.spring.boot.gp4zj.service.impl.AuthenticationServiceImpl;import cn.lz.cloud.common.service.ReqObject;/** * 我自己封装的session工具类; * @author xdsm * */public class MySession {     //私有的静态内部类保证了单例，并且是懒汉模式的;    private static class SingletonHolder{      private static final MySession INSTANCE = new MySession();    }    private MySession(){}    public static final MySession getInstance(){          return SingletonHolder.INSTANCE;    }    private ApplicationContext applicationContext = SpringUtils.getApplicationContext();    private AuthenticationService authenticationService = applicationContext.getBean(AuthenticationServiceImpl.class);    /**     * 根据请求中携带的session信息获取用‘session’中的用户户信息;     * @return     */  public Worker getAttributeOfUserInfo(HttpServletRequest request) {      //获取jseSessionId;      String jsessionid = HttpUtils.getJsessionidFromHeader(request);// 获取请求携带的sessioId;      //查询用户信息;      UserSession requestAttachmentInfo = new UserSession();      requestAttachmentInfo.setJsessionid(jsessionid);      ReqObject&lt;UserSession&gt; sessionSelecCondition = new ReqObject&lt;UserSession&gt;();      sessionSelecCondition.setObject(requestAttachmentInfo);      UserSession sessionVo = authenticationService.selectUserSessionBySessionID(sessionSelecCondition);      Worker workerInfo = new Worker();      String workerName = sessionVo.getWorkerName();      String workerPassword = sessionVo.getWorkerPassword();      workerInfo.setWorkerName(workerName);      workerInfo.setWorkerPassword(workerPassword);      Worker sessionAttruVO = authenticationService.doGetAuthenticationInfo(workerInfo);    return sessionAttruVO;  }}</code></pre><hr><pre><code>package com.spring.boot.gp4zj.util;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.InetAddress;import java.net.UnknownHostException;import java.nio.charset.Charset;import java.util.Enumeration;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.google.gson.Gson;public class HttpUtils {    public static void main(String[] args) {        HttpServletResponse response = null;        responseOutWithJson(response, null);    }    public static String getHostIp() {        InetAddress addr;        String currentIP = null;        try {            addr = InetAddress.getLocalHost();            currentIP = addr.getHostAddress().toString(); //获取本机ip        } catch (UnknownHostException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        return currentIP;    }    public static void responseOutWithJson(HttpServletResponse response, Object responseObject) {        // Person person=new Person();        Gson gson = new Gson();        // Object stu = new Student(&quot;ShaHao&quot;, 21);        String objStrJson = gson.toJson(responseObject);        // System.out.println(objStrJson);        response.reset();        response.setCharacterEncoding(&quot;UTF-8&quot;);        response.setContentType(&quot;application/json; charset=utf-8&quot;);        PrintWriter out = null;        try {            out = response.getWriter();            out.print(objStrJson);            out.flush();            out.close();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (out != null) {                out.close();            }        }    }    /**     * 获取post请求中的Body     *     * @param request     * @return     */    public static String getBodyString(HttpServletRequest request) {        System.out.println(&quot;--------HttpUtils---------HttpUtils--------&quot;);        Enumeration&lt;?&gt; ele = request.getHeaderNames();        while (ele.hasMoreElements()) {            String name = (String) ele.nextElement();            String value = request.getHeader(name);            System.out.println(name + &quot; = &quot; + value);        }        StringBuilder sb = new StringBuilder();        InputStream inputStream = null;        BufferedReader reader = null;        try {            inputStream = request.getInputStream();            // 读取流并将流写出去,避免数据流中断;            reader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName(&quot;UTF-8&quot;)));            String line = &quot;&quot;;            while ((line = reader.readLine()) != null) {                sb.append(line);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            if (inputStream != null) {                try {                    inputStream.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (reader != null) {                try {                    reader.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return sb.toString();    }    /**     * 从请求的头部获取用户的身份识别id;     *      * @param request     * @return     */    public static String getJsessionidFromHeader(HttpServletRequest request) {        String jsessionid = null;// 识别用户身份的id;        Enumeration&lt;?&gt; e = request.getHeaderNames();        while (e.hasMoreElements()) {            String name = (String) e.nextElement();            String value = request.getHeader(name);            // cookie = JSESSIONID=B926F6024438D4C693A5E5881595160C;            // SESSION=458e80dc-e354-4af3-a501-74504a873e70            if (&quot;cookie&quot;.equals(name)) {                jsessionid = value.split(&quot;;&quot;)[0].split(&quot;=&quot;)[1];            }        }        return jsessionid;    }}</code></pre><p>其实所有的根本就是获取有效的SessionId就可以了。参考文章都在上面了，里面结合了我的理解和参考的内容，希望可以帮助到大家。</p><p><img src="https://img-blog.csdn.net/20180415210950924?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqMjAxNDIyMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>夏天了，又到了长肉的季节了。。。。。。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>单例模式的几种实现方式</title>
      <link href="/2018/12/04/lao-bo-ke/dan-li-mo-shi-de-ji-chong-shi-xian-fang-shi/"/>
      <url>/2018/12/04/lao-bo-ke/dan-li-mo-shi-de-ji-chong-shi-xian-fang-shi/</url>
      
        <content type="html"><![CDATA[<hr><p>单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。</p><p><strong>懒汉式，线程不安全</strong></p><p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p><pre><code>public class Singleton {    private static Singleton instance;    private Singleton (){}    public static Singleton getInstance() {     if (instance == null) {         instance = new Singleton();     }     return instance;    }}</code></pre><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><p><strong>懒汉式，线程安全</strong></p><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><pre><code>public static synchronized Singleton getInstance() {    if (instance == null) {        instance = new Singleton();    }    return instance;}</code></pre><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p><p><strong>双重检验锁</strong></p><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><pre><code>public static Singleton getSingleTon(){  if(instance==null){//Single Checked       synchronized(SingleTon.class){           if(instance==null){              instance = new Singleton();           }       }           }    return instance;}</code></pre><p>这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p><pre><code>给 instance 分配内存调用 Singleton 的构造函数来初始化成员变量将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</code></pre><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p><pre><code>public class Singleton {    private volatile static Singleton instance; //声明成 volatile    private Singleton (){}    public static Singleton getSingleton() {        if (instance == null) {                                     synchronized (Singleton.class) {                if (instance == null) {                           instance = new Singleton();                }            }        }        return instance;    }}</code></pre><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。简单理解就是，声明为volatile的变量，其读操作一定实在写操作完成之后执行的。</p><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。<br>饿汉式 static final field</p><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><pre><code>public class Singleton{    //类加载时就初始化    private static final Singleton instance = new Singleton();    private Singleton(){}    public static Singleton getInstance(){        return instance;    }}</code></pre><p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。<br>静态内部类 static nested class</p><p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。</p><pre><code>//线程安全的且实现了懒加载的饿汉模式   //使用私有的静态内部类来实现，保证了懒加载的实现;public class Singleton{    //私有的静态内部类保证了单例，并且是懒汉模式的;    private static class SingletonHolder{      private static final Singleton INSTANCE = new Singleton();    }  private Singleton(){}public static final Singleton getInstance(){  return SingletonHolder.INSTANCE;}}</code></pre><p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。<br>枚举 Enum</p><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><pre><code>public enum EasySingleton{    INSTANCE;}</code></pre><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。<br>总结</p><p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。</p><p>就我个人而言，一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Windows服务器端软件的安装</title>
      <link href="/2018/12/04/lao-bo-ke/windows-fu-wu-qi-duan-ruan-jian-de-an-zhuang/"/>
      <url>/2018/12/04/lao-bo-ke/windows-fu-wu-qi-duan-ruan-jian-de-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows服务器端软件的安装"><a href="#Windows服务器端软件的安装" class="headerlink" title="*Windows服务器端软件的安装*"></a><strong>*</strong>Windows服务器端软件的安装<strong>*</strong></h2><p><strong><em>MYSQL的操作安装</em></strong></p><p>1.将下载下载的包解压到指定目录，（本人）解压到：D:\Program Files (x86) 目录下。<br>因此，MySQL的(安装)包的完整路径为：D:\Program Files (x86)\mysql-5.7.18-winx64<br>2.<br>2.解压后，配置好系统环境变量。<br>新增系统环境变量：<br>键名：MYSQL_HOME<br>值为：D:\Program Files (x86)\mysql-5.7.18-winx64<br>接着在 Path 中添加：%MYSQL_HOME%\bin</p><p>3.解压后，准备好 my.ini 文件。<br>注意：（据说）以前版本解压后，在解压目录下都会有 my-default.ini 或 my.ini 文件，不过，v5.7.18 版本中解压后，是没有这些文件的。因此，需要手动创建好 my.ini 文件，文件的具体（完整的）内容如下：</p><p>[client]port=3306default-character-set=utf8[mysqld]port=3306character_set_server=utf8basedir=%MYSQL_HOME%datadir=%MYSQL_HOME%\data[WinMySQLAdmin]%MYSQL_HOME%\bin\mysqld.exe</p><p>编辑好 my.ini 文件后，将 my.ini 放在 bin 目录下</p><p>4.以管理员身份打开 cmd 命令窗口，将目录切到MySQL安装包下的bin目录下</p><p>5.安装MySQL数据库，执行如下命令：<br>mysqld.exe -install<br>执行命令后，提示：Service successfully installed. 表示安装成功<br>6.初始化mysql数据，并创建一个具有空密码的root用户，执行如下命令：<br>mysqld –initialize-insecure –user=mysql<br>注意：最后的参数 –user=mysql 在 windows 也可以不用添加，但在 unix 等系统下好像很重要。<br>执行命令后，等一会后，系统会自动生成相应的 data 目录，并自动创建好空密码的 root 用户。此时表示初始化成功。<br>7.启动 mysql 服务，执行如下命令：<br>net start mysql<br>执行后，提示：<br>MySQL服务正在启动..<br>MySQL服务已经启动成功。<br>注意：要想登录使用 mysql，服务是必需要先启动的。以后也一样。<br>8.在服务启动后，因为刚创建的 root 用户是空密码的，因此，需要先进行密码设定。可执行如下命令：<br>mysqladmin -u root -p password 此处输入新的密码<br>Enter password: 此处输入旧的密码<br>执行完以上两条命令后，只要 Enter password: 后输入的旧密码正确，则 root 用户的新密码就算设定成功了。此后，要想登录 root 用户，则都需要使用新密码。<br>注意：刚创建的 root 用户是空密码的，因此，在第一次修改 root 用户的密码时，在 Enter password: 后面不需要输入任何密码，直接回车即可。</p><p>9.至此，MySQL v5.7.18 的解压安装就已经全部完成，因此，需要把先前已经启的 MySQL 服务给停止掉，执行如下命令：<br>net stop mysql<br>//———————————————<br>登录并使用MySQL</p><p>前面已经完成对MySQL数据库的安装，只要安装成功后，就可以正常登录 root 用户，并进行数据的相关操作，如：建表、增、删、改、查等等。下面是简单的流程：</p><p>以管理员身份打开 cmd，并切到 mysql 安装目录的 bin 目录下<br>net start mysql                // 说明：该命令是启动 mysql 服务<br>mysql -u root -p               // 说明：该命令是登录 root 用户<br>Enter password: 先前设置的 root 用户的密码<br>正确登录后，就可以对数据进行操作了如：增、删、改、查等等。示例：<br>mysql&gt; show databases;   // 显示所有数据库<br>mysql&gt; select 语句…………<br>…<br>不再使用数据库时，要退出用户，并停止服务，执行如下命令：<br>mysql&gt; quit;<br>net stop mysql<br>//———————————–</p><p><strong><em>Mysql5.7解压版的安装和卸载及常见问题</em></strong></p><hr><p><img src="http://img.blog.csdn.net/20170709223332467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong><em>Tomcat解压版的安装配置</em></strong></p><p>1.修改service.bat文件，更新服务名称</p><p>2.管理员身份打开命令窗口：<br> 注意：SERVICE_NAME的更改不需要空格;<br>  进入bin目录， 执行命令:service.bat install;</p><p><strong><em>JDK的安装配置</em></strong></p><p>1.系统变量→新建 JAVA_HOME 变量 。<br>变量值填写jdk的安装目录（本人是 E:\Java\jdk1.7.0)<br>2.系统变量→寻找 Path 变量→编辑<br>在变量值最后输入 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;<br>（注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码）</p><p>3.系统变量→新建 CLASSPATH 变量<br>变量值填写   .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar（注意最前面有一点）<br>系统变量配置完毕</p><p>4.检验是否配置成功 运行cmd 输入 java -version （java 和 -version 之间有空格）<br>若如图所示 显示版本信息 则说明安装和配置成功。</p><p><strong><em>新建出站入站规则</em></strong></p><p>1.注意防火墙配置;</p><p><strong><em>固定IP的分配</em></strong></p><p> 作为服务器的电脑切记IP应该分配为固定的,否则将出现访问出错的情况.</p><p> <img src="http://img.blog.csdn.net/20170709222659854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Vue中v-if 与 v-show 的区别？</title>
      <link href="/2018/12/04/lao-bo-ke/vue-zhong-v-if-yu-v-show-de-qu-bie/"/>
      <url>/2018/12/04/lao-bo-ke/vue-zhong-v-if-yu-v-show-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在切换 v-if 块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。<br>相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。<br>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p></blockquote><hr><blockquote><p>v-if 是动态添加，当值为 false 时，是完全移除该元素，即 dom 树中不存在该元素。<br>v-show 仅是隐藏 / 显示，值为 false 时，该元素依旧存在于 dom 树中。若其原有样式设置了 display: none 则会导致其无法正常显示。</p></blockquote><p>参考文章:<a href="http://www.runoob.com/vue2/vue-if.html" target="_blank" rel="noopener">Vue.js 条件与循环</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>tomcat配置外部静态资源映射路径</title>
      <link href="/2018/12/04/lao-bo-ke/tomcat-pei-zhi-wai-bu-jing-tai-zi-yuan-ying-she-lu-jing/"/>
      <url>/2018/12/04/lao-bo-ke/tomcat-pei-zhi-wai-bu-jing-tai-zi-yuan-ying-she-lu-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="tomcat配置外部静态资源映射路径"><a href="#tomcat配置外部静态资源映射路径" class="headerlink" title="tomcat配置外部静态资源映射路径"></a>tomcat配置外部静态资源映射路径</h2><p>修改apache-tomcat-7.0.56\conf文件夹下的server.xml即可；<br><em>注意修改服务器中的配置文件的过程中切忌出现中文，注释中文可能导致服务无法启动</em></p><p>修改如下：</p><pre><code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;&lt;!-- SingleSignOn valve, share authentication between web applications Documentation at: /docs/config/valve.html --&gt;&lt;!--　　&lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt;--&gt;&lt;!-- Access log processes all example.Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt;　　&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;　　　　prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot;　　　　pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;　　　　&lt;!-- 增加的静态资源映射配置 --&gt;　　&lt;Context path=&quot;/RecordFile&quot; docBase=&quot;/home/lings/recordings&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;&gt;&lt;/Context&gt;&lt;/Host&gt;</code></pre><p>红色那一行就是增加的静态资源映射配置。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Struts2中接收表单数据的三种驱动方式</title>
      <link href="/2018/12/04/lao-bo-ke/struts2-zhong-jie-shou-biao-dan-shu-ju-de-san-chong-qu-dong-fang-shi/"/>
      <url>/2018/12/04/lao-bo-ke/struts2-zhong-jie-shou-biao-dan-shu-ju-de-san-chong-qu-dong-fang-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>Struts2中接收表单数据的三种驱动方式</strong><br>  1.属性驱动<br>   前台表单中字段的name和后台action中的属性字段的名称必须保持一致；</p><p>2.域驱动<br>前台表单中字段的name应该为：objectName.attribute的形式;<br>后台action中以object为单位进行数据的接收，前台页面的取值方式为：</p><p>3.模型驱动<br>前台表单中字段的name应该为：attribute的形式;<br>后台action实行ModelDriven接口，并重写getModel方法；前台页面的取值方式为：<br>${attribute};</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SSO单点登录探究【基于cookie共享】</title>
      <link href="/2018/12/04/lao-bo-ke/sso-dan-dian-deng-lu-tan-jiu-ji-yu-cookie-gong-xiang/"/>
      <url>/2018/12/04/lao-bo-ke/sso-dan-dian-deng-lu-tan-jiu-ji-yu-cookie-gong-xiang/</url>
      
        <content type="html"><![CDATA[<p>最近看到公司的需求里面有单点登录，就去了解了一下。下面将从SSO单点登录的原理、实现步骤以及实现demo几个方面来讲述自己的理解。</p><hr><p>   1、SSO根本原理:<br>               登录状态的共享;<br>            1)、登录状态的共享有两种实现方式:<br>            一：cookie共享【但是cookie原则上不能跨域，通过合理的配置在二级域名相同的情况下可以跨域共享】。<br>            二：通过Session共享登录状态。【Spring Session共享方案，分布式系统中常用】<br>            三：通过IP+Agent+User的方式实现状态共享，实际上是模仿了cookie合session机制。【我自己研究的，适合绝对跨域的分布式系统】因为通过IP+Agent+User的形式理论上可以模仿cookie合session识别一次会话。<br>            <img src="http://ouuy81imh.bkt.clouddn.com/sso01.png" alt="这里写图片描述"><br>    2、实现的概要步骤【网络上的步骤乱七八糟各种不合理，自己整理了下】<br>            1）、子系统一登陆，未登陆则进入SSO认证中心认证，成功则更新登陆状态【创建全局会话】，返回共享媒介；<br>            2）、子系统二携带共享媒介，获取全局会话，读取登陆信息和登陆状态，实质是通过共享媒介保持了会话状态。<br>            ３）、退出时只需要注销全局会话状态即可。</p><pre><code>【以上的概要步骤对SSO根本原理的一、二、三都适用】</code></pre><p>   ３、SSＯ登陆的demo[通过cookie共享实现的]<br>       SSOAuth：<br><img src="http://ouuy81imh.bkt.clouddn.com/sso02.png" alt="这里写图片描述"><br>     SSOWebDemo1：<br>     <img src="http://ouuy81imh.bkt.clouddn.com/sso03.png" alt="这里写图片描述"><br>     SSOWebDemo2：<br>     <img src="http://ouuy81imh.bkt.clouddn.com/sso04.png" alt="这里写图片描述"></p><p> <a href="https://download.csdn.net/download/zj20142213/10499008" target="_blank" rel="noopener">SSO单点登录的源码。</a></p><p>   四：参考文章:<br>         <a href="https://www.cnblogs.com/ywlaker/p/6113927.html" target="_blank" rel="noopener">单点登录原理与简单实现</a><br>         <a href="https://baike.baidu.com/item/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/4940767?fr=aladdin" target="_blank" rel="noopener">单点登录</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>ssm整合redis</title>
      <link href="/2018/12/04/lao-bo-ke/ssm-zheng-he-redis/"/>
      <url>/2018/12/04/lao-bo-ke/ssm-zheng-he-redis/</url>
      
        <content type="html"><![CDATA[<p><strong>说明</strong><br>   redis是一个nosql数据库，具有高速，数据结构对程序员透明【数据类型支持list、set等结构】等特点。</p><p><strong>redis的使用前提：</strong></p><p>  (1.)redis 是一个数据库，和mysql相似，使用redis首先得安装redis数据库;<br>  (2.)为应用程序添加必要的配置：例如mysql中的四要素;<br>  (3.)配置redis相关的AOP【基于方法拦截】;<br>  (4.)使用redis相关的API；</p><p><strong>Spring整合redis的相关配置:</strong></p><pre><code>&lt;!-- jedis 配置 --&gt;    &lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt;        &lt;property name=&quot;maxWaitMillis&quot; value=&quot;${redis.maxWait}&quot; /&gt;        &lt;property name=&quot;testOnBorrow&quot; value=&quot;${redis.testOnBorrow}&quot; /&gt;    &lt;/bean&gt;    &lt;!-- redis服务器中心 --&gt;    &lt;bean id=&quot;connectionFactory&quot;        class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;        &lt;property name=&quot;poolConfig&quot; ref=&quot;poolConfig&quot; /&gt;        &lt;property name=&quot;port&quot; value=&quot;${redis.port}&quot; /&gt;        &lt;property name=&quot;hostName&quot; value=&quot;${redis.host}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${redis.password}&quot; /&gt;        &lt;property name=&quot;timeout&quot; value=&quot;${redis.timeout}&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;        &lt;property name=&quot;keySerializer&quot;&gt;            &lt;bean                class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot; /&gt;        &lt;/property&gt;        &lt;property name=&quot;valueSerializer&quot;&gt;            &lt;bean                class=&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot; /&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- cache配置 --&gt;    &lt;bean id=&quot;methodCacheInterceptor&quot; class=&quot;com.crossoverJie.intercept.MethodCacheInterceptor&quot;&gt;        &lt;property name=&quot;redisUtil&quot; ref=&quot;redisUtil&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;redisUtil&quot; class=&quot;com.crossoverJie.util.RedisUtil&quot;&gt;        &lt;property name=&quot;redisTemplate&quot; ref=&quot;redisTemplate&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;dataSourceExchange&quot; class=&quot;com.crossoverJie.util.DataSourceExchange&quot; /&gt;    &lt;!--配置切面拦截方法 --&gt;    &lt;aop:config&gt;        &lt;!--将com.crossoverJie.service包下的所有select开头的方法加入拦截 去掉select则加入所有方法 --&gt;        &lt;aop:pointcut id=&quot;controllerMethodPointcut&quot;            expression=&quot;        execution(* com.crossoverJie.service.*.select*(..))&quot; /&gt;        &lt;aop:pointcut id=&quot;selectMethodPointcut&quot;            expression=&quot;        execution(* com.crossoverJie.dao..*Mapper.select*(..))&quot; /&gt;        &lt;aop:advisor advice-ref=&quot;methodCacheInterceptor&quot;            pointcut-ref=&quot;controllerMethodPointcut&quot; /&gt;        &lt;!--所有数据库操作的方法加入切面 --&gt;        &lt;aop:aspect ref=&quot;dataSourceExchange&quot;&gt;            &lt;aop:pointcut id=&quot;dataSourcePointcut&quot;                expression=&quot;execution(* com.crossoverJie.service.*.*(..))&quot; /&gt;            &lt;aop:before pointcut-ref=&quot;dataSourcePointcut&quot; method=&quot;before&quot; /&gt;            &lt;aop:after pointcut-ref=&quot;dataSourcePointcut&quot; method=&quot;after&quot; /&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;</code></pre><p><strong>编码方法拦截器MethodInterceptor</strong></p><pre><code> 方法拦截器在目标方法被调用的时候被触发，作为增强业务逻辑存在，方法拦截器主要任务是将需要加入redis中数据添加进redis中;</code></pre><pre><code>package com.crossoverJie.intercept;import com.crossoverJie.util.RedisUtil;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.ArrayList;import java.util.List;/** * Created by chenjie on 2016/11/16. */public class MethodCacheInterceptor implements MethodInterceptor {    private Logger logger = LoggerFactory.getLogger(MethodCacheInterceptor.class);    private RedisUtil redisUtil;    private List&lt;String&gt; targetNamesList; // 不加入缓存的service名称    private List&lt;String&gt; methodNamesList; // 不加入缓存的方法名称    private Long defaultCacheExpireTime; // 缓存默认的过期时间    private Long xxxRecordManagerTime; //    private Long xxxSetRecordManagerTime; //    /**     * 初始化读取不需要加入缓存的类名和方法名称     */    public MethodCacheInterceptor() {        try {            // 分割字符串 这里没有加入任何方法            //            String[] targetNames = {};            String[] methodNames = {};            // 加载过期时间设置            defaultCacheExpireTime = 3600L;            xxxRecordManagerTime = 60L;            xxxSetRecordManagerTime = 60L;            // 创建list            targetNamesList = new ArrayList&lt;String&gt;(targetNames.length);            methodNamesList = new ArrayList&lt;String&gt;(methodNames.length);            Integer maxLen = targetNames.length &gt; methodNames.length ? targetNames.length                    : methodNames.length;            // 将不需要缓存的类名和方法名添加到list中            for (int i = 0; i &lt; maxLen; i++) {                if (i &lt; targetNames.length) {                    targetNamesList.add(targetNames[i]);                }                if (i &lt; methodNames.length) {                    methodNamesList.add(methodNames[i]);                }            }        } catch (Exception e) {            e.printStackTrace();        }    }    @Override    public Object invoke(MethodInvocation invocation) throws Throwable {        Object value = null;        String targetName = invocation.getThis().getClass().getName();        String methodName = invocation.getMethod().getName();        // 不需要缓存的内容        //if (!isAddCache(StringUtil.subStrForLastDot(targetName), methodName)) {        if (!isAddCache(targetName, methodName)) {            // 执行方法返回结果            return invocation.proceed();        }        Object[] arguments = invocation.getArguments();        String key = getCacheKey(targetName, methodName, arguments);        logger.debug(&quot;redisKey: &quot; + key);        try {            // 判断是否有缓存            if (redisUtil.exists(key)) {                return redisUtil.get(key);            }            // 写入缓存            value = invocation.proceed();            if (value != null) {                final String tkey = key;                final Object tvalue = value;                new Thread(new Runnable() {                    @Override                    public void run() {                        if (tkey.startsWith(&quot;com.service.impl.xxxRecordManager&quot;)) {                            redisUtil.set(tkey, tvalue, xxxRecordManagerTime);                        } else if (tkey.startsWith(&quot;com.service.impl.xxxSetRecordManager&quot;)) {                            redisUtil.set(tkey, tvalue, xxxSetRecordManagerTime);                        } else {                            redisUtil.set(tkey, tvalue, defaultCacheExpireTime);                        }                    }                }).start();            }        } catch (Exception e) {            e.printStackTrace();            if (value == null) {                return invocation.proceed();            }        }        return value;    }    /**     * 是否加入缓存     *     * @return     */    private boolean isAddCache(String targetName, String methodName) {        boolean flag = true;        if (targetNamesList.contains(targetName)                || methodNamesList.contains(methodName)) {            flag = false;        }        return flag;    }    /**     * 创建缓存key     *     * @param targetName     * @param methodName     * @param arguments     */    private String getCacheKey(String targetName, String methodName,                               Object[] arguments) {        StringBuffer sbu = new StringBuffer();        sbu.append(targetName).append(&quot;_&quot;).append(methodName);        if ((arguments != null) &amp;&amp; (arguments.length != 0)) {            for (int i = 0; i &lt; arguments.length; i++) {                sbu.append(&quot;_&quot;).append(arguments[i]);            }        }        return sbu.toString();    }    public void setRedisUtil(RedisUtil redisUtil) {        this.redisUtil = redisUtil;    }}</code></pre><p><a href="https://crossoverjie.top/2016/12/18/SSM7/" target="_blank" rel="noopener">参考博客</a></p><p><a href="https://github.com/JunZhou2016/SSM" target="_blank" rel="noopener">案例代码，参考其中的SSM-WEB</a></p><p><a href="https://crossoverjie.top/2016/12/18/SSM7/" target="_blank" rel="noopener">附加pageHelper使用案例</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SpringMVC集成redis</title>
      <link href="/2018/12/04/lao-bo-ke/springmvc-ji-cheng-redis/"/>
      <url>/2018/12/04/lao-bo-ke/springmvc-ji-cheng-redis/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p><strong>Redis 简介</strong><br>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key -<br>value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。</p></blockquote><hr><blockquote><p><strong>Redis 优势</strong><br> 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 –<br>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 –<br>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持<br>publish/subscribe, 通知, key 过期等等特性。</p></blockquote><hr><blockquote><p><strong>Redis与其他key-value存储有什么不同？</strong><br>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。<br>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p></blockquote><p><strong>Redis 的 5 个常见使用场景</strong></p><p><em>1、会话缓存（Session Cache）</em></p><p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p><p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p><p><em>2、全页缓存（FPC）</em></p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p><p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p><p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件  wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p><em>3、队列</em></p><p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</p><p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p><p><em>4.排行榜/计数器</em></p><p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p><p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><p>ZRANGE user_scores 0 10 WITHSCORES</p><p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p><p><em>5、发布/订阅</em></p><p>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</p><blockquote><p><a href="http://blog.csdn.net/u012775558/article/details/68937298?locationNum=7&amp;fps=1" target="_blank" rel="noopener">本文将着重说明SpringMVC集成redis后的数据的增删改查;</a><br><a href="https://github.com/JunZhou2016/CRU4DRedis" target="_blank" rel="noopener">Demo</a></p></blockquote><hr><blockquote><p><a href="https://www.cc520.me/article.html?c=5&amp;index=86" target="_blank" rel="noopener">shiro使用redis缓存session会话、authentication信息、authorization信息简述</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SpringCloud上传文件，经过Zuul，中文文件名乱码解决办法</title>
      <link href="/2018/12/04/lao-bo-ke/springcloud-shang-chuan-wen-jian-jing-guo-zuul-zhong-wen-wen-jian-ming-luan-ma-jie-jue-ban-fa/"/>
      <url>/2018/12/04/lao-bo-ke/springcloud-shang-chuan-wen-jian-jing-guo-zuul-zhong-wen-wen-jian-ming-luan-ma-jie-jue-ban-fa/</url>
      
        <content type="html"><![CDATA[<p>最近在使用SpringCloud搭建微服务的过程中，发现上传文件经过Zuul网关转发的时候，回应为上传文件名中文乱码导致文件的写操作失败，从而导致文件上传失败，但是不经过Zuul转发的时候，文件上传正常，因此猜测是Zuul对上传的请求的编码进行了处理。最终在网上找到了两种解决方案:</p><hr><p>  方案一、在上传文件的请求路径之前添加字符串“zuul”声明此请求的编码不做处理。</p><pre><code>/** * 各种poi导入导出的请求控制模块; *  * @author:JunZhou * @Company:LongZheng * @Email:1769676159@qq.com * @2018年1月16日@下午4:28:49 */@RestController@RequestMapping(&quot;/poi&quot;)@ClazzNote(desc = &quot;excel文件&quot;, resource = &quot;input&quot;, modName = &quot;poi&quot;)public class POIController {    @RequestMapping(&quot;/uploadExcel&quot;)    @ServiceNote(desc = &quot;上传考勤明细的excel&quot;, auth = ServiceNote.AUTH.CHECK)    public ResObject&lt;ResponseMessage&gt; singleFileUpload(MultipartHttpServletRequest request,        RedirectAttributes redirectAttributes, HttpServletResponse response) {        Integer stateCode = poiService.receiveUploadExcel(request, redirectAttributes, response);        //根据返回值确定响应信息实体;        ResponseMessage responseMessage = UploadStatusEnum.desicideUploadStatusBystateCode(stateCode, response);        //设置响应状态为200;        response.setStatus(UploadStatusEnum.UPLOAD_OK.getStateCode());        return new ResObject&lt;ResponseMessage&gt;(null,responseMessage);    }</code></pre><p>例如在当前代码下，请求路径是：</p><blockquote><p>localhost:9090/oss/poi/uploadExcel</p></blockquote><p>那么采用方案一解决中文乱码的请求路径就是:</p><blockquote><p>localhost:9090/zuul/oss/poi/uploadExcel</p></blockquote><p>经过测试，中文乱码问题成功解决。</p><hr><p>方案二:<br>在方案一的基础上，不仅要改动后端代码，前端代码也要变更，较为麻烦，<br>因此更简单的方案是在zuul的配置文件中添加一个如下的属性：</p><pre><code>zuul.servlet-path=/</code></pre><p>注意实在网关的配置文件中添加的，经过本人侧ishi，问题也成功解决了。</p><p>参考文章：<br>1、<a href="https://my.oschina.net/u/3706162/blog/1621014" target="_blank" rel="noopener">SpringCloud 上传文件，经过Zuul，中文文件名乱码解决办法</a></p><p>2、<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1385" target="_blank" rel="noopener">zuul proxy file upload, file name is Chinese garbled #1385</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Springboot中定时任务的实现</title>
      <link href="/2018/12/04/lao-bo-ke/springboot-zhong-ding-shi-ren-wu-de-shi-xian/"/>
      <url>/2018/12/04/lao-bo-ke/springboot-zhong-ding-shi-ren-wu-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>1、定时任务在J2EE项目中经常会被用到，如自动取消订单、在指定的时间清空缓存等需求就需要定时任务来实现。定时任务的完成是靠轮询来实现的，所以存在一定的延时误差是合理的。springboot在实现定时任务的过程中相关的依赖已经在父依赖中被导入了，所以不需要导入额外的依赖。<br>   2、SpringBoot中定时任务的实现分两步：（1、）定时任务的的实现;<br>   (2、)创建调度表达式;<br>   3、具体实现.<br>   (1、)定时任务的的实现，其实就是你要通过定时器完成的业务逻辑:</p><pre><code>@Scheduled(cron = &quot;*/2 * * * * ?&quot;)    public void serviceOrderTask() {        Date date = new Date();        SimpleDateFormat sdf = new SimpleDateFormat(&quot;YY:MM:DD hh:mm:ss&quot;);        String formatDataStr = sdf.format(date);        System.out.println(&quot;|_&quot;+formatDataStr);    }</code></pre><p> (2、)配置调度表达式:<br> <a href="http://blog.720ui.com/2013/quartz_cron/#cronExpression%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B" target="_blank" rel="noopener">调度表达式的声明参考文章1.</a><br>  <a href="http://blog.csdn.net/caiwenfeng_for_23/article/details/17004213" target="_blank" rel="noopener">调度表达式的声明参考文章2.</a></p><pre><code>@Scheduled(cron = &quot;*/2 * * * * ?&quot;)    public void serviceOrderTask() {        Date date = new Date();        SimpleDateFormat sdf = new SimpleDateFormat(&quot;YY:MM:DD hh:mm:ss&quot;);        String formatDataStr = sdf.format(date);        System.out.println(&quot;|_&quot;+formatDataStr);    }</code></pre><p>通过@Scheduled注解添加调度表达式.<br>4、需要注意的地方<br>在使用SpringBoot任务调度的时候，需要在启动类上添加注解@EnableScheduling。</p><pre><code>package com.example;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableSchedulingpublic class DemoApplication {    public static void main(String[] args) {        SpringApplication.run(DemoApplication.class, args);    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SpringBoot中的拦截器的使用和配置</title>
      <link href="/2018/12/04/lao-bo-ke/springboot-zhong-de-lan-jie-qi-de-shi-yong-he-pei-zhi/"/>
      <url>/2018/12/04/lao-bo-ke/springboot-zhong-de-lan-jie-qi-de-shi-yong-he-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot中的拦截器是常用的技能，接下来将参照一个小小的demo讲解SpringBoot中拦截器的配置和使用.<br>1、SpringBoot中拦截器的使用场景.<br>日志、登陆验证、权限等都会用到拦截器.<br>2、demo源码.<br>在SpringBoot中使用拦截器非常的简单，相关的依赖SpringBoot已经自动为我们导入了，因此不必进行额外的导入，相关的参考代码如下:</p><pre><code>package com.spring.boot.gp4zj.webconfig;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;/** * 添加了一个拦截器，用于登陆验证和数据加密; *  * @author:JunZhou * @Company:LongZheng * @Email:1769676159@qq.com * @2018年1月19日@下午2:24:42 */public class SessionInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception {        // 登录不做拦截        if (request.getRequestURI().equals(&quot;/mongo/attencedetail/selectAll&quot;)                || request.getRequestURI().equals(&quot;/user/login_view&quot;)) {            System.out.println(&quot;You get a http request&quot;);        }        return true;    }   /**     * 该方法将在Controller执行之后，返回视图之前执行，modelAndView表示请求Controller处理之后返回的Model和View对象，所以可以在     * 这个方法中修改modelAndView的属性，从而达到改变返回的模型和视图的效果。     */    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o,            ModelAndView modelAndView) throws Exception {    }    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,            Object o, Exception e) throws Exception {    }    public String getRemortIP(HttpServletRequest request) {        if (request.getHeader(&quot;x-forwarded-for&quot;) == null) {            return request.getRemoteAddr();        }        return request.getHeader(&quot;x-forwarded-for&quot;);    }}</code></pre><p>3、参考文章</p><p><a href="https://www.jianshu.com/p/f69b21731b41" target="_blank" rel="noopener">如何在SpringBoot项目中使用拦截器[<strong>登陆拦截器</strong>]</a></p><p><a href="https://juejin.im/post/5a5c6cad51882573514f6b38" target="_blank" rel="noopener">SpringMVC拦截器</a></p><p><a href="http://blog.csdn.net/u012706811/article/details/51100756" target="_blank" rel="noopener">SpringMVC学习记录–拦截器的使用</a></p><p><a href="http://blog.longjiazuo.com/archives/1434" target="_blank" rel="noopener">SpringMvc4.x基本配置:拦截器配置</a></p><p><a href="http://blog.longjiazuo.com/archives/1592" target="_blank" rel="noopener">Spring Boot核心:日志配置</a></p><p><a href="http://www.ityouknow.com/springboot/2017/06/26/springboot-shiro.html" target="_blank" rel="noopener">springboot整合shiro-登录认证和权限管理</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SpringBoot中Session监听器的使用</title>
      <link href="/2018/12/04/lao-bo-ke/springboot-zhong-session-jian-ting-qi-de-shi-yong/"/>
      <url>/2018/12/04/lao-bo-ke/springboot-zhong-session-jian-ting-qi-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>当需要统计应用的试试在线人数的时候，统计成功登录后创建的session的数量是最为准确的数据。SpringBoot通过SessionListener可以很方便的监听session的生命周期。在SpringBoot中监听session的步骤如下：<br>1、创建session监听器.</p><pre><code>package com.sds.listenner;import java.util.HashSet;import javax.servlet.ServletContext;import javax.servlet.annotation.WebListener;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionAttributeListener;import javax.servlet.http.HttpSessionBindingEvent;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;@WebListenerpublic class SessionListener implements HttpSessionListener, HttpSessionAttributeListener {    public Logger logger = new Logger();    @Override    public void attributeAdded(HttpSessionBindingEvent httpSessionBindingEvent) {        logger.info(&quot;--attributeAdded--&quot;);        @SuppressWarnings(&quot;unused&quot;)        HttpSession session = httpSessionBindingEvent.getSession();        logger.info(&quot;key----:&quot; + httpSessionBindingEvent.getName());        logger.info(&quot;value---:&quot; + httpSessionBindingEvent.getValue());    }    @Override    public void attributeRemoved(HttpSessionBindingEvent httpSessionBindingEvent) {        logger.info(&quot;--attributeRemoved--&quot;);    }    @Override    public void attributeReplaced(HttpSessionBindingEvent httpSessionBindingEvent) {        logger.info(&quot;--attributeReplaced--&quot;);    }    @Override    public void sessionCreated(HttpSessionEvent event) {        logger.info(&quot;---sessionCreated----&quot;);        HttpSession session = event.getSession();        ServletContext application = session.getServletContext();        // 在application范围由一个HashSet集保存所有的session        @SuppressWarnings(&quot;unchecked&quot;)        HashSet&lt;HttpSession&gt; sessions = (HashSet&lt;HttpSession&gt;) application.getAttribute(&quot;sessions&quot;);        if (sessions == null) {            sessions = new HashSet&lt;HttpSession&gt;();            application.setAttribute(&quot;sessions&quot;, sessions);        }        // 新创建的session均添加到HashSet集中        sessions.add(session);        // 可以在别处从application范围中取出sessions集合        // 然后使用sessions.size()获取当前活动的session数，即为“在线人数”        //添加新建的session到MySessionContext中;        MySessionContext.AddSession(event.getSession());    }    @Override    public void sessionDestroyed(HttpSessionEvent event) throws ClassCastException {        logger.info(&quot;---sessionDestroyed----&quot;);        HttpSession session = event.getSession();        logger.info(&quot;deletedSessionId: &quot; + session.getId());        System.out.println(session.getCreationTime());        System.out.println(session.getLastAccessedTime());        ServletContext application = session.getServletContext();        HashSet&lt;?&gt; sessions = (HashSet&lt;?&gt;) application.getAttribute(&quot;sessions&quot;);        // 销毁的session均从HashSet集中移除        sessions.remove(session);        //添加新建的session到MySessionContext中;        MySessionContext.DelSession(session);    }}</code></pre><p>2、创建session处理工具类，里面需要一个静态的HashMap存储应用中登录后创建的有效的session.</p><pre><code>package com.sds.listenner;import java.util.HashMap;import javax.servlet.http.HttpSession;public class MySessionContext {    private static HashMap&lt;String, HttpSession&gt; mymap = new HashMap&lt;String, HttpSession&gt;();        public static synchronized void AddSession(HttpSession session) {                if (session != null) {                        mymap.put(session.getId(), session);                     }             }         public static synchronized void DelSession(HttpSession session) {                 if (session != null) {                         mymap.remove(session.getId());                     }             }         public static synchronized HttpSession getSession(String session_id) {                if (session_id == null)                     return null;                 return mymap.get(session_id);             }}</code></pre><p>Logger.java</p><pre><code>package com.sds.listenner;public class Logger {    public void info(String info) {        System.out.println(info);    }}</code></pre><p>3、添加SessionListener到系统配置中:</p><pre><code>package com.sds.cfg;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configurationpublic class SessionConfiguration extends WebMvcConfigurerAdapter{    //注册session监听器;    @Bean    public ServletListenerRegistrationBean&lt;SessionListener&gt; servletListenerRegistrationBean() {        ServletListenerRegistrationBean&lt;SessionListener&gt; slrBean = new ServletListenerRegistrationBean&lt;SessionListener&gt;();        slrBean.setListener(new SessionListener());        return slrBean;    }}</code></pre><p>原理：通过SessionListener监听session的创建和销毁，并在对应的session生命周期中从静态的HashMap【自定义的session容器】中添加或者删除对应的session，从而实现session的动态管理，提供准确的统计数据。</p><p>注意：在本例中提供了根据sessionId获取session的方法。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SpringBoot中RabbitMQ的使用详解</title>
      <link href="/2018/12/04/lao-bo-ke/springboot-zhong-rabbitmq-de-shi-yong-xiang-jie/"/>
      <url>/2018/12/04/lao-bo-ke/springboot-zhong-rabbitmq-de-shi-yong-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>最近在公司的代码里面看到RabbitMQ相关的代码，于是带着好奇心研究了下RabbitMQ.<br>        <strong>RabbitMQ的核心是交换机和队列。</strong><br>        交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存     储消息，在启用ack模式后，交换机找不到队列会返回错误。队列用于临时存储消息和转发消息。<br>        <strong>交换机有四种类型：Direct, topic, Headers and Fanout。</strong><br>         Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key, 消息的routing_key 匹配时, 才会被交换器投送到绑定的队列中去.[精确匹配类型]<br>        Topic：按规则转发消息（最灵活）[模式匹配]<br>        Headers：设置header attribute参数类型的交换机<br>        <strong>RabbitMQ的队列类型有两种，即时队列和延时队列【DelayQueue】。</strong><br>         即时队列：队列中的消息会被立即消费;<br>         延时队列：队列中的消息会在指定的时间延时之后被消费。<br>        下面将从即时队列和延时队列的具体实现来详解RabbitMQ.</p><p>   <strong>即时队列详解：</strong><br>              DirectExchange：</p><pre><code>          DirectExchangeTest.java</code></pre><pre><code>@Test    public void helloTest() throws Exception {        helloSender.send();    }</code></pre><p>HelloSender.java</p><pre><code>package com.neo.rabbit.hello;import java.util.Date;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class HelloSender {    @Autowired    private AmqpTemplate rabbitTemplate;    public void send() {        String context = &quot;hello &quot; + new Date()+&quot; sender is JunZhou&quot;;        System.out.println(&quot;Sender/this messag is send by zj : &quot; + context);        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, context);    }}</code></pre><p>HelloReceiver.java</p><pre><code>package com.neo.rabbit.hello;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@RabbitListener(queues = &quot;hello&quot;)public class HelloReceiver {    @RabbitHandler    public void process(String hello) {        System.out.println(&quot;Receiver  : &quot; + hello);    }}</code></pre><p>RabbitConfig.java</p><pre><code>package com.neo.rabbit;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;//@Configuration这个注解是必须的，保证在基本类实例化之前该类已经被实例化@Configurationpublic class RabbitConfig {    @Autowired    @Qualifier(&quot;defaultDirectExchange&quot;)    private DirectExchange exchange;    //创建队列,注意加注解;    @Bean    public Queue hiQueue() {        return new Queue(&quot;hello&quot;);    }    @Bean    public Queue neoQueue() {        return new Queue(&quot;neo&quot;);    }    @Bean    public Queue objectQueue() {        return new Queue(&quot;object&quot;);    }    //绑定队列;    @Bean    public Binding  helloBinding() {        return BindingBuilder.bind(hiQueue()).to(exchange).with(&quot;hello&quot;);    }}</code></pre><hr><p><strong>FanoutExchange：</strong></p><p>FanoutExchangeTest.java</p><pre><code>@Test    public void fanoutSenderTest(){        fanoutSender.send();    }</code></pre><p>FanoutSender .java</p><pre><code>package com.neo.rabbit.fanout;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class FanoutSender {    @Autowired    private AmqpTemplate rabbitTemplate;    public void send() {        String context = &quot;Sender from JunZhou 20180806 : hi, fanout msg &quot;;        System.out.println(&quot;Sender from JunZhou 20180806 : &quot; + context);//在fancout模式下，所有绑定到该交换机的队列均会收到交换机发出的消息，因此队列的名称会被忽略不计，因此`convertAndSend(exchangeName,queueName,Msg);`中的第二个参数可以用“”代替;        this.rabbitTemplate.convertAndSend(&quot;fanoutExchange&quot;,&quot;&quot;, context);    }}</code></pre><p>FanoutReceiverA .java……FanoutReceiverC .java</p><pre><code>package com.neo.rabbit.fanout;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@RabbitListener(queues = &quot;fanout.A&quot;)public class FanoutReceiverA {    @RabbitHandler    public void process(String message) {        System.out.println(&quot;fanout Receiver A  : &quot; + message);    }}</code></pre><p>FanoutRabbitConfig.java</p><pre><code>package com.neo.rabbit;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FanoutRabbitConfig {    @Bean    public Queue AMessage() {        return new Queue(&quot;fanout.A&quot;);    }    @Bean    public Queue BMessage() {        return new Queue(&quot;fanout.B&quot;);    }    @Bean    public Queue CMessage() {        return new Queue(&quot;fanout.C&quot;);    }    @Bean    FanoutExchange fanoutExchange() {        return new FanoutExchange(&quot;fanoutExchange&quot;);    }    @Bean    Binding bindingExchangeA() {        return BindingBuilder.bind(AMessage()).to(fanoutExchange());    }    @Bean    Binding bindingExchangeB() {        return BindingBuilder.bind(BMessage()).to(fanoutExchange());    }    @Bean    Binding bindingExchangeC() {        return BindingBuilder.bind(CMessage()).to(fanoutExchange());    }}</code></pre><hr><p>TopicExchangeTest.java</p><pre><code>@Test    public void topicSenderTest(){        //topicSender.send();        //topicSender.send1();        topicSender.send2();    }</code></pre><p>TopicSender .java</p><pre><code>package com.neo.rabbit.topic;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class TopicSender {    @Autowired    private AmqpTemplate rabbitTemplate;    public void send() {        String context = &quot;hi, i am message all&quot;;        System.out.println(&quot;Sender : &quot; + context);        this.rabbitTemplate.convertAndSend(&quot;topicExchange&quot;, &quot;topic.1&quot;, context);    }    public void send1() {        String context = &quot;hi, i am message 1&quot;;        System.out.println(&quot;Sender : &quot; + context);        this.rabbitTemplate.convertAndSend(&quot;topicExchange&quot;, &quot;topic.message&quot;, context);    }    public void send2() {        String context = &quot;hi, i am messages 2&quot;;        System.out.println(&quot;Sender : &quot; + context);        this.rabbitTemplate.convertAndSend(&quot;topicExchange&quot;, &quot;topic.messages&quot;, context);    }}</code></pre><p>TopicReceiver .java</p><pre><code>package com.neo.rabbit.topic;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@RabbitListener(queues = &quot;topic.message&quot;)public class TopicReceiver {    @RabbitHandler    public void process(String message) {        System.out.println(&quot;Topic Receiver1  : &quot; + message);    }}</code></pre><p>TopicReceiver2 .java</p><pre><code>package com.neo.rabbit.topic;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@RabbitListener(queues = &quot;topic.messages&quot;)public class TopicReceiver2 {    @RabbitHandler    public void process(String message) {        System.out.println(&quot;Topic Receiver2  : &quot; + message);    }}</code></pre><p>TopicRabbitConfig .java</p><pre><code>package com.neo.rabbit;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class TopicRabbitConfig {    final static String message = &quot;topic.message&quot;;    final static String messages = &quot;topic.messages&quot;;    @Bean    public Queue queueMessage() {        return new Queue(TopicRabbitConfig.message);    }    @Bean    public Queue queueMessages() {        return new Queue(TopicRabbitConfig.messages);    }    @Bean    TopicExchange exchange() {        return new TopicExchange(&quot;topicExchange&quot;);    }    @Bean    Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) {        return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;);    }    @Bean    Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) {        return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;);    }}</code></pre><blockquote><p>topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符:<br>“*”表示一个词.<br>“#”表示零个或多个词.</p></blockquote><p>在上面的TopicExchange中，当调用send1()方法，执行<code>this.rabbitTemplate.convertAndSend(&quot;topicExchange&quot;,&quot;topic.message&quot;, context);</code>时，实际上只有两个队列,即采用with(“topic.#”);和with(“topic.message”);绑定的两个队列会接受到消息;</p><p>以上就是非常简单的即时队列的详解，线面是延时队列的详解。</p><hr><p>延时队列有哪些用处呢？打个比方，加入用户下了单，但是在30分钟内没有支付我们就返回支付失败提示这个情景就可以采用延时队列来处理。<br>延时队列的原理图如下：<br><img src="http://ouuy81imh.bkt.clouddn.com/rabbitMQ01.png" alt="这里写图片描述"></p><blockquote><p>客户端：指具体往MQ发生消息端， 客户端将消息内容进行自定义包装， 将消息中附带目标队列名称。如：客户端向队列Q1发送字符串“hello” , 延时时间为60秒， 包装后修改为{“queueName”:”Q1”,”body”: “hello”}，此时，将消息发送到DLX死信队列，而非Q1队列，并将消息设置为60秒超时。</p></blockquote><hr><blockquote><p>DLX：死信队列，用来存储有超时时间信息的消息， 并且可以设置当消息超时时，转发到另一个指定队列(此处设置转发到router), 死信队列无消费者，当接收到客户端消息之后，等待消息超时，将消息转发到指定的Router队列</p></blockquote><hr><blockquote><p>Router: 转发队列，用来接收死信队列超时消息， 如上示例消息，在接收到之后，消费者将消息解析，获取queueName，body,再向所获取的queueName队列中发送一条消息，内容为body.</p></blockquote><p>延时队列的具体实现代码如下：<br>DelaySendTest.java</p><pre><code>@Test    public void delaySendTest(){        System.out.println(&quot;发送延迟消息...&quot;);        QueueMessage message = new QueueMessage(&quot;app.queue.hello&quot;,&quot;测试延时消息...&quot;);        message.setType(20);//20代表延时消息队列;        message.setSeconds(600);//设置延时时间,单位为毫秒;        messageQueueService.send(message);    }</code></pre><p>QueueMessage.java</p><pre><code>package com.neo.rabbit.DelayMQ.Model;import java.util.Date;public class QueueMessage {    private String exchange;    private String queueName;    private Integer type;    private Integer group;    private Date timestamp;    private String message;    private Integer status;    private int retry = 0;    private int maxRetry = 10;    private int seconds = 1;    public QueueMessage() {        super();    }    public QueueMessage(String queueName, String message) {        super();        this.queueName = queueName;        this.message = message;        this.exchange = &quot;default.direct.exchange&quot;;        this.type = 10;        this.group = 10;        this.timestamp = new Date();        this.status = 10;    }    public String getExchange() {        return exchange;    }    public void setExchange(String exchange) {        this.exchange = exchange;    }    public String getQueueName() {        return queueName;    }    public void setQueueName(String queueName) {        this.queueName = queueName;    }    public Integer getType() {        return type;    }    public void setType(Integer type) {        this.type = type;    }    public Integer getGroup() {        return group;    }    public void setGroup(Integer group) {        this.group = group;    }    public Date getTimestamp() {        return timestamp;    }    public void setTimestamp(Date timestamp) {        this.timestamp = timestamp;    }    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }    public Integer getStatus() {        return status;    }    public void setStatus(Integer status) {        this.status = status;    }    public int getRetry() {        return retry;    }    public void setRetry(int retry) {        this.retry = retry;    }    public int getMaxRetry() {        return maxRetry;    }    public void setMaxRetry(int maxRetry) {        this.maxRetry = maxRetry;    }    public int getSeconds() {        return seconds;    }    public void setSeconds(int seconds) {        this.seconds = seconds;    }}</code></pre><p>MessageException.java</p><pre><code>package com.neo.rabbit.DelayMQ.exception;public class MessageException extends RuntimeException{    private static final long serialVersionUID = 140085406084367372L;    private int code ;    private String message;    private String data;    public MessageException() {        super();    }    public MessageException(int code, String message) {        super(message);        this.code = code;        this.message = message;    }    public int getCode() {        return code;    }    public void setCode(int code) {        this.code = code;    }    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }    public String getData() {        return data;    }    public void setData(String data) {        this.data = data;    }}</code></pre><p>DeafaultMessageServiceImpl.java</p><pre><code>package com.neo.rabbit.DelayMQ.service.impl;import org.springframework.amqp.AmqpException;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessagePostProcessor;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.neo.rabbit.DelayMQ.Model.QueueMessage;import com.neo.rabbit.DelayMQ.exception.MessageException;import com.neo.rabbit.DelayMQ.service.IMessageQueueService;import com.neo.rabbit.DelayMQ.utils.JSONUtils;import com.neo.rabbit.DelayMQ.utils.StringUtils;@Service(&quot;deafaultMessageService&quot;)public class DeafaultMessageServiceImpl implements IMessageQueueService{    @Autowired    private RabbitTemplate rabbitTemplate;    @Override    public void send(QueueMessage message) {        this.checkMessage(message);        if(message.getType() == 10){//即时消息            this.sendMessage(message.getExchange(),message.getQueueName(),message.getMessage());        }        if(message.getType() == 20){//延时消息            sendTimeMessage(message);        }    }    //发送即时消息;    private void sendMessage(String exchange,String queueName,String msg){        rabbitTemplate.convertAndSend(exchange,queueName, msg);    }    //发送延时消息;    public void sendTimeMessage(QueueMessage message) {        int seconds = message.getSeconds();        if(seconds &lt;= 0){// 直接发送，无需进入死信队列            sendMessage(message.getExchange(),message.getQueueName(), message.getMessage());        }else{            long times = seconds * 1000;//rabbit默认为毫秒级            //这里需要字符定义延时处理器;            MessagePostProcessor processor = new MessagePostProcessor(){                @Override                public Message postProcessMessage(Message message) throws AmqpException {                    message.getMessageProperties().setExpiration(times + &quot;&quot;);                    return message;                }            };            rabbitTemplate.convertAndSend(&quot;default.direct.exchange&quot;,&quot;default.dead.letter.queue&quot;, JSONUtils.toJson(message), processor);        }    }    private void checkMessage(QueueMessage message){        if (StringUtils.isNullOrEmpty(message.getExchange())) {            throw new MessageException(10, &quot;发送消息格式错误: 消息交换机(exchange)不能为空!&quot;);        }        if(message.getGroup() == null){            throw new MessageException(10, &quot;发送消息格式错误: 消息组(group)不能为空!&quot;);        }        if(message.getType() == null){            throw new MessageException(10, &quot;发送消息格式错误: 消息类型(type)不能为空!&quot;);        }        if(message.getStatus() == null){            throw new MessageException(10, &quot;发送消息格式错误: 消息状态(status)不能为空!&quot;);        }        if(StringUtils.isNullOrEmpty(message.getQueueName())){            throw new MessageException(10, &quot;发送消息格式错误: 消息目标名称(queueName)不能为空!&quot;);        }        if (StringUtils.isNullOrEmpty(message.getMessage())) {            throw new MessageException(10, &quot;发送消息格式错误: 消息内容(message)不能为空!&quot;);        }    }}</code></pre><p>QueueConfiguration.java</p><pre><code>package com.neo.rabbit.DelayMQ.mqconfig;import java.util.HashMap;import java.util.Map;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class QueueConfiguration {    /**     * 默认即时消息交换机     * @return     */    @Bean(&quot;defaultDirectExchange&quot;)    public DirectExchange defaultDirectExchange() {        return new DirectExchange(&quot;default.direct.exchange&quot;, true, false);    }    /**     * 默认延迟消息死信队列     * @return     */    @Bean    public Queue defaultDeadLetterQueue() {        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();        arguments.put(&quot;x-dead-letter-exchange&quot;,&quot;default.direct.exchange&quot;);//设置交换机路由        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;default.repeat.trade.queue&quot;);//设置转发队列名称        Queue queue = new Queue(&quot;default.dead.letter.queue&quot;,true,false,false,arguments);        return queue;     }    @Bean    public Binding  defaultDeadLetterBinding() {        Binding bind = BindingBuilder.bind(defaultDeadLetterQueue()).to(defaultDirectExchange()).with(&quot;default.dead.letter.queue&quot;);        return bind;    }    /**     * 默认延迟消息死信接受转发消息队列     * @return     */    @Bean    public Queue defaultRepeatTradeQueue() {        Queue queue = new Queue(&quot;default.repeat.trade.queue&quot;,true,false,false);        return queue;     }    /**     * 转发队列和默认交换机的绑定;     * @return     */    @Bean    public Binding  defaultRepeatTradeBinding() {        return BindingBuilder.bind(defaultRepeatTradeQueue()).to(defaultDirectExchange()).with(&quot;default.repeat.trade.queue&quot;);    }    @Bean    public Queue helloQueue() {        Queue queue = new Queue(&quot;app.queue.hello&quot;,true,false,false);        return queue;     }    @Bean    public Binding  helloBinding() {        return BindingBuilder.bind(helloQueue()).to(defaultDirectExchange()).with(&quot;app.queue.hello&quot;);    }}</code></pre><p>TradeProcessor.java</p><pre><code>package com.neo.rabbit.DelayMQ.receiver;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import com.neo.rabbit.DelayMQ.Model.QueueMessage;import com.neo.rabbit.DelayMQ.service.IMessageQueueService;import com.neo.rabbit.DelayMQ.utils.JSONUtils;/** *  * @author victor * @desc 死信接收处理消费者 */@Component@RabbitListener(queues = &quot;default.repeat.trade.queue&quot;)public class TradeProcessor {    @Autowired    private IMessageQueueService messageQueueService;    @RabbitHandler    public void process(String content) {        System.out.println(&quot;-----------延时结束--------------&quot;);        QueueMessage message = JSONUtils.toBean(content, QueueMessage.class);        message.setType(10);        messageQueueService.send(message);    }}</code></pre><p>HelloProcessor.java</p><pre><code>package com.neo.rabbit.DelayMQ.receiver;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@RabbitListener(queues = &quot;app.queue.hello&quot;)public class HelloProcessor {    @RabbitHandler    public void process(String content) {        System.out.println(&quot;hello 接受消息：&quot; + content);    }}</code></pre><p>延时队列在可视化界面的表现形式为：<br><img src="http://ouuy81imh.bkt.clouddn.com/rabbitMQ02.png" alt="这里写图片描述"></p><p>其实最终的原理非常简单：<br>归纳起来就是：客户端发送消息到指定的交换机，进入死信队列【死信队列没有消费者】，在死信队列里超时处理器等待消息超时，消息超时后转发消息给转发队列，转发队列的消息消费者监听到消息后进行对应的逻辑处理即可。</p><p>参考文章：<br><a href="http://www.ityouknow.com/springboot/2016/11/30/spring-boot-rabbitMQ.html" target="_blank" rel="noopener">RabbitMQ详解</a><br><a href="https://blog.csdn.net/i_vic/article/details/72742277" target="_blank" rel="noopener">Rabbitmq集成,延时消息队列实现</a><br><a href="https://segmentfault.com/a/1190000004401870" target="_blank" rel="noopener">SpringBoot应用之消息队列</a></p><p>源码：<br><a href="https://download.csdn.net/download/zj20142213/10587291" target="_blank" rel="noopener">rabbitmq延时队列和四种交换机模式下队列的简单实现</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SpringBoot中AOP的简单实现。</title>
      <link href="/2018/12/04/lao-bo-ke/springboot-zhong-aop-de-jian-dan-shi-xian/"/>
      <url>/2018/12/04/lao-bo-ke/springboot-zhong-aop-de-jian-dan-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>在SpringBoot中实现AOP很简单。<br>      1、添加依赖：</p><p>//注意依赖的版本</p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>   2、定义切面：<br>    WebLogAspect.java</p><pre><code>package com.fangshuo.Aspect;import java.util.Arrays;import javax.servlet.http.HttpServletRequest;import org.apache.log4j.Logger;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;@Aspect  @Component  public class WebLogAspect {      private Logger logger = Logger.getLogger(getClass());      @Pointcut(&quot;execution(public * com.fangshuo.controller.*.*(..))&quot;)      public void webLog(){}      @Before(&quot;webLog()&quot;)      public void doBefore(JoinPoint joinPoint) throws Throwable {          // 接收到请求，记录请求内容          ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();          HttpServletRequest request = attributes.getRequest();          // 记录下请求内容          logger.info(&quot;URL : &quot; + request.getRequestURL().toString());          logger.info(&quot;HTTP_METHOD : &quot; + request.getMethod());          logger.info(&quot;IP : &quot; + request.getRemoteAddr());          logger.info(&quot;CLASS_METHOD : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());          logger.info(&quot;ARGS : &quot; + Arrays.toString(joinPoint.getArgs()));      }      @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)      public void doAfterReturning(Object ret) throws Throwable {          // 处理完请求，返回内容          logger.info(&quot;RESPONSE : &quot; + ret);    }  }  </code></pre><p>整个AOP的代码结构如下:<br>     <img src="https://img-blog.csdn.net/20180625223007389?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqMjAxNDIyMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>注意点：</p><p>在后置通知中returning = “ret”中定义的参数名必须和通知方法受那个的参数匹配，即returning = “ret”中定义的是ret,通知方法中也必须是”ret”,否则将抛出异常。</p><pre><code>  @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)      public void doAfterReturning(Object ret) throws Throwable {          // 处理完请求，返回内容          logger.info(&quot;RESPONSE : &quot; + ret);    }  </code></pre><p>3、参考文章：<br><a href="https://www.cnblogs.com/lic309/p/4079194.html" target="_blank" rel="noopener">spring aop 面向切面编程初接触</a><br><a href="https://blog.csdn.net/owen_william/article/details/50812771" target="_blank" rel="noopener">Spring AOP(二)之AfterReturning增强处理</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>springboot配置文件的读取方式</title>
      <link href="/2018/12/04/lao-bo-ke/springboot-pei-zhi-wen-jian-de-du-qu-fang-shi/"/>
      <url>/2018/12/04/lao-bo-ke/springboot-pei-zhi-wen-jian-de-du-qu-fang-shi/</url>
      
        <content type="html"><![CDATA[<p>最近在做项目的时候，因为需求原因，要定义几个常量，但是这几个常量有可能改动，为了尽量不改动代码，就想能不能放到SpringBooot的配置文件中呢，毕竟配置文件先于SpringBoot的核心业务类加载，因此配置在配置文件中的属性便相当于有了static属性。具体的解决方案分为两大类：<br>       1、自定义配置文件类进行读取；<br>            bootstrap.properties中的属性内容如下：</p><pre><code>##spring.application.name=spring-cloud-zuul##server.port=8002spring.cloud.config.name=zj-cfg4zuulspring.cloud.config.profile=devspring.cloud.config.label=masterspring.cloud.config.discovery.enabled=truespring.cloud.config.discovery.serviceId=spring-cloud-config-servereureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/#网络前缀;NET-PREFIX.DOMAIN=http://localhost:8006/#------内部URL------;#Excel上传的URL;NET-PREFIX.EXCELUPLOADURL=uploadExcel#身份认证的URL;NET-PREFIX.AUTHENTICATIONURL=spring-cloud-producer/mongo/auth/doGetAuthenticationInfo#权限认证的URL;NET-PREFIX.AUTHORIZATIONURL=spring-cloud-producer/mongo/auth/doGetAuthorizationInfo#保存Session的URL;NET-PREFIX.SAVEUSERSESSIONURL=spring-cloud-producer/mongo/auth/saveUserSessionWithJsessionid#移除Sessin的URL;NET-PREFIX.REMOVEUSERSESSIONURL=spring-cloud-producer/mongo/auth/removeUserSessionFromDB#师傅对头部信息敏感;zuul.sensitive-headers=false</code></pre><hr><p>创建实体类MyConfig。<br>       注意：springboot1.5版本以下@ConfigurationProperties有两个属性locations（指定配置文件的所在位置），       </p><blockquote><p>当前的文件路径如下图所示：<br>       <img src="https://img-blog.csdn.net/20180417215710400?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqMjAxNDIyMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p></blockquote><hr><pre><code>package com.neo.webConfig;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;/** * 自定义的配置文件类; * @author xdsm * */@Component@ConfigurationProperties(prefix = &quot;NET-PREFIX&quot;)@PropertySource(value = &quot;classpath:bootstrap.properties&quot;)public class MyConfig {    //域名;    private String DOMAIN;    //Excel上传的URL;    private String EXCELUPLOADURL;    //身份认证的URL;    private String AUTHENTICATIONURL;    //权限认证的URL;    private String AUTHORIZATIONURL;    //Session保存的URL;    private String SAVEUSERSESSIONURL;    //Session移除的URL;    private String REMOVEUSERSESSIONURL;    public String getDOMAIN() {        return DOMAIN;    }    public void setDOMAIN(String dOMAIN) {        DOMAIN = dOMAIN;    }    public String getEXCELUPLOADURL() {        return EXCELUPLOADURL;    }    public void setEXCELUPLOADURL(String eXCELUPLOADURL) {        EXCELUPLOADURL = eXCELUPLOADURL;    }    public String getAUTHENTICATIONURL() {        return AUTHENTICATIONURL;    }    public void setAUTHENTICATIONURL(String aUTHENTICATIONURL) {        AUTHENTICATIONURL = aUTHENTICATIONURL;    }    public String getAUTHORIZATIONURL() {        return AUTHORIZATIONURL;    }    public void setAUTHORIZATIONURL(String aUTHORIZATIONURL) {        AUTHORIZATIONURL = aUTHORIZATIONURL;    }    public String getSAVEUSERSESSIONURL() {        return SAVEUSERSESSIONURL;    }    public void setSAVEUSERSESSIONURL(String sAVEUSERSESSIONURL) {        SAVEUSERSESSIONURL = sAVEUSERSESSIONURL;    }    public String getREMOVEUSERSESSIONURL() {        return REMOVEUSERSESSIONURL;    }    public void setREMOVEUSERSESSIONURL(String rEMOVEUSERSESSIONURL) {        REMOVEUSERSESSIONURL = rEMOVEUSERSESSIONURL;    }    @Override    public String toString() {        return &quot;MyConfig [DOMAIN=&quot; + DOMAIN + &quot;, EXCELUPLOADURL=&quot; + EXCELUPLOADURL + &quot;, AUTHENTICATIONURL=&quot;                + AUTHENTICATIONURL + &quot;, AUTHORIZATIONURL=&quot; + AUTHORIZATIONURL + &quot;, SAVEUSERSESSIONURL=&quot;                + SAVEUSERSESSIONURL + &quot;, REMOVEUSERSESSIONURL=&quot; + REMOVEUSERSESSIONURL + &quot;]&quot;;    }}</code></pre><h2 id="需要注意的是：在自定义属性类中，属性文件的属性名中不能出现“-”等特殊字符-如“NET-PREFIX-REMOVE-USER-SESSION-URL”，否则可能导致属性无法读取的问题【亲测】。"><a href="#需要注意的是：在自定义属性类中，属性文件的属性名中不能出现“-”等特殊字符-如“NET-PREFIX-REMOVE-USER-SESSION-URL”，否则可能导致属性无法读取的问题【亲测】。" class="headerlink" title="需要注意的是：在自定义属性类中，属性文件的属性名中不能出现“_”等特殊字符,如“NET-PREFIX.REMOVE_USER_SESSION_URL”，否则可能导致属性无法读取的问题【亲测】。"></a>需要注意的是：在自定义属性类中，属性文件的属性名中不能出现“_”等特殊字符,如“NET-PREFIX.REMOVE_USER_SESSION_URL”，否则可能导致属性无法读取的问题【亲测】。</h2><pre><code>   2、非自定义配置文件类进行读取；   （1）@Value(&quot;${键名}&quot;)</code></pre><pre><code>RestControllerpublic class HelloController {    @Value(&quot;${service.name}&quot;)    private String name;    @RequestMapping(value = &quot;/hello&quot;)    public String hello() {        return &quot;hello spring boot! &quot; + name;    }}</code></pre><p>（2）使用Environment，env.getProperty(“键名”)</p><pre><code>@RestControllerpublic class HelloController {    @Autowired    private Environment env;    @RequestMapping(value = &quot;/hello&quot;)    public String hello() {        return &quot;hello spring boot! &quot; + env.getProperty(&quot;service.name&quot;);    }}</code></pre><p>综上所述，获取SpringBoot有两大类，三种方法。如果有代码洁癖，非要对属性进行分类管理的话，推荐使用自定义属性类的方法，这样可以对属性进行分类管理。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SpringBoot+React前后端分离项目中跨域问题的完美解决方案</title>
      <link href="/2018/12/04/lao-bo-ke/springboot-react-qian-hou-duan-fen-chi-xiang-mu-zhong-kua-yu-wen-ti-de-wan-mei-jie-jue-fang-an/"/>
      <url>/2018/12/04/lao-bo-ke/springboot-react-qian-hou-duan-fen-chi-xiang-mu-zhong-kua-yu-wen-ti-de-wan-mei-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<p>springboot+react前后端分离项目中，跨域问题必然存在，解决方案有三种类型:<br>1、前端解决：<br>  在package.json中添加如下代码:</p><pre><code>{  &quot;name&quot;: &quot;myproject1&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;private&quot;: true,  **&quot;proxy&quot;: &quot;http://localhost:9090&quot;,**  &quot;dependencies&quot;: {    &quot;antd&quot;: &quot;^3.0.3&quot;,    &quot;fetch&quot;: &quot;^1.1.0&quot;,    &quot;flux&quot;: &quot;^3.1.3&quot;,    &quot;react&quot;: &quot;^15.4.1&quot;,    &quot;react-addons-css-transition-group&quot;: &quot;^15.6.2&quot;,    &quot;react-dom&quot;: &quot;^15.4.1&quot;,    &quot;react-router&quot;: &quot;^3.0.0&quot;,    &quot;react-scripts&quot;: &quot;1.0.17&quot;  },  &quot;scripts&quot;: {    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  },  &quot;devDependencies&quot;: {    &quot;reqwest&quot;: &quot;^2.0.5&quot;  }}</code></pre><p>缺点：由于域名部分是固定的，无法解决跨多个网站请求资源的跨域;<br>2.后端解决方案:<br>2.1、<a href="https://www.jianshu.com/p/c6ea21b64f6e" target="_blank" rel="noopener">参考文章；</a><br>2.2、原理:添加SpringMVC底层实现的Web配置适配器,增加CORS相关的配置信息;</p><pre><code>package com.spring.boot.gp4zj.webconfig;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configurationpublic class CORSConfiguration extends WebMvcConfigurerAdapter{    @Override    public void addCorsMappings(CorsRegistry registry) {        registry                .addMapping(&quot;/**&quot;)                .allowedMethods(&quot;*&quot;)                .allowedOrigins(&quot;*&quot;)                .allowedHeaders(&quot;*&quot;);    }}</code></pre><p>3.3、添加代理服务器,如nginx配置,前面讲过;</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>springboot+mybatis多数据源最简解决方案</title>
      <link href="/2018/12/04/lao-bo-ke/springboot-mybatis-duo-shu-ju-yuan-zui-jian-jie-jue-fang-an/"/>
      <url>/2018/12/04/lao-bo-ke/springboot-mybatis-duo-shu-ju-yuan-zui-jian-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<p>在配置多数据源之前先理解@Configuration注解、@Bean注解以及配置自动扫描、bean作用域，参考文章如下:<br><a href="http://blog.csdn.net/javaloveiphone/article/details/52182899" target="_blank" rel="noopener">@Configuration注解、@Bean注解以及配置自动扫描、bean作用域</a><br>1、原理:定义多个数据源，根据<code>basePackages</code>进行自动切换;<br>2.代码:<br><a href="https://github.com/JunZhou2016/spring-boot-mybatis-mulidatasource" target="_blank" rel="noopener">SpringBoot+Mybatis多数据员配置Demo</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Spring+quartz实现任务调度的小例子</title>
      <link href="/2018/12/04/lao-bo-ke/spring-quartz-shi-xian-ren-wu-diao-du-de-xiao-li-zi/"/>
      <url>/2018/12/04/lao-bo-ke/spring-quartz-shi-xian-ren-wu-diao-du-de-xiao-li-zi/</url>
      
        <content type="html"><![CDATA[<hr><p>实现任务调度分为三大模块：1.任务调度器Scheduler;<br>                                            2.触发器cronTrigger；<br>                                            3.自定义任务JobtTask；</p><hr><pre><code>*自定义任务JobtTask*package com.zjt.quartz;import java.text.SimpleDateFormat;import java.util.Date;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;/** * 自定义任务; */public class MyJob implements Job {    // 自定义任务Task;    public void execute(JobExecutionContext context) throws JobExecutionException {        System.out.println(&quot;当前任务开始执行: &quot; +         new SimpleDateFormat(&quot;yyyy-MM-dd HH-mm-ss&quot;)         .format(new Date()));    }}</code></pre><pre><code>*测试类*package com.zjt.quartz;import java.text.ParseException;import org.quartz.JobExecutionException;import org.springframework.context.support.ClassPathXmlApplicationContext;/** *  测试类 */public class Test {    @SuppressWarnings(&quot;resource&quot;)    public static void main(String[] args) throws ParseException, JobExecutionException {        System.out.println(&quot;--------------------------------&quot;);        new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);    }} </code></pre><pre><code>配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans-2.5.xsd      http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;    default-autowire=&quot;byName&quot;&gt;    &lt;!-- 调度器 --&gt;    &lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;        &lt;property name=&quot;triggers&quot;&gt;            &lt;list&gt;                &lt;!-- 触发器列表 --&gt;                &lt;ref bean=&quot;cronTrigger&quot; /&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;!-- 加载配置文件, 如果不配置, 将会使用quartz默认的配置 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:quartz.properties&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 触发器 --&gt;    &lt;bean id=&quot;cronTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;        &lt;!-- 指向我们的任务 --&gt;        &lt;property name=&quot;jobDetail&quot; ref=&quot;myJobtTask&quot; /&gt;        &lt;!-- 每天11点1分到59分,每分钟运行一次 --&gt;        &lt;property name=&quot;cronExpression&quot; value=&quot;0 0/1 9 * * ?&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 处理类 --&gt;    &lt;bean name=&quot;myJobtTask&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt;        &lt;property name=&quot;jobClass&quot; value=&quot;com.zjt.quartz.MyJob&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><pre><code>*quartz.properties*#============================================================================# Configure Main Scheduler Properties  #============================================================================org.quartz.scheduler.instanceName = DefaultQuartzSchedulerorg.quartz.scheduler.instanceId = AUTOorg.quartz.scheduler.rmi.export = falseorg.quartz.scheduler.rmi.proxy = falseorg.quartz.scheduler.wrapJobExecutionInUserTransaction = false#============================================================================# Configure ThreadPool  #============================================================================org.quartz.threadPool.threadCount = 10org.quartz.threadPool.threadPriority = 5#============================================================================# Configure JobStore  #============================================================================org.quartz.jobStore.misfireThreshold = 60000</code></pre><p><strong>下载链接：<a href="http://download.csdn.net/my" target="_blank" rel="noopener">http://download.csdn.net/my</a></strong></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Shiro的学习Helloworld</title>
      <link href="/2018/12/04/lao-bo-ke/shiro-de-xue-xi-helloworld/"/>
      <url>/2018/12/04/lao-bo-ke/shiro-de-xue-xi-helloworld/</url>
      
        <content type="html"><![CDATA[<h2 id="Shiro的学习Helloworld"><a href="#Shiro的学习Helloworld" class="headerlink" title="Shiro的学习Helloworld"></a>Shiro的学习Helloworld</h2><p>8月 18, 2017   框架相关, 权限管理</p><ol><li>Apache Shiro是Java的一个安全框架<br>1.1. Shiro可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等</li><li>Shiro基本功能</li><li>1.身份认证</li><li>2.权限认证<br>4.1. 核心要素：（资源，）权限，角色，用户</li><li>3.集成web进行测试<br>5.0.1. 1.新建一个maven的web项目<br>5.0.1.1. 1.authc.loginUrl配置身份认证不通过(未登录时)跳转的地址…(loginUrl是authc的一个属性)<br>5.0.1.2. 2.roles.unauthorizeUrl配置角色认证不通过跳转的地址…(noAuth.jsp页面目前只有一行字)<br>5.0.1.3. 3.perms.unauthorizeUrl配置权限认证不通过跳转的地址<br>5.0.1.4. 4.[users]下配置用户身份信息以及用户角色<br>5.0.1.5. 5.[roles]下配置角色以及角色的控制权限<br>5.0.1.6. 6.[urls]下配置访问地址所需的权限, 其中值为”anon过滤器”表示地址不需要登录即可访问; “authc过滤器”表示地址登录才能访问<br>5.0.1.7. 7.值为 roles[admin] 表示 必须有角色为admin的用户才能范围<br>5.0.1.8. 8.值为 perms[“student:create”] 表示 必须有权限为”student:create”的用户才能范围<br>5.0.1.9. 9.多个过滤器用”,”隔开 而且相互为”且”的关系(必须同时满足才能访问)<br>5.0.1.10. 10.地址可以使用?表示匹配单个任意字符(eg: /home?=authc 表示可过滤 /home1; /homef…..)<br>5.0.1.11. 11.地址可以使用表示匹配任意个任意字符(eg: /home=authc 表示可过滤 /home123; /homeef…..)<br>5.0.1.12. 12.地址可以使用表示匹配多路径(eg: /home/=authc 表示可过滤 /home/abc; /home/aaa/bbb…..)<br>5.0.2. 2.编写sevlet代码<br>5.0.3. 3.启动项目<br>5.0.3.1. 测试身份认证<br>5.0.3.2. 测试角色认证<br>5.0.3.3. 测试权限认证</li><li>—<br>6.0.1. 自定义Realm<br>6.0.1.1. 测试开发步骤<br>6.0.1.2. 1.myRealm指向自定义Realm的位置<br>6.0.1.3. 2.securityManager.realms指向自定义Realm的引用(表明使用自定义Realms进行安全认证),可以指向多个,用”,”隔开<br>Apache Shiro是Java的一个安全框架<br>Shiro可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等<br>图片说明<br>Shiro基本功能<br>Authentication：身份认证/登录，验证用户是不是拥有相应的身份；</li></ol><p>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p><p>Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</p><p>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p><p>Web Support：Web支持，可以非常容易的集成到Web环境；</p><p>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</p><p>Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</p><p>Testing：提供测试支持；</p><p>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</p><p>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</p><hr><p>1.身份认证<br>配置文件：<br>    <strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong><br>    [users]<br>    zj2626=123456<br>    ay2626=456789<br>    <strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></p><p>package com.em;</p><p>import org.apache.shiro.SecurityUtils;<br>import org.apache.shiro.authc.UsernamePasswordToken;<br>import org.apache.shiro.config.IniSecurityManagerFactory;<br>import org.apache.shiro.mgt.SecurityManager;<br>import org.apache.shiro.subject.Subject;<br>import org.apache.shiro.util.Factory;</p><p>public class Hello {</p><pre><code>public static void main(String args[]) {    //初始化SecurityManager工厂      读取配置文件中的用户名密码    Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);    //获取SecurityManager实例    SecurityManager manager = factory.getInstance();    //把SecurityManager实例绑定到SecurityUtils    SecurityUtils.setSecurityManager(manager);    //得到当前执行的用户    Subject subject = SecurityUtils.getSubject();    //创建token令牌, 用户/密码    UsernamePasswordToken token = new UsernamePasswordToken(&quot;zj2626&quot;, &quot;123456&quot;);    try {        //身份认证 登录        subject.login(token);        System.out.println(&quot;登录成功&quot;);    } catch (Exception e) {        System.out.println(&quot;登录失败&quot;);        e.printStackTrace();    }    subject.logout();}/*    Subject: 认证主体    Principals:  身份: 用户名    Credentials: 凭证: 密码    Realm: 域        1.jdbc realm | 2.jndi realm | 3.text realm */</code></pre><p>}<br>从数据库中读取用户名密码 实现登录</p><p>1.配置文件: jdbc_realm.ini （代码只需把读取的文件改成此文件即可测试使用）</p><p>[main]<br>jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm<br>dataSource=com.mchange.v2.c3p0.ComboPooledDataSource<br>dataSource.driverClass=com.mysql.jdbc.Driver<br>dataSource.jdbcUrl=jdbc:mysql://127.0.0.1:3306/test<br>dataSource.user=root<br>dataSource.password=123456<br>jdbcRealm.dataSource=$dataSource<br>securityManager.realms=$jdbcRealm<br>2.权限认证<br>核心要素：（资源，）权限，角色，用户<br>用户–（分配）–&gt;角色–（拥有）–&gt;权限–（控制）—-&gt;资源</p><p>用户代表访问系统的用户，即subject。<br>三种授权方式</p><ol><li>编程式授权<br> 1.1. 基于角色的访问控制<br> 1.2. 基于权限的访问控制</li><li>注解式授权<br>3.JSP标签授权<br>####步骤1: 封装一个工具类</li></ol><p>public class ShiroUtils {<br>    public static Subject login(String conf, String username, String passowrd) {<br>        //初始化SecurityManager工厂 conf是配置文件名称<br>        Factory<securitymanager> factory = new IniSecurityManagerFactory(“classpath:” + conf + “.ini”);<br>        //获取SecurityManager实例<br>        SecurityManager manager = factory.getInstance();<br>        //把SecurityManager实例绑定到SecurityUtils<br>        SecurityUtils.setSecurityManager(manager);<br>        //得到当前执行的用户<br>        Subject subject = SecurityUtils.getSubject();<br>        //创建token令牌, 用户/密码<br>        UsernamePasswordToken token = new UsernamePasswordToken(username, passowrd);</securitymanager></p><pre><code>    try {        //身份认证 登录        subject.login(token);    } catch (Exception e) {        e.printStackTrace();    }    return subject;}</code></pre><p>}</p><p>####步骤2: 测试多种访问控制</p><p>/*<br>    基于角色的访问控制方式1</p><pre><code>配置文件：shiro_role.ini******************************[users]zj2626=123456,role1,role2py2626=123456,role1ay2626=456789,role3****************************** */@Testpublic void testHas() {    Subject sub = ShiroUtils.login(&quot;shiro_config/shiro_role&quot;, &quot;zj2626&quot;, &quot;123456&quot;);    //判断有没有权限 返回布尔 表示验证的成功与否    boolean bool = sub.hasRole(&quot;role1&quot;);    if (bool) {        System.out.println(&quot;HAS&quot;);    }    //判断有没有权限,一次多个分别判断 返回布尔数组    boolean[] booleans = sub.hasRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;));    int i = 0;    while (booleans[i]) {        i++;        if (booleans.length &lt;= i) {            break;        }    }    //所有的角色都有才返回true    System.out.println(sub.hasAllRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;)));    //判断有没有权限 没有则抛异常    sub.checkRole(&quot;role1&quot;);    sub.checkRole(&quot;role3&quot;);    //判断多个权限 有一个没有就抛异常 (2种参数形式)    sub.checkRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;));    sub.checkRoles(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;);    //退出登陆    sub.logout();}/*基于权限的访问控制方式(过程同上)配置文件：shiro_permision.ini******************************[users]zj2626=123456,role1,role2py2626=123456,role1ay2626=456789,role3[roles]role1=user:selectrole2=user:add,user:update,user:delete****************************** */@Testpublic void testPermition() {    Subject sub = ShiroUtils.login(&quot;shiro_config/shiro_permision&quot;, &quot;py2626&quot;, &quot;123456&quot;);    System.out.println(&quot;用户是否有权限 user:select:&quot; + sub.isPermitted(&quot;user:select&quot;));    //true    System.out.println(&quot;用户是否有权限 user:update:&quot; + sub.isPermitted(&quot;user:update&quot;));    //false    boolean[] booleans = sub.isPermitted(&quot;user:add&quot;, &quot;user:select&quot;);    System.out.println(booleans[0] + &quot;____&quot; + booleans[1]);    System.out.println(sub.isPermittedAll(&quot;user:add&quot;, &quot;user:select&quot;));    //没有会抛出异常    sub.checkPermission(&quot;user:select&quot;);    sub.checkPermissions(&quot;user:select&quot;, &quot;user:update&quot;);    sub.logout();}</code></pre><p>3.集成web进行测试<br>1.新建一个maven的web项目</p><p>项目目录文件</p><p>web.xml 配置shiro的必须的配置: 监听器,过滤器</p><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p><p><web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"><br>    <display-name>Archetype Created Web Application</display-name></web-app></p><pre><code>&lt;!--三个servlet配置   /login跳转到登陆页面  /home跳转到主页,即登陆成功页面 /admin用来测试角色和权限--&gt;&lt;servlet&gt;    &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt;    &lt;servlet-name&gt;homeServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.servlet.HomeServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;homeServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/home&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt;    &lt;servlet-name&gt;adminServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.servlet.AdminServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;adminServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/admin&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--shiro监听--&gt;&lt;listener&gt;    &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--shiro过滤器 这里过滤所有的地址 并且指定权限配置文件(一般项目中权限的配置存放在数据库中)--&gt;&lt;filter&gt;    &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;config&lt;/param-name&gt;        &lt;param-value&gt;classpath:shiro.ini&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p><br>pom.xml :所需依赖</p><p><dependencies><br>    <dependency><br>        <groupid>org.apache.shiro</groupid><br>        <artifactid>shiro-web</artifactid><br>        <version>1.3.2</version><br>    </dependency><br>    <dependency><br>        <groupid>org.apache.shiro</groupid><br>        <artifactid>shiro-core</artifactid><br>        <version>1.3.2</version><br>    </dependency><br>    <dependency><br>        <groupid>org.apache.shiro</groupid><br>        <artifactid>shiro-spring</artifactid><br>        <version>1.3.2</version><br>    </dependency><br>    <dependency><br>        <groupid>org.apache.tomcat</groupid><br>        <artifactid>tomcat-servlet-api</artifactid><br>        <version>8.5.4</version><br>        <scope>provided</scope><br>    </dependency><br>    <dependency><br>        <groupid>org.slf4j</groupid><br>        <artifactid>slf4j-log4j12</artifactid><br>        <version>1.7.7</version><br>        <scope>compile</scope><br>    </dependency><br>    <dependency><br>        <groupid>commons-logging</groupid><br>        <artifactid>commons-logging</artifactid><br>        <version>1.2</version><br>    </dependency><br>    <dependency><br>        <groupid>commons-beanutils</groupid><br>        <artifactid>commons-beanutils</artifactid><br>        <version>1.9.3</version><br>    </dependency><br>    <dependency><br>        <groupid>commons-collections</groupid><br>        <artifactid>commons-collections</artifactid><br>        <version>3.2.1</version><br>    </dependency><br>    <dependency><br>        <groupid>jstl</groupid><br>        <artifactid>jstl</artifactid><br>        <version>1.2</version><br>    </dependency><br></dependencies><br>shiro.ini: 权限配置文件,配置什么用户有什么角色,什么角色有什么权限</p><p>[main]<br>authc.loginUrl=/login<br>perms.unauthorizedUrl=/noAuth.jsp<br>roles.unauthorizedUrl=/noAuth.jsp<br>[users]<br>zj2626=123456,admin<br>ay2626=456789,student<br>[roles]<br>admin=user:<em>,student:select<br>student:student:</em><br>[urls]<br>/login=anon<br>/home=authc<br>/admin=roles[admin]<br>1.authc.loginUrl配置身份认证不通过(未登录时)跳转的地址…(loginUrl是authc的一个属性)</p><p>2.roles.unauthorizeUrl配置角色认证不通过跳转的地址…(noAuth.jsp页面目前只有一行字)</p><p>3.perms.unauthorizeUrl配置权限认证不通过跳转的地址</p><p>4.[users]下配置用户身份信息以及用户角色</p><p>5.[roles]下配置角色以及角色的控制权限</p><p>6.[urls]下配置访问地址所需的权限, 其中值为”anon过滤器”表示地址不需要登录即可访问; “authc过滤器”表示地址登录才能访问</p><p>7.值为 roles[admin] 表示 必须有角色为admin的用户才能范围</p><p>8.值为 perms[“student:create”] 表示 必须有权限为”student:create”的用户才能范围</p><p>9.多个过滤器用”,”隔开 而且相互为”且”的关系(必须同时满足才能访问)</p><p>10.地址可以使用?表示匹配单个任意字符(eg: /home?=authc 表示可过滤 /home1; /homef…..)</p><p>11.地址可以使用表示匹配任意个任意字符(eg: /home=authc 表示可过滤 /home123; /homeef…..)</p><p>12.地址可以使用表示匹配多路径(eg: /home/=authc 表示可过滤 /home/abc; /home/aaa/bbb…..)</p><p>2.编写sevlet代码</p><p>LoginServlet.java :身份验证地址</p><p>package com.servlet;</p><p>import org.apache.shiro.SecurityUtils;<br>import org.apache.shiro.authc.UsernamePasswordToken;<br>import org.apache.shiro.subject.Subject;</p><p>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>import java.io.IOException;</p><p>/**</p><ul><li><p>Created by zj on 2017/4/10.<br>*/<br>public class LoginServlet extends HttpServlet {<br> /**</p><ul><li>跳转登录界面<br>*</li><li>@param req</li><li>@param resp</li><li>@throws ServletException</li><li><p>@throws IOException<br>*/<br>@Override<br>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br> System.out.println(“user no login”);<br> resp.sendRedirect(“login.jsp”);<br>}</p><p>/**</p></li><li>进行登录<br>*</li><li>@param req</li><li>@param resp</li><li>@throws ServletException</li><li><p>@throws IOException<br>*/<br>@Override<br>protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br> System.out.println(“登录”);<br> String userName = req.getParameter(“userName”);<br> String password = req.getParameter(“password”);</p><p> Subject subject = SecurityUtils.getSubject();<br> //创建token令牌, 用户/密码<br> UsernamePasswordToken token = new UsernamePasswordToken(userName, password);<br> try {</p><pre><code> //身份认证 登录 subject.login(token); System.out.println(&quot;登录成功&quot;); resp.sendRedirect(&quot;success.jsp&quot;);</code></pre><p> } catch (Exception e) {</p><pre><code> System.out.println(&quot;账号密码不对&quot;); e.printStackTrace(); resp.sendRedirect(&quot;login.jsp&quot;);</code></pre><p> }<br>}<br>}</p></li></ul></li></ul><p>//<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>login.jsp</p><p>&lt;%@ page language=”java” pageEncoding=”UTF-8” %&gt;<br>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c” %&gt;<br>&lt;!DOCTYPE HTML&gt;</p><p><html></html></p><p><body></body></p><p></p><h2>Hello World</h2><br>登录:<p></p><p><form action="/login" method="post"><br>    <input type="text" value="" name="userName"><br>    <input type="password" value="" name="password"><br>    <input type="submit" value="登录"><br></form><br><br><br>HomeServlet.java :登录成功以及退出登录地址</p><p>package com.servlet;</p><p>import org.apache.shiro.SecurityUtils;<br>import org.apache.shiro.subject.Subject;</p><p>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>import java.io.IOException;</p><p>/**</p><ul><li><p>Created by zj on 2017/4/10.<br>*/<br>public class HomeServlet extends HttpServlet {<br> /**</p><ul><li>进入主页(登陆成功界面)<br>*</li><li>@param req</li><li>@param resp</li><li>@throws ServletException</li><li><p>@throws IOException<br>*/<br>@Override<br>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br> System.out.println(“主页 get”);</p><p> req.getRequestDispatcher(“success.jsp”).forward(req, resp);</p><p>}</p><p>/**</p></li><li>用来退出登陆<br>*</li><li>@param req</li><li>@param resp</li><li>@throws ServletException</li><li><p>@throws IOException<br>*/<br>@Override<br>protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br> System.out.println(“主页 post”);</p><p> System.out.println(“login out”);</p><p> //退出登录<br> Subject subject = SecurityUtils.getSubject();<br> subject.logout();</p><p> resp.sendRedirect(“login.jsp”);<br>}<br>}</p></li></ul></li></ul><p>//<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>success.jsp</p><p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p><p><html></html></p><p><body></body></p><p></p><h2>Hello World!</h2> 成功!!!<p></p><p><form action="/home" method="post"><br>    <input type="submit" value="退出登陆"><br></form><br><br><br>AdminServlet.java</p><p>package com.servlet;</p><p>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>import java.io.IOException;</p><p>/**</p><ul><li><p>Created by zj on 2017/4/10.<br>*/<br>public class AdminServlet extends HttpServlet {<br> protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</p><pre><code> System.out.println(&quot;ADMIN GET&quot;);</code></pre><p> }</p><p> protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</p><pre><code> System.out.println(&quot;ADMIN POST&quot;);</code></pre><p> }<br>}<br>3.启动项目</p></li></ul><p>测试身份认证</p><p>不登录情况下输入地址 <a href="http://localhost:8080/home" target="_blank" rel="noopener">http://localhost:8080/home</a> 跳转到 /login地址转向的jsp页面</p><p>输入正确的用户名(ay2626)密码 点击登录 成功; 再次输入地址 <a href="http://localhost:8080/home" target="_blank" rel="noopener">http://localhost:8080/home</a> 跳转到成功的jsp</p><p>点击退出登录 成功; 再次输入地址 <a href="http://localhost:8080/home" target="_blank" rel="noopener">http://localhost:8080/home</a> 跳转到 /login地址转向的jsp页面</p><p>测试角色认证</p><p>登录 :进行其他认证前先进行身份认证 使用ay2626用户登录(其角色只有student) 登录成功 跳转到success.jsp</p><p>输入地址<a href="http://localhost:8080/admin" target="_blank" rel="noopener">http://localhost:8080/admin</a> 跳转到 <a href="http://localhost:8080/noAuth.jsp" target="_blank" rel="noopener">http://localhost:8080/noAuth.jsp</a> 表示没有权限访问此地址</p><p>退出登录 用zj2626再次登录测试 登录成功 再次输入<a href="http://localhost:8080/admin" target="_blank" rel="noopener">http://localhost:8080/admin</a> 控制台打印”ADMIN POST” 表示访问成功</p><p>测试权限认证</p><p>可把配置文件中 /admin的过滤器改为 /admin=perms[“student:create”] 进行测试</p><p>测试发现 有权限的ay2626用户可以访问而没有权限的zj2626不能访问</p><p>—<br>自定义Realm</p><p>实际开发中用户权限的配置要存放在数据库,so需要使用自定义realm来读取数据库中权限配置然后为用户赋予权限</p><p>测试开发步骤</p><p>1.添加数据库依赖</p><p><dependency><br>    <groupid>mysql</groupid><br>    <artifactid>mysql-connector-java</artifactid><br>    <version>5.1.39</version><br>    <scope>compile</scope><br></dependency><br>2.设计构建测试的数据库表:有三个表:分别存储用户,角色,权限 并其他两个都与角色关联, 然后存入部分数据 ,再根据三个表建立对应实体(简单实体)</p><p>3.添加数据库操作类(写的并不完善 仅测试使用)</p><p>package com.servlet;</p><p>import java.sql.*;</p><p>/**</p><ul><li><p>Created by zj on 2017/4/11.<br>*/<br>public class DBUtil {</p><p> //获取数据库连接<br> private static Connection getConnection() {</p><pre><code> try {     Class.forName(&quot;com.mysql.jdbc.Driver&quot;);     Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/test&quot;, &quot;root&quot;, &quot;fangshuoit&quot;);     return connection; } catch (ClassNotFoundException | SQLException e) {     e.printStackTrace(); } return null;</code></pre><p> }</p><p> /**</p><ul><li>通过用户名获取用户信息<br>*</li><li>@param name</li><li>@return</li><li><p>@throws SQLException<br><em>/<br>public static User getByUserName(String name) throws SQLException {<br> String sql = “select </em> from ay_user where loginName = ?”;</p><p> PreparedStatement preparedStatement = getConnection().prepareStatement(sql);<br> preparedStatement.setString(1, name);</p><p> ResultSet resultSet = preparedStatement.executeQuery();<br> if (resultSet.next()) {</p><pre><code> return new User(resultSet.getInt(&quot;id&quot;), resultSet.getString(&quot;loginName&quot;), resultSet.getString(&quot;password&quot;));</code></pre><p> }</p><p> return null;<br>}</p><p>/**</p></li><li>通过用户名获取用户角色<br>*</li><li>@param name</li><li>@return</li><li><p>@throws SQLException<br>*/<br>public static Role getRolesByUserName(String name) throws SQLException {<br> String sql = “select roleId from ay_user where loginName = ?”;</p><p> PreparedStatement preparedStatement = getConnection().prepareStatement(sql);<br> preparedStatement.setString(1, name);</p><p> ResultSet resultSet = preparedStatement.executeQuery();<br> if (resultSet.next()) {</p><pre><code> Integer id = resultSet.getInt(&quot;roleId&quot;); sql = &quot;select * from ay_role where id = ?&quot;; preparedStatement = getConnection().prepareStatement(sql); preparedStatement.setInt(1, id); resultSet = preparedStatement.executeQuery(); if (resultSet.next()) {     return new Role(resultSet.getInt(&quot;id&quot;), resultSet.getString(&quot;name&quot;)); }</code></pre><p> }</p><p> return null;<br>}</p><p>/**</p></li><li>通过角色id获取角色权限<br>*</li><li>@param roleId</li><li>@return</li><li><p>@throws SQLException<br><em>/<br>public static Perms getPermsByRole(Integer roleId) throws SQLException {<br> String sql = “select </em> from ay_perms where roleId = ?”;</p><p> PreparedStatement preparedStatement = getConnection().prepareStatement(sql);<br> preparedStatement.setInt(1, roleId);</p><p> ResultSet resultSet = preparedStatement.executeQuery();<br> if (resultSet.next()) {</p><pre><code> return new Perms(resultSet.getInt(&quot;id&quot;), resultSet.getString(&quot;name&quot;), resultSet.getInt(&quot;roleId&quot;));</code></pre><p> }</p><p> return null;<br>}<br>}<br>3.编写自定义的Realm类 需要AuthorizingRealm类并实现两个方法; 第一个是用来身份验证,第二是用来角色权限验证</p></li></ul></li></ul><p>public class MyRealm extends AuthorizingRealm {</p><pre><code>/** * 验证当前登录的用户(身份认证), 不再需要在配置文件中配置用户的信息和其角色信息 *  * @param token 封装有用户的信息 * @return * @throws AuthenticationException */@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {    String userName = (String) token.getPrincipal();    System.out.println(&quot;要登录的用户 : &quot; + userName);    try {        User user = DBUtil.getByUserName(userName);//这里只是通过用户名验证并获取用户信息,实际开发中需要用户名以及加密的密码        if (user != null) {            return new SimpleAuthenticationInfo(user.getLoginName(), user.getPassword(), &quot;XX&quot;);//返回登录信息        } else            return null;    } catch (SQLException e) {        e.printStackTrace();    }    return null;}/**( 身份验证(登录)以后 ) * 为当前用户授予角色和权限(根据登录的用户名,读取数据库中其角色和权限) * * @param principals 封装了身份信息 * @return */@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {    String userName = (String) principals.getPrimaryPrincipal();    System.out.println(&quot;要权限的用户 : &quot; + userName);    SimpleAuthorizationInfo authenticationInfo = new SimpleAuthorizationInfo();    try {        Role role = DBUtil.getRolesByUserName(userName);        if (null != role) {            Set&lt;String&gt; set = new HashSet&lt;&gt;();            System.out.println(&quot;获得的角色: &quot;+ role.getName());            set.add(role.getName());            authenticationInfo.setRoles(set);//赋予角色            Perms perms = DBUtil.getPermsByRole(role.getId());            Set&lt;String&gt; set2 = new HashSet&lt;&gt;();            set2.add(perms.getName());            System.out.println(&quot;获得的权限: &quot;+ perms.getName());            authenticationInfo.setStringPermissions(set2);//赋予权限            return authenticationInfo;        }    } catch (SQLException e) {    }    return null;}</code></pre><p>}<br>4.修改配置文件shiro.ini ,引入自定义Realms,并去掉原来的 [users]和[roles]下的配置</p><p>[main]<br>authc.loginUrl=/login<br>perms.unauthorizedUrl=/noAuth.jsp<br>roles.unauthorizedUrl=/noAuth.jsp</p><p>myRealm=com.servlet.MyRealm<br>securityManager.realms=$myRealm<br>[urls]<br>/login=anon<br>/home=authc<br>/admin=roles[admin]<br>1.myRealm指向自定义Realm的位置</p><p>2.securityManager.realms指向自定义Realm的引用(表明使用自定义Realms进行安全认证),可以指向多个,用”,”隔开</p><p>5.启动项目测试 发现:使用zj2626登录可以访问 /admin地址;而ay2626登录不能访问(没有user角色);而且每次请求都会进行认证(控制台打印信息)</p><p>Shiro</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Servlet的生命周期</title>
      <link href="/2018/12/04/lao-bo-ke/servlet-de-sheng-ming-zhou-qi/"/>
      <url>/2018/12/04/lao-bo-ke/servlet-de-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<p>12.Servlet的生命周期<br>1)加载：在下列时刻加载 Servlet：<br>（1）如果已配置自动加载选项，则在启动服务器时自动加载 (web.xml中        设置<load-on-start>)；<br>（2）在服务器启动后，客户机首次向 Servlet 发出请求时;<br>（3）重新加载 Servlet 时（只执行一次）</load-on-start></p><p>2)实例化：加载 Servlet 后，服务器创建一个 Servlet 实例。（只执行一次）</p><p>3)初始化：调用 Servlet 的 init() 方法。在初始化阶段，Servlet 初始化参数被传递给 Servlet 配置对象ServletConfig。 （只执行一次）[因此Servlet是单例的，线程不安全的]</p><p>4)请求处理：对于到达服务器的客户机请求，服务器创建针对此次请求的一个“请求”对象和一个“响应”对象。服务器调用 Servlet 的 service() 方法，该方法用于传递“请求”和“响应”对象。service() 方法从“请求”对象获得请求信息、处理该请求并用“响应”对象的方法以将响应传回客户机。service() 方法可以调用其它方法来处理请求，例如 doGet()、doPost() 或其它的方法。（每次请求都执行该步骤）</p><p>5)销毁：当服务器不再需要 Servlet, 或重新装入 Servlet 的新实例时，服务器会调用 Servlet 的 destroy() 方法。（只执行一次）</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Request的包装类HttpServletRequestWrapper的使用</title>
      <link href="/2018/12/04/lao-bo-ke/request-de-bao-zhuang-lei-httpservletrequestwrapper-de-shi-yong/"/>
      <url>/2018/12/04/lao-bo-ke/request-de-bao-zhuang-lei-httpservletrequestwrapper-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>在使用zuul进行鉴权的时候，我们希望从请求Request中获取输入流，解析里面的内容，奈何InputStream只能被读取一次。为啥呢？源码里是这样说的：</p><blockquote><p>public int read(byte[] b,int off, int len)<br>　　　Reads up to len bytes of data into an array of bytes from this input stream. Ifpos equals count, then -1 is  returned to indicate     end of file. Otherwise, the number k of bytes read is equal to the smaller of len and count-pos.If k is positive, then bytes buf[pos] through buf[pos+k-1] are copied into b[off] through b[off+k-1] in the manner performed by System.arraycopy. The value k is added into pos and k is returned.<br>　　　<br>      大致的意思是：在InputStream读取的时候，会有一个pos指针，它指示每次读取之后下一次要读取的起始位置。在每次读取后会更新pos的值，当你下次再来读取的时候是从pos的位置开始的，而不是从头开始，所以第二次获取String中的值的时候是不全的，API中提供了一个解决办法：reset()。但我发现在inputStream和servlet中根本不起作用。提示 mark/reset not supported 。意思是只有重写过markSupported()方法的IO流才可以用。所以一般我们使用inputStream，最好在一次内处理完所有逻辑。</p></blockquote><p>那么就没法在中途获取请求流中的数据么？当然有办法了，我可是PPZ，只需要重写Request缓存一下流中的数据就好了，实现代码如下：</p><pre><code>BodyReaderHttpServletRequestWrapper.javapackage com.neo.authUtils;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.nio.charset.Charset;import java.util.Enumeration;import java.util.NoSuchElementException;import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;  public class BodyReaderHttpServletRequestWrapper extends          HttpServletRequestWrapper {     // private final byte[] body;       -----》private byte[] body;《-------     public BodyReaderHttpServletRequestWrapper(HttpServletRequest request) throws IOException {          super(request);          System.out.println(&quot;-------------------打印请求的头信息------------------------------&quot;);            Enumeration&lt;?&gt; e = request.getHeaderNames()   ;             while(e.hasMoreElements()){                 String name = (String) e.nextElement();                 String value = request.getHeader(name);                // System.out.println(name+&quot; = &quot;+value);             }         -----》获取流中的数据缓存到字节数组中，以后要读数据就用这里的《------        body = HttpHelper.getBodyString(request).getBytes(Charset.forName(&quot;UTF-8&quot;));      }    /**     * 从请求的头部获取用户的身份识别id;     * @param request     * @return     */    public String getJsessionidFromHeader(HttpServletRequest request) {        String jsessionid = null;//识别用户身份的id;        Enumeration&lt;?&gt; e = request.getHeaderNames()   ;            while(e.hasMoreElements()){                String name = (String) e.nextElement();                String value = request.getHeader(name);            //cookie = JSESSIONID=B926F6024438D4C693A5E5881595160C; SESSION=458e80dc-e354-4af3-a501-74504a873e70            if(&quot;cookie&quot;.equals(name)) {                jsessionid = value.split(&quot;;&quot;)[0].split(&quot;=&quot;)[1];            }            System.out.println(name+&quot;=&quot;+value);        }       // System.out.println(&quot;======jsessionid========&gt;&quot;+jsessionid);        return jsessionid;    }    @Override      public BufferedReader getReader() throws IOException {          return new BufferedReader(new InputStreamReader(getInputStream()));      }      @Override      public ServletInputStream getInputStream() throws IOException {           ------》从缓存的数据中读取数据《------        final ByteArrayInputStream bais = new ByteArrayInputStream(body);          return new ServletInputStream() {              public int read() throws IOException {                  return bais.read();              }            @Override            public boolean isFinished() {                // TODO Auto-generated method stub                return false;            }            @Override            public boolean isReady() {                // TODO Auto-generated method stub                return false;            }            @Override            public void setReadListener(ReadListener listener) {                // TODO Auto-generated method stub            }          };      }      @Override      public String getHeader(String name) {          return super.getHeader(name);      }      @Override      public Enumeration&lt;String&gt; getHeaderNames() {          return super.getHeaderNames();      }     /* @Override      public Enumeration&lt;String&gt; getHeaders(String name) {          return super.getHeaders(name);      }  */    /**     * content-type=text/plain;charset=UTF-8     * 重写getHeaders方法，实现自定义Content-Type;     */    @Override      public Enumeration&lt;String&gt; getHeaders(String name) {          if ((null != name &amp;&amp; name.equals(&quot;Content-Type&quot;))||(null != name &amp;&amp; name.equals(&quot;content-type&quot;))) {              return new Enumeration&lt;String&gt;() {                  private boolean hasGetted = false;                  @Override                  public String nextElement() {                      if (hasGetted) {                          throw new NoSuchElementException();                      } else {                          hasGetted = true;                        return &quot;application/json;charset=utf-8&quot;;                      }                  }                  @Override                  public boolean hasMoreElements() {                      return !hasGetted;                  }              };          }          return super.getHeaders(name);      }      /**     * 添加自定义信息到请求体;     * @param customMsg：自定义的添加到请求体中的信息;     */    public void appendCustomMsgToReqBody(String customMsg) {        String oldBodyString = HttpHelper.getBodyString(this);//oldBodyString一定是通过当前对象的输入流解析得来的，否则接收时会报EOFException；        String appendMsg = HttpHelper.appendCustomMsgToReqBody(customMsg);        String requestBodyAfterAppend = appendMsg + &quot;,&quot; +oldBodyString;        //this.body = HttpHelper.appendCustomMsgToReqBody(HttpHelper.appendCustomMsgToReqBody(customMsg)+(HttpHelper.getBodyString(this))).getBytes(Charset.forName(&quot;UTF-8&quot;));        //this.body = HttpHelper.appendCustomMsgToReqBody((HttpHelper.getBodyString(this))).getBytes(Charset.forName(&quot;UTF-8&quot;));        this.body = HttpHelper.appendCustomMsgToReqBody(requestBodyAfterAppend).getBytes(Charset.forName(&quot;UTF-8&quot;));    } }  HttpHelper.javapackage com.neo.authUtils;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import javax.servlet.ServletRequest;public class HttpHelper {    /**     * 获取post请求中的Body     *     * @param request     * @return     */    public static String getBodyString(ServletRequest request) {        StringBuilder sb = new StringBuilder();        InputStream inputStream = null;        BufferedReader reader = null;        try {            inputStream = request.getInputStream();            //读取流并将流写出去,避免数据流中断;            reader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName(&quot;UTF-8&quot;)));            String line = &quot;&quot;;            while ((line = reader.readLine()) != null) {                sb.append(line);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            if (inputStream != null) {                try {                    inputStream.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (reader != null) {                try {                    reader.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return sb.toString();    }    //添加自定义的信息到请求体中;    public static String appendCustomMsgToReqBody(String newReqBodyStr) {        StringBuilder sb = new StringBuilder();        InputStream inputStream = null;        BufferedReader reader = null;        String newReqBody = null;        try {            //通过字符串构造输入流;            inputStream = String2InputStream(newReqBodyStr);            reader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName(&quot;UTF-8&quot;)));            String line = &quot;&quot;;            while ((line = reader.readLine()) != null) {                sb.append(line);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            if (inputStream != null) {                try {                    inputStream.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (reader != null) {                try {                    reader.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        //返回字符串;        newReqBody = sb.toString();        return newReqBody;    }    //将字符串转化为输入流;    public static InputStream String2InputStream(String str) {        ByteArrayInputStream stream = null;        try {            stream = new ByteArrayInputStream(str.getBytes(&quot;UTF-8&quot;));        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }        return stream;    }}</code></pre><p>上述方案解决了使用request.getInpuStream()方法读取流中的数据只能读取一次的问题，其实当我们在使用第三方接口时，如果请求头信息和我们的服务所需不一致，例如第三方接口中头部信息为：content-type=text/plain;charset=UTF-8<br>而我们需要的是：”application/json;charset=utf-8”时，我们也是可以通过重写对应的方法对请求的头部信息进行修改的，代码如下：</p><pre><code>/**     * content-type=text/plain;charset=UTF-8     * 重写getHeaders方法，实现自定义Content-Type;     */    @Override      public Enumeration&lt;String&gt; getHeaders(String name) {          if ((null != name &amp;&amp; name.equals(&quot;Content-Type&quot;))||(null != name &amp;&amp; name.equals(&quot;content-type&quot;))) {              return new Enumeration&lt;String&gt;() {                  private boolean hasGetted = false;                  @Override                  public String nextElement() {                      if (hasGetted) {                          throw new NoSuchElementException();                      } else {                          hasGetted = true;                        return &quot;application/json;charset=utf-8&quot;;                      }                  }                  @Override                  public boolean hasMoreElements() {                      return !hasGetted;                  }              };          }          return super.getHeaders(name);      }  </code></pre><p>当我们在后端设置了头部信息后，如果不出意外，前端发送的请求将变为简单请求，这样，服务器的处理机制将简单很多。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>reflux中一个小error[error-linstenner is no a function]总结</title>
      <link href="/2018/12/04/lao-bo-ke/reflux-zhong-yi-ge-xiao-error-error-linstenner-is-no-a-function-zong-jie/"/>
      <url>/2018/12/04/lao-bo-ke/reflux-zhong-yi-ge-xiao-error-error-linstenner-is-no-a-function-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>最近在使用reflux的时候，我想为事件监听的callback函数添加参数，如下所示:</p><pre><code>1、ContentStore.removeChangeListener(CHANGE_EVENT_BATCH_DEL_ATTENCE_DETAIL, this.receptBatchDelData(param));2、ContentStore.removeChangeListener(CHANGE_EVENT_BATCH_DEL_ATTENCE_DETAIL, this.receptBatchDelData.bind(this,param));</code></pre><p>但是，事实证明，这样是不行的，这样写将会报：</p><pre><code>error:listenner is not a function</code></pre><p>的错误。<br>3、解决方案<br>老老实实使用flux推荐的方式ContentStore.removeChangeListener(CHANGE_EVENT_BATCH_DEL_ATTENCE_DETAIL, this.receptBatchDelData);不进行参数的传递，真需要参数的话在回调函数内部用常量解决【常量代替参数】。<br>4、原因【个人理解】<br>flux的回调函数本来就是为了从store【数据中心】中回调数据的，在监听器的回调函数中添加参数是没有必要的。真需要参数的话，可以通过回调函数内部的目标函数的调用并传参解决。<br>如下：</p><pre><code>callback(){target(parm);}</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>学习reflux的总结</title>
      <link href="/2018/12/04/lao-bo-ke/reflux-de-xue-xi-zong-jie/"/>
      <url>/2018/12/04/lao-bo-ke/reflux-de-xue-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>最近学习reflux,总结一下，方便以后回顾.<br><a href="https://www.cnblogs.com/lovesueee/p/4893218.html" target="_blank" rel="noopener">参考资料,我觉得这个是极品，但是demo无法正常运行.</a><br>1.reflux的原理:<br>   1.1reflux是对flux架构的实现[flux相当于java中的架构/思想]；<br>   1.2reflux中的数据流是单向的;<br>2.reflux和flux的重点区别:<br>  2.1flux中的action是一个标准的信息载体【dataer】，并不具备publisher的功能；<br>  2.2flux中的action是一个publisher，并具备信息载体的功能;<br>  2.3reflux中的action被发送出去之后，只有订阅【监听了】了action的store中的回调函数才会被调用；<br>  2.4flux中档action被发送后，所有注册在dispatcher上的回调函数都将被触发、调用我们通过action中type进行switch后才能进行指定的操作，执行效率较低;<br>3.reflux的demo:</p><pre><code>action【action.js】action中定义了组件的行，同时reflux中的action作为publisher存在，当action被触发【执行：action.actionName();】时将自动转发action[一般携带着数据]到订阅了[监听]该action的store中，该store中的onActionName()回调函数将会被调用;----------var Reflux = require(&#39;reflux&#39;);var WorkLogActions = Reflux.createActions([    &#39;createHrWorkLog&#39;,    &#39;deleteHrWorkLog&#39;,    &#39;updateHrWorkLog&#39;,    &#39;retrieveHrWorkLog&#39;,    &#39;retrieveHrWorkLogPage&#39;,    &#39;initHrWorkLog&#39;,    &#39;retrieveEmpWorkLog&#39;,    &#39;retrieveEmpLoyee&#39;,    &#39;getCacheData&#39;]);module.exports = WorkLogActions;</code></pre><pre><code>store【WorkLogStore.js】reflux中store作为publisher和subscriber存在，当接收到action后，将执行对应的onActionName()回调函数，并执行this.fireEvent(&#39;retrieve&#39;, &#39;&#39;, this);或者storeA.trigger(3)发送事件和数据。当组件监听到后将执行监听回调函数，更新state从而驱动UI的更新;----------﻿var Reflux = require(&#39;reflux&#39;);var WorkLogActions = require(&#39;../action/WorkLogActions&#39;);var Utils = require(&#39;../../../public/script/utils&#39;);var MsgActions = require(&#39;../../../lib/action/MsgActions&#39;);var WorkLogStore = Reflux.createStore({    listenables: [WorkLogActions],    filter: {},    recordSet: [],    startPage : 0,    pageRow : 0,    totalRow : 0,    init: function() {    },    getServiceUrl: function(action)    {        return Utils.hrUrl+action;    },    fireEvent: function(operation, errMsg, self)    {        self.trigger({            filter: self.filter,            recordSet: self.recordSet,            startPage: self.startPage,            pageRow: self.pageRow,            totalRow: self.totalRow,            operation: operation,            errMsg: errMsg        });        MsgActions.showError(&#39;hr_work_log&#39;, operation, errMsg);    },    onGetCacheData: function() {        this.fireEvent(&#39;cache&#39;, &#39;&#39;, this);    },    onRetrieveHrWorkLog: function(filter) {        var self = this;        var url = this.getServiceUrl(&#39;hr_work_log/retrieve&#39;);        Utils.doRetrieveService(url, filter, self.startPage, self.pageRow, self.totalRow).then(function(result) {            if(result.errCode==null || result.errCode==&#39;&#39; || result.errCode==&#39;000000&#39;){                self.recordSet = result.object.list;                self.startPage = result.object.startPage;                self.pageRow = result.object.pageRow;                self.totalRow = result.object.totalRow;                self.filter = filter;                self.fireEvent(&#39;retrieve&#39;, &#39;&#39;, self);            }            else{                self.fireEvent(&#39;retrieve&#39;, &quot;处理错误[&quot;+result.errCode+&quot;][&quot;+result.errDesc+&quot;]&quot;, self);            }        }, function(value){            self.fireEvent(&#39;retrieve&#39;, &quot;调用服务错误&quot;, self);        });    },    onRetrieveHrWorkLogPage: function(filter, startPage, pageRow) {        this.startPage = startPage;        this.pageRow = pageRow;        this.onRetrieveHrWorkLog( filter );    },    onInitHrWorkLog: function(filter) {        if( this.recordSet.length &gt; 0 ){            if( Utils.compareTo(this.filter, filter) ){                this.fireEvent(&#39;retrieve&#39;, &#39;&#39;, this);                return;            }        }        this.onRetrieveHrWorkLog(filter);    },    onCreateHrWorkLog: function(workLog) {        var self = this;        var data = workLog;        var url = this.getServiceUrl(&#39;hr_work_log/create&#39;);        Utils.doCreateService(url, data).then(function(result) {            if(result.errCode==null || result.errCode==&#39;&#39; || result.errCode==&#39;000000&#39;){                result.object.perName = data.perName;                result.object.staffCode = data.staffCode;                result.object.deptName = data.deptName;                self.recordSet.push(result.object);                self.totalRow = self.totalRow + 1;                self.fireEvent(&#39;create&#39;, &#39;&#39;, self);            }            else{                self.fireEvent(&#39;create&#39;, &quot;处理错误[&quot;+result.errCode+&quot;][&quot;+result.errDesc+&quot;]&quot;, self);            }        }, function(value){            self.fireEvent(&#39;create&#39;, &quot;调用服务错误&quot;, self);        });    },    onUpdateHrWorkLog: function(workLog) {        var url = this.getServiceUrl(&#39;hr_work_log/update&#39;);        Utils.recordUpdate(this, workLog, url);    },    onDeleteHrWorkLog: function(uuid) {        var url = this.getServiceUrl(&#39;hr_work_log/remove&#39;);        Utils.recordDelete(this, uuid, url);    }});module.exports = WorkLogStore;</code></pre><pre><code>component【WorkLogPage.js】component中监听store中发送的事件并更新state，驱动UI的更新----------﻿&#39;use strict&#39;;import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import ReactMixin from &#39;react-mixin&#39;;var Reflux = require(&#39;reflux&#39;);import { Button, Table, Icon, Modal, Input } from &#39;antd&#39;;const Search = Input.Search;import ServiceMsg from &#39;../../lib/Components/ServiceMsg&#39;;import DimissTodoPage from &#39;./Components/DimissTodoPage&#39;;var Common = require(&#39;../../public/script/common&#39;);var Utils = require(&#39;../../public/script/utils&#39;);var WorkLogStore = require(&#39;./data/WorkLogStore.js&#39;);var WorkLogActions = require(&#39;./action/WorkLogActions&#39;);import WorkLogFilter from &#39;./Components/WorkLogFilter&#39;;import CreateWorkLogPage from &#39;./Components/CreateWorkLogPage&#39;;import UpdateWorkLogPage from &#39;./Components/UpdateWorkLogPage&#39;;import DetailsWorkLogPage from &#39;./Components/DetailsWorkLogPage&#39;;var pageRows = 10;var WorkLogPage = React.createClass({    getInitialState: function () {        return {            workLogSet: {                recordSet: [],                startPage: 1,                pageRow: 10,                totalRow: 0,                operation: &#39;&#39;,                errMsg: &#39;&#39;            },            action: &#39;query&#39;,            workLog: null,            loading: false,            moreFilter: false,            filterValue: &#39;&#39;,            filter: {},        }    },    mixins: [Reflux.listenTo(WorkLogStore, &quot;onServiceComplete&quot;)],    onServiceComplete: function (data) {        if (data.operation === &#39;cache&#39;) {            var ff = data.filter.staffCode;            if (ff === null || typeof (ff) === &#39;undefined&#39; || ff === &#39;&#39;) {                ff = data.filter.perName;                if (ff === null || typeof (ff) === &#39;undefined&#39;) {                    ff = &#39;&#39;;                }            }            this.state.filterValue = ff;            this.state.filter = data.filter;            this.state.moreFilter = (data.filter.more === &#39;1&#39;);            if (this.state.moreFilter) {                var mp = this.refs.WorkLogFilter;                if (mp !== null &amp;&amp; typeof (mp) !== &#39;undefined&#39;) {                    mp.state.workLog = this.state.filter;                }            }        }        this.setState({            loading: false,            workLogSet: data        });    },    // 第一次加载    componentDidMount: function () {        WorkLogActions.getCacheData();    },    handleQueryClick: function () {        this.setState({ loading: true });        this.state.filter.status = &#39;1&#39;;        this.state.filter.corpUuid = window.loginData.compUser.corpUuid;        this.state.filter.more = (this.state.moreFilter ? &#39;1&#39; : &#39;0&#39;);        WorkLogActions.retrieveHrWorkLogPage(this.state.filter, this.state.workLogSet.startPage, pageRows);    },    showMoreFilter: function (event) {        this.setState({ moreFilter: !this.state.moreFilter });    },    onChangePage: function (pageNumber) {        this.state.workLogSet.startPage = pageNumber;        this.handleQueryClick();    },    onShowSizeChange: function (current, pageSize) {        pageRows = pageSize;        this.handleQueryClick();    },    onChangeFilter: function (e) {        this.setState({ filterValue: e.target.value });    },    onSearch: function (e) {        this.state.filter = {};        var filterValue = this.state.filterValue;        if (Common.isIncNumber(filterValue)) {            this.state.filter.staffCode = filterValue;        }        else {            this.state.filter.perName = filterValue;        }        this.handleQueryClick();    },    onMoreSearch: function () {        this.state.filter = this.refs.WorkLogFilter.state.workLog;        this.handleQueryClick();    },    onClickDelete: function (workLog, event) {        Modal.confirm({            title: &#39;删除确认&#39;,            content: &#39;是否删除选中的工作日志&#39;,            okText: &#39;确定&#39;,            cancelText: &#39;取消&#39;,            onOk: this.onClickDelete2.bind(this, workLog)        });    },    onClickDelete2: function (workLog) {        this.setState({ loading: true });        this.state.workLogSet.operation = &#39;&#39;;        WorkLogActions.deleteHrWorkLog(workLog.uuid);    },    handleCreate: function (e) {        this.setState({ action: &#39;create&#39; });    },    onClickDetails: function (workLog, event) {        this.setState({ workLog: workLog, action: &#39;detail&#39; });    },    onClickUpdate: function (workLog, event) {        this.setState({ workLog: workLog, action: &#39;update&#39; });    },    onGoBack: function (workLog) {        this.setState({ action: &#39;query&#39; });        // 离职后处理        if (workLog) {            var chgType = workLog.chgType;            if (chgType === &#39;离职&#39; || chgType === &#39;辞退&#39; || chgType === &#39;开除&#39;) {                this.refs.nextWindow.toggle();                this.refs.nextWindow.initStaff(workLog);            }        }    },    render: function () {        const columns = [            {                title: &#39;员工编号&#39;,                dataIndex: &#39;staffCode&#39;,                key: &#39;staffCode&#39;,                width: 140,            },            {                title: &#39;姓名&#39;,                dataIndex: &#39;perName&#39;,                key: &#39;perName&#39;,                width: 140,            },            {                title: &#39;变更类型&#39;,                dataIndex: &#39;chgType&#39;,                key: &#39;chgType&#39;,                width: 140,                render: (text, record) =&gt; (Utils.getOptionName(&#39;HR系统&#39;, &#39;工作变更类型&#39;, record.chgType, false, this)),            },            {                title: &#39;部门名称&#39;,                dataIndex: &#39;deptName&#39;,                key: &#39;deptName&#39;,                width: 140,            },            {                title: &#39;调前说明&#39;,                dataIndex: &#39;befMemo&#39;,                key: &#39;befMemo&#39;,                width: 140,            },            {                title: &#39;调后说明&#39;,                dataIndex: &#39;aftMemo&#39;,                key: &#39;aftMemo&#39;,                width: 140,            },            {                title: &#39;生效日期&#39;,                dataIndex: &#39;effectDate&#39;,                key: &#39;effectDate&#39;,                width: 140,                render: (text, record) =&gt; (Common.formatDate(text, Common.dateFormat)),            },            {                title: &#39;更多操作&#39;,                key: &#39;action&#39;,                width: 70,                render: (text, record) =&gt; (                    &lt;span&gt;                        &lt;a href=&quot;#&quot; onClick={this.onClickDetails.bind(this, record)} title=&#39;详情&#39;&gt;&lt;Icon type=&#39;bars&#39; /&gt;&lt;/a&gt;                    &lt;/span&gt;                ),            }        ];        /*                        &lt;a href=&quot;#&quot; onClick={this.onClickUpdate.bind(this, record)} title=&#39;修改工作&#39;&gt;&lt;Icon type={Common.iconUpdate} /&gt;&lt;/a&gt;                        &lt;span className=&quot;ant-divider&quot; /&gt;                    &lt;a href=&quot;#&quot; onClick={this.onClickDelete.bind(this, record)} title=&#39;删除工作&#39;&gt;&lt;Icon type={Common.iconRemove}/&gt;&lt;/a&gt;                    &lt;span className=&quot;ant-divider&quot; /&gt;        */        var recordSet = this.state.workLogSet.recordSet;        var moreFilter = this.state.moreFilter;        var visible = (this.state.action === &#39;query&#39;) ? &#39;&#39; : &#39;none&#39;;        var pag = {            showQuickJumper: true, total: this.state.workLogSet.totalRow, pageSize: this.state.workLogSet.pageRow,            current: this.state.workLogSet.startPage, size: &#39;large&#39;, showSizeChanger: true, onShowSizeChange: this.onShowSizeChange, onChange: this.onChangePage        };        var contactTable =            &lt;div className=&#39;grid-page&#39; style={{ overflow: 'hidden', display: visible }}&gt;                &lt;div style={{ padding: '8px 0 0 0', height: '100%', width: '100%', overflowY: 'auto' }}&gt;                    &lt;ServiceMsg ref=&#39;mxgBox&#39; svcList={[&#39;hr_work_log/retrieve&#39;, &#39;hr_work_log/remove&#39;]} /&gt;                    &lt;WorkLogFilter ref=&quot;WorkLogFilter&quot; moreFilter={moreFilter} /&gt;                    &lt;div style={{ margin: '8px 0 0 0' }}&gt;                        &lt;div className=&#39;toolbar-table&#39;&gt;                            &lt;div style={{ float: 'left' }}&gt;                                &lt;Button icon={Common.iconAdd} type=&quot;primary&quot; title=&quot;增加工作变更信息&quot; onClick={this.handleCreate} /&gt;                                &lt;Button icon={Common.iconRefresh} title=&quot;刷新数据&quot; onClick={this.handleQueryClick} style={{ marginLeft: '4px' }} /&gt;                            &lt;/div&gt;                            {                                moreFilter ?                                    &lt;div style={{ textAlign: 'right', width: '100%' }}&gt;                                        &lt;Button title=&quot;查询&quot; onClick={this.onMoreSearch} loading={this.state.loading} style={{ marginRight: '5px' }}&gt;查询&lt;/Button&gt;                                        &lt;Button title=&quot;快速条件&quot; onClick={this.showMoreFilter}&gt;快速条件&lt;/Button&gt;                                    &lt;/div&gt; :                                    &lt;div style={{ textAlign: 'right', width: '100%' }}&gt;                                        &lt;Search placeholder=&quot;查询(员工编号/员工姓名)&quot; style={{ width: Common.searchWidth }} value={this.state.filterValue} onChange={this.onChangeFilter} onSearch={this.onSearch} /&gt;                                        &lt;Button title=&quot;更多条件&quot; onClick={this.showMoreFilter} style={{ marginLeft: '8px' }}&gt;更多条件&lt;/Button&gt;                                    &lt;/div&gt;                            }                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div style={{ width: '100%', padding: '0 18px 8px 20px' }}&gt;                        &lt;Table columns={columns} dataSource={recordSet} rowKey={record =&gt; record.uuid} loading={this.state.loading} pagination={pag} size=&quot;middle&quot; bordered={Common.tableBorder} /&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;;        var page = null;        if (this.state.action === &#39;create&#39;) {            page = &lt;CreateWorkLogPage ref=&#39;createPage&#39; onBack={this.onGoBack} /&gt;;        }        else if (this.state.action === &#39;detail&#39;) {            page = &lt;DetailsWorkLogPage onBack={this.onGoBack} userUuid={this.state.workLog.userUuid} /&gt;        }        else if (this.state.action === &#39;update&#39;) {            page = &lt;UpdateWorkLogPage onBack={this.onGoBack} workLog={this.state.workLog} /&gt;        }        return (            &lt;div style={{ width: '100%', height: '100%' }}&gt;                {contactTable}                {page}                &lt;DimissTodoPage ref=&quot;nextWindow&quot; /&gt;            &lt;/div&gt;        );    }});module.exports = WorkLogPage;</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>redis启动出错</title>
      <link href="/2018/12/04/lao-bo-ke/redis-qi-dong-chu-cuo-creating-server-tcp-listening-socket-127.0.0.1-6379-bind-no-error/"/>
      <url>/2018/12/04/lao-bo-ke/redis-qi-dong-chu-cuo-creating-server-tcp-listening-socket-127.0.0.1-6379-bind-no-error/</url>
      
        <content type="html"><![CDATA[<pre><code>   windows下安装redis第一次启动报错：</code></pre><p>[2368] 21 Apr 02:57:05.611 # Creating Server TCP listening socket 127.0.0.1:6379: bind: No error</p><p>解决方法：在命令行中运行</p><pre><code>redis-cli.exe//如果设置了密码,则此处需要先输入认证即密码:127.0.0.1:6379&gt;auth yourpassword127.0.0.1:6379&gt;shutdownnot connected&gt;exit</code></pre><p>然后重新运行redis-server.exe redis.windows.conf 【–maxmemory 200M】，启动成功！</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>redis集群批量删除指定的key</title>
      <link href="/2018/12/04/lao-bo-ke/redis-ji-qun-pi-liang-shan-chu-zhi-ding-de-key/"/>
      <url>/2018/12/04/lao-bo-ke/redis-ji-qun-pi-liang-shan-chu-zhi-ding-de-key/</url>
      
        <content type="html"><![CDATA[<p>工作中遇到一个问题,redis中存储了大量的key,而且没有设置时效,其中很大一部分后来都没用了,导致redis体积庞大,查询缓慢。服务器版本为windows,网上搜索到很多批量删除的方法都是Linux下的,几番寻找,终于找到了在windows下批量删除超大量key的方法。<br>   首先贴一下Linux下的方法:</p><pre><code> redis-cli keys&quot;*&quot; |xargs redis-cli del</code></pre><p>   //如果redis-cli没有设置成系统变量,需要指定redis-cli的完整路径,加入redis-cli的安装路径如下：<br>   <img src="http://ouuy81imh.bkt.clouddn.com/redis0120180702082947583.png" alt="这里写图片描述"><br>   那么在gitbash上模拟的linux命令则如下:</p><pre><code>./redis-cli keys &quot;*lz*&quot;|xargs ./redis-cli del</code></pre><p>原理就是通过xargs工具将前半部分的查询结果借助管道传递给后面的删除命令，进而实现循环删除，达到批量删除的结果。<br>But,测试的时候趣发现这条命令不好使,测试结果如下图所示，具体的原因不明:<br><img src="http://ouuy81imh.bkt.clouddn.com/redis02.png" alt="这里写图片描述"></p><hr><p>作为替代方案，我找到了windows、Linux下均试用的方法:<br>使用lua脚本:</p><pre><code>redis-cli eval &quot;redis.call(&#39;del&#39;, unpack(redis.call(&#39;keys&#39;,&#39;*&#39;)))&quot; 0</code></pre><p>但这种处理方式,量大的情况下,lua函数unpack会出现问题,会报错误</p><blockquote><p>(error) ERR Error running script (call to f_e177a091510d969af3b388ee986dbe6658df6b57): user_script:1: too many results to unpack</p></blockquote><p>解决方法:<br>一次性unpack太多会出问题,那就干脆一次5000吧,这样就不会有问题了,实测速度非常快哦。</p><pre><code>redis-cli eval &quot;local keys = redis.call(&#39;keys&#39;, ARGV[1]) for i=1,#keys,5000 do redis.call(&#39;del&#39;, unpack(keys, i, math.min(i+4999, #keys))) end return #keys&quot; 0 &#39;value*&#39;</code></pre><p>所以最终实现我的需求的代码就是：</p><pre><code>redis-cli eval &quot;redis.call(&#39;del&#39;, unpack(redis.call(&#39;keys&#39;,&#39;*lz*&#39;)))&quot; 0redis-cli eval &quot;local keys = redis.call(&#39;keys&#39;, ARGV[1]) for i=1,#keys,5000 do redis.call(&#39;del&#39;, unpack(keys, i, math.min(i+4999, #keys))) end return #keys&quot; 0 &#39;*lz*&#39;</code></pre><p>上述语句的执行原理其实是递归调用，通过递归最终实现了批量删除。</p><hr><p>在redis集群中可以借助脚本实现集群上的批量删除，这个还没测试过。参考文章如下:<br><a href="http://blog.51cto.com/ganbing/2050111" target="_blank" rel="noopener">redis集群批量删除指定的key</a></p><p>本文参考文章:<br><a href="https://www.aliyun.com/jiaocheng/874744.html" target="_blank" rel="noopener">redis批量删除key （windows适用）</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>React组件生命周期小结</title>
      <link href="/2018/12/04/lao-bo-ke/react-zu-jian-sheng-ming-zhou-qi-xiao-jie/"/>
      <url>/2018/12/04/lao-bo-ke/react-zu-jian-sheng-ming-zhou-qi-xiao-jie/</url>
      
        <content type="html"><![CDATA[<hr><p><em>这篇博客是我在简书上看到的，写的实在是太好了，<a href="http://www.jianshu.com/p/4784216b8194" target="_blank" rel="noopener">这是原文地址</a>。</em><br>          </p><p><strong>下面所写的，只适合前端的React。（React也支持后端渲染，而且和前端有点小区别，不过我没用过。）</strong></p><p></p><p></p><h1>相关函数</h1><p></p><p></p><p>简单地说，React Component通过其定义的几个函数来控制组件在生命周期的各个阶段的动作。</p><p></p><p></p><p>在ES6中，一个React组件是用一个class来表示的（具体可以参考<a href="https://link.jianshu.com?t=http://facebook.github.io/react/docs/reusable-components.html#es6-classes" target="_blank" rel="nofollow">官方文档</a>），如下：</p><p></p><pre class="hljs undefined"><code>// 定义一个TodoList的React组件，通过继承React.Component来实现class TodoList extends React.Component {  ...}</code></pre><p>这几个生命周期相关的函数有：</p><pre class="hljs undefined"><code>constructor(props, context)</code></pre><p>构造函数，在创建组件的时候调用一次。</p><pre class="hljs undefined"><code>void componentWillMount()</code></pre><p>在组件挂载之前调用一次。如果在这个函数里面调用setState，本次的render函数可以看到更新后的state，并且只渲染一次。</p><pre class="hljs undefined"><code>void componentDidMount()</code></pre><p>在组件挂载之后调用一次。这个时候，子主键也都挂载好了，可以在这里使用refs。</p><pre class="hljs undefined"><code>void componentWillReceiveProps(nextProps)</code></pre><p>props是父组件传递给子组件的。父组件发生render的时候子组件就会调用componentWillReceiveProps（不管props有没有更新，也不管父子组件之间有没有数据交换）。</p><pre class="hljs undefined"><code>bool shouldComponentUpdate(nextProps, nextState)</code></pre><p>组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率。</p><pre class="hljs undefined"><code>void componentWillUpdate(nextProps, nextState)</code></pre><p>shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。</p><pre class="hljs undefined"><code>void componentDidUpdate()</code></pre><p>除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。</p><p>componentWillMount、componentDidMount和componentWillUpdate、componentDidUpdate可以对应起来。区别在于，前者只有在挂载的时候会被调用；而后者在以后的每次更新渲染之后都会被调用。</p><pre class="hljs undefined"><code>ReactElement render()</code></pre><p>render是一个React组件所必不可少的核心函数（上面的其它函数都不是必须的）。记住，不要在render里面修改state。</p><pre class="hljs undefined"><code>void componentWillUnmount()</code></pre><p>组件被卸载的时候调用。一般在componentDidMount里面注册的事件需要在这里删除。</p><h1>更新方式</h1><p>在react中，触发render的有4条路径。</p><p><strong>以下假设shouldComponentUpdate都是按照默认返回true的方式。</strong></p><ol><li>首次渲染Initial Render</li><li>调用this.setState （并不是一次setState会触发一次render，React可能会合并操作，再一次性进行render）</li><li>父组件发生更新（一般就是props发生改变，但是就算props没有改变或者父子组件之间没有数据交换也会触发render）</li><li>调用this.forceUpdate</li></ol><p></p><img src="http://img.blog.csdn.net/20171219130718397?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">React组件更新路径.png<p>注意，如果在shouldComponentUpdate里面返回false可以提前退出更新路径。</p><h1>一个React组件生命周期的测试例子</h1><p>代码比较简单，没有逻辑，只是在每个相关函数里面alert一下。<a href="https://link.jianshu.com?t=http://wximg.gtimg.com/shake_tv/test/lifeCycle2113.html" target="_blank" rel="nofollow">点击链接</a>来试试这个例子。<br>源码：</p><pre class="hljs undefined"><code>class LifeCycle extends React.Component {    constructor(props) {        super(props);        alert("Initial render");        alert("constructor");        this.state = {str: "hello"};    }    componentWillMount() {        alert("componentWillMount");    }    componentDidMount() {        alert("componentDidMount");    }    componentWillReceiveProps(nextProps) {        alert("componentWillReceiveProps");    }    shouldComponentUpdate() {        alert("shouldComponentUpdate");        return true;        // 记得要返回true    }    componentWillUpdate() {        alert("componentWillUpdate");    }    componentDidUpdate() {        alert("componentDidUpdate");    }    componentWillUnmount() {        alert("componentWillUnmount");    }    setTheState() {        let s = "hello";        if (this.state.str === s) {            s = "HELLO";        }        this.setState({            str: s        });    }    forceItUpdate() {        this.forceUpdate();    }    render() {        alert("render");        return(            &lt;div&gt;                &lt;span&gt;{"Props:"}&lt;h2&gt;{parseInt(this.props.num)}&lt;/h2&gt;&lt;/span&gt;                &lt;br /&gt;                &lt;span&gt;{"State:"}&lt;h2&gt;{this.state.str}&lt;/h2&gt;&lt;/span&gt;            &lt;/div&gt;        );    }}class Container  extends React.Component {    constructor(props) {        super(props);        this.state = {            num: Math.random() * 100        };    }    propsChange() {        this.setState({            num: Math.random() * 100        });    }    setLifeCycleState() {        this.refs.rLifeCycle.setTheState();    }    forceLifeCycleUpdate() {        this.refs.rLifeCycle.forceItUpdate();    }    unmountLifeCycle() {        // 这里卸载父组件也会导致卸载子组件        React.unmountComponentAtNode(document.getElementById("container"));    }    parentForceUpdate() {        this.forceUpdate();    }    render() {        return (            &lt;div&gt;                &lt;a href="javascript:;" className="weui_btn weui_btn_primary" onClick={this.propsChange.bind(this)}&gt;propsChange&lt;/a&gt;                &lt;a href="javascript:;" className="weui_btn weui_btn_primary" onClick={this.setLifeCycleState.bind(this)}&gt;setState&lt;/a&gt;                &lt;a href="javascript:;" className="weui_btn weui_btn_primary" onClick={this.forceLifeCycleUpdate.bind(this)}&gt;forceUpdate&lt;/a&gt;                &lt;a href="javascript:;" className="weui_btn weui_btn_primary" onClick={this.unmountLifeCycle.bind(this)}&gt;unmount&lt;/a&gt;                &lt;a href="javascript:;" className="weui_btn weui_btn_primary" onClick={this.parentForceUpdate.bind(this)}&gt;parentForceUpdateWithoutChange&lt;/a&gt;                &lt;LifeCycle ref="rLifeCycle" num={this.state.num}&gt;&lt;/LifeCycle&gt;            &lt;/div&gt;        );    }}ReactDom.render(    &lt;Container&gt;&lt;/Container&gt;,    document.getElementById('container'));</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>react中router底层原理结合参考资料的分析</title>
      <link href="/2018/12/04/lao-bo-ke/react-zhong-shen-ceng-yuan-li-jie-xi/"/>
      <url>/2018/12/04/lao-bo-ke/react-zhong-shen-ceng-yuan-li-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>本文为我对react中router底层原理结合参考资料的分析:<br>1.路由是什么<br>       个人理解:路由是访问各个组件的转发器;<br>        路由的分类：路由分为一级路由和嵌套路由了;<br>        路由的实现原理:<br>       由UI = reducer(stateorproperty);可知，路由的底层原理还是状态或者属性改变驱动的；<br>       可以理解为路由有一个location属性，通过浏览器可以改变Router的属性值，从而驱动属性进行渲染:<br>3.使用路由进行页面跳转会导致渲染效率的降低么?<br>答案是不会的，当通过嵌套路由<strong>首次</strong>       访问嵌套的组件的时候，被嵌套的子组件的父级组件也会进行加载渲染，此时父子组件的生命周期函数将被执行，但是首次访问但并未离开当前页面【顶级路由路径未改变的时候】，访问嵌套的其他组件的时候，会根据访问的路径加载指定的组件，此只会加载路径中体现变更部分的组件。<br>如下图所示:<br>1.首次访问的时候，路径匹配的组件的生命周期函数都将被执行[注意访问的路径是嵌套路由的路径]:<br><img src="http://img.blog.csdn.net/20171226225338246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>2.再次访问的时候，只会加载调用匹配路径中发生改变的部分的组件的生命周期函数:<br><img src="http://img.blog.csdn.net/20171226230012717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>3.（1.0）路由实际是一个组件，其中嵌套了所有的希望访问的可以访问的组件；<br>   （2.0）通过路由访问的知识路径匹配的组件;<br>    (3.0)当存在页面内无刷新内容变换的时候建议使用嵌套路由<br>  4.路由使用的小案例:</p><p>root.js</p><pre><code>import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import Index from &#39;./index&#39;;import ComponentList from &#39;./components/list&#39;;import ComponentDetails from &#39;./components/details&#39;;import ComponentDetails2 from &#39;./components/details2&#39;;import {Router,Route,hashHistory} from &#39;react-router&#39;;export default class Root extends React.Component{  render(){    return (      //这里替换了之前的 Index，变成了程序的入口      &lt;Router history={hashHistory}&gt;        &lt;Route component={Index} path=&quot;/&quot;&gt;          &lt;Route component={ComponentDetails} path=&quot;details&quot;&gt;&lt;/Route&gt;          &lt;Route component={ComponentDetails2} path=&quot;details2&quot;&gt;&lt;/Route&gt;        &lt;/Route&gt;        &lt;Route component={ComponentList} path=&quot;list/:id&quot;&gt;&lt;/Route&gt;      &lt;/Router&gt;    );  };}ReactDOM.render(&lt;Root/&gt;, document.getElementById(&#39;example&#39;));</code></pre><p>   index.js</p><pre><code>var React = require(&#39;react&#39;);var ReactDOM = require(&#39;react-dom&#39;);import ComponentHeader from &#39;./components/header&#39;;import ComponentFooter from &#39;./components/footer&#39;;import BodyIndex from &#39;./components/bodyindex&#39;;import &#39;antd/dist/antd.css&#39;;export default class Index extends React.Component {    constructor(props) {      super(props);      alert(&#39;父级组件中的构造函数被执行&#39;);  }    componentWillMount(){        //定义你的逻辑即可        alert(&#39;父级组件中的构造函数被执行&#39;);        console.log(&quot;Index - componentWillMount&quot;);    }    componentDidMount(){        console.log(&quot;Index - componentDidMount&quot;);    }    render() {        /*        var component;        if (用户已登录) {            component = &lt;ComponentLoginedHeader/&gt;        }        else{            component = &lt;ComponentHeader/&gt;        }        */        return (            &lt;div&gt;                &lt;ComponentHeader/&gt;                &lt;BodyIndex userid={999} username={&quot;Parry1&quot;}/&gt;                &lt;div&gt;                    {this.props.children}                &lt;/div&gt;                &lt;ComponentFooter/&gt;            &lt;/div&gt;        );    }}</code></pre><p>detail.js</p><pre><code>import React from &#39;react&#39;;export default class ComponentDetails extends React.Component{  constructor(props) {    super(props);    alert(&#39;子级组件中的构造函数被执行&#39;);  }  componentWillMount(){    //定义你的逻辑即可    alert(&#39;子级组件中的构造函数被执行&#39;);    console.log(&quot;ComponentDetails - componentWillMount&quot;);  }  render(){    return (      &lt;div&gt;        &lt;h2&gt;这里是嵌套在首页中的详细的页面，测试构造函数是否会被加载&lt;/h2&gt;      &lt;/div&gt;    );  };}</code></pre><p>detail2.js</p><pre><code>import React from &#39;react&#39;;export default class ComponentDetails extends React.Component{  constructor(props) {    super(props);    alert(&#39;子级组件2中的构造函数被执行&#39;);  }  componentWillMount(){    //定义你的逻辑即可    alert(&#39;子级组件2中的构造函数被执行&#39;);    console.log(&quot;ComponentDetails - componentWillMount&quot;);  }  render(){    return (      &lt;div&gt;        &lt;h2&gt;这里是嵌套在首页中的详细的页面2，测试构造函数是否会被加载&lt;/h2&gt;      &lt;/div&gt;    );  };}</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>react中常见问题的汇总，收藏别人的</title>
      <link href="/2018/12/04/lao-bo-ke/react-zhong-chang-jian-wen-ti-de-hui-zong-shou-cang-bie-ren-de/"/>
      <url>/2018/12/04/lao-bo-ke/react-zhong-chang-jian-wen-ti-de-hui-zong-shou-cang-bie-ren-de/</url>
      
        <content type="html"><![CDATA[<p></p><p>这是我在看视频学习react过程中发现的讲师的博客，写的非常的好，所以收藏起来了作为学习的工具，供自己工作和学习方便，<a href="http://blog.parryqiu.com/2017/03/09/react-q-and-a/" target="_blank" rel="noopener">原文网址为</a>。</p><p></p><p>文章中我整理了 React.js 开发过程中一些参见问题的解答汇总，供大家参考。<br><a id="more"></a></p><p></p><p></p><h1 id="1-__u4E00_u4E9B_u8BFE_u7A0B_u8D44_u6E90"><a href="#1-__u4E00_u4E9B_u8BFE_u7A0B_u8D44_u6E90" class="headerlink" title="1. 一些课程资源"></a>1. 一些课程资源</h1><p>课程完整的思维导图请查考文章：<a href="http://blog.parryqiu.com/2017/03/05/imooc-react-mind-map/" target="_blank" rel="noopener">React.js 入门与实战课程思维导图</a>，我使用的思维导图软件是 Mac 下的 iThoughtsx。</p><p></p><p></p><p>课程网站源码包请参考慕课问答区：<a href="http://coding.imooc.com/learn/questiondetail/6090.html" target="_blank" rel="external">课程里面说的各个章节的源码在哪里哦</a>，此源码包含了 node_modules ，所以压缩文件达到了 1 个多 G，不过这样就保证了不会因为组件版本的原因引起的课程学习疑惑。</p><p></p><p></p><p>如果你想下载不包含 node_modules 的源码，请访问我上传到 GitHub 的版本：<a href="https://github.com/ParryQiu/IMOOC-React" target="_blank" rel="external">https://github.com/ParryQiu/IMOOC-React</a></p><p></p><p></p><h1 id="2-__u6267_u884C_webpack-dev-server__u2013content-base_src__u2013hot__u2013inline__u51FA_u9519"><a href="#2-__u6267_u884C_webpack-dev-server__u2013content-base_src__u2013hot__u2013inline__u51FA_u9519" class="headerlink" title="2. 执行 webpack-dev-server –content-base src –hot –inline 出错"></a>2. 执行 webpack-dev-server –content-base src –hot –inline 出错</h1><p>在新版本的 webpack-dev-server 中，因为取消了 content-base 参数，所以需要热加载自动刷新的话，直接执行命令 <code>webpack-dev-server –hot –inline</code> 即可。</p><p></p><p></p><h1 id="3-__u4F7F_u7528_Webpack_2__u642D_u5EFA_u7684_React__u6D4F_u89C8_u5668_u81EA_u52A8_u5237_u65B0_u7684_u9879_u76EE_u6A21_u677F"><a href="#3-__u4F7F_u7528_Webpack_2__u642D_u5EFA_u7684_React__u6D4F_u89C8_u5668_u81EA_u52A8_u5237_u65B0_u7684_u9879_u76EE_u6A21_u677F" class="headerlink" title="3. 使用 Webpack 2 搭建的 React 浏览器自动刷新的项目模板"></a>3. 使用 Webpack 2 搭建的 React 浏览器自动刷新的项目模板</h1><p>如果还是有同学不能搭建出能够浏览器自动刷新的配置，那么请直接下载我配置好并测试过的，使用最新的 webpack 2 配置的项目模版即可。<br>项目地址: <a href="https://github.com/ParryQiu/React-Webpack2-HMR-Template" target="_blank" rel="external">https://github.com/ParryQiu/React-Webpack2-HMR-Template</a></p><p></p><p></p><h2 id="u8FD0_u884C_u65B9_u6CD5"><a href="#u8FD0_u884C_u65B9_u6CD5" class="headerlink" title="运行方法"></a>运行方法</h2><ul><p></p><p><li>cd React-Webpack2-HMR-Template</li></p><p><li>npm install</li></p><p><li>npm start</li></p><p><li>修改 index.js 文件代码，浏览器自动刷新</li><br></p></ul><p></p><p></p><h1 id="4-__u5B89_u88C5_u4E86_React_Developer_Tool__u540E_u8C03_u8BD5_u72B6_u6001_u4E0B_u4E0D_u663E_u793A"><a href="#4-__u5B89_u88C5_u4E86_React_Developer_Tool__u540E_u8C03_u8BD5_u72B6_u6001_u4E0B_u4E0D_u663E_u793A" class="headerlink" title="4. 安装了 React Developer Tool 后调试状态下不显示"></a>4. 安装了 React Developer Tool 后调试状态下不显示</h1><p><img src="http://7xqdjc.com1.z0.glb.clouddn.com/blog_5d03291404577c508594b5e9cd355174.png" alt="截图"></p><p></p><p></p><p>请确认下载安装的版本是 2.0 版本，建议直接科学上网后去官方商店下载，不要使用百度等搜索引擎搜索下载旧版本。</p><p></p><p></p><h1 id="5-__u7F3A_u5C11_react-html-attrs__u63D2_u4EF6"><a href="#5-__u7F3A_u5C11_react-html-attrs__u63D2_u4EF6" class="headerlink" title="5. 缺少 react-html-attrs 插件"></a>5. 缺少 react-html-attrs 插件</h1><p><img src="http://7xqdjc.com1.z0.glb.clouddn.com/blog_bedd2f19ddf60a1f8e951fd3d0c11490.png" alt="截图"></p><p></p><p></p><p>在项目文件夹下执行命令 <code>npm install babel-plugin-react-html-attrs</code> 即可。</p><p></p><p></p><h1 id="6-__u5173_u4E8E_u5904_u7406_babel-loader__u6CA1_u52A0_u8F7D_u7684_u9519_u8BEF"><a href="#6-__u5173_u4E8E_u5904_u7406_babel-loader__u6CA1_u52A0_u8F7D_u7684_u9519_u8BEF" class="headerlink" title="6. 关于处理 babel-loader 没加载的错误"></a>6. 关于处理 babel-loader 没加载的错误</h1><p>如果在运行 <code>webpack-dev-server</code> 的时候出现了如下的错误。</p><p></p><p></p><p><img src="http://7xqdjc.com1.z0.glb.clouddn.com/blog_86c87eb19411247f357893d18cd741a3.png" alt="截图"></p><p></p><p></p><p>请执行以下命令 <code>npm install babel-loader</code><br>重新运行后即可正常运行了。</p><p></p><p></p><p><img src="http://7xqdjc.com1.z0.glb.clouddn.com/blog_749cc4b5d6ce98b1f59781f259f1a2fc.png" alt="截图"></p><p></p><p></p><h1 id="7-__u4F7F_u7528_React__u4E2D_u7684_fetch"><a href="#7-__u4F7F_u7528_React__u4E2D_u7684_fetch" class="headerlink" title="7. 使用 React 中的 fetch"></a>7. 使用 React 中的 fetch</h1><p>可以参考我的博文：<a href="http://blog.parryqiu.com/2016/03/02/using_fetch_in_nodejs/" target="_blank" rel="noopener">在 JS 中使用 fetch 更加高效地进行网络请求</a></p><p></p><p></p><h1 id="8-_webpack-dev-server__u5360_u7528_u7AEF_u53E3_8080__u7684_u95EE_u9898"><a href="#8-_webpack-dev-server__u5360_u7528_u7AEF_u53E3_8080__u7684_u95EE_u9898" class="headerlink" title="8. webpack-dev-server 占用端口 8080 的问题"></a>8. webpack-dev-server 占用端口 8080 的问题</h1><p><img src="http://7xqdjc.com1.z0.glb.clouddn.com/blog_ac7f3d71d21304b4d7589963adcc4df5.png" alt="截图"></p><p></p><p></p><p>当出现了端口占用的问题时，请结束掉占用端口的进程后重新运行即可。</p><p></p><p></p><h1 id="9-__u9519_u8BEF_The_root_route_must_render_a_single_element__u7684_u5904_u7406"><a href="#9-__u9519_u8BEF_The_root_route_must_render_a_single_element__u7684_u5904_u7406" class="headerlink" title="9. 错误 The root route must render a single element 的处理"></a>9. 错误 The root route must render a single element 的处理</h1><p><img src="http://7xqdjc.com1.z0.glb.clouddn.com/blog_6c3e6c605d7fd0813e37344cffbb2b3b.png" alt="截图"></p><p></p><p></p><p>需要注意 Route 绑定的 component 中的 class 有没有添加 <code>export default</code>。</p><p></p><p></p><h1 id="10-__u5982_u4F55_u5728chrome_console__u4E2D_u6253_u5F00_paint_flashing"><a href="#10-__u5982_u4F55_u5728chrome_console__u4E2D_u6253_u5F00_paint_flashing" class="headerlink" title="10. 如何在chrome console 中打开 paint flashing"></a>10. 如何在chrome console 中打开 paint flashing</h1><p>在 console 中的第二个窗口 rendering 下，如果不显示你可以在 console 下点击键盘 Esc 打开。</p><p></p><p></p><h1 id="11-__u7236_u7EC4_u4EF6_u901A_u8FC7_refs__u83B7_u53D6_u5B50_u7EC4_u4EF6_u771F_u5B9E_DOM__u8282_u70B9_u7684_u95EE_u9898"><a href="#11-__u7236_u7EC4_u4EF6_u901A_u8FC7_refs__u83B7_u53D6_u5B50_u7EC4_u4EF6_u771F_u5B9E_DOM__u8282_u70B9_u7684_u95EE_u9898" class="headerlink" title="11. 父组件通过 refs 获取子组件真实 DOM 节点的问题"></a>11. 父组件通过 refs 获取子组件真实 DOM 节点的问题</h1><p>请参见问答区：<a href="http://coding.imooc.com/learn/questiondetail/6639.html" target="_blank" rel="external">父组件通过refs获取子组件真实dom节点的问题</a><br>主要是可以通过 ReactDOM.findDOMNode(this.refs.rootChild) 进行获取。</p><p></p><p></p><h1 id="12-__u4EE3_u7801_u8DF3_u8F6C_Route__u7684_u95EE_u9898"><a href="#12-__u4EE3_u7801_u8DF3_u8F6C_Route__u7684_u95EE_u9898" class="headerlink" title="12. 代码跳转 Route 的问题"></a>12. 代码跳转 Route 的问题</h1><p>请参见问答区：<a href="http://coding.imooc.com/learn/questiondetail/6776.html" target="_blank" rel="external">老师你好，我想在点击登录的时候用router定位到特定页面怎么做？</a></p><p></p><p></p><h1 id="13-__u5982_u4F55_u5C06_AntDesign__u4E2D_u7684_getFieldProps__u66FF_u6362_u6210_getFieldDecorator"><a href="#13-__u5982_u4F55_u5C06_AntDesign__u4E2D_u7684_getFieldProps__u66FF_u6362_u6210_getFieldDecorator" class="headerlink" title="13. 如何将 AntDesign 中的 getFieldProps 替换成 getFieldDecorator"></a>13. 如何将 AntDesign 中的 getFieldProps 替换成 getFieldDecorator</h1><p>请参见问答区：<a href="http://coding.imooc.com/learn/questiondetail/6728.html" target="_blank" rel="external">如果要把getFieldProps替换成getFieldDecorator的话</a><br>或者参见官方文档：<a href="https://ant.design/components/form-cn/" target="_blank" rel="external">Form 表单</a></p><p></p><p></p><h1 id="14-_Target_container_is_not_a_DOM_element"><a href="#14-_Target_container_is_not_a_DOM_element" class="headerlink" title="14. Target container is not a DOM element"></a>14. Target container is not a DOM element</h1><p> 错误截图如下</p><p></p><p></p><p> <img src="http://7xqdjc.com1.z0.glb.clouddn.com/blog_e69bf3a00dda7b9269514338d1a17c17.png" alt="截图"></p><p></p><p></p><p> 原因是没有将页面的 JS 文件放在目标 div 的下面，注意下图正确的文件顺序。</p><p></p><p></p><p> <img src="http://7xqdjc.com1.z0.glb.clouddn.com/blog_a529c4acd0a812e92dd8d4eb8e769485.png" alt="截图"></p><p></p><p></p><h1 id="15-__u6155_u8BFE_u6CA1_u6709_u53D1_u5E03_u7684_u66F4_u65B0_u8BFE_u7A0B"><a href="#15-__u6155_u8BFE_u6CA1_u6709_u53D1_u5E03_u7684_u66F4_u65B0_u8BFE_u7A0B" class="headerlink" title="15. 慕课没有发布的更新课程"></a>15. 慕课没有发布的更新课程</h1><p>之前录制了「项目优化实战与可维护代码的编写」，没有通过慕课的审核，所以分享给需要这部分知识的同学继续学习，注意，即使是这两集，也不可用于任何商业用途，否则必将追究一切的法律责任，小心 ^_^。</p><p></p><p></p><p>链接: <a href="https://pan.baidu.com/s/1i4Zuv8D" target="_blank" rel="external">https://pan.baidu.com/s/1i4Zuv8D</a><br>密码: 6qeu</p><p></p><p></p><h1 id="16-_React_Router_4-0__u4E2D_location_undefined__u7684_u95EE_u9898"><a href="#16-_React_Router_4-0__u4E2D_location_undefined__u7684_u95EE_u9898" class="headerlink" title="16. React Router 4.0 中 location undefined 的问题"></a>16. React Router 4.0 中 location undefined 的问题</h1><p>版本 4.0 中对 hashHistory 做了迁移，你需要执行包安装命令 <code>npm install react-router-dom</code> 后，按照如下的代码进行使用即可。</p><p></p><p><pre class=" language-hljs javascript"><span class="hljs-keyword">import</span> { HashRouter } <span class="hljs-keyword">from</span> <span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-keyword">import</span> { HashRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">‘react-router-dom’</span></code></pre></p><p><hashrouter><br>  <app><br></app></hashrouter></p><p></p><p>文档请参见这里：<a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/docs/api/HashRouter.md" target="_blank" rel="external">https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/docs/api/HashRouter.md</a></p><p></p><p></p><p>官方的 issue：<a href="https://github.com/ReactTraining/react-router/issues/4752" target="_blank" rel="external">https://github.com/ReactTraining/react-router/issues/4752</a></p><p></p><p></p><h1 id="17-_AntDesign__u6587_u6863_u4E2D_u7684_u51FD_u6570_u8BED_u6CD5_u9519_u8BEF_u4EE5_u53CA_ES7__u8BED_u6CD5_u7684_u652F_u6301_u65B9_u6CD5"><a href="#17-_AntDesign__u6587_u6863_u4E2D_u7684_u51FD_u6570_u8BED_u6CD5_u9519_u8BEF_u4EE5_u53CA_ES7__u8BED_u6CD5_u7684_u652F_u6301_u65B9_u6CD5" class="headerlink" title="17. AntDesign 文档中的函数语法错误以及 ES7 语法的支持方法"></a>17. AntDesign 文档中的函数语法错误以及 ES7 语法的支持方法</h1><p>如果你直接照搬 AntDesign 的语法，可能会遇到如下错误。</p><p></p><p></p><p><img src="http://7xqdjc.com1.z0.glb.clouddn.com/blog_a5a7fc501a3d144daa11c1dc1fa3f765.png" alt="截图"></p><p></p><p></p><p>原因是因为此文档使用了最新的 ES7 的语法，所以如果你想这样使用，你需要安装 <code>babel-preset-stage-0</code> 组件。<br>需要在项目文件夹下执行如下命令即可：<code>npm install –save-dev babel-preset-stage-0</code>。</p><p></p><p></p><p>如果需要安装其他对应的规则集，如下供参考。</p><p></p><ul><br><li><p>ES2015转码规则<br>$ npm install –save-dev babel-preset-es2015</p><br></li><br><li><p>react转码规则<br>$ npm install –save-dev babel-preset-react</p><br></li><br><li><p>ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个<br>$ npm install –save-dev babel-preset-stage-0<br>$ npm install –save-dev babel-preset-stage-1<br>$ npm install –save-dev babel-preset-stage-2<br>$ npm install –save-dev babel-preset-stage-3</p><br></li><br></ul><br><h1 id="18-__u89E3_u51B3_webpack-dev-server__u4E0D_u80FD_u81EA_u52A8_u5237_u65B0_u7684_u95EE_u9898"><a href="#18-__u89E3_u51B3_webpack-dev-server__u4E0D_u80FD_u81EA_u52A8_u5237_u65B0_u7684_u95EE_u9898" class="headerlink" title="18. 解决 webpack-dev-server 不能自动刷新的问题"></a>18. 解决 webpack-dev-server 不能自动刷新的问题</h1><p>请参见我的博文 <a href="http://blog.parryqiu.com/2017/03/25/fix-webpack-dev-server-automatic-refresh/" target="_blank" rel="noopener">解决 webpack-dev-server 不能自动刷新的问题</a></p><br><p>2017-04-08 更新了最新版本的 webpack 2 浏览器自动刷新的视频教程，请参见这里：<a href="http://v.youku.com/v_show/id_XMjY5NTg4NzU4OA==.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMjY5NTg4NzU4OA==.html</a>，如果你不想使用和课程一样的 1.0 版本但是又看不懂最新版本的文档，请参见此视频即可。</p><br><h1 id="19-__u89E3_u51B3_u8BFE_u7A0B_u4E2D_React_Router__u7248_u672C_u7684_u5DEE_u5F02_u95EE_u9898"><a href="#19-__u89E3_u51B3_u8BFE_u7A0B_u4E2D_React_Router__u7248_u672C_u7684_u5DEE_u5F02_u95EE_u9898" class="headerlink" title="19. 解决课程中 React Router 版本的差异问题"></a>19. 解决课程中 React Router 版本的差异问题</h1><p>您可以直接查看最新的 React Router 4 的文档自己学习，如果想使用和课程一样的版本，请安装特定的版本和课程同步学习。</p><br><p><code>npm install <a href="mailto:react-router@2.8.1" target="_blank" rel="noopener">react-router@2.8.1</a></code></p><br><p>这样安装的版本就是 React Router 2 的版本，所有的使用就会和课程一样了。</p><br><h1 id="20-__u8BFE_u7A0B_u5B9E_u6218_u65B0_u95FB_u9879_u76EE_API__u6E90_u7801_u4EE5_u53CA_API__u5730_u5740"><a href="#20-__u8BFE_u7A0B_u5B9E_u6218_u65B0_u95FB_u9879_u76EE_API__u6E90_u7801_u4EE5_u53CA_API__u5730_u5740" class="headerlink" title="20. 课程实战新闻项目 API 源码以及 API 地址"></a>20. 课程实战新闻项目 API 源码以及 API 地址</h1><p>源码地址：<a href="https://github.com/ParryQiu/IMOOC-React-NewsAPI" target="_blank" rel="external">https://github.com/ParryQiu/IMOOC-React-NewsAPI</a></p><br><p>API 请求地址</p><br><ul><br><li><a href="http://newsapi.gugujiankong.com/Handler.ashx?action=getnews&amp;type=top&amp;count=10" target="_blank" rel="external">获取新闻列表</a></li><br><li><a href="http://newsapi.gugujiankong.com/Handler.ashx?action=getnewsitem&amp;uniquekey=161022191707874" target="_blank" rel="external">获取新闻详情</a></li><br><li><a href="http://newsapi.gugujiankong.com/Handler.ashx?action=getcomments&amp;uniquekey=123" target="_blank" rel="external">获取文章评论</a></li><br><li><a href="http://newsapi.gugujiankong.com/Handler.ashx?action=comment&amp;userid=1&amp;uniquekey=123&amp;commnet=content" target="_blank" rel="external">新闻添加评论</a></li><br><li><a href="http://newsapi.gugujiankong.com/Handler.ashx?action=uc&amp;userid=1&amp;uniquekey=123" target="_blank" rel="external">收藏新闻</a></li><br><li><a href="http://newsapi.gugujiankong.com/Handler.ashx?action=register&amp;username=userName&amp;password=password&amp;r_userName=r_userName&amp;r_password=r_password&amp;r_confirmPassword=r_confirmPassword" target="_blank" rel="external">注册登录接口</a></li><br><li><a href="http://newsapi.gugujiankong.com/Handler.ashx?action=getuc&amp;userid=1" target="_blank" rel="external">获取用户收藏</a></li><br><li><a href="http://newsapi.gugujiankong.com/Handler.ashx?action=getusercomments&amp;userid=1" target="_blank" rel="external">获取用户发出的评论</a></li><br></ul><pre><code>                &lt;div class=&quot;entry_copyright&quot;&gt;                  &lt;p class=&quot;eof&quot;&gt;–&lt;abbr title=&quot;End of File&quot;&gt;EOF&lt;/abbr&gt;–&lt;/p&gt;                  &lt;p&gt;&lt;abbr title=&quot;版权以及转载声明&quot;&gt;转载须以超链接形式标明文章原始出处和作者信息&lt;/abbr&gt;&lt;/p&gt;                  &lt;p&gt;&lt;img src=&quot;https://oindk07nf.qnssl.com/wxtips.jpg&quot;&gt;&lt;/p&gt;                &lt;/div&gt;      &lt;/div&gt;      &lt;footer&gt;</code></pre>  <div class="categories"><br>    <a href="/categories/React/">React</a><br>  </div>  <div class="tags"><br>    <a href="/tags/React/">React</a>, <a href="/tags/视频教程/">视频教程</a><br>  </div><pre><code>                            &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;      &lt;/footer&gt;    &lt;/div&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>React中常见的坑 之 React中XXX is not an absolute  path!</title>
      <link href="/2018/12/04/lao-bo-ke/react-zhong-xxx-is-not-an-absolute-path/"/>
      <url>/2018/12/04/lao-bo-ke/react-zhong-xxx-is-not-an-absolute-path/</url>
      
        <content type="html"><![CDATA[<hr><p>本周学习react中遇到了如下问题:<br>         <img src="http://img.blog.csdn.net/20171207164914387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>   根据提示，<code>The provided value  &quot;node_modules&quot; is not an absolute path!</code>        [你所提供的值“node_mudules”不是一个局对路径    ],所以应该更改webpack.config.js中的相关属性，并将其设置为绝对路径;本次错误中做的修改如下所示:<br>     <img src="http://img.blog.csdn.net/20171208090929061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>React中es5与es6写法对比</title>
      <link href="/2018/12/04/lao-bo-ke/react-zhong-es5-yu-es6-xie-fa-dui-bi/"/>
      <url>/2018/12/04/lao-bo-ke/react-zhong-es5-yu-es6-xie-fa-dui-bi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1.引入与导出方式不同</p><p>//ES5 var React = require(“react”);<br>//ES6 import React, { Component,<br>PropTypes } from ‘react</p></blockquote><hr><blockquote><p>2.导入： ES5使用require导入，而ES6使用了import<br>//ES5<br>module.exports = Test;<br>//ES6<br>export default Test;</p></blockquote><hr><blockquote><p>3.创建组件的方式不同<br> //ES5<br>  var Test = React.createClass( {<br>       ………. } );<br>        //ES6<br>        class Test extends Component {<br>       ………. }</p></blockquote><hr><blockquote><p>4.初始化组件属性的方式以及限制组件属性类型的方式不同<br>//ES5<br>var Test = React.createClass({<br>      getDefaultProps: function() {<br>             return {<br>                   myPro: 10<br>             };<br>      },<br>      propTypes: {<br>             myPro: React.PropTypes.number. isRequired<br>      }<br>});</p><p>ES6<br>class Test extends Component {<br>       static defaultProps = {<br>             myPro: 10<br>       };<br>       static propTypes = {<br>             myPro: React.PropTypes.number. isRequired<br>       };<br>}</p></blockquote><hr><blockquote><p>5.初始化方法不同</p><p>//ES5<br>getInitialState: function() {<br>      ………..<br>      return {<br>           myState: 10<br>      }<br>}<br>//ES6<br>constructor(props){<br>        super(props);<br>        this.state = {<br>            myState: 10<br>        };<br>    }</p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>react中“create-react-app”不是内部或者外部命令也不是可运行程序的解决办法</title>
      <link href="/2018/12/04/lao-bo-ke/react-zhong-create-react-app-bu-shi-nei-bu-huo-zhe-wai-bu-ming-ling...jie-jue-fang-an/"/>
      <url>/2018/12/04/lao-bo-ke/react-zhong-create-react-app-bu-shi-nei-bu-huo-zhe-wai-bu-ming-ling...jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<hr><p>1.分析问题的原因：<br>           出现这种问题一般是因为命令所在路径和配置的环境变量的路径不统一所导致的，即命令所在的位置不是环境变量所指向的位置；<br> 2解决方案:<br>         (1.)使用npm自带的命令npm config list查看npm相关的环境变量(如果没有手动配置，则npm的环境变量一般配置的是默认路径：<img src="http://img.blog.csdn.net/20171215161443549?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">)，采用默认路径一般是在系统盘，这样不太好，下面将详细介绍自定义环境变,通过对比当前的安装路径：<img src="http://img.blog.csdn.net/20171215161847450?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">，会发现两者确实不同，只要将命令安装路径和命令运行路径（环境变量指向的路径）统一即可。<br>       (2.)  通过命令：<code>npm config set prefix &quot;D:\XXXXXX\XXXXX\XXX&quot;</code>即可设置命令的安装路径（该路径和环境变量指向的路径应该保持一致）；</p><hr><p><strong>node.js的自定义配置：</strong></p><p> (1.)安装</p><ol><br><li>双击安装包，一路下一步，路径最好别放C盘，因为我是强迫症，不喜欢C盘被乱七八糟的东西塞满。</li><br><li>安装完成后，建议再找个喜欢的地方创建一个全局包文件夹，这样你的全局包与缓存会放在这个文件夹下，比较好找。比如我的路径：<code>D:\software\dev\Node</code> <br><br><ul><li><img src="http://img.blog.csdn.net/20170322224905671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE0NTEzNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></li><br><li>Cache：缓存目录</li><br><li>Lib：全局包目录</li></ul></li><br><li>包目录创建好后，在nodejs安装目录下的<code>node_modules\npm</code>下找到npmrc文件，并修改： <br><br><ul><li><img src="http://img.blog.csdn.net/20170322225147238?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE0NTEzNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></li><br><li>修改全局包与缓存的目录配置为刚刚我们创建的文件夹。</li></ul></li><br></ol><p>(3) 配置环境变量</p><ol><br><li>右键我的电脑-属性-高级系统设置-高级-环境变量，打开环境变量设置窗口 <br><br><ul><li><img src="http://img.blog.csdn.net/20170322225344460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE0NTEzNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></li></ul></li><br><li>在下面的系统变量中找到Path，点击编辑，在后面加入nodejs的安装目录，我这里就是<code>D:\software\dev\nodeJS\</code></li><br><li>然后打开cmd，输入node -v回车显示node版本，输入npm -v回车，显示npm版本，则表示node安装成功。</li><br><li>在用户变量Path中，修改默认配置为刚刚设置的<strong>prefix</strong>路径。</li><br></ol><hr><p><strong>注意</strong>：prefix指向的路径中，应该包含<code>全局安装包的文件夹</code>和<code>缓存文件夹</code>,这两个文件夹应该是同级的文件，层次结构如下所示：<img src="http://img.blog.csdn.net/20171215163304642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>react结合d3.js和svg绘制条形统计图</title>
      <link href="/2018/12/04/lao-bo-ke/react-jie-he-d3.js-he-svg-hui-zhi-tiao-xing-tong-ji-tu/"/>
      <url>/2018/12/04/lao-bo-ke/react-jie-he-d3.js-he-svg-hui-zhi-tiao-xing-tong-ji-tu/</url>
      
        <content type="html"><![CDATA[<p>最近学习了下D3.js并仿照别人的案例写了个小demo【参考文章》<a href="http://wiki.jikexueyuan.com/project/d3wiki/chart.html】，遇到了一些问题，在这里记录下" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/d3wiki/chart.html】，遇到了一些问题，在这里记录下</a>:<br>1.遇到的一些坑:<br>(1.)D3.js中V3和V4的版本差别很大,所以一定要注意版本;<br>(2.)引用D3.js的js库文件的时候，应该通过npm安装库依赖，虽然D3.js不咋出名，但是npm还是可以安装它，安装命令是:<br><code>npm安装：npm install d3前端导入：import * as d3 from &#39;d3&#39;;</code><br>(3.)react中css的解析和导入：<br>一：如果是通过create-react-app创建的项目，可以直接通过命令：</p><pre><code>import &#39;./styles.css&#39;;</code></pre><p>导入，可以参考蚂蚁金服的样式导入和操作；<br>二:非create-react-app项目，可以参考文章:<br><a href="http://echizen.github.io/tech/2017/03-09-css-in-react" target="_blank" rel="noopener">http://echizen.github.io/tech/2017/03-09-css-in-react</a><br>2.demo的源码：<br>animSVG.js</p><pre><code>import React, { Component } from &#39;react&#39;;import * as SimulationData from &#39;./svgData&#39;;import * as d3 from &#39;d3&#39;;import &#39;./styles.css&#39;;//需要注意的问题：v3和v4版本差别很大，需要高度注意;class AnimSVG extends React.Component {    render() {        {/* 定义柱状图的颜色数组; */ }        const colors = [&quot;#39D1DE&quot;, &quot;#1CDB62&quot;, &quot;#1FE015&quot;, &quot;#A7E51F&quot;, &quot;#E3E312&quot;, &quot;#EA6A1F&quot;, &quot;#29A0E3&quot;];        {/* 画布大小 */ }        var width = 400;        var height = 400;        {/* 在 body 里添加一个 SVG 画布 */ }        var svg = d3.select(&quot;body&quot;)            .append(&quot;svg&quot;)            .attr(&quot;width&quot;, width)            .attr(&quot;height&quot;, height);        {/* 画布周边的空白 */ }        var padding = { left: 30, right: 30, top: 20, bottom: 20 };        {/* 定义一个数组 */ }        var dataset = [10, 20, 30, 40, 33, 24, 12, 5];        {/* x轴的比例尺 */ }        var xScale = d3.scale.ordinal()            .domain(d3.range(dataset.length))            .rangeRoundBands([0, width - padding.left - padding.right]);        {/* y轴的比例尺 */ }        var yScale = d3.scale.linear()            .domain([0, d3.max(dataset)])            .range([height - padding.top - padding.bottom, 0]);        {/* 定义x轴 */ }        var xAxis = d3.svg.axis()            .scale(xScale)            .orient(&quot;bottom&quot;);        {/* 定义y轴 */ }        var yAxis = d3.svg.axis()            .scale(yScale)            .orient(&quot;left&quot;);        {/* 矩形之间的空白间距的宽度; */ }        var rectPadding = 4;        //添加矩形元素        var rects = svg.selectAll(&quot;.MyRect&quot;)            .data(dataset)            .enter()            .append(&quot;rect&quot;)            .attr(&quot;class&quot;, &quot;MyRect&quot;)            .attr(&quot;transform&quot;, &quot;translate(&quot; + padding.left + &quot;,&quot; + padding.top + &quot;)&quot;)            .attr(&quot;x&quot;, function (d, i) {                return xScale(i) + rectPadding / 2;            })            .attr(&quot;width&quot;, xScale.rangeBand() - rectPadding)            .attr(&quot;y&quot;, function (d) {                var min = yScale.domain()[0];                return yScale(min);            })            .attr(&quot;height&quot;, function (d) {                return 0;            })            .transition()            .delay(function (d, i) {                return i * 200;            })            .duration(2000)            .ease(&quot;bounce&quot;)            .style(&quot;fill&quot;, function (uselsssVO, index) {                var currentColorIndex = index % (colors.length);                return colors[currentColorIndex];            })            .attr(&quot;y&quot;, function (d) {                return yScale(d);            })            .attr(&quot;height&quot;, function (d) {                return height - padding.top - padding.bottom - yScale(d);            });        {/* 添加文字元素 */ }        var texts = svg.selectAll(&quot;.MyText&quot;)            .data(dataset)            .enter()            .append(&quot;text&quot;)            .attr(&quot;class&quot;, &quot;MyText&quot;)            .attr(&quot;transform&quot;, &quot;translate(&quot; + padding.left + &quot;,&quot; + padding.top + &quot;)&quot;)            .attr(&quot;x&quot;, function (d, i) {                return xScale(i) + rectPadding / 2;            })            .attr(&quot;dx&quot;, function () {                return (xScale.rangeBand() - rectPadding) / 2;            })            .attr(&quot;dy&quot;, function (d) {                return 20;            })            .text(function (d) {                return d;            })            .attr(&quot;y&quot;, function (d) {                var min = yScale.domain()[0];                return yScale(min);            })            .transition()            .delay(function (d, i) {                return i * 200;            })            .duration(2000)            .ease(&quot;bounce&quot;)            .attr(&quot;y&quot;, function (d) {                return yScale(d);            });        {/* 添加x轴 */ }        svg.append(&quot;g&quot;)            .attr(&quot;class&quot;, &quot;axis&quot;)            .attr(&quot;transform&quot;, &quot;translate(&quot; + padding.left + &quot;,&quot; + (height - padding.bottom) + &quot;)&quot;)            .call(xAxis);         {/* 添加y轴 */ }        svg.append(&quot;g&quot;)            .attr(&quot;class&quot;, &quot;axis&quot;)            .attr(&quot;transform&quot;, &quot;translate(&quot; + padding.left + &quot;,&quot; + padding.top + &quot;)&quot;)            .call(yAxis);        return (            &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;/svg&gt;        );    }}export default AnimSVG;</code></pre><p>styles.css</p><pre><code>.axis path,.axis line {    fill: none;    stroke: black;    shape-rendering: crispEdges;}.axis text {    font-family: sans-serif;    font-size: 11px;}.MyRect {    fill: steelblue;}.MyText {    fill: white;    text-anchor: middle;}</code></pre><p>3.demo的效果:<br><img src="http://img.blog.csdn.net/20180118173937870?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>React和SpringBoot前后端分离开发模式下采用WebSocket实现单设备登录</title>
      <link href="/2018/12/04/lao-bo-ke/react-he-springboot-qian-hou-duan-fen-chi-kai-fa-mo-shi-xia-cai-yong-websocket-shi-xian-dan-she-bei-deng-lu/"/>
      <url>/2018/12/04/lao-bo-ke/react-he-springboot-qian-hou-duan-fen-chi-kai-fa-mo-shi-xia-cai-yong-websocket-shi-xian-dan-she-bei-deng-lu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>首先介绍下，什么是单设备登录？<br>单设备登录可以理解为同一个应用某一时刻只允许单一用户使用处于登录状态。单设备登录可以类比QQ的踢出第二者登录模式，可以在一定的程度上保障账号的安全。</p></blockquote><hr><blockquote><p>   单设备登录的难点在哪？<br>   单设备登录的难点在于如何主动、准确的推动消息到客户端。但是幸运的是我们可以通过WebSocket实现消息的准确推送，并且React中也有对应的WebSocket的Js依赖包可以使用。</p></blockquote><p>下面将介绍详细的实现流程：<br>A、前端开发准备流程：<br>   1、使用npm 安装正确的js依赖包：</p><pre><code>npm install websockt</code></pre><p>参考文章：<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">阮一峰的WebSocket 教程</a></p><p>2、websocket前端实现代码：</p><pre><code>   /**    * 建立WS链接相关的方法;jSESSIONID:&#39;&#39;    * @param {*} wsUrl :建立webSocket链接的Url;    */    estabConnectWithWS(wsUrl) {    const ws = new WebSocket(wsUrl);    let result = &quot;&quot;;    ws.onopen = function (e) {      console.log(&#39;连接上 ws 服务端了&#39;);      ws.send(JSON.stringify({ flag: wsUrl, data: &quot;Hello WebSocket!&quot; }));    }    ws.onmessage = (msg)=&gt; {         console.log(&#39;接收服务端发过来的消息: %o&#39;, msg);         var msgJson = JSON.parse(msg.data);        result += msgJson.MsgBody + &#39;\n&#39;;        if (msgJson.MsgCode == &quot;999999&quot;) {//多设备在线的异常发生时;           window.location.href = &#39;/#/&#39;;        } else if (msgJson.MsgCode == &quot;555555&quot;) {//用户退出系统的时候;            ws.close();            window.location.href = &#39;/#/&#39;;        }        alert(msgJson.MsgBody);    };     ws.onclose = function (e) {        console.log(&#39;ws 连接关闭了&#39;);        console.log(e);    }  }</code></pre><p>主要步骤就是在登录校验通过后就建立和WebSocket服务终端的链接，并启动消息监听，在多用户登录的时候，前端弹出提示消息并跳转到登录页面，在用户执行退出操作的时候终断websocket链接并跳转到登录页面。</p><p>具体情境如下图所示：<br><img src="http://ouuy81imh.bkt.clouddn.com/singleDeviceLogin001.gif" alt="这里写图片描述"><br>B、websocket后端开发流程<br>1、在用户成功登录后创建session并存储用户的登录信息；<br>2、websocket客户端和websocket服务端握手成功之后，将第一步中的session中的数据放入WebSocketSession中，便于在MyWebSocketHandler中创建在线用户表，最终将根据在线用户表中的userId实现一对一的消息推送。<br>3、ws请求进入MyWebSocketHandler【ws处理】中，在ws链接建立的生命周期中进行合理的数据处理。</p><p>WebSocketInterceptor.java</p><pre><code>package com.sds.socketInterceptor;import java.io.IOException;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.http.server.ServletServerHttpRequest;import org.springframework.web.socket.TextMessage;import org.springframework.web.socket.WebSocketHandler;import org.springframework.web.socket.WebSocketSession;import org.springframework.web.socket.server.HandshakeInterceptor;import com.sds.enums.MsgEnum;import com.sds.model.LoginerInfo;import com.sds.model.WSMsg;import com.sds.socketHandle.MyWebSocketHandler;public class WebSocketInterceptor implements HandshakeInterceptor {    @Override    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,            Map&lt;String, Object&gt; map) throws Exception {        if (request instanceof ServletServerHttpRequest) {            HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest();            HttpSession session = servletRequest.getSession(false);            if (session != null) {                // 处理已经建立的链接;                dealWithConnectioned(session);                // 添加自定义的属性值到wobsocket中，便于进行访问控制，注意逻辑上的先后顺序;                map.put(&quot;userInfo&quot;, session.getAttribute(&quot;userInfo&quot;));            }        }        return true;    }    @Override    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,            Exception exception) {    }    /**     * 处理多设备登录;     */    public static boolean dealWithConnectioned(HttpSession userInfoStore) {        boolean isConnectioned = false;        LoginerInfo currentUserInfo = ((LoginerInfo) userInfoStore.getAttribute(&quot;userInfo&quot;));        String userId = null;        if (null != currentUserInfo) {            userId = ((LoginerInfo) userInfoStore.getAttribute(&quot;userInfo&quot;)).getUserId();        } else {            System.out.println(&quot;--CurrentUserInfo--Is----Null--&quot;);        }        Map&lt;String, WebSocketSession&gt; users = MyWebSocketHandler.users;        if (null != users) {            if (users.containsKey(userId)) {                // 如果已经登录过，则推送&quot;已登录过的提示&quot;到客户端;                // 客户端接受信息，请求退出系统的接口;                // 清除session中保存的用户信息;                WebSocketSession webSocketSession = users.get(userId);                WSMsg wsMsg = new WSMsg(MsgEnum.FORCE_LOFOUT_MSG.getMsgCode(), MsgEnum.FORCE_LOFOUT_MSG.getMsgBody());                TextMessage promptMsg = new TextMessage(wsMsg.getMsgJson());                try {                    webSocketSession.sendMessage(promptMsg);                } catch (IOException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }                // 从已登录用户列表中清除已经登录过的用户的信息记录;                users.remove(userId);                isConnectioned = true;            }        }        return isConnectioned;    }}</code></pre><p>MyWebSocketHandler.java</p><pre><code>package com.sds.socketHandle;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Set;import org.springframework.stereotype.Component;import org.springframework.web.socket.CloseStatus;import org.springframework.web.socket.TextMessage;import org.springframework.web.socket.WebSocketSession;import org.springframework.web.socket.handler.TextWebSocketHandler;import com.sds.enums.MsgEnum;import com.sds.model.LoginerInfo;import com.sds.model.WSMsg;@Componentpublic class MyWebSocketHandler extends TextWebSocketHandler {    // 在线用户列表    public static final Map&lt;String, WebSocketSession&gt; users = new HashMap&lt;String, WebSocketSession&gt;();    /**     * 连接已关闭，移除在Map集合中的记录     */    @Override    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {        users.remove(getUserId(session));    }    @Override    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {        if (session.isOpen()) {            session.close();        }        System.out.println(&quot;连接出错&quot;);        users.remove(getUserId(session));    }    /**     * 连接建立成功之后，记录用户的连接标识，便于后面发信息     */    @Override    public void afterConnectionEstablished(WebSocketSession session) throws Exception {        System.out.println(&quot;成功建立连接&quot;);        String userId = getUserId(session);        System.out.println(userId);        if (userId != null) {            users.put(userId, session);            WSMsg wsMsg = new WSMsg(MsgEnum.CONNECTION_SUCCESS_MSG.getMsgCode(),                    MsgEnum.CONNECTION_SUCCESS_MSG.getMsgBody());            TextMessage promptMsg = new TextMessage(wsMsg.getMsgJson());            session.sendMessage(promptMsg);        }    }    /**     * 处理收到的websocket信息     */    @Override    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {    }    /**     * 发送信息给指定用户     *      * @param clientId     * @param message     * @return     */    public boolean sendMessageToUser(String userId, String message) {        if (users.get(userId) == null) {            return false;        }        WebSocketSession session = users.get(userId);        System.out.println(&quot;sendMessage:&quot; + session);        if (!session.isOpen()) {            return false;        }        try {            int count = 1;            TextMessage textMessage = null;            @SuppressWarnings(&quot;unused&quot;)            String newMessage = &quot;&quot;;            // 循环向客户端发送数据            // while (true) {            newMessage = message + String.valueOf(count);            textMessage = new TextMessage(message);            session.sendMessage(textMessage);            Thread.sleep(500);            newMessage = &quot;&quot;;            // }            return true;        } catch (IOException e) {            e.printStackTrace();            return false;        } catch (InterruptedException e) {            e.printStackTrace();            return false;        }    }    /**     * 发送信息给指定用户的浏览器;     *      * @param clientId     * @param message     * @return     */    public boolean sendMessageToTargetFront(String userId, TextMessage message) {        boolean isSendSuccessfully = true;        WebSocketSession webSocketSession = users.get(userId);        try {            webSocketSession.sendMessage(message);        } catch (IOException e) {            // TODO Auto-generated catch block            isSendSuccessfully = false;            e.printStackTrace();        }        return isSendSuccessfully;    }    /**     * 广播信息     *      * @param message     * @return     */    public boolean sendMessageToAllUsers(TextMessage message) {        boolean allSendSuccess = true;        Set&lt;String&gt; clientIds = users.keySet();        WebSocketSession session = null;        for (String clientId : clientIds) {            try {                session = users.get(clientId);                if (session.isOpen()) {                    session.sendMessage(message);                }            } catch (IOException e) {                e.printStackTrace();                allSendSuccess = false;            }        }        return allSendSuccess;    }    /**     * 获取用户标识     *      * @param session     * @return     */    private String getUserId(WebSocketSession session) {        try {            String userId = ((LoginerInfo) session.getAttributes().get(&quot;userInfo&quot;)).getUserId();            return userId;        } catch (Exception e) {            return null;        }    }}</code></pre><p>源码：<br><a href="https://download.csdn.net/download/zj20142213/10655466" target="_blank" rel="noopener">React前端源码</a><br>           <a href="https://download.csdn.net/download/zj20142213/10655470" target="_blank" rel="noopener">SpringBoot后端源码</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>react中的常见问题</title>
      <link href="/2018/12/04/lao-bo-ke/react-gao-pin-xun-wen/"/>
      <url>/2018/12/04/lao-bo-ke/react-gao-pin-xun-wen/</url>
      
        <content type="html"><![CDATA[<blockquote><p>npm下载很慢或者下载失败</p><p>此问题比较困扰新手，npm由node一同发布，但由于众所周知的原因导致下载速度过慢，甚至无法下载情况解决方案有以下两种：</p><p></p></blockquote><p><ol></ol></p><p><li>NPM换源<br>故名思议，就是把NPM的下载服务器更换为国内的服务器，国内当然是大厂阿里了。</li><br></p><p><blockquote></blockquote></p><p> npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>   (npm config get registry 验证是否更换成功）<br>yarn config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>    (yarn为Facebook出的包管理工具）</p><br><br><ol><br><li>使用淘宝出的NPM替代品<code>CNPM</code>  (CNPM是使用文件夹快捷方式使用的，有时候会因为这个出现莫名BUG所以还是推荐第一种方法）</li><br></ol><br><blockquote><br><p> npm install -g cnpm —registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br> 安装成功之后所有需要使用NPM的地方换成CNPM即可 比如NPM i React 就可以写成CNPM i React</p><br></blockquote><br><h3 id="NPM安装NODE-SASS-使用SASS但是无法下载NODE-SASS"><a href="#NPM安装NODE-SASS-使用SASS但是无法下载NODE-SASS" class="headerlink" title="NPM安装NODE-SASS 使用SASS但是无法下载NODE-SASS"></a>NPM安装NODE-SASS 使用SASS但是无法下载NODE-SASS</h3><p>因为NODE—SASS在GitHub托管的是源码，需要用户自己编译。而编译需要Python和Visual C ++构建环境（Windows同学，其他操作系统Linux以及Mac不需要）最简单的办法就是通过上面的办法进行换源，淘宝源上的是编译好的，如果非要自己编译，请自行安装Python2.7以及<a href="http://landinghub.visualstudio.com/visual-cpp-build-tools" target="_blank" rel="noopener">Visual C ++生成工具</a>,具体请参考<a href="https://github.com/nodejs/node-gyp#on-windows" target="_blank" rel="noopener">官方文档</a><br><code>更新</code> NODE-SASS 只有CNPM 下载下来的是编译好的</p><br><h3 id="can-39-t-not-find-39-xxModule-39-找不到相关资源"><a href="#can-39-t-not-find-39-xxModule-39-找不到相关资源" class="headerlink" title="can't not find 'xxModule' 找不到相关资源"></a><code>can’t not find ‘xxModule’</code> 找不到相关资源</h3><p>出现这个问题有两种原因：</p><br><ol><br><li>引用路径有问题，npm包是直接Import React from ‘react’ 只需要写包名即可。而引用组件，静态资源是需要写相对路径的（有个问题就是所有文件里面的静态资源都需要import引入或者require引入，否则webpack无法得知依赖关系，而导致找不到）。</li><br><li>第二种就是相关包没有下载或者下载不齐全，项目根目录重新命令行NPM i 即可</li><br></ol><br><h3 id="React的给return出来的HTML添加事件报错this-xxxx-xxxx-not-a-function"><a href="#React的给return出来的HTML添加事件报错this-xxxx-xxxx-not-a-function" class="headerlink" title="React的给return出来的HTML添加事件报错this.xxxx.xxxx not a function"></a>React的给return出来的HTML添加事件报错this.xxxx.xxxx not a function</h3><p>在class和模块的内部。默认是使用严格模式的，以及React的基类 <code>Component</code> 中所有的this都是指向class本身的，但是return出来的HTML 会被转化成实际的dom这个时候的this指向就不是定义的时候的那个class（个人肤浅理解)举例说明<br></p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, { Component } <span class="keyword">from</span>  <span class="string">‘react’</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">APP</span>  <span class="keyword">extends</span>  <span class="title">Component</span> </span>{</span><br><span class="line">OnClick () {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2333</span>)</span><br><span class="line">}</span><br><span class="line">render () {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;button  onClick={<span class="keyword">this</span>.OnClick}&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br><span class="line"><span class="regexp">export default APP</span></span><br></pre></td></tr></tbody></table></figure><p></p><br><p>以上代码逻辑上点击按钮会触发OnClick函数，但是实际上只会报错。<br>解决方法(推荐度由高至低)：<br>1.使用提案阶段语法静态属性的<a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">提案</a>，改提案在写累的实例属性的时候可以使用等式，从而将属性和方法写入类中。（提案阶段语法，需要单独的<a href="http://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">babel插件</a>  官方脚手架create-react-app 已有此项配置(需要使用antd，sass，代码检查功能的可以参考这个<a href="https://gitee.com/HiMrHu/ReactGuanFangJiaoShouJia" target="_blank" rel="noopener">脚手架</a><br></p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, { Component } <span class="keyword">from</span>  <span class="string">‘react’</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">APP</span>  <span class="keyword">extends</span>  <span class="title">Component</span> </span>{</span><br><span class="line">OnClick  = <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2333</span>)</span><br><span class="line">    }</span><br><span class="line">render () {</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;button  onClick={<span class="keyword">this</span>.OnClick}&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">   )</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br><span class="line"><span class="regexp">export default APP</span></span><br></pre></td></tr></tbody></table></figure><p></p><br><p>2.在构造函数中bind(this)<br></p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, { Component } <span class="keyword">from</span>  <span class="string">‘react’</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">APP</span>  <span class="keyword">extends</span>  <span class="title">Component</span> </span>{</span><br><span class="line"><span class="keyword">constructor</span> () {</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.OnClick = <span class="keyword">this</span>.OnClick.bind(<span class="keyword">this</span>)</span><br><span class="line">}</span><br><span class="line">OnClick () {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2333</span>)</span><br><span class="line">}</span><br><span class="line">render () {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;button  onClick={<span class="keyword">this</span>.OnClick}&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br><span class="line"><span class="regexp">export default APP</span></span><br></pre></td></tr></tbody></table></figure><p></p><br><p>3.使用匿名箭头函数返回方法<br>此方法会生成不可服用的匿名函数，但是这个方法是可以主动给调用方法传参数的，慎重使用。<br></p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, { Component } <span class="keyword">from</span>  <span class="string">‘react’</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">APP</span>  <span class="keyword">extends</span>  <span class="title">Component</span> </span>{</span><br><span class="line">OnClick () {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2333</span>)</span><br><span class="line">}</span><br><span class="line">render () {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;button  onClick={ () =&gt; <span class="keyword">this</span>.OnClick }&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br><span class="line"><span class="regexp">export default APP</span></span><br></pre></td></tr></tbody></table></figure><p></p><br><p>4.还有一种方法就是在jsx中bind，这个方法也可以给方法传参数而且不会产生不可复用的匿名函数，但是不好维护。和方法3各有优缺点吧（代码检查不允许在jsx中bind，所以放在了最后）<br></p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, { Component } <span class="keyword">from</span>  <span class="string">‘react’</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">APP</span>  <span class="keyword">extends</span>  <span class="title">Component</span> </span>{</span><br><span class="line">OnClick () {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2333</span>)</span><br><span class="line">}</span><br><span class="line">render () {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;button  onClick={ <span class="keyword">this</span>.OnClick.bind(<span class="keyword">this</span>) }&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp">}</span></span><br><span class="line"><span class="regexp">export default APP</span></span><br></pre></td></tr></tbody></table></figure><p></p><br><h3 id="使用Fetch，但是ie浏览器报错Fetch未定义，及其他浏览器set未定义Map未定义"><a href="#使用Fetch，但是ie浏览器报错Fetch未定义，及其他浏览器set未定义Map未定义" class="headerlink" title="使用Fetch，但是ie浏览器报错Fetch未定义，及其他浏览器set未定义Map未定义"></a>使用Fetch，但是ie浏览器报错Fetch未定义，及其他浏览器set未定义Map未定义</h3><p>Fetch是浏览器原生支持的，但是ie浏览器全系列都不支持promise，解决方案<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install whatwg-fetch</span><br></pre></td></tr></tbody></table></figure><p></p><br><p>然后项目<code>入口</code>文件内</p><br><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ‘whatwg-fetch’</span><br></pre></td></tr></tbody></table></figure><br><p>React使用了Es6的Set和Map数据结构低版本浏览器不支持，一劳永逸型方案(此方案是吧所有es6特性都通过es5函数模拟，弊端是会增加js文件体积，也可以自己百度挑单独的polyfill添加）<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install –save babel-polyfill</span><br><span class="line">入口文件内</span><br><span class="line">import ‘babel-polyfill’</span><br></pre></td></tr></tbody></table></figure><p></p><br><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>这个问题我也快被问烂了，真的太多人遇到了都不知道怎么吐槽<br>    1.使用<code>CORS</code> 跨域方案，后端配置前端无忧请求只支持IE10+。<br>    2.使用<code>nginx</code>反向代理，一劳永逸。<br>    3.Webpack有开发代理功能，自己去Webpack官网看，我记不住<br>    4.React官方脚手架<code>create-react-app</code>看<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#proxying-api-requests-in-development" target="_blank" rel="noopener">这里</a></p><br><h3 id="为什么我用import-style-from-‘-xxx-css’不管用啊还有为什么要这么用啊"><a href="#为什么我用import-style-from-‘-xxx-css’不管用啊还有为什么要这么用啊" class="headerlink" title="为什么我用import style from ‘../../xxx.css’不管用啊还有为什么要这么用啊"></a>为什么我用import style from ‘../../xxx.css’不管用啊还有为什么要这么用啊</h3><p>这种是为了使用css模块化，需要在webpack中配置看<a href="https://doc.webpack-china.org/loaders/css-loader/" target="_blank" rel="noopener">这里</a><br>其原理是给你的css类名随机化，或者添加随机后缀达到全局不会重复。用不用都行,自己衡量。</p><br><h3 id="为什么我使用BrowserRouter开发环境正常，部署之后刷新就是404"><a href="#为什么我使用BrowserRouter开发环境正常，部署之后刷新就是404" class="headerlink" title="为什么我使用BrowserRouter开发环境正常，部署之后刷新就是404"></a>为什么我使用BrowserRouter开发环境正常，部署之后刷新就是404</h3><p>这个问题是因为BrowserRouter 使用了HTML5的api导致每次url变化都是实际向服务器进行请求，所以需要后端收到前端路由请求之后都返回index.html。实在不会弄就去用HashRouter，url变化不会产生额外请求，因为他本质上一直是在/路径下</p><br><h3 id="我想拦截页面。或者在页面进入之前做一些事情"><a href="#我想拦截页面。或者在页面进入之前做一些事情" class="headerlink" title="我想拦截页面。或者在页面进入之前做一些事情"></a>我想拦截页面。或者在页面进入之前做一些事情</h3><p>请使用:<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">“/home”</span> render={(props) =&gt; &lt;div {…props}&gt;Home&lt;/div&gt;}/&gt;</span><br></pre></td></tr></tbody></table></figure><p></p><br><p>render接受一个函数会向函数附加一个参数，这个参数是所有的Router方法和参数，记得传给组件，可以在return之前做一些判断。</p><br><h3 id="xxx-is-not-a-function-这个问题我被问了无数遍"><a href="#xxx-is-not-a-function-这个问题我被问了无数遍" class="headerlink" title="xxx is not a function  这个问题我被问了无数遍"></a><code>xxx is not a function</code>  这个问题我被问了无数遍</h3><p>我不知道怎么解释，我也不想解释。</p><br><h3 id="Cannot-read-property-39-xxx-39-of-undefined-quot-这个问题比上面那个问题问的少一点或许吧。"><a href="#Cannot-read-property-39-xxx-39-of-undefined-quot-这个问题比上面那个问题问的少一点或许吧。" class="headerlink" title="Cannot read property 'xxx' of undefined&quot; 这个问题比上面那个问题问的少一点或许吧。"></a><code>Cannot read property ‘xxx’ of undefined”</code> 这个问题比上面那个问题问的少一点或许吧。</h3><p>这个一般都是组件内部引用了props传下来的值，但是父组件没传，或者引用了不存在的值。自己仔细检查。</p><br><h3 id="token-operator-xxxxx-这个问题问的人少。"><a href="#token-operator-xxxxx-这个问题问的人少。" class="headerlink" title="token: operator xxxxx 这个问题问的人少。"></a><code>token: operator xxxxx</code> 这个问题问的人少。</h3><p>少了括号，多了逗号，多了括号巴拉巴拉的。</p><br><h3 id="npm-run-build之后我打开index-html不能访问啊"><a href="#npm-run-build之后我打开index-html不能访问啊" class="headerlink" title="npm run build之后我打开index.html不能访问啊"></a><code>npm run build</code>之后我打开index.html不能访问啊</h3><pre><code>1. 给后端，让他给你弄。<br>2. 参考上一条。<br>3. 还不死心？那就打开index.html 吧文件路径改成./开头的就好了。<br></code></pre><h3 id="axios的-post-请求后台接受不到-直接抄原文的，我没遇到过，自己弄得垃圾node也只接受json格式化）"><a href="#axios的-post-请求后台接受不到-直接抄原文的，我没遇到过，自己弄得垃圾node也只接受json格式化）" class="headerlink" title="axios的 post 请求后台接受不到 (直接抄原文的，我没遇到过，自己弄得垃圾node也只接受json格式化）"></a><code>axios</code>的 <code>post</code> 请求后台接受不到 (直接抄原文的，我没遇到过，自己弄得垃圾node也只接受json格式化）</h3><p><code>axios</code>默认是 json 格式提交,确认后台是否做了对应的支持;</p><br><p>若是只能接受传统的表单序列化,就需要自己写一个转义的方法…</p><br><p>当然还有一个更加省事的方案,装一个小模块<code>qs</code><br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm install qs -S </span><br><span class="line"><span class="comment">// 然后在对应的地方转就行了..单一请求也行,拦截器也行…我是写在拦截器的. </span></span><br><span class="line"><span class="comment">// 具体可以看看我 axios 封装那篇文章 //POST传参序列化(添加请求拦截器) Axios.interceptors.request.use( config =&gt; { </span></span><br><span class="line"><span class="comment">// 在发送请求之前做某件事 </span></span><br><span class="line"><span class="keyword">if</span> ( config.method === <span class="string">“post”</span> ) { </span><br><span class="line"><span class="comment">// 序列化 </span></span><br><span class="line">config.data = qs.stringify(config.data); </span><br><span class="line"><span class="comment">// <strong>*</strong> 这里转义 } </span></span><br><span class="line"><span class="comment">// 若是有做鉴权token , 就给头部带上token </span></span><br><span class="line"><span class="keyword">if</span> (localStorage.token) { config.headers.Authorization = localStorage.token; } <span class="keyword">return</span> config; }, error =&gt; { Message({ </span><br><span class="line"><span class="comment">// 饿了么的消息弹窗组件,类似toast showClose: true, message: error, type: “error.data.error.message” }); </span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error.data.error.message); } );</span><br></pre></td></tr></tbody></table></figure><p></p><br><h3 id="Array-mapState-SOME-MUTATION-state-increment-commit-是什么"><a href="#Array-mapState-SOME-MUTATION-state-increment-commit-是什么" class="headerlink" title="[...Array],...mapState,[SOME_MUTATION] (state) {},increment ({ commit }) {}是什么"></a><code>[…Array]</code>,<code>…mapState</code>,<code>[SOME_MUTATION] (state) {}</code>,<code>increment ({ commit }) {}</code>是什么</h3><p>数组解构,对象解构,对象风格函数,对象解构赋值传递（第三个我也不知道）</p><br><h3 id="redux-的用户信息为什么还要存一遍在浏览器里-sessionStorage-or-localStorage"><a href="#redux-的用户信息为什么还要存一遍在浏览器里-sessionStorage-or-localStorage" class="headerlink" title="redux 的用户信息为什么还要存一遍在浏览器里(sessionStorage or localStorage)"></a>redux 的用户信息为什么还要存一遍在浏览器里(sessionStorage or localStorage)</h3><p>因为 <code>Redux</code>的 store 干不过刷新啊.<br>保存在浏览器的缓存内,若用户刷新的话,在从里面取一下信息</p><br><h3 id="有什么React-Redux-Router学习项目吗"><a href="#有什么React-Redux-Router学习项目吗" class="headerlink" title="有什么React+Redux+Router学习项目吗"></a>有什么React+Redux+Router学习项目吗</h3><p>偷偷放上自己的<a href="https://github.com/HiMrHu/cnode" target="_blank" rel="noopener">代码</a></p><br><h3 id="nginx部署"><a href="#nginx部署" class="headerlink" title="nginx部署"></a>nginx部署</h3><p>传送门:<a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F58bfc412da2f60124db5999a" target="_blank" rel="noopener">一篇不大靠谱的nginx 1.11.10配置文件</a></p><br><h3 id="为什么我的-npm-或者-yarn-安装依赖会生成-lock文件-有什么用"><a href="#为什么我的-npm-或者-yarn-安装依赖会生成-lock文件-有什么用" class="headerlink" title="为什么我的 npm 或者 yarn 安装依赖会生成 lock文件,有什么用"></a>为什么我的 <code>npm</code> 或者 <code>yarn</code> 安装依赖会生成 <code>lock</code>文件,有什么用</h3><p>版本锁工具，以前有次npm出现了npm到的包不是自己想要的，所以就用lock这个文件记录了下载地址包版本，加密的值。用于控制版本。保证包的前后一致。</p><br><h3 id="package-json里面的dependencies-和devDependencies的差异"><a href="#package-json里面的dependencies-和devDependencies的差异" class="headerlink" title="package.json里面的dependencies 和devDependencies的差异"></a><code>package.json</code>里面的<code>dependencies</code> 和<code>devDependencies</code>的差异</h3><p>其实不严格的话,没有特别的差异;<br>若是严格,遵循官方的理解;</p><br><ul><br><li><code>dependencies</code> : 存放线上或者业务能访问的核心代码模块,比如 <code>vue</code>,<code>vue-router</code>;</li><br><li><code>devDependencies</code>: 处于开发模式下所依赖的开发模块,也许只是用来解析代码,转义代码,但是不产生额外的代码到生产环境, 比如什么<code>babel-core</code>这些</li><br></ul><br><p>新版的npm已经不需要<code>–save</code> <code>–save-dev</code> 这指令的，当然也可以加上，npm会根据包的说明摆放位置的。<br>再说一遍代码打包看的是引入以及依赖关系，和在<code>dependencies</code>还是<code>devDependencies</code>放的没有一毛钱关系！！！！！！！！！！</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>POI实现excel的导入导出-[未采用反射实现的版本]</title>
      <link href="/2018/12/04/lao-bo-ke/poi-shi-xian-excel-de-dao-ru-dao-chu-wei-cai-yong-fan-she-shi-xian-de-ban-ben/"/>
      <url>/2018/12/04/lao-bo-ke/poi-shi-xian-excel-de-dao-ru-dao-chu-wei-cai-yong-fan-she-shi-xian-de-ban-ben/</url>
      
        <content type="html"><![CDATA[<p>最近在做项目中遇到了使用POI导入导出excel的需求,所以在这里总结下，方便自己和朋友学习:<br>1.经典博客:<br>    1.<a href="http://blog.csdn.net/Jack__Frost/article/details/77498797" target="_blank" rel="noopener">JavaWEB–POI之EXCEL操作、优化、封装详解系列（一）–概述与原理</a><br>    2.<a href="http://blog.csdn.net/wangchangpen62/article/details/44410967" target="_blank" rel="noopener">公共POI导出Excel方法–java</a><br>    3.<a href="https://www.cnblogs.com/java-class/p/5255024.html" target="_blank" rel="noopener">Apache POI 实现对 Excel 文件读写</a><br>    4.<a href="http://easypoi.mydoc.io/" target="_blank" rel="noopener">EasyPoi教程V1.0</a></p><p>2.原理:<br>原理如下图<br><img src="http://img.blog.csdn.net/20180116220557857?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3.代码:<br>POIController.java</p><pre><code>package com.spring.boot.gp4zj.controller;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.spring.boot.gp4zj.service.POIService;import cn.lz.cloud.common.service.ClazzNote;import cn.lz.cloud.common.service.ServiceNote;/** * 各种poi导入导出的请求控制模块; *  * @author:JunZhou * @Company:LongZheng * @Email:1769676159@qq.com * @2018年1月16日@下午4:28:49 */@RestController@RequestMapping(&quot;/poi&quot;)@ClazzNote(desc = &quot;excel文件&quot;, resource = &quot;input&quot;, modName = &quot;poi&quot;)public class POIController {    @Autowired    private POIService poiService;    // 获取考勤明细的excel文件;    @RequestMapping(&quot;/getAttenceDetailExcel&quot;)    @ServiceNote(desc = &quot;获取考勤明细的excel&quot;, auth = ServiceNote.AUTH.CHECK)    public void getAttenceDetailExcel(HttpServletResponse response) {        poiService.getAttenceDetailExcel(response);    }    // 读取考勤明细的excel文件;    @RequestMapping(&quot;/readAttenceDetailData&quot;)    @ServiceNote(desc = &quot;获取考勤明细的excel&quot;, auth = ServiceNote.AUTH.CHECK)    public void readAttenceDetailData() {    }}</code></pre><p>POIServiceImpl.java</p><pre><code>package com.spring.boot.gp4zj.service.impl;import java.io.IOException;import java.io.OutputStream;import java.util.List;import javax.servlet.http.HttpServletResponse;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.spring.boot.gp4zj.model.AttenceDetail;import com.spring.boot.gp4zj.model.SimulationVO;import com.spring.boot.gp4zj.service.AttenceDetailService;import com.spring.boot.gp4zj.service.POIService;import com.spring.boot.gp4zj.util.POIUtils;import cn.lz.cloud.common.service.ResList;/** * 获取excel的业务逻辑模块; * @author:JunZhou * @Company:LongZheng * @Email:1769676159@qq.com * @2018年1月16日@下午4:47:09 */@Servicepublic class POIServiceImpl implements POIService {    @Autowired    private AttenceDetailService attenceDetailService;    public void getAttenceDetailExcel(HttpServletResponse response) {        // TODO Auto-generated method stub        ResList&lt;AttenceDetail&gt;  list = attenceDetailService.selectAll(SimulationVO.getADSimulationVo());        List&lt;AttenceDetail&gt; excelData = list.getList();        HSSFWorkbook workbook = POIUtils.createExcel(excelData);        OutputStream out = null;        if (workbook != null) {            try {                String fileName = &quot;Excel-&quot; + String.valueOf(System.currentTimeMillis()).substring(4, 13) + &quot;.xls&quot;;                String headStr = &quot;attachment; filename=\&quot;&quot; + fileName + &quot;\&quot;&quot;;                response.setContentType(&quot;APPLICATION/OCTET-STREAM&quot;);                response.setHeader(&quot;Content-Disposition&quot;, headStr);                out = response.getOutputStream();                workbook.write(out);                out.flush();                out.close();            } catch (IOException e) {                e.printStackTrace();            } finally {                try {                    out.flush();                    out.close();                } catch (IOException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }            }        }    }}</code></pre><p>POIUtils.java</p><pre><code>package com.spring.boot.gp4zj.util;import java.io.FileInputStream;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFCellStyle;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import com.spring.boot.gp4zj.model.AttenceDetail;/** * Excel操作相关的工具类; *  * @author:JunZhou * @Company:LongZheng * @Email:1769676159@qq.com * @2018年1月16日@下午3:19:25 */public class POIUtils {    public static void main(String[] args) {        List&lt;AttenceDetail&gt; list = readExcel();        /*for (int i = 0; i &lt; list.size(); i++) {            System.out.println(list.get(i).toString());        }*/        System.out.println(list.get(0).toString());    }    /**     * 创建Excel     *      * @param list     *            数据     */    public static HSSFWorkbook createExcel(List&lt;AttenceDetail&gt; list) {        // 创建一个Excel文件        HSSFWorkbook workbook = new HSSFWorkbook();        // 创建一个工作表        HSSFSheet sheet = workbook.createSheet(&quot;考勤明细表&quot;);        // 添加表头行        HSSFRow hssfRow = sheet.createRow(0);        // 设置单元格格式居中        HSSFCellStyle cellStyle = workbook.createCellStyle();        cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);        // 添加表头内容        // -------第一行第0-2列---------        HSSFCell headCell = hssfRow.createCell(0);        headCell.setCellValue(&quot;考勤日期&quot;);        headCell.setCellStyle(cellStyle);        headCell = hssfRow.createCell(1);        headCell.setCellValue(&quot;考勤名称&quot;);        headCell.setCellStyle(cellStyle);        headCell = hssfRow.createCell(2);        headCell.setCellValue(&quot;员工编码&quot;);        headCell.setCellStyle(cellStyle);        // -----------------------        headCell = hssfRow.createCell(3);        headCell.setCellValue(&quot;出勤时长&quot;);        headCell.setCellStyle(cellStyle);        headCell = hssfRow.createCell(4);        headCell.setCellValue(&quot;加班时长&quot;);        headCell.setCellStyle(cellStyle);        headCell = hssfRow.createCell(5);        headCell.setCellValue(&quot;合计出勤时长&quot;);        headCell.setCellStyle(cellStyle);        // -----------------------        headCell = hssfRow.createCell(6);        headCell.setCellValue(&quot;报工单位&quot;);        headCell.setCellStyle(cellStyle);        headCell = hssfRow.createCell(7);        headCell.setCellValue(&quot;结算单位&quot;);        headCell.setCellStyle(cellStyle);        headCell = hssfRow.createCell(8);        headCell.setCellValue(&quot;创建人&quot;);        headCell.setCellStyle(cellStyle);        // -----------------------        headCell = hssfRow.createCell(9);        headCell.setCellValue(&quot;出勤人天&quot;);        headCell.setCellStyle(cellStyle);        headCell = hssfRow.createCell(10);        headCell.setCellValue(&quot;加班人天&quot;);        headCell.setCellStyle(cellStyle);        headCell = hssfRow.createCell(11);        headCell.setCellValue(&quot;合计人天&quot;);        headCell.setCellStyle(cellStyle);        // -----------------------        headCell = hssfRow.createCell(12);        headCell.setCellValue(&quot;是否删除汇总表&quot;);        headCell.setCellStyle(cellStyle);        headCell = hssfRow.createCell(13);        headCell.setCellValue(&quot;是否确认&quot;);        headCell.setCellStyle(cellStyle);        headCell = hssfRow.createCell(14);        headCell.setCellValue(&quot;创建时间&quot;);        headCell.setCellStyle(cellStyle);        // -----------------------        headCell = hssfRow.createCell(15);        headCell.setCellValue(&quot;修改时间&quot;);        headCell.setCellStyle(cellStyle);        // 添加数据内容        for (int i = 0; i &lt; list.size(); i++) {            hssfRow = sheet.createRow((int) i + 1);            AttenceDetail attenceDetail = list.get(i);            // 创建单元格，并设置值            HSSFCell cell = hssfRow.createCell(0);            cell.setCellValue(attenceDetail.getAttencedTime());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(1);            cell.setCellValue(attenceDetail.getAttencerName());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(2);            cell.setCellValue(attenceDetail.getAttencerCode());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(3);            cell.setCellValue(attenceDetail.getWorkTimeLen());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(4);            cell.setCellValue(attenceDetail.getExtraTimeLen());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(5);            cell.setCellValue(attenceDetail.getTotalTimeLen());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(6);            cell.setCellValue(attenceDetail.getApplyCompany());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(7);            cell.setCellValue(attenceDetail.getPayCompany());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(8);            cell.setCellValue(attenceDetail.getCreator());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(9);            cell.setCellValue(attenceDetail.getWorkDayNum());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(10);            cell.setCellValue(attenceDetail.getExtraDayNum());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(11);            cell.setCellValue(attenceDetail.getTotalDayNum());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(12);            cell.setCellValue(attenceDetail.getIsDelGather());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(13);            cell.setCellValue(attenceDetail.getIsConfirmed());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(14);            cell.setCellValue(attenceDetail.getCreateTime());            cell.setCellStyle(cellStyle);            cell = hssfRow.createCell(15);            cell.setCellValue(attenceDetail.getEditTime());            cell.setCellStyle(cellStyle);        }        /*// 保存Excel文件        try {            OutputStream outputStream = new FileOutputStream(&quot;D:/students.xls&quot;);            workbook.write(outputStream);            outputStream.close();        } catch (Exception e) {            e.printStackTrace();        }*/        return workbook;    }    /**     * 接收上传的excel并读取其中的信息;     */    public static List&lt;AttenceDetail&gt; readExcel(){        List&lt;AttenceDetail&gt; list = new ArrayList&lt;AttenceDetail&gt;();        HSSFWorkbook workbook = null;        try {            // 读取Excel文件            InputStream inputStream = new FileInputStream(&quot;D:/Excel-095968073.xls&quot;);            workbook = new HSSFWorkbook(inputStream);            inputStream.close();        } catch (Exception e) {            e.printStackTrace();        }        // 循环工作表        for (int numSheet = 0; numSheet &lt; workbook.getNumberOfSheets(); numSheet++) {            HSSFSheet hssfSheet = workbook.getSheetAt(numSheet);            if (hssfSheet == null) {                continue;            }            // 循环行            for (int rowNum = 1; rowNum &lt;= hssfSheet.getLastRowNum(); rowNum++) {                HSSFRow hssfRow = hssfSheet.getRow(rowNum);                if (hssfRow == null) {                    continue;                }                // 将单元格中的内容存入集合                AttenceDetail attenceDetail = new AttenceDetail();                HSSFCell cell = hssfRow.getCell(0);                if (cell == null) {                    continue;                }                attenceDetail.setAttencedTime(cell.getStringCellValue());                cell = hssfRow.getCell(1);                if (cell == null) {                    continue;                }                attenceDetail.setAttencerName(cell.getStringCellValue());                cell = hssfRow.getCell(2);                if (cell == null) {                    continue;                }                attenceDetail.setAttencerCode(cell.getStringCellValue());                //-------------------------------                cell = hssfRow.getCell(3);                if (cell == null) {                    continue;                }                attenceDetail.setWorkTimeLen(cell.getStringCellValue());                cell = hssfRow.getCell(4);                if (cell == null) {                    continue;                }                attenceDetail.setExtraTimeLen(cell.getStringCellValue());                cell = hssfRow.getCell(5);                if (cell == null) {                    continue;                }                attenceDetail.setTotalTimeLen(cell.getStringCellValue());              //-------------------------------                cell = hssfRow.getCell(6);                if (cell == null) {                    continue;                }                attenceDetail.setApplyCompany(cell.getStringCellValue());                cell = hssfRow.getCell(7);                if (cell == null) {                    continue;                }                attenceDetail.setPayCompany(cell.getStringCellValue());              //-------------------------------                cell = hssfRow.getCell(8);                if (cell == null) {                    continue;                }                attenceDetail.setCreator(cell.getStringCellValue());                cell = hssfRow.getCell(9);                if (cell == null) {                    continue;                }                attenceDetail.setWorkDayNum(cell.getStringCellValue());                cell = hssfRow.getCell(10);                if (cell == null) {                    continue;                }                attenceDetail.setExtraDayNum(cell.getStringCellValue());                //-------------------------------                cell = hssfRow.getCell(11);                if (cell == null) {                    continue;                }                attenceDetail.setTotalDayNum(cell.getStringCellValue());                cell = hssfRow.getCell(12);                if (cell == null) {                    continue;                }                attenceDetail.setIsDelGather(cell.getStringCellValue());                cell = hssfRow.getCell(13);                if (cell == null) {                    continue;                }                attenceDetail.setIsConfirmed(cell.getStringCellValue());                cell = hssfRow.getCell(14);                if (cell == null) {                    continue;                }                attenceDetail.setCreateTime(cell.getStringCellValue());              //-------------------------------                cell = hssfRow.getCell(15);                if (cell == null) {                    continue;                }                attenceDetail.setEditTime(cell.getStringCellValue());                list.add(attenceDetail);            }        }        return list;    }}</code></pre><p>这部份的代码由于没有采用反射实现，效率较高，但是代码冗余和灵活性不高，所以接下来将采用反射实现.。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>POI实现excel的导入导出-[采用反射实现的版本]</title>
      <link href="/2018/12/04/lao-bo-ke/poi-shi-xian-excel-de-dao-ru-dao-chu-cai-yong-fan-she-shi-xian-de-ban-ben/"/>
      <url>/2018/12/04/lao-bo-ke/poi-shi-xian-excel-de-dao-ru-dao-chu-cai-yong-fan-she-shi-xian-de-ban-ben/</url>
      
        <content type="html"><![CDATA[<p>前段时间学习了POI实现excel的导入导出-[未采用反射实现的版本]的文章，觉得不采用反射实现非常不合理，在祥哥【我眼中的大佬】的指导下实现了POI实现excel的导入导出-[采用反射实现的版本]的实现。<br>A、具体的要点如下:</p><hr><p>1、采用泛型，增加代码的灵活性和可扩展性；<br>2、使用适配器模式；<br>3、使用反射自动执行对应字段的方法；<br>4、绑定字段的值和表头文字【采用linkedhashmap()】实现；</p><p>B、代码</p><hr><p>ExcelVO.java</p><pre><code>package com.spring.boot.gp4zj.util;import java.util.List;import java.util.Map;/** * excel导入导出相关的必须信息; *  * @author xdsm * */public class ExcelVO&lt;T&gt; {    // 表头列表;    Map&lt;String, String&gt; workBookHeaderFields = null;    // excel中的数据值对象;    List&lt;T&gt; workBookVos = null;    // 泛型数据对象;    T clazzRes = null;    public List&lt;T&gt; getWorkBookVos() {        return workBookVos;    }    public void setWorkBookVos(List&lt;T&gt; workBookVos) {        this.workBookVos = workBookVos;    }    public Map&lt;String, String&gt; getWorkBookHeaderFields() {        return workBookHeaderFields;    }    public void setWorkBookHeaderFields(Map&lt;String, String&gt; workBookHeaderFields) {        this.workBookHeaderFields = workBookHeaderFields;    }    public T getClazzRes() {        return clazzRes;    }    public void setClazzRes(T clazzRes) {        this.clazzRes = clazzRes;    }}</code></pre><p>POIUtils.java</p><pre><code>package com.spring.boot.gp4zj.util;import java.io.FileInputStream;import java.io.InputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Map.Entry;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFCellStyle;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import com.spring.boot.gp4zj.model.AttenceDetail;import com.spring.boot.gp4zj.model.ExcelVOMapper;/** * Excel操作相关的工具类; *  * @author:JunZhou * @Company:LongZheng * @Email:1769676159@qq.com * @2018年1月16日@下午3:19:25 */public class POIUtils2 {    public static void main(String[] args) throws Exception {        /*         * AttenceDetail clazzRes = new AttenceDetail(); // 测试数据;         * ExcelVO&lt;AttenceDetail&gt; excelVo = new ExcelVO&lt;AttenceDetail&gt;();         * excelVo.setClazzRes(clazzRes);         *          * @SuppressWarnings(&quot;unused&quot;) List&lt;String&gt; workBookHeaderFields = new         * ArrayList&lt;String&gt;(); final Map&lt;String, String&gt; HEADER_FIELDS = new         * LinkedHashMap&lt;String, String&gt;(); HEADER_FIELDS.put(&quot;考勤日期&quot;,         * &quot;attencedTime&quot;); HEADER_FIELDS.put(&quot;考勤名称&quot;, &quot;attencerName&quot;);         * HEADER_FIELDS.put(&quot;员工编码&quot;, &quot;attencerCode&quot;); HEADER_FIELDS.put(&quot;出勤时长&quot;,         * &quot;workTimeLen&quot;); HEADER_FIELDS.put(&quot;加班时长&quot;, &quot;extraTimeLen&quot;);         * HEADER_FIELDS.put(&quot;合计出勤时长&quot;, &quot;totalTimeLen&quot;);         * HEADER_FIELDS.put(&quot;报工单位&quot;, &quot;applyCompany&quot;); HEADER_FIELDS.put(&quot;结算单位&quot;,         * &quot;payCompany&quot;); HEADER_FIELDS.put(&quot;创建人&quot;, &quot;creator&quot;);         * HEADER_FIELDS.put(&quot;出勤人天&quot;, &quot;workDayNum&quot;); HEADER_FIELDS.put(&quot;加班人天&quot;,         * &quot;extraDayNum&quot;); HEADER_FIELDS.put(&quot;合计人天&quot;, &quot;totalDayNum&quot;);         * HEADER_FIELDS.put(&quot;是否删除汇总表&quot;, &quot;isDelGather&quot;);         * HEADER_FIELDS.put(&quot;是否确认&quot;, &quot;isConfirmed&quot;); HEADER_FIELDS.put(&quot;创建时间&quot;,         * &quot;createTime&quot;); HEADER_FIELDS.put(&quot;修改时间&quot;, &quot;editTime&quot;); // 生成测试数据;         * excelVo.setWorkBookHeaderFields(HEADER_FIELDS); List&lt;AttenceDetail&gt;         * workBookVos = TestDataGenerater.attenceDetailTestDatasGenerater(2);         * excelVo.setWorkBookVos(workBookVos); createExcel(excelVo);         */        String excelPath = &quot;C:/Users/xdsm/Desktop/Excel-900500219.xls&quot;;        AttenceDetail attenceDetailClazz = new AttenceDetail();        List&lt;AttenceDetail&gt; attenctDetailList = readExcel(excelPath, attenceDetailClazz);        for (AttenceDetail attenceDetail : attenctDetailList) {            System.out.println(attenceDetail);        }    }    /**     * 创建Excel     *      * @param &lt;T&gt;     *      * @param list     *            数据     */    @SuppressWarnings({ &quot;unchecked&quot;, &quot;unused&quot; })    public static &lt;T&gt; HSSFWorkbook createExcel(ExcelVO&lt;T&gt; excelVo) {        @SuppressWarnings(&quot;rawtypes&quot;)        Class clazz = excelVo.getClazzRes().getClass();        // 表头信息列表;        List&lt;String&gt; workBookHeaderFields = new ArrayList&lt;String&gt;();        Map&lt;String, String&gt; headerFields = excelVo.getWorkBookHeaderFields();        // 表格数据信息列表;        List&lt;T&gt; dataList = excelVo.getWorkBookVos();        // 创建一个Excel文件        HSSFWorkbook workbook = new HSSFWorkbook();        // 创建一个工作表        HSSFSheet sheet = workbook.createSheet(&quot;考勤明细表&quot;);        // 添加表头行        HSSFRow hssfRow = sheet.createRow(0);        // 设置单元格格式居中        HSSFCellStyle cellStyle = workbook.createCellStyle();        cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);        // 添加表头内容        // -------第一行第0-2列---------        // 设置表头的相关信息;        int headTitleIndex = 0;        HSSFCell headCell = null;// 此处使用同一个引用对象，可以节省内存;        for (Entry&lt;String, String&gt; vo : headerFields.entrySet()) {            // 表头的名称字段;            if (headTitleIndex == 0) {                headCell = hssfRow.createCell(headTitleIndex);                headCell.setCellValue(vo.getKey());                headCell.setCellStyle(cellStyle);            } else {                headCell = hssfRow.createCell(headTitleIndex);                headCell.setCellValue(vo.getKey());                headCell.setCellStyle(cellStyle);            }            headTitleIndex++;        }        // 填充数据到工作簿;        for (int i = 0; i &lt; dataList.size(); i++) {            // 创建数据行;            hssfRow = sheet.createRow((int) i + 1);            T attenceDetail = dataList.get(i);            // 创建单元格，并设置值            int fieldVoIndex = 0;            HSSFCell cell = null;// 此处使用同一个引用对象，可以节省内存;            for (Entry&lt;String, String&gt; vo : headerFields.entrySet()) {                // 字段值取值器;                String fieldVoGetter = &quot;get&quot; + (vo.getValue()).substring(0, 1).toUpperCase()                        + (vo.getValue()).substring(1);                cell = hssfRow.createCell(fieldVoIndex);                // TODO Auto-generated                Method method;                try {                    String invokeResultStr = null;                    method = clazz.getMethod(fieldVoGetter);                    Object methodResult = method.invoke(attenceDetail);                    if (methodResult != null) {                        invokeResultStr = methodResult.toString();                    }                    cell.setCellValue(invokeResultStr);                    cell.setCellStyle(cellStyle);                } catch (Exception e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }                // method.invoke(clazz.newInstance());                fieldVoIndex++;            }        }        return workbook;    }    /**     * 接收上传的excel并读取其中的信息;     *      * @throws IllegalAccessException     * @throws Exception     */    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })    public static &lt;T&gt; List&lt;T&gt; readExcel(String excelPath, T clazzRes) throws Exception {        Class clazz = clazzRes.getClass();        List&lt;T&gt; list = new ArrayList&lt;T&gt;();        HSSFWorkbook workbook = null;        try {            // 读取Excel文件            InputStream inputStream = new FileInputStream(excelPath);            workbook = new HSSFWorkbook(inputStream);            inputStream.close();        } catch (Exception e) {            e.printStackTrace();        }        // 循环工作表        for (int numSheet = 0; numSheet &lt; workbook.getNumberOfSheets(); numSheet++) {            HSSFSheet hssfSheet = workbook.getSheetAt(numSheet);            if (hssfSheet == null) {                continue;            }            // 循环行            for (int rowNum = 1; rowNum &lt; hssfSheet.getLastRowNum(); rowNum++) {                HSSFRow hssfRow = hssfSheet.getRow(rowNum);                if (hssfRow == null) {                    continue;                }                // 填充数据到行;                Map&lt;String, String&gt; HEADER_FIELDS = ExcelVOMapper.getAttenceDetailMapper();                HSSFCell cell = null;// 公用cell，节省内存的开销;                // 每行的数据对象;                T dataVo = (T) clazz.newInstance();                int fieldVoIndex = 0;                for (Entry&lt;String, String&gt; vo : HEADER_FIELDS.entrySet()) {                    // 字段值取值器;                    String fieldVoSetter = &quot;set&quot; + (vo.getValue()).substring(0, 1).toUpperCase()                            + (vo.getValue()).substring(1);                    // TODO Auto-generated                    Method method;                    try {                        cell = hssfRow.getCell(fieldVoIndex);                        if (cell == null) {                            continue;                        }                        method = clazz.getMethod(fieldVoSetter, String.class);                        String cellValue = cell.getStringCellValue();                        /*                         * if(cellValue==null||&quot;&quot;.equals(cellValue)){ // 空数据列测试;                         * if (fieldVoIndex == 1) { throw new                         * MyException(&quot;员工编码不能为空&quot;); } }                         */                        // System.out.println(cellValue);                        method.invoke(dataVo, cellValue);                    } catch (Exception e) {                        // TODO Auto-generated catch block                        e.printStackTrace();                    }                    fieldVoIndex++;                }                list.add(dataVo);            }        }        return list;    }    /**     * 获取指定数据类型的所有声明字段;     *      * @param dataObj:泛型对象;     * @return:返回字段列表【String】;     */    public static &lt;T&gt; List&lt;String&gt; getAllFields(T dataObj) {        Class&lt;? extends Object&gt; dataObjClazz = dataObj.getClass();        Field[] fields = dataObjClazz.getDeclaredFields();        List&lt;String&gt; fieldsList = new ArrayList&lt;String&gt;();        for (int i = 0; i &lt; fields.length; i++) {            String fieldStr = fields[i].toString();            String realFieldStr = fieldStr.substring(fieldStr.lastIndexOf(&quot;.&quot;) + 1);            fieldsList.add(realFieldStr);        }        return fieldsList;    }    /**     * 获取对象中的所有已声明的方法名;     *      * @param dataObj:泛型对象;     * @return:返回方法列表【String】;     */    public static &lt;T&gt; List&lt;String&gt; getAllMethods(T dataObj) {        List&lt;String&gt; methodsList = new ArrayList&lt;String&gt;();        Class&lt;? extends Object&gt; dataObjClazz = dataObj.getClass();        Method[] methods = dataObjClazz.getDeclaredMethods();        for (int i = 0; i &lt; methods.length; i++) {            String fieldStr = methods[i].toString();            if (fieldStr.contains(&quot;get&quot;)) {                String realFieldStr = fieldStr.substring(fieldStr.lastIndexOf(&quot;.&quot;) + 1, fieldStr.lastIndexOf(&quot;(&quot;));                methodsList.add(realFieldStr);            }        }        return methodsList;    }    /**     * 获取对象中的所有已声明的方法名;     *      * @param dataObj:泛型对象;     * @return:返回方法列表【String】;     */    public static &lt;T&gt; List&lt;String&gt; getAllSetMethods(T dataObj) {        List&lt;String&gt; methodsList = new ArrayList&lt;String&gt;();        @SuppressWarnings(&quot;unused&quot;)        Class&lt;? extends Object&gt; dataObjClazz = dataObj.getClass();        List&lt;String&gt; methods = getAllFields(dataObj);        for (int i = 0; i &lt; methods.size(); i++) {            String fieldStr = methods.get(i).toString();            String methodName = &quot;set&quot; + fieldStr.substring(0, 1).toUpperCase() + fieldStr.substring(1);            methodsList.add(methodName);        }        return methodsList;    }}</code></pre><p>C、使用要点</p><hr><p>1、本工具类的使用前提是所有的字段均采用驼峰命名方式，且前两个字母为小写【因为eclipse自动生成的getter和setter会根据前两个字母进行自适应处理，并非固定模式】<br>2、本工具类并未对导入数据进行全面的非空或者类型等校验，具体的校验可自行添加。<br>3、本工具类因为采用的是反射是想，因此执行效率较低;<br>D、参考文章.<br><a href="https://www.cnblogs.com/fingerboy/p/5468994.html" target="_blank" rel="noopener">设计模式–观察者模式初探和java Observable模式</a><br><a href="http://easypoi.mydoc.io/" target="_blank" rel="noopener">EasyPoi教程V1.0</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>POI的基本使用</title>
      <link href="/2018/12/04/lao-bo-ke/poi-de-ji-ben-shi-yong/"/>
      <url>/2018/12/04/lao-bo-ke/poi-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<p><em>POI的基本使用</em></p><p>首先，理解一下一个Excel的文件的组织形式，一个Excel文件对应于一个workbook(HSSFWorkbook)，一个workbook可以有多个sheet（HSSFSheet）组成，一个sheet是由多个row（HSSFRow）组成，一个row是由多个cell（HSSFCell）组成。 </p><p>POI可以到<a href="http://www.apache.org下载到。实际运行时，需要有poi包就可以了。HSSF提供给用户使用的对象在*rg.apache.poi.hssf.usermodel*包中,主要部分包括Excel对象，样式和格式，还有辅助操作。有以下几种对象" target="_blank" rel="noopener">www.apache.org下载到。实际运行时，需要有poi包就可以了。HSSF提供给用户使用的对象在*rg.apache.poi.hssf.usermodel*包中,主要部分包括Excel对象，样式和格式，还有辅助操作。有以下几种对象</a></p><p><img src="http://img.blog.csdn.net/20170707174737152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><p><strong>下面详细介绍POI操作的具体实例和思路:</strong></p><hr><p><strong><em>导出大体思路如下：</em></strong><br>1.先创建文件对象，<br>2.文件对象创建sheet页对象，<br>3.sheet页对象创建行对象，<br>4.行对象创建单元格填入数据<br>5.保存文档使用流将文件导出到服务器中转站<br>6.在由服务器中转站导出（下载功能）到指定文件夹<br>7.导出完成</p><p>实际操作poi报表进行导出excel文档时的实例如下：<br>第一步，创建一个webbook，对应一个Excel文件<br>步骤1：HSSFWorkbook wb = new HSSFWorkbook();<br>第二步，在webbook中添加一个sheet页,对应Excel文件中的sheet页</p><p>以下createSheet中填写sheet页名称  并非文件名称<br>步骤2：HSSFSheet sheet = wb.createSheet(“学生表一”);<br>第三步，在sheet中添加表头第0行,注意老版本poi对Excel的行数列数有限制short<br>步骤3：HSSFRow row = sheet.createRow((int) 0);<br>第四步，创建一个居中格式，在创建单元格是设置居中格式<br>步骤4：<br>HSSFCellStyle style = wb.createCellStyle();<br>style.setAlignment(HSSFCellStyle.ALIGN_CENTER);<br>第五步，创建单元格填入数据并设置居中格式<br>步骤5：<br>①创建单元格：<br>HSSFCell cell = row.createCell((short) 0);<br>②设置单元格内容：<br>cell.setCellValue(“内容”);<br>③将以上创建好的居中格式添加进单元格：cell.setCellStyle(style);<br>第六步，使用字节输出流将文件存入指定路径<br>FileOutputStream fout = new FileOutputStream(“指定路径”);<br>wb.write(fout);<br>fout.close();</p><p>注意：区分创建行使用（int）创建列使用（short）<br>基本操作：<br>创建Excel对象：new HSSFWorkbook();<br>创建sheet页：<strong>(Excel对象).createSheet(“学生表一”);<br>创建行：</strong>（sheet对象）.createRow((int) 0);<br>创建列：<strong>(行对象).createCell((short) 0);<br>创建一个样式对象：</strong>（Excel对象）.createCellStyle();<br>添加居中格式：**（样式对象）.setAlignment(HSSFCellStyle.ALIGN_CENTER);</p><hr><p><strong><em>导入大体思路如下</em></strong><br>1.使用 BufferedInputStream输入流 读取Excel文档<br>2.得到文件后采用POIFSFileSystem 进行解析并转为HSSFWorkbook对象<br>3.使用HSSFWorkbook对象.getSheetAt(0);获取该Excel的第一个sheet页<br>4.Sheet. getLastRowNum()获取该sheet页的数据条数进行for循环每一条数据【for（int i= 0 ； i&lt; Sheet. getLastRowNum();i++）】<br>5.HSSFRow row =Sheet.getRow(i)获取此行数据<br>6.Row. getLastCellNum()获取本行有N条数据<br>7.row.getCell(columnIndex);获取单元格并导出值存入相应的对象中<br>8.使用存好的对象进行数据库添加操作<br>9.导入完成</p><p>具体导入操作实例：<br>第一步、创建输入流并转换为HSSFWorkbook对象<br>1、BufferedInputStream  in = new<br>BufferedInputStream(new FileInputStream(new File(“文件路径”)));<br>2、POIFSFileSystem fs = new POIFSFileSystem(in);<br>3、HSSFWorkbook wb = new HSSFWorkbook(fs);<br>第二步、用HSSFWorkbook获取第一个sheet页（sheet页下标从0开始）<br>HSSFSheet st = wb.getSheetAt(0);<br>第三步使用for循环循环每条数据（行）并获取行对象<br>for (int rowIndex = 0; rowIndex &lt;= st.getLastRowNum(); rowIndex++) {<br>            HSSFRow row = st.getRow(rowIndex);<br>}<br>第四步循环行对象并获取单元格对象<br>for (short columnIndex = 0, size = row.getLastCellNum(); columnIndex &lt;= size; columnIndex++) {<br>                cell = row.getCell(columnIndex);<br>}<br>第五步将单元格中不同格式的的值以不同方式导出（可以直接复制使用）最终value为单元中的值可进行任意操作<br>if (cell != null) {<br>                    switch (cell.getCellType()) {<br>                    case HSSFCell.CELL_TYPE_STRING:<br>                        value = cell.getStringCellValue();<br>                        break;<br>                    case HSSFCell.CELL_TYPE_NUMERIC:<br>                        if (HSSFDateUtil.isCellDateFormatted(cell)) {<br>                            Date date = cell.getDateCellValue();<br>                            if (date != null) {<br>                                value = new SimpleDateFormat(“yyyy-MM-dd HH:mm:SS”)<br>                                .format(date);<br>                            } else {<br>                                value = “”;<br>                            }<br>                        } else {<br>                            value = new DecimalFormat(“0”).format(cell<br>                                    .getNumericCellValue());<br>                        }<br>                        break;<br>                    case HSSFCell.CELL_TYPE_FORMULA:<br>                        // 导入时如果为公式生成的数据则无值<br>                        if (!cell.getStringCellValue().equals(“”)) {<br>                            value = cell.getStringCellValue();<br>                        } else {<br>                            value = cell.getNumericCellValue() + “”;<br>                        }<br>                        break;<br>                    case HSSFCell.CELL_TYPE_BLANK:<br>                        break;<br>                    case HSSFCell.CELL_TYPE_ERROR:<br>                        value = “”;<br>                        break;<br>                    case HSSFCell.CELL_TYPE_BOOLEAN:<br>                        value = (cell.getBooleanCellValue() == true ? “Y”<br>                                : “N”);<br>                        break;<br>                    default:<br>                        value = “”;<br>                    }</p><p>} </p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Object.assign() 方法详解</title>
      <link href="/2018/12/04/lao-bo-ke/object.assign-fang-fa-xiang-jie/"/>
      <url>/2018/12/04/lao-bo-ke/object.assign-fang-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p><code><strong>Object.assign()</strong></code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><h2 id="Syntax" name="Syntax">语法</h2><pre class="syntaxbox"><code>Object.assign(<var>target</var>, ...<var>sources</var>)</code></pre><h3 id="Parameters" name="Parameters" class="highlight-spanned"><span class="highlight-span">参数</span></h3><dl><br> <dt><code>target</code></dt><br> <dd>目标对象。</dd><br> <dt><code>sources</code></dt><br> <dd>源对象。</dd><br></dl><h3 id="Return_value" name="Return_value" class="highlight-spanned"><span class="highlight-span">返回值</span></h3><p>目标对象。</p><h2 id="描述">描述</h2><p>如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。</p><p><code>Object.assign</code> 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的<code>[[Get]]</code>和目标对象的<code>[[Set]]</code>，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用<a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" title="Object.getOwnPropertyDescriptor()&nbsp;方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）"><code>Object.getOwnPropertyDescriptor()</code></a>和<a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" title="Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。"><code>Object.defineProperty()</code></a>&nbsp;。</p><p><a href="/zh-CN/docs/Web/JavaScript/Reference/String" title="此页面仍未被本地化, 期待您的翻译!"><code>String</code></a>类型和 <a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" title="Symbol()函数会返回symbol?类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：&quot;new Symbol()&quot;。"><code>Symbol</code></a> 类型的属性都会被拷贝。</p><p>在出现错误的情况下，例如，如果属性不可写，会引发<a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError" title="TypeError（类型错误）&nbsp;对象用来表示值的类型非预期类型时发生的错误。"><code>TypeError</code></a>，如果在引发错误之前添加了任何属性，则可以更改<code>target</code>对象。</p><p>注意，<code>Object.assign</code> 会跳过那些值为 <a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" title="值&nbsp;null&nbsp;是一个 JavaScript 字面量，表示空值（null or an &quot;empty&quot; value），即没有对象被呈现（no object value is present）。它是 JavaScript 原始值 之一。"><code>null</code></a> 或 <a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。"><code>undefined</code></a> 的源对象。</p><h2 id="Examples" name="Examples">示例</h2><h3 id="Example:_Cloning_an_object" name="Example:_Cloning_an_object" class="highlight-spanned"><span class="highlight-span">复制一个对象</span></h3><pre class="brush: js line-numbers  language-js"><code class=" language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> copy <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 1 }</span><span class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Deep_Clone" name="Deep_Clone" class="highlight-spanned"><span class="highlight-span">深拷贝问题</span></h3><p>针对深拷贝，需要使用其他方法，因为&nbsp;<code>Object.assign()</code>拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。</p><pre class="brush: js line-numbers  language-js"><code class=" language-js"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token string">'use strict'</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span> c<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 0, b: { c: 0}}</span>  obj1<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 1, b: { c: 0}}</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 0, b: { c: 0}}</span>  obj2<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 1, b: { c: 0}}</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 2, b: { c: 0}}</span>  obj2<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 1, b: { c: 3}}</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 2, b: { c: 3}}</span>  <span class="token comment" spellcheck="true">// Deep Clone</span>  obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span> c<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> obj3 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  obj1<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  obj1<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 0, b: { c: 0}}</span><span class="token punctuation">}</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>底层原理图如下:<br><img src="http://img.blog.csdn.net/20171220213550534?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>nodejs npm install -g 全局安装和非全局安装的区别</title>
      <link href="/2018/12/04/lao-bo-ke/nodejs-npm-install-g-quan-ju-an-zhuang-he-fei-quan-ju-an-zhuang-de-qu-bie/"/>
      <url>/2018/12/04/lao-bo-ke/nodejs-npm-install-g-quan-ju-an-zhuang-he-fei-quan-ju-an-zhuang-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>1、<a href="https://blog.csdn.net/ylhsuper/article/details/71082466" target="_blank" rel="noopener">nodejs npm install -g 全局安装和非全局安装的区别</a><br>2、<a href="https://www.jianshu.com/p/2e7f3b69e51e" target="_blank" rel="noopener">npm install -S -D -g 有什么区别</a><br>3、<a href="https://segmentfault.com/q/1010000010864391" target="_blank" rel="noopener">npm install -g 和npm install –save-dev的关系</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Nginx实现文件下载限速的功能</title>
      <link href="/2018/12/04/lao-bo-ke/nginx-shi-xian-wen-jian-xia-zai-de-xian-su-gong-neng/"/>
      <url>/2018/12/04/lao-bo-ke/nginx-shi-xian-wen-jian-xia-zai-de-xian-su-gong-neng/</url>
      
        <content type="html"><![CDATA[<p>同一时刻对服务器上文件的大量的高速访问，可能会极大的增加服务器的负担，为了缓解服务器的I/O负担，如果配置了nginx服务器，建议进行限速，具体实现如下:</p><hr><p>首先在 http 段配置一个 limit_zone，然后在需要的地方使用 limit_conn 和 limit_rate 进行限速设置,如下一个简单的例子。</p><pre><code>http {  limit_zone one $binary_remote_addr 10m;  server {    location /files/ {      limit_conn one 1;      limit_rate_after 1000k;      limit_rate 100k;    }  }}</code></pre><blockquote><p>limit_zone，是针对每个IP定义一个存储session状态的容器。这个示例中定义了一个名叫one的10m大小的容器，这个名字会在后面的limit_conn中使用。<br>limit_conn one 1，限制在one中记录状态的每个IP只能发起一个并发连接。<br>limit_rate_after 1000k，在下载1000k后开始限速。<br>limit_rate 100k，对每个连接限速100k. 注意，这里是对连接限速，而不是对IP限速。如果一个IP允许三个并发连接，那么这个IP就是限速为limit_rate×3，在设置的时候要根据自己的需要做设置调整，要不然会达不到自己希望的目的。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>nginx跨域详解</title>
      <link href="/2018/12/04/lao-bo-ke/nginx-jie-jue-kua-yu-wen-ti-xiang-jie/"/>
      <url>/2018/12/04/lao-bo-ke/nginx-jie-jue-kua-yu-wen-ti-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>今天看了一篇nginx跨域原理的文章，还没有验证过，先记下，文章的链接是：<br><a href="http://www.liuyiqi.cn/2015/12/17/nginx-cross-domain/，另外，今天感冒好了，感觉自己萌萌哒。" target="_blank" rel="noopener">http://www.liuyiqi.cn/2015/12/17/nginx-cross-domain/，另外，今天感冒好了，感觉自己萌萌哒。</a><br><img src="http://img.blog.csdn.net/20180114221627751?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>nginx反向代理机制解决跨域问题详解【windows上的】</title>
      <link href="/2018/12/04/lao-bo-ke/nginx-fan-xiang-dai-li-ji-zhi-jie-jue-kua-yu-wen-ti-xiang-jie-windows-shang-de/"/>
      <url>/2018/12/04/lao-bo-ke/nginx-fan-xiang-dai-li-ji-zhi-jie-jue-kua-yu-wen-ti-xiang-jie-windows-shang-de/</url>
      
        <content type="html"><![CDATA[<p>以前学过linux服务器上的配置，感觉linux上的比较好用。下面是windows上的详细配置、案例和原理图:<br>        1.背景<br>            我要在本地服务器上的jsp【react】页面上访问聚合网上的数据，但是由于端口、域名、协议的不同导致浏览器识别为跨域请求，因此需要借用nginx的反向代理机制实现跨域请求【其实用jsonp是最简单的方法，但是生产方必须提供必要的回调api】。<a href="http://blog.csdn.net/lambert310/article/details/51683775" target="_blank" rel="noopener">【什么是跨域】</a><br>         2.解决方案<br>         使用ngin反向代理实现跨域请求：<br>         nginx.conf配置：</p><pre><code>#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    #反向代理的配置;     server {        listen       8081;        server_name  127.0.0.1;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location /juhe {        proxy_pass   http://api.shujuzhihui.cn/api/invokingApi/searchExpress?appKey=0c98fbe6005e4c09b398bf9fcaf9cd3d&amp;expressNo=9891754549340;        //------------------必须设置部分---------------------------        proxy_redirect default;        proxy_connect_timeout 1s;        proxy_read_timeout 30s;        proxy_send_timeout 1s;        add_header &#39;Access-Control-Allow-Headers&#39; &#39;Content-Type&#39;;        add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;        add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET&#39;;        //-------------------必须设置部分--------------------------        index  index.html index.htm;        }    }    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server {    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}    # HTTPS server    #    #server {    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}}</code></pre><p><em>不要忘了设置请求方式，否则参数的传递可能会出现问题</em><br><img src="http://img.blog.csdn.net/20171222091925231?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>前端访问案例:</p><pre><code>  &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script  src=&quot;http://libs.baidu.com/jquery/1.8.2/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(function(){    alert(&#39;Hello&#39;);        //按钮单击时执行        $(&quot;#testAjax&quot;).click(function(){              //Ajax调用处理            $.ajax({               type: &quot;POST&quot;,               url: &quot;http://127.0.0.1:8081/juhe/&quot;,               data: &quot;&quot;,               success: function(data){                        $(&quot;#myDiv&quot;).html(&#39;&lt;h2&gt;&#39;+data+&#39;&lt;/h2&gt;&#39;);                  }            });         });    });&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;通过 AJAX 改变文本&lt;/h2&gt;&lt;/div&gt;        &lt;button id=&quot;testAjax&quot; type=&quot;button&quot;&gt;Ajax改变内容&lt;/button&gt;    &lt;/body&gt;&lt;/html&gt;  </code></pre><p>   3.根本原理<br>   <img src="http://img.blog.csdn.net/20171221093523848?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 4.参考文档:<a href="http://m.blog.csdn.net/kkgbn/article/details/52276866" target="_blank" rel="noopener">Nginx 配置Ajax跨域访问</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>mysql中文乱码的解决方法</title>
      <link href="/2018/12/04/lao-bo-ke/mysql-zhong-wen-luan-ma-de-jie-jue-fang-fa/"/>
      <url>/2018/12/04/lao-bo-ke/mysql-zhong-wen-luan-ma-de-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>mysql中文乱码的解决方法</strong></p><pre><code>  参考文章：http://blog.csdn.net/tomcat_2014/article/details/75006600            https://blog.csdn.net/u011421398/article/details/51992148/</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>mysql中使用递归实现父级部门所有子级信息的查询</title>
      <link href="/2018/12/04/lao-bo-ke/mysql-zhong-shi-yong-di-gui-shi-xian-fu-ji-bu-men-suo-you-zi-ji-xin-xi-de-cha-xun/"/>
      <url>/2018/12/04/lao-bo-ke/mysql-zhong-shi-yong-di-gui-shi-xian-fu-ji-bu-men-suo-you-zi-ji-xin-xi-de-cha-xun/</url>
      
        <content type="html"><![CDATA[<p>最近在项目中遇到了根据父级部门的部门id查询其所有子级部门的需求，下面介绍其详细过程和原理。<br>1、创建部门表。</p><pre><code>/*Navicat MySQL Data TransferSource Server         : LongZhengSource Server Version : 50718Source Host           : localhost:3306Source Database       : ljyTarget Server Type    : MYSQLTarget Server Version : 50718File Encoding         : 65001Date: 2018-03-02 21:39:04*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for hr_dept-- ----------------------------DROP TABLE IF EXISTS `hr_dept`;CREATE TABLE `hr_dept` (  `deptId` bigint(200) NOT NULL,  `parent_id` bigint(200) DEFAULT NULL,  `dept_name` varchar(128) DEFAULT NULL,  `dept_code` varchar(24) DEFAULT NULL,  `dept_desc` varchar(512) DEFAULT NULL,  `dept_office_address` varchar(128) DEFAULT NULL,  `is_delete` varchar(255) DEFAULT NULL,  PRIMARY KEY (`deptId`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of hr_dept-- ----------------------------INSERT INTO `hr_dept` VALUES (&#39;1&#39;, &#39;3&#39;, &#39;行政部门&#39;, &#39;100004&#39;, &#39;管理公司事物&#39;, &#39;江苏无锡菱湖大道&#39;, &#39;1&#39;);INSERT INTO `hr_dept` VALUES (&#39;2&#39;, &#39;3&#39;, &#39;人事部门&#39;, &#39;100003&#39;, &#39;管理公司员工&#39;, &#39;江苏无锡菱湖大道&#39;, &#39;1&#39;);INSERT INTO `hr_dept` VALUES (&#39;3&#39;, &#39;1&#39;, &#39;测试部门&#39;, &#39;100005&#39;, &#39;前后台测试&#39;, &#39;江苏无锡菱湖大道&#39;, &#39;1&#39;);INSERT INTO `hr_dept` VALUES (&#39;4&#39;, &#39;1&#39;, &#39;移动应用部&#39;, &#39;100006&#39;, &#39;手机端开发&#39;, &#39;江苏无锡菱湖大道&#39;, &#39;1&#39;);INSERT INTO `hr_dept` VALUES (&#39;5&#39;, &#39;1&#39;, &#39;金融业务部门&#39;, &#39;100007&#39;, &#39;银行业务&#39;, &#39;江苏无锡菱湖大道&#39;, &#39;1&#39;);INSERT INTO `hr_dept` VALUES (&#39;6&#39;, &#39;1&#39;, &#39;战略规划部&#39;, &#39;100001&#39;, &#39;研发软件架构&#39;, &#39;江苏无锡菱湖大道&#39;, &#39;1&#39;);INSERT INTO `hr_dept` VALUES (&#39;7&#39;, &#39;2&#39;, &#39;应用开发部&#39;, &#39;100002&#39;, &#39;PC端后台开发&#39;, &#39;江苏无锡菱湖大道&#39;, &#39;1&#39;);INSERT INTO `hr_dept` VALUES (&#39;8&#39;, &#39;2&#39;, &#39;咨询部&#39;, &#39;100008&#39;, &#39;接洽外部项目&#39;, &#39;江苏无锡菱湖大道&#39;, &#39;1&#39;);INSERT INTO `hr_dept` VALUES (&#39;9&#39;, &#39;2&#39;, &#39;华北交付中心&#39;, &#39;100009&#39;, &#39;调试软件项目&#39;, &#39;江苏无锡菱湖大道&#39;, &#39;1&#39;);</code></pre><p>2、创建存储过程.<br>执行下面的语句就可以创建function了，也就是执行语句创建存储过程。</p><pre><code>create function getChildrenOrgOfHr(orgid INT)returns varchar(4000)BEGINDECLARE oTemp VARCHAR(4000);DECLARE oTempChild VARCHAR(4000);SET oTemp = &#39;&#39;;SET oTempChild = CAST(orgid AS CHAR);WHILE oTempChild IS NOT NULLDOSET oTemp = CONCAT(oTemp,&#39;,&#39;,oTempChild);SELECT GROUP_CONCAT(deptId) INTO oTempChild FROM hr_dept WHERE FIND_IN_SET(parent_id,oTempChild) &gt; 0;END WHILE;RETURN oTemp;END</code></pre><p>3、测试</p><pre><code>select * from  hr_dept where FIND_IN_SET(deptId,getChildrenOrgOfHr(2));</code></pre><p><img src="http://img.blog.csdn.net/20180302220013439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>4、原理<br>其实就是一个递归的过程，在存储过程中最终返回的是一个字符串数组，这个字符串数组中包含当前父级节点和所有子级节点的id,而这个字符串数组是通过递归进行拼接逐次增加的哦。<br>5、可能会出现的问题：</p><pre><code>Data too long for column &#39;oTemp&#39; at row 1</code></pre><p>6、参考文章<br><a href="http://blog.csdn.net/moyanxuan_1993_2_24/article/details/52790314" target="_blank" rel="noopener">mysql递归查询组织机构</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>MySQL优化之------索引原理</title>
      <link href="/2018/12/04/lao-bo-ke/mysql-you-hua-zhi-suo-yin-yuan-li/"/>
      <url>/2018/12/04/lao-bo-ke/mysql-you-hua-zhi-suo-yin-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>最近大佬优化了一条SQL，讲100万条的数据查询速度从27s降低到了0.8S,因此研究了下MySQL优化的原理和方式。下面将从Mysql中索引的本质，原理等方面介绍下MySQL中的索引原理。</p><hr><pre><code>1、MySQL中数据的存储方式;</code></pre><blockquote></blockquote><p> mysql的数据在磁盘上的存储：<br>       A、数据块：<br>        由多个磁盘block组成的块，存储引擎负责管理数据块。<br>        磁盘是block块设备，数据在磁盘上的存放也是按照块存放的。<br>        mysql读取表到内存的时候，也必然是按照一块一块的方式读取。假设     要查询的表在和其他表在都在同一个块内。加载块的时候除了读取要查询的表，其他表也一并被读取出来。<br>        当一个块内的部分表被删除时，这是就是形成了碎片。这样会降低装载到内存的速度。<br>        所以会生成一个块头，记录一个快内表的大小，有无空闲空间，空闲空间的位置。<br>        B、散列文件组织：<br>       人为将表分成多个部分，每个部分称为桶。根据行中的某个或某些字段做使用散列函数做哈希运算，运算结果属于某个范围的放在指定的桶中。多个桶组成一个表。<br>        桶有可能溢出。所以要选定一个合适散列函数，让行平均在各个桶中。</p><hr><pre><code>2、什么是MySQL的索引;</code></pre><blockquote><p>引用块内容<br>MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。索引也是一种数据，需要占用物理空间。B+Tree索引索引的数据结构如图所示：<br><img src="http://ouuy81imh.bkt.clouddn.com/mysqlIndex01.png" alt="这里写图片描述"><br>    3、MySQL中索引【hash和BTree】的实现原理;<br>    ……等我研究下两种算法再确定。<br>    4、两种索引【hash和BTree】的区别和缺点；<br>一、BTree<br>BTree索引是最常用的mysql数据库索引算法，因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量，例如：<br>select <em> from user where name like ‘jack%’;<br>select </em> from user where name like ‘jac%k%’;<br>如果一通配符开头，或者没有使用常量，则不会使用索引，例如：<br>select <em> from user where name like ‘%jack’;<br>select </em> from user where name like simply_name;<br>二、Hash<br>Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。<br>但为什么我们使用BTree比使用Hash多呢？主要Hash本身由于其特殊性，也带来了很多限制和弊端： </p><ol><li>Hash索引仅仅能满足“=”,“IN”,“&lt;=&gt;”查询，不能使用范围查询。 </li><li>联合索引中，Hash索引不能利用部分索引键查询。<br>对于联合索引中的多个列，Hash是要么全部使用，要么全部不使用，并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。 </li><li>Hash索引无法避免数据的排序操作<br>由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。 </li><li>Hash索引任何时候都不能避免表扫描<br>Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。 </li><li>Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高<br>对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据访问，而造成整体性能底下。</li></ol></blockquote><p>5、参考文章。<br>   1、 <a href="http://blog.51cto.com/ggvylf/1679322" target="_blank" rel="noopener">mysql之mysql数据在磁盘的储存方式</a><br>   2、<a href="https://www.cnblogs.com/57rongjielong/p/8039452.html" target="_blank" rel="noopener">索引的优缺点</a><br>   3、<a href="https://blog.csdn.net/liutong123987/article/details/79384395" target="_blank" rel="noopener">什么是索引？Mysql目前主要的几种索引类型</a><br>   4、<a href="http://baijiahao.baidu.com/s?id=1596556730540273699&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">MySQL的索引是什么？怎么优化？</a><br>   5、<a href="https://blog.csdn.net/tongdanping/article/details/79878302" target="_blank" rel="noopener">深入理解MySQL索引原理和实现——为什么索引可以加速查询？</a><br>    6、<a href="https://blog.csdn.net/u011305680/article/details/55520853" target="_blank" rel="noopener">数据库索引系列四：索引算法Hash与BTree的区别</a><br>    7、<a href="https://www.jianshu.com/p/d7665192aaaf?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">MySQL优化原理</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Mysql优化之索引</title>
      <link href="/2018/12/04/lao-bo-ke/mysql-you-hua-zhi-suo-yin-lei-xing/"/>
      <url>/2018/12/04/lao-bo-ke/mysql-you-hua-zhi-suo-yin-lei-xing/</url>
      
        <content type="html"><![CDATA[<pre><code>     Mysql中索引的类型：</code></pre><pre><code>  Mysql中的索引分为三种类型：        1.Normal:该类型的索引对建立索引的字段基本不做特殊要求【唯一性、有序性】        2.Unique:要求建立索引的字段必须是唯一的;        3.Full Text:当建立索引的字段是长文本类型等数据长度较长的字段时，建议使用该类型的索引; Mysql中索引的方法:       Mysql中的索引方法有Hash和BTree两种：       Hash索引方法：</code></pre><hr><p><a href="http://pic002.cnblogs.com/images/2012/288799/2012092709470640.jpg" target="_blank" rel="noopener">Hash图解</a></p><pre><code>       Hash 索引的缺点：</code></pre><p>（1）Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。</p><p>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</p><p>（2）Hash 索引无法被用来避免数据的排序操作。</p><p>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</p><p>（3）Hash 索引不能利用部分索引键查询。</p><p>对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</p><p>（4）Hash 索引在任何时候都不能避免表扫描。</p><p>前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p><p>（5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</p><p>对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。<br>           2.BTree:<br>           二叉查找树</p><blockquote><p>二叉搜索树，也称有序二叉树,排序二叉树，是指一棵空树或者具有下列性质的二叉树：</p><ol><li><p>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li><p>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li><li><p>任意节点的左、右子树也分别为二叉查找树。</p></li><li><p>没有键值相等的节点。</p></li></ol></blockquote><p><img src="http://img.blog.csdn.net/20170912200040959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>总结：两种索引方法的最终目的都是通过减少查询次数增加了查询的效率，最终达到了数据库优化的效果，但两者都在一定程度上增加了数据库的系统开销，或是内存上的，或是执行效率撒谎那个的。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>mybatis中#{}【占位符】和${}【字符串】拼接的区别</title>
      <link href="/2018/12/04/lao-bo-ke/mybatis-zhong-zhan-wei-fu-he-zi-fu-chuan-pin-jie-de-qu-bie/"/>
      <url>/2018/12/04/lao-bo-ke/mybatis-zhong-zhan-wei-fu-he-zi-fu-chuan-pin-jie-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>#{}</code></pre><blockquote><p>表示一个占位符号，通过#{}可以实现 preparedStatement 向占      位符中设置值， 自动进行 java<br>类型和 jdbc 类型转换。#{}可以有效防止 sql 注入。 #{}可以接 收简单类型值或 pojo 属性值。 如果<br>parameterType 传输单个简单类型值，#{} 括号中可以是 value 或其它名称。</p></blockquote><hr><p>   ${}</p><blockquote><p>  表示拼接 sql 串，通过${}可以将 parameterType 传入的内容拼接在 sql 中 且不进行 jdbc 类型转换，<br>${}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。</p></blockquote><hr><p>  <strong><em>使用占位符的形式</em></strong>最终会将Java中的字符串类型数据”%王%”转换为  jdbc中的数据类型【通配符的形式】<em>%王%</em>，最终形成的sql语句为<br>  SELECT * FROM <code>user</code> WHERE username LIKE %王%</p><pre><code>&lt;!-- 如果返回多个结果，mybatis 会自动把返回的结果放在 list 容器中 --&gt;&lt;!-- resultType 的配置和返回一个结果的配置一样 --&gt;&lt;select id=&quot;queryUserByUsername1&quot; parameterType=&quot;string&quot;resultType=&quot;cn.itcast.mybatis.pojo.User&quot;&gt;SELECT * FROM `user` WHERE username LIKE #{username}&lt;/select&gt;</code></pre><pre><code>// 查询多条数据使用 selectList 方法List&lt;Object&gt; list =sqlSession.selectList(&quot;queryUserByUsername1&quot;, &quot;%王%&quot;);</code></pre><hr><pre><code>&lt;!-- 如果传入的参数是简单数据类型，${}里面必须写 value --&gt;&lt;select id=&quot;queryUserByUsername2&quot; parameterType=&quot;string&quot;resultType=&quot;cn.itcast.mybatis.pojo.User&quot;&gt;SELECT * FROM `user` WHERE username LIKE &#39;%${value}%&#39;&lt;/select&gt;</code></pre><pre><code>// 查询多条数据使用 selectList 方法List&lt;Object&gt; list = sqlSession.selectList(&quot;queryUserByUsername2&quot;, &quot;王&quot;);</code></pre><p>  <strong><em>使用字符串拼接的形式</em></strong>  不会进行数据类型的转化，最终解析出来的数据相当于带有“‘”号，此处传值的时候需要进行注意，最终形成的sql语句为<br>  SELECT * FROM <code>user</code> WHERE username LIKE %王%</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>linux运维常用命令</title>
      <link href="/2018/12/04/lao-bo-ke/linux-yun-wei-chang-yong-ming-ling/"/>
      <url>/2018/12/04/lao-bo-ke/linux-yun-wei-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p><strong>1.目录操作</strong></p><p><em>使用 mkdir 命令创建目录</em></p><pre><code>mkdir $HOME/testFolder</code></pre><p><em>切换目录</em></p><pre><code>使用 cd 命令切换目录cd $HOME/testFolder</code></pre><pre><code>使用 cd ../ 命令切换到上一级目录cd ../</code></pre><p><em>移动目录</em></p><pre><code>使用 mv 命令移动目录mv $HOME/testFolder /var/tmp</code></pre><p><em>删除目录</em></p><pre><code>使用 rm -rf 命令删除目录rm -rf /var/tmp/testFolder</code></pre><p><em>查看目录下的文件</em></p><pre><code>ls /etc</code></pre><p><strong>2.文件操作</strong></p><p><em>创建文件</em></p><pre><code>使用 touch 命令创建文件touch ~/testFile</code></pre><pre><code>执行 ls 命令, 可以看到刚才新建的 testFile 文件ls ~</code></pre><p><em>复制文件</em></p><pre><code>使用 cp 命令复制文件cp ~/testFile ~/testNewFile</code></pre><p><em>删除文件</em></p><pre><code>使用 rm 命令删除文件, 输入 y 后回车确认删除rm ~/testFile</code></pre><p><em>查看文件内容</em></p><pre><code>使用 cat 命令查看 .bash_history 文件内容cat ~/.bash_history</code></pre><p><strong>3.过滤, 管道与重定向</strong></p><p><em>过滤</em></p><pre><code>过滤出 /etc/passwd 文件中包含 root 的记录grep &#39;root&#39; /etc/passwd递归地过滤出 /var/log/ 目录中包含 linux 的记录grep -r &#39;linux&#39; /var/log/</code></pre><p><em>管道</em></p><pre><code>简单来说, Linux 中管道的作用是将上一个命令的输出作为下一个命令的输入, 像 pipe 一样将各个命令串联起来执行, 管道的操作符是 |比如, 我们可以将 cat 和 grep 两个命令用管道组合在一起cat /etc/passwd | grep &#39;root&#39;过滤出 /etc 目录中名字包含 ssh 的目录(不包括子目录)ls /etc | grep &#39;ssh&#39;</code></pre><p><em>重定向</em></p><pre><code>可以使用 &gt; 或 &lt; 将命令的输出重定向到一个文件中echo &#39;Hello World&#39; &gt; ~/test.txt</code></pre><p><strong>4.运维常用命令</strong></p><p><em>ping 命令</em></p><pre><code>对 cloud.tencent.com 发送 4 个 ping 包, 检查与其是否联通ping -c 4 cloud.tencent.com</code></pre><p><em>netstat 命令</em></p><pre><code>netstat 命令用于显示各种网络相关信息，如网络连接, 路由表, 接口状态等等列出所有处于监听状态的tcp端口netstat -lt查看所有的端口信息, 包括 PID 和进程名称netstat -tulpn</code></pre><p><em>ps 命令</em></p><pre><code>过滤得到当前系统中的 ssh 进程信息ps -aux | grep &#39;ssh&#39;</code></pre><p><strong>5.Linux ssh登录命令</strong></p><blockquote><p>ssh命令用于远程登录上Linux主机。</p><p>常用格式：ssh [-l login_name] [-p port] [user@]hostname 更详细的可以用ssh -h查看。</p><p>举例</p><p>不指定用户：</p><p>ssh 192.168.0.11</p><p>指定用户：</p><p>ssh -l root 192.168.0.11</p><p>ssh <a href="mailto:root@192.168.0.11" target="_blank" rel="noopener">root@192.168.0.11</a></p><p>如果修改过ssh登录端口的可以：</p><p>ssh -p 12333 192.168.0.11</p><p>ssh -l root -p 12333 216.230.230.114</p><p>ssh -p 12333 <a href="mailto:root@216.230.230.114" target="_blank" rel="noopener">root@216.230.230.114</a></p><p>另外修改配置文件/etc/ssh/sshd_config，可以改ssh登录端口和禁止root登录。改端口可以防止被端口扫描。</p><p>编辑配置文件：</p><p>vim /etc/ssh/sshd_config</p><p>找到#Port 22，去掉注释，修改成一个五位的端口：</p><p>Port 12333</p><p>找到#PermitRootLogin yes，去掉注释，修改为：</p><p>PermitRootLogin no</p><p>重启sshd服务：</p><p>service sshd restart</p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Linux部署Java web项目</title>
      <link href="/2018/12/04/lao-bo-ke/linux-bu-shu-java-web-xiang-mu/"/>
      <url>/2018/12/04/lao-bo-ke/linux-bu-shu-java-web-xiang-mu/</url>
      
        <content type="html"><![CDATA[<p>详情请参照下面的博客<br><a href="https://juejin.im/post/5847cac461ff4b006bae5a12" target="_blank" rel="noopener">https://juejin.im/post/5847cac461ff4b006bae5a12</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Linux(Centos)之安装tomcat并且部署Java Web项目</title>
      <link href="/2018/12/04/lao-bo-ke/linux-centos-zhi-an-zhuang-tomcat-bing-qie-bu-shu-java-web-xiang-mu/"/>
      <url>/2018/12/04/lao-bo-ke/linux-centos-zhi-an-zhuang-tomcat-bing-qie-bu-shu-java-web-xiang-mu/</url>
      
        <content type="html"><![CDATA[<p>阅读目录</p><blockquote><p>1.准备工作<br>    2.在Linux下安装Tomcat8.0<br>    3.Linux中设置tomcat的服务器启动和关闭<br>    4.Linux中设置tomcat的开机启动<br>    5.给tomcat设置用户名和密码登录<br>    6.使用MyEclipse打包Java Web项目<br>    7.将Java Web项目发布到Tomcat8.0下面并且访问展示</p></blockquote><p><strong>1.准备工作</strong></p><p>首先检查软件的安装情况，使用的命令如下:</p><pre><code>     rpm -qa|grep jdk        rpm -qa|grep mysql          rpm -qa|grep tomcat</code></pre><p>a.下载tomcat linux的包，地址：<a href="http://tomcat.apache.org/download-80.cgi，我们下载的版本是8.0，下载方式如图：" target="_blank" rel="noopener">http://tomcat.apache.org/download-80.cgi，我们下载的版本是8.0，下载方式如图：</a></p><p><img src="http://img.blog.csdn.net/20170905213621123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>b.因为tomcat的安装依赖于Java jdk，所以我们需要在判断linux系统下面是否安装jdk<br>　　　　b.1 使用（Xshell）连接到Linux系统下面<br>　　　　b.2 输入命令：java -version，如果显示jdk版本号，则证明已经安装，如果不显示，则证明没有安装，如果没有安装，请参考下面地址进行安装：<a href="http://www.cnblogs.com/hanyinglong/p/5025635.html" target="_blank" rel="noopener">http://www.cnblogs.com/hanyinglong/p/5025635.html</a> ，如图所示：</p><p><img src="http://img.blog.csdn.net/20170905213816543?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>　c.操作需要的软件以及系统如下：虚拟机(Vmware),虚拟机中安装的Centos系统，Xshell,Xftp,Tomcat8.0，MyEclipse开发的WebDemo，apache-tomcat-8.0.29.tar.gz。</p><p><strong>2.在Linux下安装Tomcat8.0</strong><br>tomcat的通用安装路径是：/usr/local/tomcat,此处使用Xftp进行操作，模拟常规的项目发布<br>流程；</p><p>详细的安装步骤如下:</p><blockquote><p>(1)、使用Xftp工具复制文件到/usr/local目录下;<br>          (2)、使用 tar -zxv -f apache-tomcat-8.0.46.tar.gz 命令进行解压；<br>           (3)、解压完成后将解压的问价夹更正为tomcat;</p></blockquote><p><img src="http://img.blog.csdn.net/20170905220414982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>解析完成后即可以启动Tomcat，检查是否安装成功，命令如下，如图所示：　　</p><blockquote><p>　(4)、解压完成之后使用　/usr/local/tomcat/startup.sh命令查看tomcat是否能够正常启动；</p></blockquote><p><img src="http://img.blog.csdn.net/20170905220740683?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>　出现如图上所示的信息，则表示启动成功。这时候我们可以在windows下面使用<a href="http://ip:8080访问，如能够显示Tomcat的主页，则表示不需要进行任何操作了，如不能显示，则需要在Linux中开放防火墙的8080端口。" target="_blank" rel="noopener">http://ip:8080访问，如能够显示Tomcat的主页，则表示不需要进行任何操作了，如不能显示，则需要在Linux中开放防火墙的8080端口。</a>　　</p><blockquote><p>f.在Linux下面的防火墙里面开放8080端口 会用命令如下：<br>　　　　f.1  vim /etc/sysconfig/iptables<br>　　　　f.2  打开之后按键盘（i）进入编辑模式，写入开发8080端口，如图所示：</p></blockquote><p><img src="http://img.blog.csdn.net/20170905220918645?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>　</p><blockquote><p>f.3  写完之后我们按键盘（ESC）按钮退出，然后按（:wq）保存并且关闭Vim。 　　g.之后重启防火墙,命令如下：<br>　　　　service iptables restart  　　h.然后再次在浏览器中输入<a href="http://ip:8080，如果看到tomcat系统界面，说明安装成功，你可以进行下一步了。" target="_blank" rel="noopener">http://ip:8080，如果看到tomcat系统界面，说明安装成功，你可以进行下一步了。</a><br>　　i.停止Tomcat的命令是：/usr/local/tomcat/bin/shutdown.sh</p></blockquote><p><strong>3.Linux中设置tomcat的服务器启动和关闭</strong></p><p>a.如2所示，我们已经完成了对tomcat的安装，接下来就可以部署项目，但是这里存在一个问题，那就是Linux的系统和重启我们每次都需要接路径并且执行命令，那么我们可以设置成service的形式来实现这个功能。</p><p>　　b.执行命令：vim /etc/rc.d/init.d/tomcat，创建脚本文件，在文件中写入如下代码，保存并且退出</p><pre><code>#!/bin/bash# /etc/rc.d/init.d/tomcat# init script for tomcat precesses# processname: tomcat# description: tomcat is a j2se server# chkconfig: 2345 86 16# description: Start up the Tomcat servlet engine.if [ -f /etc/init.d/functions ]; then. /etc/init.d/functionselif [ -f /etc/rc.d/init.d/functions ]; then. /etc/rc.d/init.d/functionselseecho -e &quot;\atomcat: unable to locate functions lib. Cannot continue.&quot;exit -1fiRETVAL=$?CATALINA_HOME=&quot;/usr/local/kencery/tomcat&quot;   #tomcat安装目录，你安装在什么目录下就复制什么目录case &quot;$1&quot; instart)if [ -f $CATALINA_HOME/bin/startup.sh ];thenecho $&quot;Starting Tomcat&quot;$CATALINA_HOME/bin/startup.shfi;;stop)if [ -f $CATALINA_HOME/bin/shutdown.sh ];thenecho $&quot;Stopping Tomcat&quot;$CATALINA_HOME/bin/shutdown.shfi;;*)echo $&quot;Usage: $0 {start|stop}&quot;exit 1;;esacexit $RETVALLinux</code></pre><blockquote><p>c.给文件添加权限，使得脚本文件可以执行，命令为  chmod 755 /etc/rc.d/init.d/tomcat<br>　　d.将其添加到服务中，命令为 chkconfig –add /etc/rc.d/init.d/tomcat<br>　　e.然后将下面的配置文件加到tomcat中的catalina.sh文件中的最后面，命令为：vim<br>/usr/local/kencery/tomcat/bin/catalina.sh<br>　　　　export JAVA_HOME=/usr/local/kencery/javajdk   #javajdk的安装路径，使用echo $JAVA_HOME命令可以读取<br>　　　　export CATALINA_HOME=/usr/local/kencery/tomcat<br>　　　　export CATALINA_BASE=/usr/local/kencery/tomcat<br>　　　　export CATALINA_TMPDIR=/usr/local/kencery/tomcat/temp 　　f.以上所有工作顺利进行并且没有报错，则配置完成，你可以输入命令service tomcat start和service tomcat<br>stop进行验证(请自行实验)。</p></blockquote><p><strong>4.Linux中设置tomcat的开机启动</strong></p><p>　a. 通过第三步的设置我们可以很方便的设置tomcat的启动和关闭，但是这里存在一个问题，那就是当服务器关机重启的时候，服务不能随计算机的启动而自己启动，那么我们可以将tomcat服务设置为开机启动。<br>　　b.打开linux设置开启启动的文件，将下面的配置文件写入此文件的最后，命令为：</p><pre><code>       vim /etc/rc.d/rc.local　　　　export JAVA_HOME=/usr/local/kencery/javajdk　　　　export        CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.j ar　　　　export PATH=$PATH:$JAVA_HOME/bin　　　　export CATALINA_HOME=/usr/local/kencery/tomcat/　　　　#tomcat自启动　　　　/usr/local/kencery/tomcat/bin/startup.</code></pre><p>　　c.tomcat依赖于Java的jdk，所以设置的时候讲jdk也同步导入。<br>　　d.完成上面的步骤之后我们就可以将centos关机重启检查一番。<br>　　<br><strong>5.给tomcat设置用户名和密码登录</strong></p><p>　a.当tomcat安装完成之后，访问<a href="http://ip:8080即可以看到tomcat发布的网站，这时候需要管理我们发布网站，就需要登录tomcat，那么在centos中如何设置登录名和密码。" target="_blank" rel="noopener">http://ip:8080即可以看到tomcat发布的网站，这时候需要管理我们发布网站，就需要登录tomcat，那么在centos中如何设置登录名和密码。</a><br>　　b.在tomcat安装包下面的conf文件下含有一个tomcat-user.xml文件，修改此文件即可，命令为：vim tomcat-users.xml<br>　　c.在打开的xml配置文件最后面写入下面这段配置文件之后保存并且退出即可。　　　</p><pre><code>　     &lt;role rolename=&quot;admin-gui&quot;/&gt;   　　　　&lt;role rolename=&quot;manager-gui&quot;/&gt;　　　　&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,admin-gui&quot;/&gt;</code></pre><p>　　d.在这里会出现一个问题，因为tomcat-users.xml里面有注释的用户设置的信息，取消注释，用文件提供的用户名和密码去访问的时候，会出现403错误，什么原因呢？这是因为我们没有指定用户所拥有的权限的原因，如我们现在想访问tomcat中图形化管理应用的功能，也就是Manager App，就需要指定manager-gui的权限，如果想访问host manager就必须指定admin-gui权限，故而如c所示的配置。</p><p>　　e.配置完用户名密码之后，需要重新启动tomcat，命令如下：　　　</p><pre><code>　            service tomcat stop              service tomcat start</code></pre><p>　　f. 重启服务之后，检测是否登录成功，如果登录进入系统，则说明登录成功。</p><p><strong>6.将Java Web项目发布到Tomcat8.0下面并且访问展示</strong></p><p>导出war包，将war包存放于tomcat默认的发布web项目目录：webapps下即可；<br>启动tomcat，war包可以自动被解析。<br>然后访问项目，检查项目是否发布成功。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Linux 下虚拟机克隆步骤（CentOS）</title>
      <link href="/2018/12/04/lao-bo-ke/linux-xia-xu-ni-ji-ke-long-bu-zou-centos/"/>
      <url>/2018/12/04/lao-bo-ke/linux-xia-xu-ni-ji-ke-long-bu-zou-centos/</url>
      
        <content type="html"><![CDATA[<p>当一个Linux完全设置完成以后，就可以使用克隆的方式来在短时间内创建出多个Linux来；<br>   linux虚拟机克隆主要涉及网络方面的问题：</p><p><strong>1.关闭要克隆的Linux 关机命令：</strong></p><pre><code>init 0  或者  shutdown -h now</code></pre><p><strong>2.新建快照，给母本一个备份,如下图所示:</strong><br><img src="http://img.blog.csdn.net/20170905161029126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>3.右击要克隆的虚拟机-》管理-》克隆，在选择克隆的步骤中有两步比较重要：</strong></p><p><img src="http://img.blog.csdn.net/20170905161335542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>在这里要选择创建完整的克隆</p><p><img src="http://img.blog.csdn.net/20170905161358161?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>在这里虚拟机的存放路径一定要不能包含中文字和字符</p><p><strong>4.克隆的速度很快，完成以后启动克隆的虚拟机，用户名和密码都是被克隆的linux的用户名密码：</strong></p><p><strong>5.克隆之后由于是完全的克隆过来的Linux所以需要更改这几项：操作系统物理地址、IP地址、主机名：</strong></p><p>使用vi命令删除网卡中的UUID和物理地址两行（这两行在Linux重启之后，操作系统会自动生成的,如果不进行更改会造成IP冲突），同时更改一个新的IP地址：</p><pre><code>vi /etc/sysconfig/network-scripts/ifcfg-eth0</code></pre><p>更改成下图：</p><p><img src="http://img.blog.csdn.net/20170905161756674?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>更改完成以后保存并退出，然后删除Linux物理地址绑定的文件（该文件会在操作系统重启并生成物理地址以后将物理地址绑定到IP上）；</p><p>如果不删除，则操作系统会一直绑定着克隆过来的物理地址；</p><pre><code>使用命令：rm -rf /etc/udev/rules.d/70-persistent-net.rules</code></pre><p><strong>6.更改主机名还是使用vi命令：</strong><br>     更改主机名称的意图是可以通过主机名进行SSH访问，简化了访问操作，因为主机名映射了IP；</p><pre><code>vi /etc/sysconfig/network</code></pre><p>设置完成以后，保存并退出，然后重启Linux就完成了克隆后的设置，重启Linux命令：</p><pre><code>init 6  或者  shutdown -r now</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JS中常用方法的封装【转载】</title>
      <link href="/2018/12/04/lao-bo-ke/js-zhong-chang-yong-fang-fa-de-feng-zhuang-zhuan-zai/"/>
      <url>/2018/12/04/lao-bo-ke/js-zhong-chang-yong-fang-fa-de-feng-zhuang-zhuan-zai/</url>
      
        <content type="html"><![CDATA[<p></p><p><br>JS中常用方法的封装【<a href="https://juejin.im/post/5a2a7a5051882535cd4abfce#heading-53" target="_blank" rel="noopener">转载</a>】<br>转载理由：我想这么好的内容，有些方法连lodash 和 ramda上都没有，可不能因为作者的博客倒闭了就没了，所以就Fork了一份，并复制了一份到自己的博客。<br><br></p><p></p><h2>前言</h2><br><p></p><p></p><div data-v-3269f0ad="" class="catalog-body"><ul data-v-3269f0ad="" class="catalog-list" style="margin-top: -122.469px;"><li data-v-3269f0ad="" class="item d1"><a href="#heading-0" title="1.前言">1.前言</a><!----></li><li data-v-3269f0ad="" class="item d1"><a href="#heading-1" title="2.字符串操作">2.字符串操作</a><ul class="sub-list"><li class="item d2"><a href="#heading-2" title="2-1去除字符串空格">2-1去除字符串空格</a><!----></li><li class="item d2"><a href="#heading-3" title="2-2字母大小写切换">2-2字母大小写切换</a><!----></li><li class="item d2"><a href="#heading-4" title="2-3字符串循环复制">2-3字符串循环复制</a><!----></li><li class="item d2"><a href="#heading-5" title="2-4字符串替换">2-4字符串替换</a><!----></li><li class="item d2 active"><a href="#heading-6" title="2-5替换*">2-5替换<em></em></a><!----></li><li class="item d2"><a href="#heading-7" title="2-6检测字符串">2-6检测字符串</a><!----></li><li class="item d2"><a href="#heading-8" title="2-7 检测密码强度">2-7 检测密码强度</a><!----></li><li class="item d2"><a href="#heading-9" title="2-8随机码（toString详解）">2-8随机码（toString详解）</a><!----></li><li class="item d2"><a href="#heading-10" title="2-9查找字符串">2-9查找字符串</a><!----></li><li class="item d2"><a href="#heading-11" title="2-10 过滤字符串">2-10 过滤字符串</a><!----></li><li class="item d2"><a href="#heading-12" title="2-11格式化处理字符串">2-11格式化处理字符串</a><!----></li><li class="item d2"><a href="#heading-13" title="2-12找出最长单词">2-12找出最长单词</a><!----></li><li class="item d2"><a href="#heading-14" title="2-13句中单词首字母大写">2-13句中单词首字母大写</a><!----></li></ul></li><li data-v-3269f0ad="" class="item d1"><a href="#heading-15" title="3.数组操作">3.数组操作</a><ul class="sub-list"><li class="item d2"><a href="#heading-16" title="3-1数组去重">3-1数组去重</a><!----></li><li class="item d2"><a href="#heading-17" title="3-2数组顺序打乱">3-2数组顺序打乱</a><!----></li><li class="item d2"><a href="#heading-18" title="3-3数组最大值最小值">3-3数组最大值最小值</a><!----></li><li class="item d2"><a href="#heading-19" title="3-4数组求和，平均值">3-4数组求和，平均值</a><!----></li><li class="item d2"><a href="#heading-20" title="3-5从数组中随机获取元素">3-5从数组中随机获取元素</a><!----></li><li class="item d2"><a href="#heading-21" title="3-6返回数组（字符串）一个元素出现的次数">3-6返回数组（字符串）一个元素出现的次数</a><!----></li><li class="item d2"><a href="#heading-22" title="3-7返回数组（字符串）出现最多的几次元素和出现次数 ###">3-7返回数组（字符串）出现最多的几次元素和出现次数 ###</a><!----></li><li class="item d2"><a href="#heading-23" title="3-8得到n1-n2下标的数组">3-8得到n1-n2下标的数组</a><!----></li><li class="item d2"><a href="#heading-24" title="3-9筛选数组">3-9筛选数组</a><!----></li><li class="item d2"><a href="#heading-25" title="3-10 获取对象数组某些项">3-10 获取对象数组某些项</a><!----></li><li class="item d2"><a href="#heading-26" title="3-11 排除对象数组某些项">3-11 排除对象数组某些项</a><!----></li><li class="item d2"><a href="#heading-27" title="3-12 对象数组排序">3-12 对象数组排序</a><!----></li><li class="item d2"><a href="#heading-28" title="3-13 数组扁平化">3-13 数组扁平化</a><!----></li></ul></li><li data-v-3269f0ad="" class="item d1"><a href="#heading-29" title="4.基础DOM操作">4.基础DOM操作</a><ul class="sub-list"><li class="item d2"><a href="#heading-30" title="4-1检测对象是否有哪个类名">4-1检测对象是否有哪个类名</a><!----></li><li class="item d2"><a href="#heading-31" title="4-2 添加类名">4-2 添加类名</a><!----></li><li class="item d2"><a href="#heading-32" title="4-3删除类名">4-3删除类名</a><!----></li><li class="item d2"><a href="#heading-33" title="4-4替换类名(&quot;被替换的类名&quot;,&quot;替换的类名&quot;)">4-4替换类名(“被替换的类名”,”替换的类名”)</a><!----></li><li class="item d2"><a href="#heading-34" title="4-5获取兄弟节点">4-5获取兄弟节点</a><!----></li><li class="item d2"><a href="#heading-35" title="4-6设置样式">4-6设置样式</a><!----></li><li class="item d2"><a href="#heading-36" title="4-7设置文本内容">4-7设置文本内容</a><!----></li><li class="item d2"><a href="#heading-37" title="4-8显示隐藏">4-8显示隐藏</a><!----></li></ul></li><li data-v-3269f0ad="" class="item d1"><a href="#heading-38" title="5.其他操作">5.其他操作</a><ul class="sub-list"><li class="item d2"><a href="#heading-39" title="5-1cookie">5-1cookie</a><!----></li><li class="item d2"><a href="#heading-40" title="5-2清除对象中值为空的属性">5-2清除对象中值为空的属性</a><!----></li><li class="item d2"><a href="#heading-41" title="5-3现金额大写转换函数">5-3现金额大写转换函数</a><!----></li><li class="item d2"><a href="#heading-42" title="5-4获取，设置url参数">5-4获取，设置url参数</a><!----></li><li class="item d2"><a href="#heading-43" title="5-5随机返回一个范围的数字">5-5随机返回一个范围的数字</a><!----></li><li class="item d2"><a href="#heading-44" title="5-6随进产生颜色">5-6随进产生颜色</a><!----></li><li class="item d2"><a href="#heading-45" title="5-7Date日期时间部分">5-7Date日期时间部分</a><!----></li><li class="item d2"><a href="#heading-46" title="5-8适配rem">5-8适配rem</a><!----></li><li class="item d2"><a href="#heading-47" title="5-9ajax">5-9ajax</a><!----></li><li class="item d2"><a href="#heading-48" title="5-10图片懒加载">5-10图片懒加载</a><!----></li><li class="item d2"><a href="#heading-49" title="5-11关键词加标签">5-11关键词加标签</a><!----></li><li class="item d2"><a href="#heading-50" title="5-12数据类型判断">5-12数据类型判断</a><!----></li><li class="item d2"><a href="#heading-51" title="5-13手机类型判断">5-13手机类型判断</a><!----></li><li class="item d2"><a href="#heading-52" title="5-14函数节流">5-14函数节流</a><!----></li></ul></li><li data-v-3269f0ad="" class="item d1"><a href="#heading-53" title="6.封装成形">6.封装成形</a><!----></li><li data-v-3269f0ad="" class="item d1"><a href="#heading-54" title="7.小结">7.小结</a><!----></li></ul></div><br><div><h2 data-id="heading-0">1.前言</h2><br><p>大家在开发的时候应该知道，有很多常见的实例操作。比如数组去重，关键词高亮，打乱数组等。这些操作，代码一般不会很多，实现的逻辑也不会很难，下面的代码，我解释就不解释太多了，打上注释，相信大家就会懂了。但是，用的地方会比较，如果项目有哪个地方需要用，如果重复写的话，就是代码沉余，开发效率也不用，复用基本就是复制粘贴！这样是一个很不好的习惯，大家可以考虑一下把一些常见的操作封装成函数，调用的时候，直接调用就好！<br>源码都放在github上了，大家想以后以后有什么修改或者增加的，欢迎大家来star一下<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FchenhuiYj%2Fec-do" target="_blank" rel="nofollow noopener noreferrer">ec-do</a>。</p><br><blockquote><br>  <p>1.下面代码，我放的是es5版本的，如果大家需要看es6版本的，请移步<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FchenhuiYj%2Fec-do%2Fblob%2Fmaster%2Fsrc%2Fec-do-2.0.0.js" target="_blank" rel="nofollow noopener noreferrer">ec-do2.0.0.js</a></p><br>  <p>2.想看完整代码的，或者部分实例的demo，建议去github看！</p><br>  <p>3.下面的代码，都是封装在ecDo这个对象里面，如果里面有this，除了特别说明的，都是指向ecDo</p><br></blockquote><br><h2 data-id="heading-1">2.字符串操作</h2><br><h3 data-id="heading-2">2-1去除字符串空格</h3><br><pre class="hljs bash"><code>//去除空格  <span class="hljs-built_in">type</span> 1-所有空格  2-前后空格  3-前空格 4-后空格<br>//ecDo.trim(<span class="hljs-string">‘  1235asd’</span>,1)<br>//result：1235asd<br>//这个方法有原生的方案代替，但是考虑到有时候开发PC站需要兼容IE8，所以就还是继续保留<br>trim: <span class="hljs-keyword">function</span> (str, <span class="hljs-built_in">type</span>) {<br>    switch (<span class="hljs-built_in">type</span>) {<br>        <span class="hljs-keyword">case</span> 1:<br>            <span class="hljs-built_in">return</span> str.replace(/\s+/g, <span class="hljs-string">“”</span>);<br>        <span class="hljs-keyword">case</span> 2:<br>            <span class="hljs-built_in">return</span> str.replace(/(^\s)|(\s<em>$)/g, <span class="hljs-string">“”</span>);<br>        <span class="hljs-keyword">case</span> 3:<br>            <span class="hljs-built_in">return</span> str.replace(/(^\s</em>)/g, <span class="hljs-string">“”</span>);<br>        <span class="hljs-keyword">case</span> 4:<br>            <span class="hljs-built_in">return</span> str.replace(/(\s<em>$)/g, <span class="hljs-string">“”</span>);<br>        default:<br>            <span class="hljs-built_in">return</span> str;<br>    }<br>}<br></em></code></pre><br><h3 data-id="heading-3">2-2字母大小写切换</h3><br><pre class="hljs bash"><code>/<span class="hljs-built_in">type</span><br> 1:首字母大写<br> 2：首页母小写<br> 3：大小写转换<br> 4：全部大写<br> 5：全部小写<br> <em> </em>/<br>//ecDo.changeCase(<span class="hljs-string">‘asdasd’</span>,1)<br>//result：Asdasd<br>changeCase: <span class="hljs-keyword">function</span> (str, <span class="hljs-built_in">type</span>) {<br>    <span class="hljs-keyword">function</span> ToggleCase(str) {<br>        var itemText = <span class="hljs-string">“”</span><br>        str.split(<span class="hljs-string">“”</span>).forEach(<br>            <span class="hljs-keyword">function</span> (item) {<br>                <span class="hljs-keyword">if</span> (/^([a-z]+)/.test(item)) {<br>                    itemText += item.toUpperCase();<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (/^([A-Z]+)/.test(item)) {<br>                    itemText += item.toLowerCase();<br>                } <span class="hljs-keyword">else</span> {<br>                    itemText += item;<br>                }<br>            });<br>        <span class="hljs-built_in">return</span> itemText;<br>    }<br>    switch (<span class="hljs-built_in">type</span>) {<br>        <span class="hljs-keyword">case</span> 1:<br>            <span class="hljs-built_in">return</span> str.replace(/\b\w+\b/g, <span class="hljs-keyword">function</span> (word) {<br>                <span class="hljs-built_in">return</span> word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();<br>            });<br>        <span class="hljs-keyword">case</span> 2:<br>            <span class="hljs-built_in">return</span> str.replace(/\b\w+\b/g, <span class="hljs-keyword">function</span> (word) {<br>                <span class="hljs-built_in">return</span> word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();<br>            });<br>        <span class="hljs-keyword">case</span> 3:<br>            <span class="hljs-built_in">return</span> ToggleCase(str);<br>        <span class="hljs-keyword">case</span> 4:<br>            <span class="hljs-built_in">return</span> str.toUpperCase();<br>        <span class="hljs-keyword">case</span> 5:<br>            <span class="hljs-built_in">return</span> str.toLowerCase();<br>        default:<br>            <span class="hljs-built_in">return</span> str;<br>    }<br>}<br></code></pre><br><h3 data-id="heading-4">2-3字符串循环复制</h3><br><pre class="hljs bash"><code>//repeatStr(str-&gt;字符串, count-&gt;次数)<br>//ecDo.repeatStr(<span class="hljs-string">‘123’</span>,3)<br>//<span class="hljs-string">“result：123123123”</span><br>repeatStr: <span class="hljs-keyword">function</span> (str, count) {<br>    var text = <span class="hljs-string">‘’</span>;<br>    <span class="hljs-keyword">for</span> (var i = 0; i &lt; count; i++) {<br>        text += str;<br>    }<br>    <span class="hljs-built_in">return</span> text;<br>}<br></code></pre><br><h3 data-id="heading-5">2-4字符串替换</h3><br><pre class="hljs bash"><code>//ecDo.replaceAll(<span class="hljs-string">‘这里是上海，中国第三大城市，广东省省会，简称穗，’</span>,<span class="hljs-string">‘上海’</span>,<span class="hljs-string">‘广州’</span>)<br>//result：<span class="hljs-string">“这里是广州，中国第三大城市，广东省省会，简称穗，”</span><br>replaceAll: <span class="hljs-keyword">function</span> (str, AFindText, ARepText) {<br>    raRegExp = new RegExp(AFindText, <span class="hljs-string">“g”</span>);<br>    <span class="hljs-built_in">return</span> str.replace(raRegExp, ARepText);<br>}<br></code></pre><br><h3 data-id="heading-6">2-5替换<em>&nbsp;</em></h3><br><pre class="hljs bash"><code>//字符替换<br>//replaceStr(字符串,字符格式, 替换方式,替换的字符（默认<em>）)<br>//ecDo.replaceStr(<span class="hljs-string">‘18819322663’</span>,[3,5,3],0)<br>//result：188<em>**</em></em>663<br>//ecDo.replaceStr(<span class="hljs-string">‘asdasdasdaa’</span>,[3,5,3],1)<br>//result：<strong><em>asdas</em></strong><br>//ecDo.replaceStr(<span class="hljs-string">‘1asd88465asdwqe3’</span>,[5],0)<br>//result：<strong>*</strong>8465asdwqe3<br>//ecDo.replaceStr(<span class="hljs-string">‘1asd88465asdwqe3’</span>,[5],1,<span class="hljs-string">‘+’</span>)<br>//result：<span class="hljs-string">“1asd88465as+++++”</span><br>replaceStr: <span class="hljs-keyword">function</span> (str, regArr, <span class="hljs-built_in">type</span>, ARepText) {<br>    var regtext = <span class="hljs-string">‘’</span>,<br>        Reg = null,<br>        replaceText = ARepText || <span class="hljs-string">‘<em>‘</em></span>;<br>    //repeatStr是在上面定义过的（字符串循环复制），大家注意哦<br>    <span class="hljs-keyword">if</span> (regArr.length === 3 &amp;&amp; <span class="hljs-built_in">type</span> === 0) {<br>        regtext = <span class="hljs-string">‘(\w{‘</span> + regArr[0] + <span class="hljs-string">‘})\w{‘</span> + regArr[1] + <span class="hljs-string">‘}(\w{‘</span> + regArr[2] + <span class="hljs-string">‘})’</span><br>        Reg = new RegExp(regtext);<br>        var replaceCount = this.repeatStr(replaceText, regArr[1]);<br>        <span class="hljs-built_in">return</span> str.replace(Reg, <span class="hljs-string">‘$1’</span> + replaceCount + <span class="hljs-string">‘$2’</span>)<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (regArr.length === 3 &amp;&amp; <span class="hljs-built_in">type</span> === 1) {<br>        regtext = <span class="hljs-string">‘\w{‘</span> + regArr[0] + <span class="hljs-string">‘}(\w{‘</span> + regArr[1] + <span class="hljs-string">‘})\w{‘</span> + regArr[2] + <span class="hljs-string">‘}’</span><br>        Reg = new RegExp(regtext);<br>        var replaceCount1 = this.repeatStr(replaceText, regArr[0]);<br>        var replaceCount2 = this.repeatStr(replaceText, regArr[2]);<br>        <span class="hljs-built_in">return</span> str.replace(Reg, replaceCount1 + <span class="hljs-string">‘$1’</span> + replaceCount2)<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (regArr.length === 1 &amp;&amp; <span class="hljs-built_in">type</span> === 0) {<br>        regtext = <span class="hljs-string">‘(^\w{‘</span> + regArr[0] + <span class="hljs-string">‘})’</span><br>        Reg = new RegExp(regtext);<br>        var replaceCount = this.repeatStr(replaceText, regArr[0]);<br>        <span class="hljs-built_in">return</span> str.replace(Reg, replaceCount)<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (regArr.length === 1 &amp;&amp; <span class="hljs-built_in">type</span> === 1) {<br>        regtext = <span class="hljs-string">‘(\w{‘</span> + regArr[0] + <span class="hljs-string">‘}$)’</span><br>        Reg = new RegExp(regtext);<br>        var replaceCount = this.repeatStr(replaceText, regArr[0]);<br>        <span class="hljs-built_in">return</span> str.replace(Reg, replaceCount)<br>    }<br>}<br></code></pre><br><h3 data-id="heading-7">2-6检测字符串</h3><br><pre class="hljs bash"><code>//检测字符串<br>//ecDo.checkType(<span class="hljs-string">‘165226226326’</span>,<span class="hljs-string">‘phone’</span>)<br>//result：<span class="hljs-literal">false</span><br>//大家可以根据需要扩展<br>checkType: <span class="hljs-keyword">function</span> (str, <span class="hljs-built_in">type</span>) {<br>    switch (<span class="hljs-built_in">type</span>) {<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘email’</span>:<br>            <span class="hljs-built_in">return</span> /^[\w-]+(.[\w-]+)@[\w-]+(.[\w-]+)+$/.test(str);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘phone’</span>:<br>            <span class="hljs-built_in">return</span> /^1[3|4|5|7|8][0-9]{9}$/.test(str);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘tel’</span>:<br>            <span class="hljs-built_in">return</span> /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘number’</span>:<br>            <span class="hljs-built_in">return</span> /^[0-9]$/.test(str);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘english’</span>:<br>            <span class="hljs-built_in">return</span> /^[a-zA-Z]+$/.test(str);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘text’</span>:<br>            <span class="hljs-built_in">return</span> /^\w+$/.test(str);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘chinese’</span>:<br>            <span class="hljs-built_in">return</span> /^[\u4E00-\u9FA5]+$/.test(str);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘lower’</span>:<br>            <span class="hljs-built_in">return</span> /^[a-z]+$/.test(str);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘upper’</span>:<br>            <span class="hljs-built_in">return</span> /^[A-Z]+$/.test(str);<br>        default:<br>            <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br></code></pre><br><h3 data-id="heading-8">2-7 检测密码强度</h3><br><pre class="hljs bash"><code>//ecDo.checkPwd(<span class="hljs-string">‘12asdASAD’</span>)<br>//result：3(强度等级为3)<br>checkPwd: <span class="hljs-keyword">function</span> (str) {<br>    var nowLv = 0;<br>    <span class="hljs-keyword">if</span> (str.length &lt; 6) {<br>        <span class="hljs-built_in">return</span> nowLv<br>    }<br>    <span class="hljs-keyword">if</span> (/[0-9]/.test(str)) {<br>        nowLv++<br>    }<br>    <span class="hljs-keyword">if</span> (/[a-z]/.test(str)) {<br>        nowLv++<br>    }<br>    <span class="hljs-keyword">if</span> (/[A-Z]/.test(str)) {<br>        nowLv++<br>    }<br>    <span class="hljs-keyword">if</span> (/[.|-|_]/.test(str)) {<br>        nowLv++<br>    }<br>    <span class="hljs-built_in">return</span> nowLv;<br>}<br></code></pre><br><h3 data-id="heading-9">2-8随机码（toString详解）</h3><br><pre class="hljs bash"><code>//count取值范围0-36<br>//ecDo.randomWord(10)<br>//result：<span class="hljs-string">“2584316588472575”</span><br>//ecDo.randomWord(14)<br>//result：<span class="hljs-string">“9b405070dd00122640c192caab84537”</span><br>//ecDo.randomWord(36)<br>//result：<span class="hljs-string">“83vhdx10rmjkyb9”</span><br>randomWord: <span class="hljs-keyword">function</span> (count) {<br>    <span class="hljs-built_in">return</span> Math.random().toString(count).substring(2);<br>}<br></code></pre><br><h3 data-id="heading-10">2-9查找字符串</h3><br><p>可能标题会有点误导，下面我就简单说明一个需求，在字符串<code>‘sad44654blog5a1sd67as9dablog4s5d16zxc4sdweasjkblogwqepaskdkblogahseiuadbhjcibloguyeajzxkcabloguyiwezxc967’</code>中找出’blog’的出现次数。代码如下</p><br><pre class="hljs bash"><code>//var strTest=<span class="hljs-string">‘sad44654blog5a1sd67as9dablog4s5d16zxc4sdweasjkblogwqepaskdkblogahseiuadbhjcibloguyeajzxkcabloguyiwezxc967’</span><br>//ecDo.countStr(strTest,<span class="hljs-string">‘blog’</span>)<br>//result：6<br>countStr: <span class="hljs-keyword">function</span> (str, strSplit) {<br>    <span class="hljs-built_in">return</span> str.split(strSplit).length - 1<br>}<br></code></pre><br><h3 data-id="heading-11">2-10 过滤字符串&nbsp;</h3><br><pre class="hljs bash"><code>//过滤字符串(html标签，表情，特殊字符)<br>//字符串，替换内容（special-特殊字符,html-html标签,emjoy-emjoy表情,word-小写字母，WORD-大写字母，number-数字,chinese-中文），要替换成什么，默认<span class="hljs-string">‘’</span>,保留哪些特殊字符<br>//如果需要过滤多种字符，<span class="hljs-built_in">type</span>参数使用,分割，如下栗子<br>//过滤字符串的html标签，大写字母，中文，特殊字符，全部替换成<em>,但是特殊字符<span class="hljs-string">‘%’</span>，<span class="hljs-string">‘?’</span>，除了这两个，其他特殊字符全部清除<br>//var str=<span class="hljs-string">‘asd    654a大蠢sasdasdASDQWEXZC6d5#%^</span></em>^&amp;<em>^%^&amp;</em>$\“\’<span class="hljs-comment">#@!()<em>/-())_\’”:”{}?&lt;div&gt;&lt;/div&gt;&lt;img src=””/&gt;啊实打实大蠢猪自行车这些课程’;</em></span><br>// ecDo.filterStr(str,<span class="hljs-string">‘html,WORD,chinese,special’</span>,<span class="hljs-string">‘‘</span>,<span class="hljs-string">‘%?’</span>)<br>//result：<span class="hljs-string">“asd    654a<strong>sasdasd<strong>***</strong></strong>6d5#%^<em>^&amp;</em>^%^&amp;<em>$\”‘#@!()</em>/-())_’”</span>:<span class="hljs-string">“{}?<strong><strong><strong><strong>*</strong></strong></strong></strong>“</span><br>filterStr: <span class="hljs-keyword">function</span> (str, <span class="hljs-built_in">type</span>, restr, spstr) {<br>    var <span class="hljs-built_in">type</span>Arr = type.split(<span class="hljs-string">‘,’</span>), _str = str;<br>    <span class="hljs-keyword">for</span> (var i = 0, len = <span class="hljs-built_in">type</span>Arr.length; i &lt; len; i++) {<br>        //是否是过滤特殊符号<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">type</span>Arr[i] === <span class="hljs-string">‘special’</span>) {<br>            var pattern, regText = <span class="hljs-string">‘$()[]{}?|^<em>+./\”\’</em></span>+<span class="hljs-string">‘;<br>            //是否有哪些特殊符号需要保留<br>            if (spstr) {<br>                var _spstr = spstr.split(“”), _regText = “[^0-9A-Za-z\s”;<br>                for (var j = 0, len1 = _spstr.length; j &lt; len1; j++) {<br>                    if (regText.indexOf(_spstr[j]) === -1) {<br>                        _regText += _spstr[j];<br>                    }<br>                    else {<br>                        _regText += ‘</span>\<span class="hljs-string">‘ + _spstr[j];<br>                    }<br>                }<br>                _regText += ‘</span>]<span class="hljs-string">‘<br>                pattern = new RegExp(_regText, ‘</span>g<span class="hljs-string">‘);<br>            }<br>            else {<br>                pattern = new RegExp(“[^0-9A-Za-z\s]”, ‘</span>g<span class="hljs-string">‘)<br>            }<br>        }<br>        var _restr = restr || ‘</span><span class="hljs-string">‘;<br>        switch (typeArr[i]) {<br>            case ‘</span>special<span class="hljs-string">‘:<br>                _str = _str.replace(pattern, _restr);<br>                break;<br>            case ‘</span>html<span class="hljs-string">‘:<br>                _str = _str.replace(/&lt;\/?[^&gt;]&gt;/g, _restr);<br>                break;<br>            case ‘</span>emjoy<span class="hljs-string">‘:<br>                _str = _str.replace(/[^\u4e00-\u9fa5|\u0000-\u00ff|\u3002|\uFF1F|\uFF01|\uff0c|\u3001|\uff1b|\uff1a|\u3008-\u300f|\u2018|\u2019|\u201c|\u201d|\uff08|\uff09|\u2014|\u2026|\u2013|\uff0e]/g, _restr);<br>                break;<br>            case ‘</span>word<span class="hljs-string">‘:<br>                _str = _str.replace(/[a-z]/g, _restr);<br>                break;<br>            case ‘</span>WORD<span class="hljs-string">‘:<br>                _str = _str.replace(/[A-Z]/g, _restr);<br>                break;<br>            case ‘</span>number<span class="hljs-string">‘:<br>                _str = _str.replace(/[0-9]/g, _restr);<br>                break;<br>            case ‘</span>chinese<span class="hljs-string">‘:<br>                _str = _str.replace(/[\u4E00-\u9FA5]/g, _restr);<br>                break;<br>        }<br>    }<br>    return _str;<br>}<br></span></code></pre><br><h3 data-id="heading-12">2-11格式化处理字符串</h3><br><pre class="hljs bash"><code>//ecDo.formatText(<span class="hljs-string">‘1234asda567asd890’</span>)<br>//result：<span class="hljs-string">“12,34a,sda,567,asd,890”</span><br>//ecDo.formatText(<span class="hljs-string">‘1234asda567asd890’</span>,4,<span class="hljs-string">‘ ‘</span>)<br>//result：<span class="hljs-string">“1 234a sda5 67as d890”</span><br>//ecDo.formatText(<span class="hljs-string">‘1234asda567asd890’</span>,4,<span class="hljs-string">‘-‘</span>)<br>//result：<span class="hljs-string">“1-234a-sda5-67as-d890”</span><br>formatText: <span class="hljs-keyword">function</span> (str, size, delimiter) {<br>    var _size = size || 3, _delimiter = delimiter || <span class="hljs-string">‘,’</span>;<br>    var regText = <span class="hljs-string">‘\B(?=(\w{‘</span> + _size + <span class="hljs-string">‘})+(?!\w))’</span>;<br>    var reg = new RegExp(regText, <span class="hljs-string">‘g’</span>);<br>    <span class="hljs-built_in">return</span> str.replace(reg, _delimiter);<br>}<br></code></pre><br><h3 data-id="heading-13">2-12找出最长单词</h3><br><pre class="hljs bash"><code>//ecDo.longestWord(<span class="hljs-string">‘Find the Longest word in a String’</span>)<br>//result：7<br>//ecDo.longestWord(<span class="hljs-string">‘Find|the|Longest|word|in|a|String’</span>,<span class="hljs-string">‘|’</span>)<br>//result：7<br>longestWord: <span class="hljs-keyword">function</span> (str, splitType) {<br>    var _splitType = splitType || /\s+/g,<br>        _max = 0,_item=<span class="hljs-string">‘’</span>;<br>    var strArr = str.split(_splitType);<br>    strArr.forEach(<span class="hljs-keyword">function</span> (item) {<br>        <span class="hljs-keyword">if</span> (_max &lt; item.length) {<br>            _max = item.length<br>            _item=item;<br>        }<br>    })<br>    <span class="hljs-built_in">return</span> {el:_item,max:_max};<br>}<br></code></pre><br><h3 data-id="heading-14">2-13句中单词首字母大写&nbsp;</h3><br><pre class="hljs bash"><code>//这个我也一直在纠结，英文标题，即使是首字母大写，也未必每一个单词的首字母都是大写的，但是又不知道哪些应该大写，哪些不应该大写<br>//ecDo.titleCaseUp(<span class="hljs-string">‘this is a title’</span>)<br>//<span class="hljs-string">“This Is A Title”</span><br>titleCaseUp: <span class="hljs-keyword">function</span> (str, splitType) {<br>    var _splitType = splitType || /\s+/g;<br>    var strArr = str.split(_splitType),<br>        result = <span class="hljs-string">“”</span>, _this = this<br>    strArr.forEach(<span class="hljs-keyword">function</span> (item) {<br>        result += _this.changeCase(item, 1) + <span class="hljs-string">‘ ‘</span>;<br>    })<br>    <span class="hljs-built_in">return</span> this.trim(result, 4)<br>}<br></code></pre><br><h2 data-id="heading-15">3.数组操作</h2><br><h3 data-id="heading-16">3-1数组去重</h3><br><pre class="hljs bash"><code>removeRepeatArray: <span class="hljs-keyword">function</span> (arr) {<br>    <span class="hljs-built_in">return</span> arr.filter(<span class="hljs-keyword">function</span> (item, index, self) {<br>        <span class="hljs-built_in">return</span> self.indexOf(item) === index;<br>    });<br>}<br></code></pre><br><h3 data-id="heading-17">3-2数组顺序打乱</h3><br><pre class="hljs bash"><code>upsetArr: <span class="hljs-keyword">function</span> (arr) {<br>    <span class="hljs-built_in">return</span> arr.sort(<span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>        <span class="hljs-built_in">return</span> Math.random() - 0.5<br>    });<br>},<br></code></pre><br><h3 data-id="heading-18">3-3数组最大值最小值</h3><br><pre class="hljs bash"><code>//数组最大值<br>maxArr: <span class="hljs-keyword">function</span> (arr) {<br>    <span class="hljs-built_in">return</span> Math.max.apply(null, arr);<br>},<br>//数组最小值<br>minArr: <span class="hljs-keyword">function</span> (arr) {<br>    <span class="hljs-built_in">return</span> Math.min.apply(null, arr);<br>}<br></code></pre><br><h3 data-id="heading-19">3-4数组求和，平均值</h3><br><pre class="hljs bash"><code>//这一块的封装，主要是针对数字类型的数组<br>//求和<br>sumArr: <span class="hljs-keyword">function</span> (arr) {<br>    <span class="hljs-built_in">return</span> arr.reduce(<span class="hljs-keyword">function</span> (pre, cur) {<br>        <span class="hljs-built_in">return</span> pre + cur<br>    })<br>}<br>//数组平均值,小数点可能会有很多位，这里不做处理，处理了使用就不灵活！<br>covArr: <span class="hljs-keyword">function</span> (arr) {<br>    <span class="hljs-built_in">return</span> this.sumArr(arr) / arr.length;<br>},<br></code></pre><br><h3 data-id="heading-20">3-5从数组中随机获取元素</h3><br><pre class="hljs bash"><code>//ecDo.randomOne([1,2,3,6,8,5,4,2,6])<br>//2<br>//ecDo.randomOne([1,2,3,6,8,5,4,2,6])<br>//8<br>//ecDo.randomOne([1,2,3,6,8,5,4,2,6])<br>//8<br>//ecDo.randomOne([1,2,3,6,8,5,4,2,6])<br>//1<br>randomOne: <span class="hljs-keyword">function</span> (arr) {<br>    <span class="hljs-built_in">return</span> arr[Math.floor(Math.random() <em> arr.length)];<br>}<br></em></code></pre><br><h3 data-id="heading-21">3-6返回数组（字符串）一个元素出现的次数</h3><br><pre class="hljs bash"><code>//ecDo.getEleCount(<span class="hljs-string">‘asd56+asdasdwqe’</span>,<span class="hljs-string">‘a’</span>)<br>//result：3<br>//ecDo.getEleCount([1,2,3,4,5,66,77,22,55,22],22)<br>//result：2<br>getEleCount: <span class="hljs-keyword">function</span> (obj, ele) {<br>    var num = 0;<br>    <span class="hljs-keyword">for</span> (var i = 0, len = obj.length; i &lt; len; i++) {<br>        <span class="hljs-keyword">if</span> (ele === obj[i]) {<br>            num++;<br>        }<br>    }<br>    <span class="hljs-built_in">return</span> num;<br>}<br></code></pre><br><h3 data-id="heading-22">3-7返回数组（字符串）出现最多的几次元素和出现次数 ###</h3><br><pre class="hljs bash"><code>//arr, rank-&gt;长度，默认为数组长度，ranktype，排序方式，默认降序<br>//返回值：el-&gt;元素，count-&gt;次数<br>//ecDo.getCount([1,2,3,1,2,5,2,4,1,2,6,2,1,3,2])<br>//默认情况，返回所有元素出现的次数<br>//result：[{<span class="hljs-string">“el”</span>:<span class="hljs-string">“2”</span>,<span class="hljs-string">“count”</span>:6},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“1”</span>,<span class="hljs-string">“count”</span>:4},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“3”</span>,<span class="hljs-string">“count”</span>:2},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“4”</span>,<span class="hljs-string">“count”</span>:1},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“5”</span>,<span class="hljs-string">“count”</span>:1},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“6”</span>,<span class="hljs-string">“count”</span>:1}]<br>//ecDo.getCount([1,2,3,1,2,5,2,4,1,2,6,2,1,3,2],3)<br>//传参（rank=3），只返回出现次数排序前三的<br>//result：[{<span class="hljs-string">“el”</span>:<span class="hljs-string">“2”</span>,<span class="hljs-string">“count”</span>:6},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“1”</span>,<span class="hljs-string">“count”</span>:4},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“3”</span>,<span class="hljs-string">“count”</span>:2}]<br>//ecDo.getCount([1,2,3,1,2,5,2,4,1,2,6,2,1,3,2],null,1)<br>//传参（ranktype=1,rank=null），升序返回所有元素出现次数<br>//result：[{<span class="hljs-string">“el”</span>:<span class="hljs-string">“6”</span>,<span class="hljs-string">“count”</span>:1},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“5”</span>,<span class="hljs-string">“count”</span>:1},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“4”</span>,<span class="hljs-string">“count”</span>:1},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“3”</span>,<span class="hljs-string">“count”</span>:2},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“1”</span>,<span class="hljs-string">“count”</span>:4},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“2”</span>,<span class="hljs-string">“count”</span>:6}]<br>//ecDo.getCount([1,2,3,1,2,5,2,4,1,2,6,2,1,3,2],3,1)<br>//传参（rank=3，ranktype=1），只返回出现次数排序（升序）前三的<br>//result：[{<span class="hljs-string">“el”</span>:<span class="hljs-string">“6”</span>,<span class="hljs-string">“count”</span>:1},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“5”</span>,<span class="hljs-string">“count”</span>:1},{<span class="hljs-string">“el”</span>:<span class="hljs-string">“4”</span>,<span class="hljs-string">“count”</span>:1}]<br>getCount: <span class="hljs-keyword">function</span> (arr, rank, ranktype) {<br>    var obj = {},<br>        k, arr1 = []<br>    //记录每一元素出现的次数<br>    <span class="hljs-keyword">for</span> (var i = 0, len = arr.length; i &lt; len; i++) {<br>        k = arr[i];<br>        <span class="hljs-keyword">if</span> (obj[k]) {<br>            obj[k]++;<br>        } <span class="hljs-keyword">else</span> {<br>            obj[k] = 1;<br>        }<br>    }<br>    //保存结果{el-<span class="hljs-string">‘元素’</span>，count-出现次数}<br>    <span class="hljs-keyword">for</span> (var o <span class="hljs-keyword">in</span> obj) {<br>        arr1.push({el: o, count: obj[o]});<br>    }<br>    //排序（降序）<br>    arr1.sort(<span class="hljs-keyword">function</span> (n1, n2) {<br>        <span class="hljs-built_in">return</span> n2.count - n1.count<br>    });<br>    //如果ranktype为1，则为升序，反转数组<br>    <span class="hljs-keyword">if</span> (ranktype === 1) {<br>        arr1 = arr1.reverse();<br>    }<br>    var rank1 = rank || arr1.length;<br>    <span class="hljs-built_in">return</span> arr1.slice(0, rank1);<br>}<br></code></pre><br><h3 data-id="heading-23">3-8得到n1-n2下标的数组</h3><br><pre class="hljs bash"><code>//ecDo.getArrayNum([0,1,2,3,4,5,6,7,8,9],5,9)<br>//result：[5, 6, 7, 8, 9]<br>//getArrayNum([0,1,2,3,4,5,6,7,8,9],2) //不传第二个参数,默认返回从n1到数组结束的元素<br>//result：[2, 3, 4, 5, 6, 7, 8, 9]<br>getArrayNum: <span class="hljs-keyword">function</span> (arr, n1, n2) {<br>    <span class="hljs-built_in">return</span> arr.slice(n1, n2);<br>}<br></code></pre><br><h3 data-id="heading-24">3-9筛选数组</h3><br><pre class="hljs bash"><code>//删除值为<span class="hljs-string">‘val’</span>的数组元素<br>//ecDo.removeArrayForValue([<span class="hljs-string">‘test’</span>,<span class="hljs-string">‘test1’</span>,<span class="hljs-string">‘test2’</span>,<span class="hljs-string">‘test’</span>,<span class="hljs-string">‘aaa’</span>],<span class="hljs-string">‘test’</span>,<span class="hljs-string">‘)<br>//result：[“aaa”]   带有’</span><span class="hljs-built_in">test</span><span class="hljs-string">‘的都删除<br>//ecDo.removeArrayForValue([‘</span><span class="hljs-built_in">test</span><span class="hljs-string">‘,’</span><span class="hljs-built_in">test</span>1<span class="hljs-string">‘,’</span><span class="hljs-built_in">test</span>2<span class="hljs-string">‘,’</span><span class="hljs-built_in">test</span><span class="hljs-string">‘,’</span>aaa<span class="hljs-string">‘],’</span><span class="hljs-built_in">test</span><span class="hljs-string">‘)<br>//result：[“test1”, “test2”, “aaa”]  //数组元素的值全等于’</span><span class="hljs-built_in">test</span><span class="hljs-string">‘才被删除<br>removeArrayForValue: function (arr, val, type) {<br>    return arr.filter(function (item) {<br>        return type ? item.indexOf(val) === -1 : item !== val<br>    })<br>}<br></span></code></pre><br><h3 data-id="heading-25">3-10 获取对象数组某些项</h3><br><pre class="hljs bash"><code>//var arr=[{a:1,b:2,c:9},{a:2,b:3,c:5},{a:5,b:9},{a:4,b:2,c:5},{a:4,b:5,c:7}]<br>//ecDo.getOptionArray(arr,<span class="hljs-string">‘a,c’</span>)<br>//result：[{a:1,c:9},{a:2,c:5},{a:5,c:underfind},{a:4,c:5},{a:4,c:7}]<br>//ecDo.getOptionArray(arr,<span class="hljs-string">‘b’</span>)<br>//result：[2, 3, 9, 2, 5]<br>getOptionArray: <span class="hljs-keyword">function</span> (arr, keys) {<br>    var newArr = []<br>    <span class="hljs-keyword">if</span> (!keys) {<br>        <span class="hljs-built_in">return</span> arr<br>    }<br>    var _keys = keys.split(<span class="hljs-string">‘,’</span>), newArrOne = {};<br>    //是否只是需要获取某一项的值<br>    <span class="hljs-keyword">if</span> (_keys.length === 1) {<br>        <span class="hljs-keyword">for</span> (var i = 0, len = arr.length; i &lt; len; i++) {<br>            newArr.push(arr[i][keys])<br>        }<br>        <span class="hljs-built_in">return</span> newArr;<br>    }<br>    <span class="hljs-keyword">for</span> (var i = 0, len = arr.length; i &lt; len; i++) {<br>        newArrOne = {};<br>        <span class="hljs-keyword">for</span> (var j = 0, len1 = _keys.length; j &lt; len1; j++) {<br>            newArrOne[_keys[j]] = arr[i][_keys[j]]<br>        }<br>        newArr.push(newArrOne);<br>    }<br>    <span class="hljs-built_in">return</span> newArr<br>}<br></code></pre><br><h3 data-id="heading-26">3-11 排除对象数组某些项&nbsp;</h3><br><pre class="hljs bash"><code>//var arr=[{a:1,b:2,c:9},{a:2,b:3,c:5},{a:5,b:9},{a:4,b:2,c:5},{a:4,b:5,c:7}]<br>//ecDo.filterOptionArray(arr,<span class="hljs-string">‘a’</span>)<br>//result：[{b:2,c:9},{b:3,c:5},{b:9},{b:2,c:5},{b:5,c:7}]<br>//ecDo.filterOptionArray(arr,<span class="hljs-string">‘a,c’</span>)<br>//result：[{b:2},{b:3},{b:9},{b:2},{b:5}]<br>filterOptionArray: <span class="hljs-keyword">function</span> (arr, keys) {<br>    var newArr = []<br>    var _keys = keys.split(<span class="hljs-string">‘,’</span>), newArrOne = {};<br>    <span class="hljs-keyword">for</span> (var i = 0, len = arr.length; i &lt; len; i++) {<br>        newArrOne = {};<br>        <span class="hljs-keyword">for</span> (var key <span class="hljs-keyword">in</span> arr[i]) {<br>            //如果key不存在排除keys里面,添加数据<br>            <span class="hljs-keyword">if</span> (_keys.indexOf(key) === -1) {<br>                newArrOne[key] = arr[i][key];<br>            }<br>        }<br>        newArr.push(newArrOne);<br>    }<br>    <span class="hljs-built_in">return</span> newArr<br>}<br></code></pre><br><h3 data-id="heading-27">3-12 对象数组排序</h3><br><pre class="hljs bash"><code>//var arr=[{a:1,b:2,c:9},{a:2,b:3,c:5},{a:5,b:9},{a:4,b:2,c:5},{a:4,b:5,c:7}]<br>//ecDo.arraySort(arr,<span class="hljs-string">‘a,b’</span>)a是第一排序条件，b是第二排序条件<br>//result：[{<span class="hljs-string">“a”</span>:1,<span class="hljs-string">“b”</span>:2,<span class="hljs-string">“c”</span>:9},{<span class="hljs-string">“a”</span>:2,<span class="hljs-string">“b”</span>:3,<span class="hljs-string">“c”</span>:5},{<span class="hljs-string">“a”</span>:4,<span class="hljs-string">“b”</span>:2,<span class="hljs-string">“c”</span>:5},{<span class="hljs-string">“a”</span>:4,<span class="hljs-string">“b”</span>:5,<span class="hljs-string">“c”</span>:7},{<span class="hljs-string">“a”</span>:5,<span class="hljs-string">“b”</span>:9}]<br>arraySort: <span class="hljs-keyword">function</span> (arr, sortText) {<br>    <span class="hljs-keyword">if</span> (!sortText) {<br>        <span class="hljs-built_in">return</span> arr<br>    }<br>    var _sortText = sortText.split(<span class="hljs-string">‘,’</span>).reverse(), _arr = arr.slice(0);<br>    <span class="hljs-keyword">for</span> (var i = 0, len = _sortText.length; i &lt; len; i++) {<br>        _arr.sort(<span class="hljs-keyword">function</span> (n1, n2) {<br>            <span class="hljs-built_in">return</span> n1[_sortText[i]] - n2[_sortText[i]]<br>        })<br>    }<br>    <span class="hljs-built_in">return</span> _arr;<br>}<br></code></pre><br><h3 data-id="heading-28">3-13 数组扁平化</h3><br><pre class="hljs bash"><code>//ecDo.steamroller([1,2,[4,5,[1,23]]])<br>//[1, 2, 4, 5, 1, 23]<br>steamroller: <span class="hljs-keyword">function</span> (arr) {<br>    var newArr = [],_this=this;<br>    <span class="hljs-keyword">for</span> (var i = 0; i &lt; arr.length; i++) {<br>        <span class="hljs-keyword">if</span> (Array.isArray(arr[i])) {<br>            // 如果是数组，调用(递归)steamroller 将其扁平化<br>            // 然后再 push 到 newArr 中<br>            newArr.push.apply(newArr, _this.steamroller(arr[i]));<br>        } <span class="hljs-keyword">else</span> {<br>            // 不是数组直接 push 到 newArr 中<br>            newArr.push(arr[i]);<br>        }<br>    }<br>    <span class="hljs-built_in">return</span> newArr;<br>}<br></code></pre><br><h2 data-id="heading-29">4.基础DOM操作</h2><br><p>这个部分代码其实参考jquery的一些函数写法，唯一区别就是调用不用，参数一样.<br>比如下面的栗子</p><br><pre class="hljs bash"><code>//设置对象内容<br>jquery：$(<span class="hljs-string">‘#xxx’</span>).html(<span class="hljs-string">‘hello world’</span>);<br>现在：ecDo.html(document.getElementById(<span class="hljs-string">‘xxx’</span>),<span class="hljs-string">‘hello world’</span>)<br>//获取对象内容<br>jquery：$(<span class="hljs-string">‘#xxx’</span>).html();<br>现在：ecDo.html(document.getElementById(<span class="hljs-string">‘xxx’</span>))<br></code></pre><br><h3 data-id="heading-30">4-1检测对象是否有哪个类名</h3><br><pre class="hljs bash"><code>//检测对象是否有哪个类名<br>hasClass: <span class="hljs-keyword">function</span> (obj, classStr) {<br>    <span class="hljs-keyword">if</span> (obj.className &amp;&amp; this.trim(obj.className, 1) !== <span class="hljs-string">“”</span>) {<br>        var arr = obj.className.split(/\s+/); //这个正则表达式是因为class可以有多个,判断是否包含<br>        <span class="hljs-built_in">return</span> (arr.indexOf(classStr) == -1) ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>    }<br>}<br></code></pre><br><h3 data-id="heading-31">4-2 添加类名</h3><br><pre class="hljs bash"><code>addClass: <span class="hljs-keyword">function</span> (obj, classStr) {<br>    <span class="hljs-keyword">if</span> ((this.istype(obj, <span class="hljs-string">‘array’</span>) || this.istype(obj, <span class="hljs-string">‘elements’</span>)) &amp;&amp; obj.length &gt;= 1) {<br>        <span class="hljs-keyword">for</span> (var i = 0, len = obj.length; i &lt; len; i++) {<br>            <span class="hljs-keyword">if</span> (!this.hasClass(obj[i], classStr)) {<br>                obj[i].className += <span class="hljs-string">“ “</span> + classStr;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">if</span> (!this.hasClass(obj, classStr)) {<br>            obj.className += <span class="hljs-string">“ “</span> + classStr;<br>        }<br>    }<br>}<br></code></pre><br><h3 data-id="heading-32">4-3删除类名</h3><br><pre class="hljs bash"><code>removeClass: <span class="hljs-keyword">function</span> (obj, classStr) {<br>    <span class="hljs-keyword">if</span> ((this.istype(obj, <span class="hljs-string">‘array’</span>) || this.istype(obj, <span class="hljs-string">‘elements’</span>)) &amp;&amp; obj.length &gt; 1) {<br>        <span class="hljs-keyword">for</span> (var i = 0, len = obj.length; i &lt; len; i++) {<br>            <span class="hljs-keyword">if</span> (this.hasClass(obj[i], classStr)) {<br>                var reg = new RegExp(<span class="hljs-string">‘(\s|^)’</span> + classStr + <span class="hljs-string">‘(\s|$)’</span>);<br>                obj[i].className = obj[i].className.replace(reg, <span class="hljs-string">‘’</span>);<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">if</span> (this.hasClass(obj, classStr)) {<br>            var reg = new RegExp(<span class="hljs-string">‘(\s|^)’</span> + classStr + <span class="hljs-string">‘(\s|$)’</span>);<br>            obj.className = obj.className.replace(reg, <span class="hljs-string">‘’</span>);<br>        }<br>    }<br>}<br></code></pre><br><h3 data-id="heading-33">4-4替换类名(“被替换的类名”,”替换的类名”)</h3><br><pre class="hljs bash"><code>replaceClass: <span class="hljs-keyword">function</span> (obj, newName, oldName) {<br>    this.removeClass(obj, oldName);<br>    this.addClass(obj, newName);<br>}<br></code></pre><br><h3 data-id="heading-34">4-5获取兄弟节点</h3><br><pre class="hljs bash"><code>//ecDo.siblings(obj,<span class="hljs-string">‘#id’</span>)<br>siblings: <span class="hljs-keyword">function</span> (obj, opt) {<br>    var a = []; //定义一个数组，用来存o的兄弟元素<br>    var p = obj.previousSibling;<br>    <span class="hljs-keyword">while</span> (p) { //先取o的哥哥们 判断有没有上一个哥哥元素，如果有则往下执行 p表示previousSibling<br>        <span class="hljs-keyword">if</span> (p.nodeType === 1) {<br>            a.push(p);<br>        }<br>        p = p.previousSibling //最后把上一个节点赋给p<br>    }<br>    a.reverse() //把顺序反转一下 这样元素的顺序就是按先后的了<br>    var n = obj.nextSibling; //再取o的弟弟<br>    <span class="hljs-keyword">while</span> (n) { //判断有没有下一个弟弟结点 n是nextSibling的意思<br>        <span class="hljs-keyword">if</span> (n.nodeType === 1) {<br>            a.push(n);<br>        }<br>        n = n.nextSibling;<br>    }<br>    <span class="hljs-keyword">if</span> (opt) {<br>        var _opt = opt.substr(1);<br>        var b = [];//定义一个数组，用于储存过滤a的数组<br>        <span class="hljs-keyword">if</span> (opt[0] === <span class="hljs-string">‘.’</span>) {<br>            b = a.filter(<span class="hljs-keyword">function</span> (item) {<br>                <span class="hljs-built_in">return</span> item.className === _opt<br>            });<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt[0] === <span class="hljs-string">‘#’</span>) {<br>            b = a.filter(<span class="hljs-keyword">function</span> (item) {<br>                <span class="hljs-built_in">return</span> item.id === _opt<br>            });<br>        }<br>        <span class="hljs-keyword">else</span> {<br>            b = a.filter(<span class="hljs-keyword">function</span> (item) {<br>                <span class="hljs-built_in">return</span> item.tagName.toLowerCase() === opt<br>            });<br>        }<br>        <span class="hljs-built_in">return</span> b;<br>    }<br>    <span class="hljs-built_in">return</span> a;<br>}<br></code></pre><br><h3 data-id="heading-35">4-6设置样式</h3><br><pre class="hljs bash"><code>css: <span class="hljs-keyword">function</span> (obj, json) {<br>    <span class="hljs-keyword">for</span> (var attr <span class="hljs-keyword">in</span> json) {<br>        obj.style[attr] = json[attr];<br>    }<br>}<br></code></pre><br><h3 data-id="heading-36">4-7设置文本内容</h3><br><pre class="hljs bash"><code>html: <span class="hljs-keyword">function</span> (obj) {<br>    <span class="hljs-keyword">if</span> (arguments.length === 1) {<br>        <span class="hljs-built_in">return</span> obj.innerHTML;<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arguments.length === 2) {<br>        obj.innerHTML = arguments[1];<br>    }<br>}<br>text: <span class="hljs-keyword">function</span> (obj) {<br>    <span class="hljs-keyword">if</span> (arguments.length === 1) {<br>        <span class="hljs-built_in">return</span> obj.innerHTML;<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arguments.length === 2) {<br>        obj.innerHTML = this.filterStr(arguments[1],<span class="hljs-string">‘html’</span>);<br>    }<br>}<br></code></pre><br><h3 data-id="heading-37">4-8显示隐藏</h3><br><pre class="hljs bash"><code>show: <span class="hljs-keyword">function</span> (obj) {<br>    var blockArr=[<span class="hljs-string">‘div’</span>,<span class="hljs-string">‘li’</span>,<span class="hljs-string">‘ul’</span>,<span class="hljs-string">‘ol’</span>,<span class="hljs-string">‘dl’</span>,<span class="hljs-string">‘table’</span>,<span class="hljs-string">‘article’</span>,<span class="hljs-string">‘h1’</span>,<span class="hljs-string">‘h2’</span>,<span class="hljs-string">‘h3’</span>,<span class="hljs-string">‘h4’</span>,<span class="hljs-string">‘h5’</span>,<span class="hljs-string">‘h6’</span>,<span class="hljs-string">‘p’</span>,<span class="hljs-string">‘hr’</span>,<span class="hljs-string">‘header’</span>,<span class="hljs-string">‘footer’</span>,<span class="hljs-string">‘details’</span>,<span class="hljs-string">‘summary’</span>,<span class="hljs-string">‘section’</span>,<span class="hljs-string">‘aside’</span>,<span class="hljs-string">‘’</span>]<br>    <span class="hljs-keyword">if</span>(blockArr.indexOf(obj.tagName.toLocaleLowerCase())===-1){<br>        obj.style.display =<span class="hljs-string">‘inline’</span>;<br>    }<br>    <span class="hljs-keyword">else</span>{<br>        obj.style.display =<span class="hljs-string">‘block’</span>;<br>    }<br>},<br>hide: <span class="hljs-keyword">function</span> (obj) {<br>    obj.style.display = <span class="hljs-string">“none”</span>;<br>}<br></code></pre><br><h2 data-id="heading-38">5.其他操作</h2><br><h3 data-id="heading-39">5-1cookie</h3><br><pre class="hljs bash"><code>//cookie<br>//设置cookie<br><span class="hljs-built_in">set</span>Cookie: <span class="hljs-keyword">function</span> (name, value, iDay) {<br>    var oDate = new Date();<br>    oDate.setDate(oDate.getDate() + iDay);<br>    document.cookie = name + <span class="hljs-string">‘=’</span> + value + <span class="hljs-string">‘;expires=’</span> + oDate;<br>},<br>//获取cookie<br>getCookie: <span class="hljs-keyword">function</span> (name) {<br>    var arr = document.cookie.split(<span class="hljs-string">‘; ‘</span>);<br>    <span class="hljs-keyword">for</span> (var i = 0; i &lt; arr.length; i++) {<br>        var arr2 = arr[i].split(<span class="hljs-string">‘=’</span>);<br>        <span class="hljs-keyword">if</span> (arr2[0] == name) {<br>            <span class="hljs-built_in">return</span> arr2[1];<br>        }<br>    }<br>    <span class="hljs-built_in">return</span> <span class="hljs-string">‘’</span>;<br>},<br>//删除cookie<br>removeCookie: <span class="hljs-keyword">function</span> (name) {<br>    this.setCookie(name, 1, -1);<br>},<br></code></pre><br><h3 data-id="heading-40">5-2清除对象中值为空的属性</h3><br><pre class="hljs bash"><code>//ecDo.filterParams({a:<span class="hljs-string">“”</span>,b:null,c:<span class="hljs-string">“010”</span>,d:123})<br>//Object {c: <span class="hljs-string">“010”</span>, d: 123}<br>filterParams: <span class="hljs-keyword">function</span> (obj) {<br>    var _newPar = {};<br>    <span class="hljs-keyword">for</span> (var key <span class="hljs-keyword">in</span> obj) {<br>        <span class="hljs-keyword">if</span> ((obj[key] === 0 ||obj[key] === <span class="hljs-literal">false</span>|| obj[key]) &amp;&amp; obj[key].toString().replace(/(^\s)|(\s<em>$)/g, <span class="hljs-string">‘’</span>) !== <span class="hljs-string">‘’</span>) {<br>            _newPar[key] = obj[key];<br>        }<br>    }<br>    <span class="hljs-built_in">return</span> _newPar;<br>}<br></em></code></pre><br><h3 data-id="heading-41">5-3现金额大写转换函数</h3><br><pre class="hljs bash"><code>//ecDo.upDigit(168752632)<br>//result：<span class="hljs-string">“人民币壹亿陆仟捌佰柒拾伍万贰仟陆佰叁拾贰元整”</span><br>//ecDo.upDigit(1682)<br>//result：<span class="hljs-string">“人民币壹仟陆佰捌拾贰元整”</span><br>//ecDo.upDigit(-1693)<br>//result：<span class="hljs-string">“欠人民币壹仟陆佰玖拾叁元整”</span><br>upDigit: <span class="hljs-keyword">function</span> (n) {<br>    var fraction = [<span class="hljs-string">‘角’</span>, <span class="hljs-string">‘分’</span>, <span class="hljs-string">‘厘’</span>];<br>    var digit = [<span class="hljs-string">‘零’</span>, <span class="hljs-string">‘壹’</span>, <span class="hljs-string">‘贰’</span>, <span class="hljs-string">‘叁’</span>, <span class="hljs-string">‘肆’</span>, <span class="hljs-string">‘伍’</span>, <span class="hljs-string">‘陆’</span>, <span class="hljs-string">‘柒’</span>, <span class="hljs-string">‘捌’</span>, <span class="hljs-string">‘玖’</span>];<br>    var unit = [<br>        [<span class="hljs-string">‘元’</span>, <span class="hljs-string">‘万’</span>, <span class="hljs-string">‘亿’</span>],<br>        [<span class="hljs-string">‘’</span>, <span class="hljs-string">‘拾’</span>, <span class="hljs-string">‘佰’</span>, <span class="hljs-string">‘仟’</span>]<br>    ];<br>    var head = n &lt; 0 ? <span class="hljs-string">‘欠人民币’</span> : <span class="hljs-string">‘人民币’</span>;<br>    n = Math.abs(n);<br>    var s = <span class="hljs-string">‘’</span>;<br>    <span class="hljs-keyword">for</span> (var i = 0; i &lt; fraction.length; i++) {<br>        s += (digit[Math.floor(n  10 <em> Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, <span class="hljs-string">‘’</span>);<br>    }<br>    s = s || <span class="hljs-string">‘整’</span>;<br>    n = Math.floor(n);<br>    <span class="hljs-keyword">for</span> (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) {<br>        var p = <span class="hljs-string">‘’</span>;<br>        <span class="hljs-keyword">for</span> (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) {<br>            p = digit[n % 10] + unit[1][j] + p;<br>            n = Math.floor(n / 10);<br>        }<br>        s = p.replace(/(零.)</em>零$/, <span class="hljs-string">‘’</span>).replace(/^$/, <span class="hljs-string">‘零’</span>) + unit[0][i] + s;<br>        //s = p + unit[0][i] + s;<br>    }<br>    <span class="hljs-built_in">return</span> head + s.replace(/(零.)<em>零元/, <span class="hljs-string">‘元’</span>).replace(/(零.)+/g, <span class="hljs-string">‘零’</span>).replace(/^整$/, <span class="hljs-string">‘零元整’</span>);<br>}<br></em></code></pre><br><h3 data-id="heading-42">5-4获取，设置url参数</h3><br><pre class="hljs bash"><code>//设置url参数<br>//ecDo.setUrlPrmt({<span class="hljs-string">‘a’</span>:1,<span class="hljs-string">‘b’</span>:2})<br>//result：a=1&amp;b=2<br><span class="hljs-built_in">set</span>UrlPrmt: <span class="hljs-keyword">function</span> (obj) {<br>    var _rs = [];<br>    <span class="hljs-keyword">for</span> (var p <span class="hljs-keyword">in</span> obj) {<br>        <span class="hljs-keyword">if</span> (obj[p] != null &amp;&amp; obj[p] != <span class="hljs-string">‘’</span>) {<br>            _rs.push(p + <span class="hljs-string">‘=’</span> + obj[p])<br>        }<br>    }<br>    <span class="hljs-built_in">return</span> _rs.join(<span class="hljs-string">‘&amp;’</span>);<br>},<br>//获取url参数<br>//ecDo.getUrlPrmt(<span class="hljs-string">‘test.com/write?draftId=122000011938’</span>)<br>//result：Object{draftId: <span class="hljs-string">“122000011938”</span>}<br>getUrlPrmt: <span class="hljs-keyword">function</span> (url) {<br>    url = url ? url : window.location.href;<br>    var _pa = url.substring(url.indexOf(<span class="hljs-string">‘?’</span>) + 1),<br>        _arrS = _pa.split(<span class="hljs-string">‘&amp;’</span>),<br>        _rs = {};<br>    <span class="hljs-keyword">for</span> (var i = 0, _len = _arrS.length; i &lt; _len; i++) {<br>        var pos = _arrS[i].indexOf(<span class="hljs-string">‘=’</span>);<br>        <span class="hljs-keyword">if</span> (pos == -1) {<br>            <span class="hljs-built_in">continue</span>;<br>        }<br>        var name = _arrS[i].substring(0, pos),<br>            value = window.decodeURIComponent(_arrS[i].substring(pos + 1));<br>        _rs[name] = value;<br>    }<br>    <span class="hljs-built_in">return</span> _rs;<br>}<br></code></pre><br><h3 data-id="heading-43">5-5随机返回一个范围的数字</h3><br><pre class="hljs bash"><code>//ecDo.randomNumber(5,10)<br>//返回5-10的随机整数，包括5，10<br>//ecDo.randomNumber(10)<br>//返回0-10的随机整数，包括0，10<br>//ecDo.randomNumber()<br>//返回0-255的随机整数，包括0，255<br>randomNumber: <span class="hljs-keyword">function</span> (n1, n2) {<br>    <span class="hljs-keyword">if</span> (arguments.length === 2) {<br>        <span class="hljs-built_in">return</span> Math.round(n1 + Math.random()  (n2 - n1));<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arguments.length === 1) {<br>        <span class="hljs-built_in">return</span> Math.round(Math.random() <em> n1)<br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-built_in">return</span> Math.round(Math.random() </em> 255)<br>    }<br>}<br></code></pre><br><h3 data-id="heading-44">5-6随进产生颜色</h3><br><pre class="hljs bash"><code>randomColor: <span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>    //randomNumber是下面定义的函数<br>    //写法1<br>    //<span class="hljs-built_in">return</span> <span class="hljs-string">‘rgb(‘</span> + this.randomNumber(255) + <span class="hljs-string">‘,’</span> + this.randomNumber(255) + <span class="hljs-string">‘,’</span> + this.randomNumber(255) + <span class="hljs-string">‘)’</span>;<br>    //写法2<br>    <span class="hljs-built_in">return</span> <span class="hljs-string">‘#’</span> + Math.random().toString(16).substring(2).substr(0, 6);<br>    //写法3<br>    //var color=<span class="hljs-string">‘#’</span>,_index=this.randomNumber(15);<br>    //<span class="hljs-keyword">for</span>(var i=0;i&lt;6;i++){<br>    //color+=<span class="hljs-string">‘0123456789abcdef’</span>[_index];<br>    //}<br>    //<span class="hljs-built_in">return</span> color;<br>}<br>//这种写法，偶尔会有问题。大家得注意哦<br>//Math.floor(Math.random()<em>0xffffff).toString(16);<br></em></code></pre><br><p><img alt="clipboard.png" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2017/12/8/16031bc0d8a33cb2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="549" data-height="216" src="https://user-gold-cdn.xitu.io/2017/12/8/16031bc0d8a33cb2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><br><h3 data-id="heading-45">5-7Date日期时间部分</h3><br><pre class="hljs bash"><code>//到某一个时间的倒计时<br>//ecDo.getEndTime(<span class="hljs-string">‘2017/7/22 16:0:0’</span>)<br>//result：<span class="hljs-string">“剩余时间6天 2小时 28 分钟20 秒”</span><br>getEndTime: <span class="hljs-keyword">function</span> (endTime) {<br>    var startDate = new Date(); //开始时间，当前时间<br>    var endDate = new Date(endTime); //结束时间，需传入时间参数<br>    var t = endDate.getTime() - startDate.getTime(); //时间差的毫秒数<br>    var d = 0,<br>        h = 0,<br>        m = 0,<br>        s = 0;<br>    <span class="hljs-keyword">if</span> (t &gt;= 0) {<br>        d = Math.floor(t / 1000 / 3600 / 24);<br>        h = Math.floor(t / 1000 / 60 / 60 % 24);<br>        m = Math.floor(t / 1000 / 60 % 60);<br>        s = Math.floor(t / 1000 % 60);<br>    }<br>    <span class="hljs-built_in">return</span> <span class="hljs-string">“剩余时间”</span> + d + <span class="hljs-string">“天 “</span> + h + <span class="hljs-string">“小时 “</span> + m + <span class="hljs-string">“ 分钟”</span> + s + <span class="hljs-string">“ 秒”</span>;<br>}<br></code></pre><br><h3 data-id="heading-46">5-8适配rem</h3><br><p>这个适配的方法很多，我就写我自己用的方法。大家也可以去我回答过得一个问题那里看更详细的说明！<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fq%2F1010000010179208%2Fa-1020000010179558" target="_blank" rel="nofollow noopener noreferrer">移动端适配问题</a></p><br><pre class="hljs bash"><code>getFontSize: <span class="hljs-keyword">function</span> (_client) {<br>    var doc = document,<br>        win = window;<br>    var docEl = doc.documentElement,<br>        resizeEvt = <span class="hljs-string">‘orientationchange’</span> <span class="hljs-keyword">in</span> window ? <span class="hljs-string">‘orientationchange’</span> : <span class="hljs-string">‘resize’</span>,<br>        recalc = <span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>            var clientWidth = docEl.clientWidth;<br>            <span class="hljs-keyword">if</span> (!clientWidth) <span class="hljs-built_in">return</span>;<br>            //如果屏幕大于750（750是根据我效果图设置的，具体数值参考效果图），就设置clientWidth=750，防止font-size会超过100px<br>            <span class="hljs-keyword">if</span> (clientWidth &gt; _client) {<br>                clientWidth = _client<br>            }<br>            //设置根元素font-size大小<br>            docEl.style.fontSize = 100  (clientWidth / _client) + <span class="hljs-string">‘px’</span>;<br>        };<br>    //屏幕大小改变，或者横竖屏切换时，触发函数<br>    win.addEventListener(resizeEvt, recalc, <span class="hljs-literal">false</span>);<br>    //文档加载完成时，触发函数<br>    doc.addEventListener(<span class="hljs-string">‘DOMContentLoaded’</span>, recalc, <span class="hljs-literal">false</span>);<br>}<br>//ecDo.getFontSize(750)<br>//使用方式很简单，比如效果图上，有张图片。宽高都是100px;<br>//750是设计图的宽度<br>//样式写法就是<br>img{<br>    width:1rem;<br>    height:1rem;<br>}<br>//这样的设置，比如在屏幕宽度大于等于750px设备上，1rem=100px；图片显示就是宽高都是100px<br>//比如在iphone6(屏幕宽度：375)上，375/750<em>100=50px;就是1rem=50px;图片显示就是宽高都是50px;<br></em></code></pre><br><h3 data-id="heading-47">5-9ajax</h3><br><pre class="hljs bash"><code>/ 封装ajax函数<br> <em> @param {string}obj.type http连接的方式，包括POST和GET两种方式 </em> @param {string}obj.url 发送请求的url<br> <em> @param {boolean}obj.async 是否为异步请求，<span class="hljs-literal">true</span>为异步的，<span class="hljs-literal">false</span>为同步的 </em> @param {object}obj.data 发送的参数，格式为对象类型<br> <em> @param {<span class="hljs-keyword">function</span>}obj.success ajax发送并接收成功调用的回调函数 </em> @param {<span class="hljs-keyword">function</span>}obj.error ajax发送失败或者接收失败调用的回调函数<br> <em>/<br>//  ecDo.ajax({<br>//      <span class="hljs-built_in">type</span>:<span class="hljs-string">‘get’</span>,<br>//      url:<span class="hljs-string">‘xxx’</span>,<br>//      data:{<br>//          id:<span class="hljs-string">‘111’</span><br>//      },<br>//      success:<span class="hljs-keyword">function</span>(res){<br>//          console.log(res)<br>//      }<br>//  })<br>ajax: <span class="hljs-keyword">function</span> (obj) {<br>    obj = obj || {};<br>    obj.type = obj.type.toUpperCase() || <span class="hljs-string">‘POST’</span>;<br>    obj.url = obj.url || <span class="hljs-string">‘’</span>;<br>    obj.async = obj.async || <span class="hljs-literal">true</span>;<br>    obj.data = obj.data || null;<br>    obj.success = obj.success || <span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>        };<br>    obj.error = obj.error || <span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>        };<br>    var xmlHttp = null;<br>    <span class="hljs-keyword">if</span> (XMLHttpRequest) {<br>        xmlHttp = new XMLHttpRequest();<br>    } <span class="hljs-keyword">else</span> {<br>        xmlHttp = new ActiveXObject(<span class="hljs-string">‘Microsoft.XMLHTTP’</span>);<br>    }<br>    var params = [];<br>    <span class="hljs-keyword">for</span> (var key <span class="hljs-keyword">in</span> obj.data) {<br>        params.push(key + <span class="hljs-string">‘=’</span> + obj.data[key]);<br>    }<br>    var postData = params.join(<span class="hljs-string">‘&amp;’</span>);<br>    <span class="hljs-keyword">if</span> (obj.type.toUpperCase() === <span class="hljs-string">‘POST’</span>) {<br>        xmlHttp.open(obj.type, obj.url, obj.async);<br>        xmlHttp.setRequestHeader(<span class="hljs-string">‘Content-Type’</span>, <span class="hljs-string">‘application/x-www-form-urlencoded;charset=utf-8’</span>);<br>        xmlHttp.send(postData);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj.type.toUpperCase() === <span class="hljs-string">‘GET’</span>) {<br>        xmlHttp.open(obj.type, obj.url + <span class="hljs-string">‘?’</span> + postData, obj.async);<br>        xmlHttp.send(null);<br>    }<br>    xmlHttp.onreadystatechange = <span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>        <span class="hljs-keyword">if</span> (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) {<br>            obj.success(xmlHttp.responseText);<br>        } <span class="hljs-keyword">else</span> {<br>            obj.error(xmlHttp.responseText);<br>        }<br>    };<br>}<br></em></code></pre><br><h3 data-id="heading-48">5-10图片懒加载&nbsp;</h3><br><pre class="hljs bash"><code>//图片没加载出来时用一张图片代替<br>aftLoadImg: <span class="hljs-keyword">function</span> (obj, url, errorUrl,cb) {<br>    var oImg = new Image(), _this = this;<br>    oImg.src = url;<br>    oImg.onload = <span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>        obj.src = oImg.src;<br>        <span class="hljs-keyword">if</span> (cb &amp;&amp; _this.istype(cb, <span class="hljs-string">‘function’</span>)) {<br>            cb(obj);<br>        }<br>    }<br>    oImg.onerror=<span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>        obj.src=errorUrl;<br>        <span class="hljs-keyword">if</span> (cb &amp;&amp; _this.istype(cb, <span class="hljs-string">‘function’</span>)) {<br>            cb(obj);<br>        }<br>    }<br>},<br>//图片滚动懒加载<br>//@className {string} 要遍历图片的类名<br>//@num {number} 距离多少的时候开始加载 默认 0<br>//比如，一张图片距离文档顶部3000，num参数设置200，那么在页面滚动到2800的时候，图片加载。不传num参数就滚动，num默认是0，页面滚动到3000就加载<br>//html代码<br>//&lt;p&gt;&lt;img data-src=<span class="hljs-string">“<a href="https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot;" target="_blank" rel="noopener">https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot;</a></span> class=<span class="hljs-string">“load-img”</span> width=<span class="hljs-string">‘528’</span> height=<span class="hljs-string">‘304’</span> /&gt;&lt;/p&gt;<br>//&lt;p&gt;&lt;img data-src=<span class="hljs-string">“<a href="https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot;" target="_blank" rel="noopener">https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot;</a></span> class=<span class="hljs-string">“load-img”</span> width=<span class="hljs-string">‘528’</span> height=<span class="hljs-string">‘304’</span> /&gt;&lt;/p&gt;<br>//&lt;p&gt;&lt;img data-src=<span class="hljs-string">“<a href="https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot;" target="_blank" rel="noopener">https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot;</a></span> class=<span class="hljs-string">“load-img”</span> width=<span class="hljs-string">‘528’</span> height=<span class="hljs-string">‘304’</span> /&gt;&lt;/p&gt;….<br>//data-src储存src的数据，到需要加载的时候把data-src的值赋值给src属性，图片就会加载。<br>//详细可以查看<span class="hljs-built_in">test</span>LoadImg.html<br>//window.onload = <span class="hljs-function"><span class="hljs-title">function</span></span>() {<br>//    loadImg(<span class="hljs-string">‘load-img’</span>,100);<br>//    window.onscroll = <span class="hljs-function"><span class="hljs-title">function</span></span>() {<br>//        ecDo.loadImg(<span class="hljs-string">‘load-img’</span>,100);<br>//        }<br>//}<br>loadImg: <span class="hljs-keyword">function</span> (className, num, errorUrl) {<br>    var _className = className || <span class="hljs-string">‘ec-load-img’</span>, _num = num || 0, _this = this,_errorUrl=errorUrl||null;<br>    var oImgLoad = document.getElementsByClassName(_className);<br>    <span class="hljs-keyword">for</span> (var i = 0, len = oImgLoad.length; i &lt; len; i++) {<br>        //如果图片已经滚动到指定的高度<br>        <span class="hljs-keyword">if</span> (document.documentElement.clientHeight + document.documentElement.scrollTop &gt; oImgLoad[i].offsetTop - _num &amp;&amp; !oImgLoad[i].isLoad) {<br>            //记录图片是否已经加载<br>            oImgLoad[i].isLoad = <span class="hljs-literal">true</span>;<br>            //设置过渡，当图片下来的时候有一个图片透明度变化<br>            oImgLoad[i].style.cssText = <span class="hljs-string">“transition: ‘’; opacity: 0;”</span><br>            <span class="hljs-keyword">if</span> (oImgLoad[i].dataset) {<br>                this.aftLoadImg(oImgLoad[i], oImgLoad[i].dataset.src, _errorUrl, <span class="hljs-keyword">function</span> (o) {<br>                    //添加定时器，确保图片已经加载完了，再把图片指定的的class，清掉，避免重复编辑<br>                    <span class="hljs-built_in">set</span>Timeout(<span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>                        <span class="hljs-keyword">if</span> (o.isLoad) {<br>                            _this.removeClass(o, _className);<br>                            o.style.cssText = <span class="hljs-string">“”</span>;<br>                        }<br>                    }, 1000)<br>                });<br>            } <span class="hljs-keyword">else</span> {<br>                this.aftLoadImg(oImgLoad[i], oImgLoad[i].getAttribute(<span class="hljs-string">“data-src”</span>), _errorUrl, <span class="hljs-keyword">function</span> (o) {<br>                    //添加定时器，确保图片已经加载完了，再把图片指定的的class，清掉，避免重复编辑<br>                    <span class="hljs-built_in">set</span>Timeout(<span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>                        <span class="hljs-keyword">if</span> (o.isLoad) {<br>                            _this.removeClass(o, _className);<br>                            o.style.cssText = <span class="hljs-string">“”</span>;<br>                        }<br>                    }, 1000)<br>                });<br>            }<br>            (<span class="hljs-keyword">function</span> (i) {<br>                <span class="hljs-built_in">set</span>Timeout(<span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>                    oImgLoad[i].style.cssText = <span class="hljs-string">“transition:all 1s; opacity: 1;”</span>;<br>                }, 16)<br>            })(i);<br>        }<br>    }<br>}<br></code></pre><br><h3 data-id="heading-49">5-11关键词加标签&nbsp;</h3><br><pre class="hljs bash"><code>//这两个函数多用于搜索的时候，关键词高亮<br>//创建正则字符<br>//ecDo.createKeyExp([前端，过来])<br>//result:(前端|过来)/g<br>createKeyExp: <span class="hljs-keyword">function</span> (strArr) {<br>    var str = <span class="hljs-string">“”</span>;<br>    <span class="hljs-keyword">for</span> (var i = 0; i &lt; strArr.length; i++) {<br>        <span class="hljs-keyword">if</span> (i != strArr.length - 1) {<br>            str = str + strArr[i] + <span class="hljs-string">“|”</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            str = str + strArr[i];<br>        }<br>    }<br>    <span class="hljs-built_in">return</span> <span class="hljs-string">“(“</span> + str + <span class="hljs-string">“)”</span>;<br>},<br>//关键字加标签（多个关键词用空格隔开）<br>//ecDo.findKey(<span class="hljs-string">‘守侯我oaks接到了来自下次你离开快乐吉祥留在开城侯’</span>,<span class="hljs-string">‘守侯 开’</span>,<span class="hljs-string">‘i’</span>)<br>//<span class="hljs-string">“&lt;i&gt;守侯&lt;/i&gt;我oaks接到了来自下次你离&lt;i&gt;开&lt;/i&gt;快乐吉祥留在&lt;i&gt;开&lt;/i&gt;城侯”</span><br>findKey: <span class="hljs-keyword">function</span> (str, key, el) {<br>    var arr = null,<br>        regStr = null,<br>        content = null,<br>        Reg = null,<br>        _el = el || <span class="hljs-string">‘span’</span>;<br>    arr = key.split(/\s+/);<br>    //alert(regStr); //    如：(前端|过来)<br>    regStr = this.createKeyExp(arr);<br>    content = str;<br>    //alert(Reg);//        /如：(前端|过来)/g<br>    Reg = new RegExp(regStr, <span class="hljs-string">“g”</span>);<br>    //过滤html标签 替换标签，往关键字前后加上标签<br>    content = content.replace(/&lt;\/?[^&gt;]&gt;/g, <span class="hljs-string">‘’</span>)<br>    <span class="hljs-built_in">return</span> content.replace(Reg, <span class="hljs-string">“&lt;”</span> + _el + <span class="hljs-string">“&gt;<span class="hljs-variable">$1</span>&lt;/“</span> + _el + <span class="hljs-string">“&gt;”</span>);<br>}<br></code></pre><br><h3 data-id="heading-50">5-12数据类型判断&nbsp;</h3><br><pre class="hljs bash"><code>//ecDo.istype([],<span class="hljs-string">‘array’</span>)<br>//<span class="hljs-literal">true</span><br>//ecDo.istype([])<br>//<span class="hljs-string">‘[object Array]’</span><br>istype: <span class="hljs-keyword">function</span> (o, <span class="hljs-built_in">type</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">type</span>) {<br>        var _type = type.toLowerCase();<br>    }<br>    switch (_type) {<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘string’</span>:<br>            <span class="hljs-built_in">return</span> Object.prototype.toString.call(o) === <span class="hljs-string">‘[object String]’</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘number’</span>:<br>            <span class="hljs-built_in">return</span> Object.prototype.toString.call(o) === <span class="hljs-string">‘[object Number]’</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘boolean’</span>:<br>            <span class="hljs-built_in">return</span> Object.prototype.toString.call(o) === <span class="hljs-string">‘[object Boolean]’</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘undefined’</span>:<br>            <span class="hljs-built_in">return</span> Object.prototype.toString.call(o) === <span class="hljs-string">‘[object Undefined]’</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘null’</span>:<br>            <span class="hljs-built_in">return</span> Object.prototype.toString.call(o) === <span class="hljs-string">‘[object Null]’</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘function’</span>:<br>            <span class="hljs-built_in">return</span> Object.prototype.toString.call(o) === <span class="hljs-string">‘[object Function]’</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘array’</span>:<br>            <span class="hljs-built_in">return</span> Object.prototype.toString.call(o) === <span class="hljs-string">‘[object Array]’</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘object’</span>:<br>            <span class="hljs-built_in">return</span> Object.prototype.toString.call(o) === <span class="hljs-string">‘[object Object]’</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘nan’</span>:<br>            <span class="hljs-built_in">return</span> isNaN(o);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘elements’</span>:<br>            <span class="hljs-built_in">return</span> Object.prototype.toString.call(o).indexOf(<span class="hljs-string">‘HTML’</span>) !== -1<br>        default:<br>            <span class="hljs-built_in">return</span> Object.prototype.toString.call(o)<br>    }<br>}<br></code></pre><br><h3 data-id="heading-51">5-13手机类型判断</h3><br><pre class="hljs bash"><code>browserInfo: <span class="hljs-keyword">function</span> (<span class="hljs-built_in">type</span>) {<br>    switch (<span class="hljs-built_in">type</span>) {<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘android’</span>:<br>            <span class="hljs-built_in">return</span> navigator.userAgent.toLowerCase().indexOf(<span class="hljs-string">‘android’</span>) !== -1<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘iphone’</span>:<br>            <span class="hljs-built_in">return</span> navigator.userAgent.toLowerCase().indexOf(<span class="hljs-string">‘iphone’</span>) !== -1<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘ipad’</span>:<br>            <span class="hljs-built_in">return</span> navigator.userAgent.toLowerCase().indexOf(<span class="hljs-string">‘ipad’</span>) !== -1<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">‘weixin’</span>:<br>            <span class="hljs-built_in">return</span> navigator.userAgent.toLowerCase().indexOf(<span class="hljs-string">‘micromessenger’</span>) !== -1<br>        default:<br>            <span class="hljs-built_in">return</span> navigator.userAgent.toLowerCase()<br>    }<br>}<br></code></pre><br><h3 data-id="heading-52">5-14函数节流</h3><br><pre class="hljs bash"><code>//多用于鼠标滚动，移动，窗口大小改变等高频率触发事件<br>// var count=0;<br>// <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn1</span></span>(){<br>//     count++;<br>//     console.log(count)<br>// }<br>// //100ms内连续触发的调用，后一个调用会把前一个调用的等待处理掉，但每隔200ms至少执行一次<br>// document.onmousemove=ecDo.delayFn(fn1,100,200)<br>delayFn: <span class="hljs-keyword">function</span> (fn, delay, mustDelay) {<br>    var timer = null;<br>    var t_start;<br>    <span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>        var context = this, args = arguments, t_cur = +new Date();<br>        //先清理上一次的调用触发（上一次调用触发事件不执行）<br>        clearTimeout(timer);<br>        //如果不存触发时间，那么当前的时间就是触发时间<br>        <span class="hljs-keyword">if</span> (!t_start) {<br>            t_start = t_cur;<br>        }<br>        //如果当前时间-触发时间大于最大的间隔时间（mustDelay），触发一次函数运行函数<br>        <span class="hljs-keyword">if</span> (t_cur - t_start &gt;= mustDelay) {<br>            fn.apply(context, args);<br>            t_start = t_cur;<br>        }<br>        //否则延迟执行<br>        <span class="hljs-keyword">else</span> {<br>            timer = <span class="hljs-built_in">set</span>Timeout(<span class="hljs-function"><span class="hljs-title">function</span></span> () {<br>                fn.apply(context, args);<br>            }, delay);<br>        }<br>    };<br>}<br></code></pre><br><h2 data-id="heading-53">6.封装成形</h2><br><blockquote><br>  <p>可能有小伙伴会有疑问，这样封装，调用有点麻烦，为什么不直接在原型上面封装，调用方便。比如下面的栗子！</p><br></blockquote><br><pre class="hljs bash"><code>String.prototype.trim=<span class="hljs-keyword">function</span>(<span class="hljs-built_in">type</span>){<br>    switch (<span class="hljs-built_in">type</span>){<br>        <span class="hljs-keyword">case</span> 1:<span class="hljs-built_in">return</span> this.replace(/\s+/g,<span class="hljs-string">“”</span>);<br>        <span class="hljs-keyword">case</span> 2:<span class="hljs-built_in">return</span> this.replace(/(^\s<em>)|(\s</em>$)/g, <span class="hljs-string">“”</span>);<br>        <span class="hljs-keyword">case</span> 3:<span class="hljs-built_in">return</span> this.replace(/(^\s<em>)/g, <span class="hljs-string">“”</span>);<br>        <span class="hljs-keyword">case</span> 4:<span class="hljs-built_in">return</span> this.replace(/(\s</em>$)/g, <span class="hljs-string">“”</span>);<br>        default:<span class="hljs-built_in">return</span> this;<br>    }<br>}<br>//<span class="hljs-string">‘  12345 6 8 96  ‘</span>.trim(1)<br>//<span class="hljs-string">“123456896”</span><br>//比这样trim(<span class="hljs-string">‘  12345 6 8 96  ‘</span>,1)调用方便。<br>//但是，这样是不推荐的做法，这样就污染了原生对象String,别人创建的String也会被污染，造成不必要的开销。<br>//更可怕的是，万一自己命名的跟原生的方法重名了，就被覆盖原来的方法了<br>//String.prototype.substr=<span class="hljs-function"><span class="hljs-title">function</span></span>(){console.log(<span class="hljs-string">‘asdasd’</span>)}<br>//<span class="hljs-string">‘asdasdwe46546’</span>.substr()<br>//asdasd<br>//substr方法有什么作用，大家应该知道，不知道的可以去w3c看下<br></code></pre><br><p>所以在原生对象原型的修改很不推荐！至少很多的公司禁止这样操作！</p><br><p>所以建议的封装姿势是</p><br><pre class="hljs bash"><code>var ecDo={<br>    trim:<span class="hljs-function"><span class="hljs-title">function</span></span>(){..},<br>    changeCase:<span class="hljs-function"><span class="hljs-title">function</span></span>(){..}…<br>}<br></code></pre><br><h2 data-id="heading-54">7.小结</h2><br><p>这篇文章，写了很久了，几个小时了，因为我写这篇文章，我也是重新改我以前代码的，因为我以前写的代码，功能一样，代码比较多，现在是边想边改边写，还要自己测试（之前的代码for循环很多，现在有很多简洁的写法代替）。加上最近公司比较忙，所以这一篇文章也是花了几天才整理完成。<br>源码都放在github上了，大家想以后以后有什么修改或者增加的，欢迎大家来star一下<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FchenhuiYj%2Fec-do" target="_blank" rel="nofollow noopener noreferrer">ec-do</a>。<br>我自己封装这个，并不是我有造轮子的习惯，而是：</p><br><p>1，都是一些常用，但是零散的小实例，网上基本没有插件。</p><br><p>2，因为零散的小实例，涉及到的有字符串，数组，对象等类型，就算找到插件，在项目引入的很有可能不止一个插件。</p><br><p>3.都是简单的代码，封装也不难。维护也简单。</p><br><p>其他的不多说了，上面的只是我自己在开发中常用到，希望能帮到小伙伴们，最理想就是这篇文章能起到一个 <b><code>抛砖引玉</code></b> 的作用，就是说，如果觉得还有什么操作是常用的，或者觉得我哪里写得不好的，也欢迎指出，让大家相互帮助，相互学习。</p><p><br></p><p><br></p><p>————————-华丽的分割线——————–<br>想了解更多，关注关注我的微信公众号：守候书阁</p><p><img class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2018/1/8/160d33b27d3f303a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="258" data-height="258" src="https://user-gold-cdn.xitu.io/2018/1/8/160d33b27d3f303a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p></div><p><br></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>js中this的理解和实践【包含箭头函数中的this】</title>
      <link href="/2018/12/04/lao-bo-ke/js-zhong-this-de-li-jie-he-shi-jian-bao-han-jian-tou-han-shu-zhong-de-this/"/>
      <url>/2018/12/04/lao-bo-ke/js-zhong-this-de-li-jie-he-shi-jian-bao-han-jian-tou-han-shu-zhong-de-this/</url>
      
        <content type="html"><![CDATA[<p>最近在做项目的时候，因为对this的理解不清楚，导致了不清不楚的bug,因此抽出时间进行了js中this的学习。<br>1、js中this的理解要点。</p><blockquote><p>(1、)对普通函数，this指向的是调用者[‘.’之前的，没有’.’则为全局对象];<br> (2、)箭头函数中的this指向为定义箭头函数的作用域中的this【<strong>是作用域中的this而不是定义的作用域</strong>】;<br> 友情提示：此处是可以根据内存中this的指向来理解的，但是我们理解this是为了更好更快的做项目，记住一般的规律即可。</p></blockquote><p>2、js中的this理解和实践的demo。</p><pre><code>function test1() {    console.log(this);    alert(&quot;打印出了全局对象【global/window】[Window {frames: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …}]&quot;);};test1();console.log(&quot;----------------作为对象的方法调用-------------------&quot;);var obj1 = {    name: &#39;qiutc&#39;,    foo: function () {        console.log(this.name);    }}obj1.foo();console.log(&quot;-----------------------------------&quot;);function test2() {    console.log(this.name);}var obj2 = {    name: &#39;qiutc&#39;,    foo2: test2}obj2.foo2();console.log(&quot;--------------把对象的方法赋值给一个变量，然后直接调用这个变量---------------------&quot;);var obj3 = {    name: &#39;qiutc&#39;,    foo3: function () {        console.log(this);    }}var test3 = obj3.foo3;test3();console.log(&quot;--------------利用 闭包 的特性来绑定this---------------------&quot;);//为了避免对下面测试中定时器的影响，注释了当前代码块;/**  * var obj4 = {    name: &#39;qiutc&#39;,    foo: function () {        console.log(this);    },    foo2: function () {        console.log(this);        var _this = this;        setTimeout(function () {           // console.log(this);           console.log(_this);        }, 1000);    }}obj4.foo2();  */console.log(&quot;--------------箭头函数---------------------&quot;);/** * 箭头函数中的 this 只和定义它时候的作用域的 this 有关; * 即：[箭头函数中的this和定义它的作用域中的this相等]; * 函数参数列表中的箭头函数的是定义在外部的，但是其作用域在方法内部; * 而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的。 *//** * var obj5 = {    name: &#39;qiutc&#39;,    foo: function () {        console.log(this);    },    foo2: function () {        console.log(&quot;obj5--》a&quot; + this);        setTimeout(() =&gt; {            console.log(&quot;obj5--》b&quot; + this);        }, 1000);    }}obj5.foo2(); */console.log(&quot;--------------通过call, apply, bind给函数绑定指定的this对象---------------------&quot;);console.log(&quot;-----------------------为一个普通函数指定 this---------------------&quot;);var obj7 = {    name: &#39;qiutc&#39;};function foo7() {    console.log(this);}foo7.call(obj7);console.log(&quot;-----------------------为对象中的方法指定一个 this---------------------&quot;);var obj = {    name: &#39;qiutc&#39;,    foo: function () {        console.log(this);    }}var obj2 = {    name: &#39;tcqiu222222&#39;};obj.foo.call(obj2);console.log(&quot;-----------------------为箭头函数指定 this【无效性验证】---------------------&quot;);var afoo = (a) =&gt; {    console.log(a);    console.log(this);}afoo(1);var obj = {    name: &#39;qiutc&#39;};afoo.call(obj, 2); //期望输出：obj;实际输出:全局对象;/** * 可以看到，这里的 call 指向 this 的操作并没有成功，所以可以得出：  * 箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this）， * 与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this。 *只要记住箭头函数大法好，不变的 this。 */</code></pre><p>3、参考文章<br><a href="https://juejin.im/entry/57bd2ec1efa631005a8eae1a" target="_blank" rel="noopener">JavaScript 中的 this</a></p><p>4、<a href="https://github.com/JunZhou2016/ThisInJsPractice" target="_blank" rel="noopener">demo源码。</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Jrebel热部署插件的安装、破解和使用</title>
      <link href="/2018/12/04/lao-bo-ke/jrebel-re-bu-shu-cha-jian-de-an-zhuang-po-jie-he-shi-yong/"/>
      <url>/2018/12/04/lao-bo-ke/jrebel-re-bu-shu-cha-jian-de-an-zhuang-po-jie-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>1、什么是jrebel？<br>Jrebel是一款热部署插件，用于提高开发效率。一般我们在开发j2ee项目的时候，每次代码跟新就得重启服务，这样效率很低，尤其是对于大项目的，启动很慢，白白浪费了很多时间。使用jrebel插件后可以在java【配置文件更新后还是得重启服务】代码更新后自动编译更新而不用重启项目。但是jrebel的破解码很难搞，下面介绍jrebel的安装、破解和使用.。</p><hr><p>2、jrebel的安装、破解和使用.<br>(1、)安装<br>可以直接去eclipse的应用商店中下载，如图:<br><img src="http://img.blog.csdn.net/20180123211934330?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(2、)破解<br>jrebel理论上是收费的，但是我们可以破解，不是通过破解码和破解工具破解，因为这些方大都是无效的，老旧的。幸好，jrebel爱好者【可能是jrebe官方】搭建了一个网站，专门用于破解激活jrebel.<br>破解网站:<a href="https://my.jrebel.com/" target="_blank" rel="noopener">MyJrebel</a><br>登录这个网站，使用facebook 或者推特登录（需要翻墙），然后输入邮箱，会要求验证（登录邮箱验证，点击验证链接），在输入手机号，不需要验证手机号。之后会进入破解网站:<a href="https://my.jrebel.com/" target="_blank" rel="noopener">MyJrebel</a>,登录后按照如下步骤操作即可获取激活码：<br>A、<img src="http://img.blog.csdn.net/20180123213841967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>B、<img src="http://img.blog.csdn.net/20180123213954522?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>C、<img src="http://img.blog.csdn.net/20180123214111441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(3、)使用<br>3.1、将jrebel插件作用于选中的项目;</p><p><img src="http://img.blog.csdn.net/20180123220751006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>3.2、更新代码，jrebel自动重新编译，无需重新启动。<br><img src="http://img.blog.csdn.net/20180123222138572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java中枚举类略解</title>
      <link href="/2018/12/04/lao-bo-ke/java-zhong-mei-ju-lei-lue-jie/"/>
      <url>/2018/12/04/lao-bo-ke/java-zhong-mei-ju-lei-lue-jie/</url>
      
        <content type="html"><![CDATA[<p>为什么在java中要用枚举类呢?<br>我的理解：如果不用枚举类，而用传统的方法，那么如果要定义三个常量:</p><pre><code>[{0,&quot;服务订单&quot;},{1,&quot;商品订单&quot;},{2,&quot;会员卡订单&quot;}]</code></pre><p>而且在引用的时候做到见名知意,那么就得这么些：<br>OrderType.java</p><pre><code>package com.lz.orign.enums;/** * 模拟枚举类中元素的底层实现; *  * @author:JunZhou * @Company:LongZheng * @Email:1769676159@qq.com * @2018年1月20日@下午12:32:22 */public class OrderType {    private String type;    private int typeCode;    public OrderType(int typeCode,String type) {        super();        this.type = type;        this.typeCode = typeCode;    }    public String getType() {        return type;    }    public void setType(String type) {        this.type = type;    }    public int getTypeCode() {        return typeCode;    }    public void setTypeCode(int typeCode) {        this.typeCode = typeCode;    }}</code></pre><p>SumuOrderEnum.java</p><pre><code>package com.lz.orign.enums;/** * 模拟枚举类中元素的声明; * @author:JunZhou * @Company:LongZheng * @Email:1769676159@qq.com * @2018年1月20日@下午2:08:12 */public class SumuOrderEnum {    public static OrderType orderType1 = new OrderType(0,&quot;服务订单&quot;);    public static OrderType orderType2 = new OrderType(1,&quot;商品订单&quot;);    public static OrderType orderType3 = new OrderType(2,&quot;会员卡订单&quot;);}</code></pre><p>EnumTest .java</p><pre><code>package com.lz.orign.enums;public class EnumTest {/** * 模拟枚举类的调用; * @param args */public static void main(String[] args) {    SumuOrderEnum sumuOrderEnum = new SumuOrderEnum();    System.out.println(sumuOrderEnum.orderType1.getTypeCode()+&quot;-&quot;+sumuOrderEnum.orderType1.getType());}}</code></pre><hr><p>但是用枚举类就方便许多了:<br>OrderTypeEnum.java</p><pre><code>/** * * @(#) OrderTypeEnum.java * @Package cn.lz.life.enums *  * Copyright  Icerno Corporation. All rights reserved. * */package com.lz.enums;/** * 定义枚举类; * @author:JunZhou * @Company:LongZheng * @Email:1769676159@qq.com * @2018年1月20日@下午2:11:26 */public enum OrderTypeEnum {    //声明枚举类的元素;    ORDER_TYPE_IS_ZERO(0,&quot;服务订单&quot;),    ORDER_TYPE_IS_ONE(1,&quot;商品订单&quot;),    ORDER_TYPE_IS_TWO(2,&quot;会员卡订单&quot;),    ;    //声明枚举类的属性，实际上是    private int orderType;    private String msg;    public int getOrderType() {        return orderType;    }    public void setOrderType(int orderType) {        this.orderType = orderType;    }    public String getMsg() {        return msg;    }    public void setMsg(String msg) {        this.msg = msg;    }    private OrderTypeEnum(int orderType, String msg) {        this.orderType = orderType;        this.msg = msg;    }}</code></pre><p>EnumTest.java</p><pre><code>package com.lz.enums;/** * 枚举类的调用; * @author:JunZhou * @Company:LongZheng * @Email:1769676159@qq.com * @2018年1月20日@下午2:12:01 */public class EnumTest {public static void main(String[] args) {    System.out.println(OrderTypeEnum.ORDER_TYPE_IS_ONE.getOrderType());    System.out.println(OrderTypeEnum.ORDER_TYPE_IS_ONE.getMsg());}}</code></pre><p>枚举类使用过程中因该注意的地方:<br>一：枚举类中必须定义构造方法;<br>二:枚举类中元素声明的类型必须和构造函数匹配,可以理解为元素的声明就是调用构造方法实例化了一个元素实例;<br>三:枚举类中属性可以没有，如果属性存在的话，枚举类中属性的名称可以随意，最好做到见名知意,但是其类型必须匹配构造函数中的类型;<br>四:元素的声明必须放在枚举类的首部;<br>五:枚举类的存在是为了简化常量的定义和使用;</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java中类和类之间的关系</title>
      <link href="/2018/12/04/lao-bo-ke/java-zhong-lei-he-lei-zhi-jian-de-guan-xi/"/>
      <url>/2018/12/04/lao-bo-ke/java-zhong-lei-he-lei-zhi-jian-de-guan-xi/</url>
      
        <content type="html"><![CDATA[<p><strong>java中类和类之间的关系</strong><br>       <em>(如下图所示)：</em><br>       <img src="http://img.blog.csdn.net/20170726102604990?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java中获取map的key和value的方法</title>
      <link href="/2018/12/04/lao-bo-ke/java-zhong-huo-qu-map-de-key-he-value-de-fang-fa/"/>
      <url>/2018/12/04/lao-bo-ke/java-zhong-huo-qu-map-de-key-he-value-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>最近做POI反射方法实现的时候，遇到了map的取值相关的问题，在这里总结下。<br>获取map的key和value的方法分为两种形式：</p><p>map.keySet()：先获取map的key，然后根据key获取对应的value；<br>map..entrySet()：同时查询map的key和value，只需要查询一次；<br>两者的性能比较可以查看map.keySet()和map.EntrySet()的比较。</p><p>1、以下是获取map的key和value，以及map里面的元素通过key或者value来比较大小并排序；<br>【注意：当map的value值相等时，根据key值进行排序】</p><pre><code>public class MapSort { public static void main(String[] args) {  Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();  map.put(&quot;b&quot;,&quot;4&quot;);  map.put(&quot;a&quot;,&quot;5&quot;);  map.put(&quot;c&quot;,&quot;3&quot;);  map.put(&quot;d&quot;,&quot;5&quot;);  //通过map.keySet()方法  //方法一：通过得到key的值，然后获取value;  /*for(String key : map.keySet()){   String value = map.get(key);   System.out.println(key+&quot;  &quot;+value);  }*/  //使用迭代器，获取key;  /*Iterator&lt;String&gt; iter = map.keySet().iterator();  while(iter.hasNext()){   String key=iter.next();   String value = map.get(key);   System.out.println(key+&quot; &quot;+value);   */  //通过map.entrySet()方法  //方法一：循环map里面的每一对键值对，然后获取key和value  /*for(Entry&lt;String, String&gt; vo : map.entrySet()){   vo.getKey();   vo.getValue();   System.out.println(vo.getKey()+&quot;  &quot;+vo.getValue());  }*/  /*//使用迭代器，获取key  Iterator&lt;Entry&lt;String,String&gt;&gt; iter = map.entrySet().iterator();  while(iter.hasNext()){   Entry&lt;String,String&gt; entry = iter.next();   String key = entry.getKey();   String value = entry.getValue();   System.out.println(key+&quot; &quot;+value);  }*/  //将map&lt;String,String&gt; 转化为ArryList,但list里面的元素为Entry&lt;String,String&gt;  List&lt;Entry&lt;String,String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet());  //通过匿名比较器的方式进行比较。  Collections.sort(list,new Comparator&lt;Entry&lt;String,String&gt;&gt;(){   @Override   public int compare(Entry&lt;String, String&gt; o1,     Entry&lt;String, String&gt; o2) {    int flag = o1.getValue().compareTo(o2.getValue());    if(flag==0){     return o1.getKey().compareTo(o2.getKey());    }    return flag;   }  });  //遍历list得到map里面排序后的元素  for(Entry&lt;String, String&gt; en : list){   System.out.println(en.getKey()+&quot; &quot;+en.getValue());  } }}</code></pre><p>2、注意Map中的元素是唯一无序的，如果希望根据存入的顺序取出数据，建议使用linkedhashmap,存入其中的数据是唯一且有序的。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Java中对List中的存储对象根据属性进行排序的办法</title>
      <link href="/2018/12/04/lao-bo-ke/java-zhong-dui-list-zhong-de-cun-chu-dui-xiang-gen-ju-shu-xing-jin-xing-pai-xu-de-ban-fa/"/>
      <url>/2018/12/04/lao-bo-ke/java-zhong-dui-list-zhong-de-cun-chu-dui-xiang-gen-ju-shu-xing-jin-xing-pai-xu-de-ban-fa/</url>
      
        <content type="html"><![CDATA[<p>有时候需要对集合中的元素按照一定的规则进行排序，对于比较简单单一的数据可以用Java中提供的对集合进行操作的工具类Collections中的sort方法,对于对象，如果要一依据属性进行排序，就需要参与比较的对象实现Comparable<t>T接口，或者使用匿名比较器的方式实现比较。<br>先看一个简单的例子：<br>1、简单数据</t></p><pre><code>public static void main(String[] args) {      List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();          nums.add(3);          nums.add(5);          nums.add(1);          nums.add(0);          System.out.println(nums);          Collections.sort(nums);          System.out.println(nums);  }  </code></pre><blockquote><p>输出结果：<br>[3, 5, 1, 0]<br>[0, 1, 3, 5]<br>稍微复杂的List里面放一个复杂的对象</p></blockquote><p>2、复杂数据<br>(1、)通过实现接口进行比较</p><pre><code>package core.java.collection.collections;  public class User implements Comparable&lt;User&gt;{      private int score;      private int age;      public User(int score, int age){          super();          this.score = score;          this.age = age;      }      public int getScore() {          return score;      }      public void setScore(int score) {          this.score = score;      }      public int getAge() {          return age;      }      public void setAge(int age) {          this.age = age;      }      @Override      public int compareTo(User o) {          int i = this.getAge() - o.getAge();//先按照年龄排序          if(i == 0){              return this.score - o.getScore();//如果年龄相等了再用分数进行排序          }          return i;      }  }  public static void main(String[] args) {          List&lt;User&gt; users = new ArrayList&lt;User&gt;();          users.add(new User(78, 26));          users.add(new User(67, 23));          users.add(new User(34, 56));          users.add(new User(55, 23));          Collections.sort(users);          for(User user : users){              System.out.println(user.getScore() + &quot;,&quot; + user.getAge());          }  }  </code></pre><blockquote><p>输出结果：<br>55,23<br>67,23<br>78,26<br>34,56<br>我们会发现sort(List<t>)方法中List中的T必须实现Comparable<t>接口，然后实现<br>compareTo（）方法，该方法的返回值0代表相等，1表示大于，-1表示小于；为什么<br>在简单例子中没有看到实现Comparable接口呢？是因为Integer类其实自己已经实现<br>了Comparable接口，Java已经给我们做好了。</t></t></p></blockquote><p>(2、)通过匿名比较器实现比较<br>Collections提供的第二种排序方法sort(List<t> list, Comparator&lt;? super T&gt; c)<br>先看例子：</t></p><pre><code>package core.java.collection.collections;  public class Students {      private int age;      private int score;      public Students(int age, int score){          super();          this.age = age;          this.score = score;      }      public int getAge() {          return age;      }      public void setAge(int age) {          this.age = age;      }      public int getScore() {          return score;      }      public void setScore(int score) {          this.score = score;      }  }  public static void main(String[] args) {          List&lt;Students&gt; students = new ArrayList&lt;Students&gt;();          students.add(new Students(23, 100));          students.add(new Students(27, 98));          students.add(new Students(29, 99));          students.add(new Students(29, 98));          students.add(new Students(22, 89));          Collections.sort(students, new Comparator&lt;Students&gt;() {              @Override              public int compare(Students o1, Students o2) {                  int i = o1.getScore() - o2.getScore();                  if(i == 0){                      return o1.getAge() - o2.getAge();                  }                  return i;              }          });          for(Students stu : students){              System.out.println(&quot;score:&quot; + stu.getScore() + &quot;:age&quot; + stu.getAge());          }  }  </code></pre><blockquote><p>输出结果：<br>score:89:age22<br>score:98:age27<br>score:98:age29<br>score:99:age29<br>score:100:age23</p></blockquote><p>3、总结<br>两种方式都可以实现数据的比较，从上面的例子我们可以看出Students类没有实现Comparable<t>接口，只是在sort()方法中多传入一个参数，只不过该参数是一个接口我们需要实现其compare方法，但是通过实现接口的方式代码结构将更加清晰。</t></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JAVA学习中收藏的大神的博客</title>
      <link href="/2018/12/04/lao-bo-ke/java-xue-xi-zhong-shou-cang-de-da-shen-de-bo-ke/"/>
      <url>/2018/12/04/lao-bo-ke/java-xue-xi-zhong-shou-cang-de-da-shen-de-bo-ke/</url>
      
        <content type="html"><![CDATA[<hr><p>   JAVA:<br>            <a href="https://crossoverjie.top/categories/" target="_blank" rel="noopener">crossoverjie的博客</a><br>            <a href="http://wuchong.me/" target="_blank" rel="noopener">Jark‘s的博客</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>建立一颗二叉排序树，并输出它的前序、中序、后序以及层次遍历结</title>
      <link href="/2018/12/04/lao-bo-ke/java-shi-xian-er-cha-shu-de-qian-xu-zhong-xu-hou-xu-yi-ji-ceng-ci-bian-li/"/>
      <url>/2018/12/04/lao-bo-ke/java-shi-xian-er-cha-shu-de-qian-xu-zhong-xu-hou-xu-yi-ji-ceng-ci-bian-li/</url>
      
        <content type="html"><![CDATA[<hr><p>输入：</p><pre><code>56 9 1 5 8输出：6 1 5 9 8 //前序1 5 6 8 9 //中序5 1 8 9 6 //后序6 1 9 5 8 //层次</code></pre><p><code class="java"><span class="hljs-comment">//Main函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">while</span>(scanner.hasNextInt()){<br>            <span class="hljs-keyword">int</span> num = scanner.nextInt();<br>            <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++){<br>                array[i] = scanner.nextInt();<br>            }<br>            TreeNode root = <span class="hljs-keyword">new</span> TreeNode(array[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; num; i++){<br>                buildBST(root,array[i]);<br>            }<br>            DLR(root);<span class="hljs-comment">//前序遍历</span><br>            System.out.println();<br>            LDR(root);<span class="hljs-comment">//中序遍历</span><br>            System.out.println();<br>            LRD(root);<span class="hljs-comment">//后序遍历</span><br>            System.out.println();<br>            levelOrder(root);<span class="hljs-comment">//层次遍历</span><br>            System.out.println();<br>        }<br>    }<br><span class="hljs-comment">//前序遍历非递归</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DLR</span><span class="hljs-params">(TreeNode node)</span></span>{<br>        <span class="hljs-keyword">if</span>(node!=<span class="hljs-keyword">null</span>){<br>            Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();<br>            stack.push(node);<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty()){<br>                node = stack.pop();<br>                System.out.print(node.val+<span class="hljs-string">“ “</span>);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)stack.push(node.right);<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)stack.push(node.left);<br>            }<br>        }<br>    }<br><span class="hljs-comment">//中序遍历非递归</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LDR</span><span class="hljs-params">(TreeNode node)</span></span>{<br>      Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">while</span>(node!=<span class="hljs-keyword">null</span> || !stack.isEmpty()){<br>            <span class="hljs-keyword">if</span>(node!=<span class="hljs-keyword">null</span>){<br>                stack.push(node);<br>                node = node.left;<br>            }<span class="hljs-keyword">else</span>{<br>                node = stack.pop();<br>                System.out.print(node.val+<span class="hljs-string">“ “</span>);<br>                node = node.right;<br>            }<br>        }<br>    }<br><span class="hljs-comment">//后序遍历非递归</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LRD</span><span class="hljs-params">(TreeNode node)</span></span>{<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();<br>        TreeNode pre = node;<br>        <span class="hljs-keyword">while</span>(node!=<span class="hljs-keyword">null</span>){<br>            <span class="hljs-keyword">while</span>(node.left!=<span class="hljs-keyword">null</span>){<br>                stack.push(node);<br>                node = node.left;<br>            }<br>            <span class="hljs-keyword">while</span>(node!=<span class="hljs-keyword">null</span> &amp;&amp; (node.right==<span class="hljs-keyword">null</span> || node.right==pre)){<br>                System.out.print(node.val+<span class="hljs-string">“ “</span>);<br>                pre = node;<br>                <span class="hljs-keyword">if</span>(stack.isEmpty()) <span class="hljs-keyword">return</span>;<br>                node = stack.pop();<br>            }<br>            stack.push(node);<br>            node = node.right;<br>        }<br>    }<br><span class="hljs-comment">//层次遍历非递归</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode node)</span></span>{<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;TreeNode&gt;();<br>        queue.offer(node);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()){<br>            node = queue.poll();<br>            System.out.print(node.val+<span class="hljs-string">“ “</span>);<br>            <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)queue.add(node.left);<br>            <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)queue.add(node.right);<br>        }<br>    }<br><span class="hljs-comment">//构建二叉排序树</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildBST</span><span class="hljs-params">(TreeNode node,<span class="hljs-keyword">int</span> val)</span></span>{<br>        <span class="hljs-keyword">if</span>(node.val == val) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span>(val &lt; node.val){<br>            <span class="hljs-keyword">if</span>(node.left==<span class="hljs-keyword">null</span>) node.left = <span class="hljs-keyword">new</span> TreeNode(val);<br>            <span class="hljs-keyword">else</span> buildBST(node.left,val);<br>        }<span class="hljs-keyword">else</span>{<br>            <span class="hljs-keyword">if</span>(node.right==<span class="hljs-keyword">null</span>) node.right = <span class="hljs-keyword">new</span> TreeNode(val);<br>            <span class="hljs-keyword">else</span> buildBST(node.right,val);<br>        }<br>    }<br></code></p><p><code class="java"><span class="hljs-comment">//二叉树节点结构</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span></span>{<br> <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;<br>TreeNode left = <span class="hljs-keyword">null</span>;<br>TreeNode right = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>{<br><span class="hljs-keyword">this</span>.val = val;<br>}<br>}<code>`</code></code></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JAVA实现对包含数字、字母、中文的字符串按首字母排序</title>
      <link href="/2018/12/04/lao-bo-ke/java-shi-xian-dui-bao-han-shu-zi-zi-mu-zhong-wen-de-zi-fu-chuan-an-shou-zi-mu-pai-xu/"/>
      <url>/2018/12/04/lao-bo-ke/java-shi-xian-dui-bao-han-shu-zi-zi-mu-zhong-wen-de-zi-fu-chuan-an-shou-zi-mu-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>最近项目中有新的需求，需要对包含数字、字母、中文的字符串按首字母排序。看似简单，但是实现起来却很难。因为这里面包含了中文，不能单纯的取首字母的ASSIC值进行比较。考虑到最终是根据英文字母进行比较的，索性将字符串统统转化成拼音字符串进行处理。具体的代码如下。</p><hr><pre><code>   PinyinUtils.java</code></pre><pre><code>package com.fangshuo;import net.sourceforge.pinyin4j.PinyinHelper;import net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;import net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;import net.sourceforge.pinyin4j.format.HanyuPinyinToneType;import net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;/** * 汉字转换为拼音 * @author Red */public class PinyinUtils {    /**     * 获取字符串拼音的第一个字母     * @param chinese     * @return     */    public static String ToFirstChar(String chinese){                 String pinyinStr = &quot;&quot;;          char[] newChar = chinese.toCharArray();  //转为单个字符        HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();         defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);          defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);          for (int i = 0; i &lt; newChar.length; i++) {              if (newChar[i] &gt; 128) {                  try {                      pinyinStr += PinyinHelper.toHanyuPinyinStringArray(newChar[i], defaultFormat)[0].charAt(0);                  } catch (BadHanyuPinyinOutputFormatCombination e) {                      e.printStackTrace();                  }              }else{                  pinyinStr += newChar[i];              }          }          return pinyinStr;      }      /**     * 汉字转为拼音     * @param chinese     * @return     */    public static String ToPinyin(String chinese){                  String pinyinStr = &quot;&quot;;          char[] newChar = chinese.toCharArray();          HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();          defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);          defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);          for (int i = 0; i &lt; newChar.length; i++) {              if (newChar[i] &gt; 128) {                  try {                      pinyinStr += PinyinHelper.toHanyuPinyinStringArray(newChar[i], defaultFormat)[0];                  } catch (BadHanyuPinyinOutputFormatCombination e) {                      e.printStackTrace();                  }              }else{                  pinyinStr += newChar[i];              }          }          return pinyinStr;      }    /**     * 汉字转为拼音并获取大写的首字母;     * @param chinese     * @return     */    public static String ToPinyinAndGetFirstChar(String chinese){                  String pinyinStr = &quot;&quot;;          char[] newChar = chinese.toCharArray();          HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();          defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);          defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);          for (int i = 0; i &lt; newChar.length; i++) {              if (newChar[i] &gt; 128) {                  try {                      pinyinStr += PinyinHelper.toHanyuPinyinStringArray(newChar[i], defaultFormat)[0];                  } catch (BadHanyuPinyinOutputFormatCombination e) {                      e.printStackTrace();                  }              }else{                  pinyinStr += newChar[i];              }          }          return pinyinStr.toUpperCase();    }  }</code></pre><p>测试载体Students.java</p><pre><code>package com.fangshuo;public class Students {      private int age;      private int score;    private String name;    public Students() {        super();    }    public Students(int age, int score, String name) {        super();        this.age = age;        this.score = score;        this.name = name;    }    public Students(int age, int score){          super();          this.age = age;          this.score = score;      }      public int getAge() {          return age;      }      public void setAge(int age) {          this.age = age;      }      public int getScore() {          return score;      }      public void setScore(int score) {          this.score = score;      }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }  }  </code></pre><p>测试类：</p><pre><code>package com.fangshuo;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class SortTest {    public static void main(String[] args) {         List&lt;Students&gt; students = new ArrayList&lt;Students&gt;();           students.add(new Students(23, 100,&quot;阿里azj001&quot;));           students.add(new Students(27, 98,&quot;腾讯bzj002&quot;));           students.add(new Students(29, 99,&quot;百度dzj003&quot;));           students.add(new Students(29, 98,&quot;华为czj004&quot;));           students.add(new Students(22, 89,&quot;择天ezj005&quot;));           students.add(new Students(22, 89,&quot;a择天ezj005&quot;));           students.add(new Students(22, 89,&quot;A择天ezj005&quot;));           students.add(new Students(22, 89,&quot;8择天ezj005&quot;));           students.add(new Students(22, 89,&quot;0择天ezj005&quot;));           students.add(new Students(22, 89,&quot;z择天ezj005&quot;));           students.add(new Students(22, 89,&quot;_z择天ezj005&quot;));           Collections.sort(students, new Comparator&lt;Students&gt;() {               @Override               public int compare(Students o1, Students o2) {                 Students newo1 = new Students();                 newo1.setName(PinyinUtils.ToPinyinAndGetFirstChar(o1.getName()));                 Students newo2 = new Students();                 newo2.setName(PinyinUtils.ToPinyinAndGetFirstChar(o2.getName()));                 int i = newo1.getName().substring(0, 1).compareTo(newo2.getName().substring(0, 1));                 return i;             }         });           for(Students stu : students){               System.out.println(&quot;score:&quot; + stu.getScore() + &quot;:age&quot; + stu.getAge()+&quot;:name:&quot;+stu.getName());           }      }}</code></pre><p>执行结果如下：<br><img src="https://img-blog.csdn.net/2018062821285871?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqMjAxNDIyMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>知识点：<br>字符串比较大小，可以使用现有的工具类：int result = str1.compareTo(str2);该方法返回两者的ASSIC 码的差值;</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java去除list中重复的数据【distinct】</title>
      <link href="/2018/12/04/lao-bo-ke/java-qu-chu-list-zhong-chong-fu-de-shu-ju-distinct/"/>
      <url>/2018/12/04/lao-bo-ke/java-qu-chu-list-zhong-chong-fu-de-shu-ju-distinct/</url>
      
        <content type="html"><![CDATA[<p>最近项目中需要对list集合中的重复值进行处理，大部分是采用两种方法，一种是用遍历list集合判断后赋给另一个list集合，一种是用赋给set集合再返回给list集合。<br>但是赋给set集合后，由于set集合是无序的，原先的顺序就打乱了。所以我又想着能不能用set的特性进行去重又不打乱顺序呢？<br>【注意:set是无序唯一的】<br>试了一下，也是可以的，几种方法在不同情况下都有各自的优势。现在将代码写出来，比较一下。</p><pre><code>1、//set集合去重，不打乱顺序    public static void main(String[] args){         List&lt;String&gt; list  =   new  ArrayList&lt;String&gt;();          list.add(&quot;aaa&quot;);         list.add(&quot;bbb&quot;);         list.add(&quot;aaa&quot;);         list.add(&quot;aba&quot;);         list.add(&quot;aaa&quot;);         Set set = new  HashSet();          List newList = new  ArrayList();          for (String cd:list) {            if(set.add(cd)){                newList.add(cd);            }        }         System.out.println( &quot;去重后的集合： &quot; + newList);       }</code></pre><hr><pre><code>2、 //遍历后判断赋给另一个list集合     public static void main(String[] args){         List&lt;String&gt; list  =   new  ArrayList&lt;String&gt;();          list.add(&quot;aaa&quot;);         list.add(&quot;bbb&quot;);         list.add(&quot;aaa&quot;);         list.add(&quot;aba&quot;);         list.add(&quot;aaa&quot;);         List&lt;String&gt; newList = new  ArrayList&lt;String&gt;();          for (String cd:list) {            if(!newList.contains(cd)){                newList.add(cd);            }        }         System.out.println( &quot;去重后的集合： &quot; + newList);       }</code></pre><hr><pre><code>3、//set去重    public static void main(String[] args){         List&lt;String&gt; list  =   new  ArrayList&lt;String&gt;();          list.add(&quot;aaa&quot;);         list.add(&quot;bbb&quot;);         list.add(&quot;aaa&quot;);         list.add(&quot;aba&quot;);         list.add(&quot;aaa&quot;);        Set set = new  HashSet();          List newList = new  ArrayList();          set.addAll(list);         newList.addAll(set);         System.out.println( &quot;去重后的集合： &quot; + newList);      }</code></pre><hr><pre><code>4、 //set去重(缩减为一行)        public static void main(String[] args){             List&lt;String&gt; list  =   new  ArrayList&lt;String&gt;();              list.add(&quot;aaa&quot;);             list.add(&quot;bbb&quot;);             list.add(&quot;aaa&quot;);             list.add(&quot;aba&quot;);             list.add(&quot;aaa&quot;);             List newList = new ArrayList(new HashSet(list));              System.out.println( &quot;去重后的集合： &quot; + newList);          }</code></pre><hr><p>hashset不进行排序，即hashset是无序唯一的，还有一种方法是用treeset，去重并且按照自然顺序排列，将hashset改为treeset就可以了。（原本的顺序是改变的，只是按照字母表顺序排列而已）</p><pre><code>5、//去重并且按照自然顺序排列List newList = new ArrayList(new TreeSet(list)); </code></pre><p>6、参考文章<br><a href="https://www.cnblogs.com/aipan/p/6118129.html" target="_blank" rel="noopener">Java中List，ArrayList、Vector，map，HashTable，HashMap区别用法</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java乱码解决之道</title>
      <link href="/2018/12/04/lao-bo-ke/java-luan-ma-jie-jue-zhi-dao/"/>
      <url>/2018/12/04/lao-bo-ke/java-luan-ma-jie-jue-zhi-dao/</url>
      
        <content type="html"><![CDATA[<p>收藏了一篇解决java乱码的文章，希望作者的博客不要挂掉了，不然查询又不方便了。<br>网址:<a href="http://cmsblogs.com/?p=1530" target="_blank" rel="noopener">java乱码解决之道</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JAVA反射</title>
      <link href="/2018/12/04/lao-bo-ke/java-fan-she/"/>
      <url>/2018/12/04/lao-bo-ke/java-fan-she/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>前言</strong><br>现在在我们构建自己或公司的项目中，或多或少都会依赖几个流行比较屌的第三方库，比如：Butter Knife、Retrofit 、Dagger 、GreenDao等，如果你没用过，那你需要找时间补一下啦；有时在使用后我们会好奇他们到底是怎么做到这种简洁、高效、松耦合等诸多优点的，当然这里我不探讨它们具体怎么实现的 (可以看看我之前写的几篇文章) ，而关心的是它们都用到同样的技术那就是本篇所讲的反射和注解，并实现的依赖注入。</p><p>阅读本篇文章有助于你更好的理解这些大形框架的原理和复习Java的知识点。为什么要把反射放在前面讲呢，实际上是因为我们学习注解的时候需要用到反射机制，所以，先学习反射有助于理解后面的知识。</p><p><strong>JAVA反射</strong></p><hr><blockquote><p>主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p></blockquote><p><strong>反射机制是什么</strong></p><blockquote><p>反射机制就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。</p></blockquote><p><strong>反射机制能做什么</strong></p><pre><code>               ***反射机制主要提供了以下功能：***</code></pre><pre><code> - 在运行时判断任意一个对象所属的类；          - 在运行时构造任意一个类的对象; - 在运行时判断任意一个类所具有的成员变量和方法; - 在运行时调用任意一个对象的方法； - 生成动态代理(ps:这个知识点也很重要)</code></pre><p><strong>Java 反射机制的应用场景</strong></p><ul><li>逆向代码 ，例如反编译 </li><li>与注解相结合的框架 例如Retrofit </li><li>单纯的反射机制应用框架 例如EventBus </li><li>动态生成类框架  例如Gson</li></ul><p><strong>反射机制的优点与缺点</strong></p><p>为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念</p><p>静态编译：在编译时确定类型，绑定对象,即通过。</p><p>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。</p><p><strong><em>优点</em></strong></p><blockquote><p>可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</p></blockquote><p><strong><em>缺点</em></strong></p><blockquote><p>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</p></blockquote><p><strong>理解Class类和类类型</strong></p><blockquote><p>想要了解反射首先理解一下Class类，它是反射实现的基础。<br>类是java.lang.Class类的实例对象，而Class是所有类的类（There is a class named Class）<br>对于普通的对象，我们一般都会这样创建和表示：</p></blockquote><p><strong>Code code1 = new Code();</strong></p><p> 但是我们查看Class的源码时，是这样写的：</p><pre><code>private  Class(ClassLoader loader) {     classLoader = loader; }</code></pre><blockquote><p>可以看到构造器是私有的，只有JVM可以创建Class的对象，因此不可以像普通类一样new一个Class对象，虽然我们不能new一个Class对象，但是却可以通过已有的类得到一个Class对象，共有三种方式，如下：</p></blockquote><pre><code>Class c1 = Code.class; 这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的Class c2 = code1.getClass(); code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的 Class c3 = Class.forName(&quot;com.trigl.reflect.Code&quot;); 这种方法是Class类调用forName方法，通过一个类的全量限定名获得</code></pre><pre><code>这里，c1、c2、c3都是Class的对象，他们是完全一样的，而且有个学名，叫做Code的类类型（class type）。这里就让人奇怪了，前面不是说Code是Class的对象吗，而c1、c2、c3也是Class的对象，那么Code和c1、c2、c3不就一样了吗？为什么还叫Code什么类类型？这里不要纠结于它们是否相同，只要理解类类型是干什么的就好了，顾名思义，类类型就是类的类型，也就是描述一个类是什么，都有哪些东西，所以我们可以通过类类型知道一个类的属性和方法，并且可以调用一个类的属性和方法，这就是反射的基础。</code></pre><p>举个简单例子代码：</p><pre><code>public class ReflectDemo {    public static void main(String[] args) throws ClassNotFoundException {        //第一种：Class c1 = Code.class;        Class class1=ReflectDemo.class;        System.out.println(class1.getName());        //第二种：Class c2 = code1.getClass();        ReflectDemo demo2= new ReflectDemo();        Class c2 = demo2.getClass();        System.out.println(c2.getName());        //第三种：Class c3 = Class.forName(&quot;com.trigl.reflect.Code&quot;);        Class class3 = Class.forName(&quot;com.tengj.reflect.ReflectDemo&quot;);        System.out.println(class3.getName());    }}</code></pre><p><strong>执行结果：</strong></p><pre><code>1.com.tengj.reflect.ReflectDemo2.com.tengj.reflect.ReflectDemo3.com.tengj.reflect.ReflectDemo</code></pre><p><strong>Java反射相关操作</strong></p><p>在这里先看一下sun为我们提供了那些反射机制中的类：</p><blockquote><p>java.lang.Class; java.lang.reflect.Constructor;<br>java.lang.reflect.Field; java.lang.reflect.Method;<br>java.lang.reflect.Modifier;</p></blockquote><p>前面我们知道了怎么获取Class，那么我们可以通过这个Class干什么呢？<br>总结如下：</p><pre><code>获取成员方法Method获取成员变量Field获取构造函数Constructor下面来具体介绍</code></pre><p><strong><code>1.获取成员方法信息</code></strong></p><blockquote><p><strong>两个参数分别是方法名和方法参数类的类类型列表。</strong></p></blockquote><pre><code>public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的方法，不包括父类的 public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的public方法，包括父类的//具体使用Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法 Method[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法 Method method = class1.getMethod(&quot;info&quot;, String.class);//返回次Class对象对应类的、带指定形参列表的public方法 Method declaredMethod = class1.getDeclaredMethod(&quot;info&quot;, String.class);//返回次Class对象对应类的、带指定形参列表的方法</code></pre><p>举个例子：</p><p>例如类A有如下一个方法：</p><pre><code>public void fun(String name,int age) {        System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;);    }</code></pre><p>现在知道A有一个对象a，那么就可以通过：</p><pre><code>Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);  //先生成classObject o = c.newInstance();                           //newInstance可以初始化一个实例Method method = c.getMethod(&quot;fun&quot;, String.class, int.class);//获取方法method.invoke(o, &quot;tengj&quot;, 10);                         //通过invoke调用该方法，参数第一个为实例对象，后面为具体参数值</code></pre><p>完整代码如下：</p><pre><code>public class Person {    private String name;    private int age;    private String msg=&quot;hello wrold&quot;; public String getName() {        return name;  }    public void setName(String name) {        this.name = name;  }    public int getAge() {        return age;  }    public void setAge(int age) {        this.age = age;  }    public Person() {    }    private Person(String name) {        this.name = name;  System.out.println(name);  }    public void fun() {        System.out.println(&quot;fun&quot;);  }    public void fun(String name,int age) {        System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;);  }}public class ReflectDemo {    public static void main(String[] args){        try {            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);            Object o = c.newInstance();            Method method = c.getMethod(&quot;fun&quot;, String.class, int.class);            method.invoke(o, &quot;tengj&quot;, 10);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>执行结果：</p><pre><code>我叫tengj,今年10岁</code></pre><p>怎样，是不是感觉很厉害，我们只要知道这个类的路径全称就能玩弄它于鼓掌之间。</p><p>有时候我们想获取类中所有成员方法的信息，要怎么办。可以通过以下几步来实现：</p><p>1.获取所有方法的数组：</p><pre><code>Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);Method[] methods = c.getDeclaredMethods(); // 得到该类所有的方法，不包括父类的或者：Method[] methods = c.getMethods();// 得到该类所有的public方法，包括父类的</code></pre><p>然后循环这个数组就得到每个方法了：</p><pre><code>for (Method method : methods)</code></pre><p>完整代码如下：<br>person类跟上面一样，这里以及后面就不贴出来了，只贴关键代码</p><pre><code>public class ReflectDemo {    public static void main(String[] args){        try {            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);            Method[] methods = c.getDeclaredMethods();            for(Method m:methods){                String  methodName= m.getName();                System.out.println(methodName);            }        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>执行结果：</p><pre><code>getNamesetNamesetAgefunfungetAge</code></pre><p>这里如果把c.getDeclaredMethods();改成c.getMethods();执行结果如下，多了很多方法，以为把Object里面的方法也打印出来了，因为Object是所有类的父类：</p><pre><code>getNamesetNamegetAgesetAgefunfunwaitwaitwaitequalstoStringhashCodegetClassnotifynotifyAll</code></pre><pre><code>获取成员变量信息</code></pre><p>想一想成员变量中都包括什么：成员变量类型+成员变量名</p><p>类的成员变量也是一个对象，它是java.lang.reflect.Field的一个对象，所以我们通过java.lang.reflect.Field里面封装的方法来获取这些信息。</p><p>单独获取某个成员变量，通过Class类的以下方法实现：</p><blockquote><p>参数是成员变量的名字</p></blockquote><pre><code>public Field getDeclaredField(String name) // 获得该类自身声明的所有变量，不包括其父类的变量public Field getField(String name) // 获得该类自所有的public成员变量，包括其父类变量//具体实现Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性 Field[] publicFields = class1.getFields();//获取class对象的public属性 Field ageField = class1.getDeclaredField(&quot;age&quot;);//获取class指定属性 Field desField = class1.getField(&quot;des&quot;);//获取class指定的public属性</code></pre><p>举个例子：</p><p>例如一个类A有如下成员变量：</p><blockquote><p>private int n;</p></blockquote><p>如果A有一个对象a，那么就可以这样得到其成员变量：</p><pre><code>Class c = a.getClass();Field field = c.getDeclaredField(&quot;n&quot;);</code></pre><p>完整代码如下：</p><pre><code>public class ReflectDemo {    public static void main(String[] args){        try {            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);            //获取成员变量            Field field = c.getDeclaredField(&quot;msg&quot;); //因为msg变量是private的，所以不能用getField方法            Object o = c.newInstance();            field.setAccessible(true);//设置是否允许访问，因为该变量是private的，所以要手动设置允许访问，如果msg是public的就不需要这行了。            Object msg = field.get(o);            System.out.println(msg);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>执行结果：</p><pre><code>hello wrold</code></pre><p>同样，如果想要获取所有成员变量的信息，可以通过以下几步</p><p>1.获取所有成员变量的数组：</p><pre><code>Field[] fields = c.getDeclaredFields();</code></pre><p>2.遍历变量数组，获得某个成员变量field</p><pre><code>for (Field field : fields)</code></pre><p>完整代码：</p><pre><code>public class ReflectDemo {    public static void main(String[] args){        try {            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);            Field[] fields = c.getDeclaredFields();            for(Field field :fields){                System.out.println(field.getName());            }        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>执行结果：</p><pre><code>nameagemsg</code></pre><p><strong>1.获取构造函数</strong></p><p>最后再想一想构造函数中都包括什么：构造函数参数<br>同上，类的成构造函数也是一个对象，它是java.lang.reflect.Constructor的一个对象，所以我们通过java.lang.reflect.Constructor里面封装的方法来获取这些信息。</p><p>单独获取某个构造函数,通过Class类的以下方法实现：</p><blockquote><p>这个参数为构造函数参数类的类类型列表</p></blockquote><pre><code>public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) //  获得该类所有的构造器，不包括其父类的构造器public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所以public构造器，包括父类//具体Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数 Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();//获取class对象public构造函数 Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数 Constructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数</code></pre><p>举个例子：</p><p>例如类A有如下一个构造函数：</p><pre><code>public A(String a, int b) {    // code body}</code></pre><p>那么就可以通过：</p><pre><code>Constructor constructor = a.getDeclaredConstructor(String.class, int.class);</code></pre><p>来获取这个构造函数。</p><p>完整代码：</p><pre><code>public class ReflectDemo {    public static void main(String[] args){        try {            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);            //获取构造函数            Constructor constructor = c.getDeclaredConstructor(String.class);            constructor.setAccessible(true);//设置是否允许访问，因为该构造器是private的，所以要手动设置允许访问，如果构造器是public的就不需要这行了。            constructor.newInstance(&quot;tengj&quot;);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>执行结果：</p><blockquote><p>tengj</p></blockquote><p>注意：Class的newInstance方法，只能创建只包含无参数的构造函数的类，如果某类只有带参数的构造函数，那么就要使用另外一种方式：</p><pre><code>fromClass.getDeclaredConstructor(String.class).newInstance(&quot;tengj&quot;);</code></pre><p>获取所有的构造函数，可以通过以下步骤实现：</p><p>1.获取该类的所有构造函数，放在一个数组中：</p><pre><code>Constructor[] constructors = c.getDeclaredConstructors();</code></pre><p>2.遍历构造函数数组，获得某个构造函数constructor:</p><pre><code>for (Constructor constructor : constructors)</code></pre><p>完整代码：</p><pre><code>public class ReflectDemo {    public static void main(String[] args){            Constructor[] constructors = c.getDeclaredConstructors();            for(Constructor constructor:constructors){                System.out.println(constructor);            }        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>执行结果：</p><pre><code>public com.tengj.reflect.Person()public com.tengj.reflect.Person(java.lang.String)</code></pre><p>其他方法<br>注解需要用到的</p><p>Annotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解 </p><pre><code>Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解 Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的type集合</code></pre><p>获取class对象的信息</p><pre><code>boolean isPrimitive = class1.isPrimitive();//判断是否是基础类型 boolean isArray = class1.isArray();//判断是否是集合类 boolean isAnnotation = class1.isAnnotation();//判断是否是注解类 boolean isInterface = class1.isInterface();//判断是否是接口类 boolean isEnum = class1.isEnum();//判断是否是枚举类 boolean isAnonymousClass = class1.isAnonymousClass();//判断是否是匿名内部类 boolean isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);//判断是否被某个注解类修饰 String className = class1.getName();//获取class名字 包含包名路径 Package aPackage = class1.getPackage();//获取class的包信息 String simpleName = class1.getSimpleName();//获取class类名 int modifiers = class1.getModifiers();//获取class访问权限 Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();//内部类 Class&lt;?&gt; declaringClass = class1.getDeclaringClass();//外部类getSuperclass()：获取某类的父类  getInterfaces()：获取某类实现的接口</code></pre><p><strong>通过反射了解集合泛型的本质</strong></p><blockquote><p>扩展的知识点，了解就可以了。后续会为大家写一篇关于泛型的文章。</p></blockquote><p>首先下结论：</p><blockquote><p>Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译到了运行期就无效了。</p></blockquote><p>下面通过一个实例来验证：</p><pre><code>/** * 集合泛型的本质 */public class GenericEssence {    public static void main(String[] args) {        List list1 = new ArrayList(); // 没有泛型         List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); // 有泛型        /*         * 1.首先观察正常添加元素方式，在编译器检查泛型，         * 这个时候如果list2添加int类型会报错         */        list2.add(&quot;hello&quot;);//      list2.add(20); // 报错！list2有泛型限制，只能添加String，添加int报错        System.out.println(&quot;list2的长度是：&quot; + list2.size()); // 此时list2长度为1        /*         * 2.然后通过反射添加元素方式，在运行期动态加载类，首先得到list1和list2         * 的类类型相同，然后再通过方法反射绕过编译器来调用add方法，看能否插入int         * 型的元素         */        Class c1 = list1.getClass();        Class c2 = list2.getClass();        System.out.println(c1 == c2); // 结果：true，说明类类型完全相同        // 验证：我们可以通过方法的反射来给list2添加元素，这样可以绕过编译检查        try {            Method m = c2.getMethod(&quot;add&quot;, Object.class); // 通过方法反射得到add方法            m.invoke(list2, 20); // 给list2添加一个int型的，上面显示在编译器是会报错的            System.out.println(&quot;list2的长度是：&quot; + list2.size()); // 结果：2，说明list2长度增加了，并没有泛型检查        } catch (Exception e) {            e.printStackTrace();        }        /*         * 综上可以看出，在编译器的时候，泛型会限制集合内元素类型保持一致，但是编译器结束进入         * 运行期以后，泛型就不再起作用了，即使是不同类型的元素也可以插入集合。         */    }}</code></pre><p>执行结果：</p><pre><code>list2的长度是：1truelist2的长度是：2</code></pre><p>思维导图</p><blockquote><p>有助于理解上述所讲的知识点<br><img src="http://img.blog.csdn.net/20170829191338838?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></blockquote><p>拓展阅读<br>Java反射机制深入详解 - 火星十一郎 - 博客园<br>Java反射入门 - Trigl的博客 - CSDN博客<br>Java反射机制 - ①块腹肌 - 博客园<br>Java 反射机制浅析 - 孤旅者 - 博客园<br>反射机制的理解及其用途 - 每天进步一点点！ - ITeye博客<br>Java动态代理与反射详解 - 浩大王 - 博客园</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Java的三种代理模式</title>
      <link href="/2018/12/04/lao-bo-ke/java-de-san-chong-dai-li-mo-shi/"/>
      <url>/2018/12/04/lao-bo-ke/java-de-san-chong-dai-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:<strong><em>可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.</em></strong><br><strong>代理模式使用的场景非常多，例如框架中的AOP思想的实</strong>现。<br>这里使用到编程中的一个思想:<strong>不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法，即狭义上的开闭原则</strong></p><p>举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子</p><p>用图表示如下:<br><img src="http://img.blog.csdn.net/20170909223642510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象</p><hr><p><strong>1.1.静态代理</strong></p><p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.</p><p>下面举个案例来解释:<br>模拟保存动作,定义一个保存动作的接口:IUserDao.java,然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象.<br>需要注意的是,代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</p><p>代码示例:<br>接口:IUserDao.java</p><pre><code>/** * 接口 */public interface IUserDao {    void save();}目标对象:UserDao.java/** * 接口实现 * 目标对象 */public class UserDao implements IUserDao {    public void save() {        System.out.println(&quot;----已经保存数据!----&quot;);    }}</code></pre><p>代理对象:UserDaoProxy.java</p><pre><code>/** * 代理对象,静态代理 */public class UserDaoProxy implements IUserDao{    //接收保存目标对象    private IUserDao target;    public UserDaoProxy(IUserDao target){        this.target=target;    }    public void save() {        System.out.println(&quot;开始事务...&quot;);        target.save();//执行目标对象的方法        System.out.println(&quot;提交事务...&quot;);    }}</code></pre><p>测试类:App.java</p><pre><code>/** * 测试类 */public class App {    public static void main(String[] args) {        //目标对象        UserDao target = new UserDao();        //代理对象,把目标对象传给代理对象,建立代理关系        UserDaoProxy proxy = new UserDaoProxy(target);        proxy.save();//执行的是代理的方法    }}</code></pre><p><strong>静态代理总结:</strong></p><pre><code>1.可以做到在不修改目标对象的功能前提下,对目标功能扩展.2.缺点:    因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.如何解决静态代理中的缺点呢?答案是可以使用动态代理方式</code></pre><hr><p><strong>1.2.动态代理</strong></p><p><strong>动态代理有以下特点:</strong></p><p>1.代理对象,不需要实现接口<br>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)<br>3.动态代理也叫做:JDK代理,接口代理</p><p>JDK中生成代理对象的API<br>代理类所在包:java.lang.reflect.Proxy<br>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:</p><p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</p><p>注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:</p><pre><code>ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</code></pre><p>代码示例:<br>接口类IUserDao.java以及接口实现类,目标对象UserDao是一样的,没有做修改.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类(需要使用到代理的代码)中先建立目标对象和代理对象的联系,然后代用代理对象的中同名方法</p><p>代理工厂类:ProxyFactory.java</p><pre><code>/** * 创建动态代理对象 * 动态代理不需要实现接口,但是需要指定接口类型 */public class ProxyFactory{    //维护一个目标对象    private Object target;    public ProxyFactory(Object target){        this.target=target;    }   //给目标对象生成代理对象    public Object getProxyInstance(){        return Proxy.newProxyInstance(                target.getClass().getClassLoader(),                target.getClass().getInterfaces(),                new InvocationHandler() {                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                        System.out.println(&quot;开始事务2&quot;);                        //执行目标对象方法                        Object returnValue = method.invoke(target, args);                        System.out.println(&quot;提交事务2&quot;);                        return returnValue;                    }                }        );    }}</code></pre><p>测试类:App.java</p><pre><code>/** * 测试类 */public class App {    public static void main(String[] args) {        // 目标对象        IUserDao target = new UserDao();        // 【原始的类型 class cn.itcast.b_dynamic.UserDao】        System.out.println(target.getClass());        // 给目标对象，创建代理对象        IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();        // class $Proxy0   内存中动态生成的代理对象        System.out.println(proxy.getClass());        // 执行方法   【代理对象】        proxy.save();    }}</code></pre><p>总结:<br>代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理<br>1.3.Cglib代理</p><p>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理</p><p>Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p><pre><code>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.</code></pre><p>Cglib子类代理实现方法:<br>1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入pring-core-3.2.5.jar即可.<br>2.引入功能包后,就可以在内存中动态构建子类<br>3.代理的类不能为final,否则报错<br>4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.</p><p>代码示例:<br>目标对象类:UserDao.j/**</p><ul><li><p>目标对象,没有实现任何接口<br>*/<br>public class UserDao {</p><p> public void save() {</p><pre><code> System.out.println(&quot;----已经保存数据!----&quot;);</code></pre><p> }<br>}ib代理工厂:ProxyFactory.j/**</p></li><li>Cglib子类代理工厂</li><li><p>对UserDao在内存中动态构建一个子类对象<br>*/<br>public class ProxyFactory implements MethodInterceptor{<br> //维护目标对象<br> private Object target;</p><p> public ProxyFactory(Object target) {</p><pre><code> this.target = target;</code></pre><p> }</p><p> //给目标对象创建一个代理对象<br> public Object getProxyInstance(){</p><pre><code> //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(target.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create();</code></pre><p> }</p><p> @Override<br> public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {</p><pre><code> System.out.println(&quot;开始事务...&quot;); //执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(&quot;提交事务...&quot;); return returnValue;</code></pre><p> }<br>}:</p></li></ul><pre><code>/** * 测试类 */public class App {    @Test    public void test(){        //目标对象        UserDao target = new UserDao();        //代理对象        UserDao proxy = (UserDao)new ProxyFactory(target).getProxyInstance();        //执行代理对象的方法        proxy.save();    }}</code></pre><p>在Spring的AOP编程中:<br>如果加入容器的目标对象有实现接口,用JDK代理<br>如果目标对象没有实现接口,用Cglib代理</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Javascript节流和防抖</title>
      <link href="/2018/12/04/lao-bo-ke/javascript-jie-liu-he-fang-dou-zhuan-zai/"/>
      <url>/2018/12/04/lao-bo-ke/javascript-jie-liu-he-fang-dou-zhuan-zai/</url>
      
        <content type="html"><![CDATA[<div class="post-body" itemprop="articleBody" style="opacity: 1; display: block; transform: translateY(0px);"><br><p>在前端开发中可能会遇到一些频发触发的事件，例如</p><ol><li>window 的 resize(浏览器窗口或者HTML对象改变大小)、scroll(滚动条事件）</li><li>mousedown(鼠标在元素上按下事执行事件)、onmousemove(鼠标指针移动到元素上触发)</li><li>keyup(按键被释放触发)、keydown(按键被按下触发)<a id="more"></a> 举例</li></ol><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    #root{</span></span><br><span class="line"><span class="undefined">        width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #444; font-size: 30px;</span></span><br><span class="line"><span class="undefined">    }</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">‘root’</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">‘./demo.js’</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dome.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> conut = <span class="number">1</span>; <span class="comment">// 声明一个变量储存触发次数</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="built_in">document</span>.getElementById(<span class="string">‘root’</span>); <span class="comment">// 获取id为root的div</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAction</span>(<span class="params"></span>) </span>{ <span class="comment">// 声明一个函数更改root的HTML为conut的值并将conut值++</span></span><br><span class="line">        root.innerHTML = conut++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">root.onmousemove = getUserAction;</span><br></pre></td></tr></tbody></table></figure><p>效果如下</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/debounce.gif" class="fancybox fancybox.image" rel="noopener" target="_blank"><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/debounce.gif" alt=""></a></p><p>从图上可以看到从左边到右边一共触发了160多次onmousemove事件，同样执行了160多次getUserAction函数。<br>因为这个例子简单，浏览器可以处理的过来，如果换成请求， 频繁触发就会出现卡顿。</p><p>修改一下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> dome.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> conut = <span class="number">1</span>; <span class="comment">// 声明一个变量储存触发次数</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="built_in">document</span>.getElementById(<span class="string">‘root’</span>); <span class="comment">// 获取id为root的div</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAction</span>(<span class="params"></span>) </span>{ <span class="comment">// 声明一个函数更改root的HTML为conut的值并将conut值++</span></span><br><span class="line">        root.innerHTML = conut++;</span><br><span class="line">    }</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>{ <span class="comment">// 声明一个函数，函数接受两个参数。</span></span><br><span class="line">    <span class="keyword">var</span> timeout; <span class="comment">// 声明一个变量储存定时器的返回值；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        clearTimeout(timeout) 函数被执行了先清除先前定时器的返回值(传入一个错误的ID 给 clearTime 不会有任何影响（也不会抛出异常）)</span><br><span class="line">        timeout = setTimeout(fn, wait); <span class="comment">// 定时器会返回一个id给timeout</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">root.onmousemove = debounce(getUserAction, <span class="number">1000</span>);</span><br></pre></td></tr></tbody></table></figure><p>上面这个函数</p><p>分析一下上面的操作</p><ol><li>鼠标移动触发onmousemove事件。</li><li>onmousemove事件调用debounce函数</li><li>debounce函数接收到getUserAction， 1000函数之后返回一个匿名函数-清除前面的定时器-执行新的定时器</li></ol><p>然后只要鼠标移动就会1-2-3执行，直至鼠标停留超过一秒，才会执行getUserAction函数。</p><h3 id="JavaScript节流"><a href="#JavaScript节流" class="headerlink" title="JavaScript节流"></a>JavaScript节流</h3><p>节流就是如果持续触发事件，则每个一段时间，只执行一次事件。</p><p>主流有两种方法：<code>使用时间戳</code>， <code>设置定时器</code></p><p>使用时间戳</p><p>使用时间戳，当事件触发时，去除当前的时间戳，然后减去之前的时间戳，最开始可以设置为0，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前时间戳，如果小于，则不执行。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fu, wait</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> previos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// new Date()做一个+运算，触发对象执行valueOf进行求值得到为毫秒数</span></span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) { <span class="comment">// 判断当前的毫秒数减去预制的毫秒数是否大于传入参数的设置</span></span><br><span class="line">            fu(); <span class="comment">// 执行传入的函数</span></span><br><span class="line">            previous = now; <span class="comment">// 更新储存的毫秒数为此次执行的</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">root.onmousemove = throttle(getUserAction, <span class="number">1000</span>);</span><br></pre></td></tr></tbody></table></figure><p>使用定时器</p><p>当事件被触发的时候设置一个定时器，在触发事件，如果定时器存在则不执行，直至定时器执行然后执行函数，清空定时器。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> timeout; <span class="comment">// 声明一个变量储存定时器返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> {  <span class="comment">// 返回一个函数</span></span><br><span class="line">        <span class="keyword">if</span>(!timeout) { <span class="comment">// 判断timeout是否存有定时器返回值</span></span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>{</span><br><span class="line">                timeout = <span class="literal">null</span>;<span class="comment">// 定时器执行</span></span><br><span class="line">                fun(); <span class="comment">// 执行传入函数</span></span><br><span class="line">            }, wait) <span class="comment">// 延迟多久</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">root.onmousemove = throttle(getUserAction, <span class="number">1000</span>);</span><br></pre></td></tr></tbody></table></figure></div>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Java8之lambda表达式略解</title>
      <link href="/2018/12/04/lao-bo-ke/java8-zhi-lambda-biao-da-shi-lue-jie/"/>
      <url>/2018/12/04/lao-bo-ke/java8-zhi-lambda-biao-da-shi-lue-jie/</url>
      
        <content type="html"><![CDATA[<p>一、什么是lambda表达式？</p><pre><code>Lambda 表达式，其实就是匿名函数。而函数其实就是功能（function），匿名函数，就是匿名的功能代码了，我们可以把 Lambda 表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java的语言表达能力得到了提升。Lambda就是为了替换匿名函数而存在的【本人的理解】;</code></pre><p>二、lambda的使用场景。</p><pre><code>Lambda表达式是用于替代匿名函数，写出更简洁的代码的，因此，所有期待匿名函数、或者函数式接口类型参数出现的地方都可以使用Lambda替换。</code></pre><p>三、什么是函数式接口。</p><pre><code>函数式接口：Functional Interface. 定义的一个接口，接口里面必须 有且只有一个抽象方法 ，这样的接口就成为函数式接口。 在可以使用lambda表达式的地方，方法声明时必须包含一个函数式的接口，匿名内部类其实是函数式接口的实现类。 （JAVA8的接口可以有多个default方法）</code></pre><p>四、写法、规则</p><pre><code>基本语法: (parameters) -&gt; expression 或 (parameters) -&gt;{ statements; } 即: 参数 -&gt; 带返回值的表达式/无返回值的陈述----------//1. 接收2个int型整数,返回他们的和(int x, int y) -&gt; x + y;//2. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)(String s) -&gt; System.out.print(s);----------lambda表达式的结构参数可以是零个或多个参数类型可指定，可省略（根据表达式上下文推断）参数包含在圆括号中，用逗号分隔表达式主体可以是零条或多条语句,包含在花括号中表达式主体只有一条语句时,花括号可省略表达式主体有一条以上语句时，表达式的返回类型与代码块的返回类型一致表达式只有一条语句时，表达式的返回类型与该语句的返回类型一致//零个 ()-&gt; System.out.println(&quot;no argument&quot;);//一个  x-&gt;x+1//两个  (x,y)-&gt;x+y//省略参数类型 View.OnClickListener oneArgument = view-&gt;Log.d(TAG,&quot;one argument&quot;); //指定参数类型 View.OnClickListener oneArgument = (View view)-&gt;Log.d(TAG,&quot;one argument&quot;);//多行语句//返回类型是代码块返回的voidView.OnClickListener multiLine = (View view)-&gt;{      Log.d(TAG,&quot;multi statements&quot;);      Log.d(TAG,&quot;second line&quot;);}//返回类型是表达式主体语句的返回类型int(int x)-&gt;x+1</code></pre><p>五.几个特性</p><pre><code>1. 类型推导 编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文所期待的类型进行推导， 这个被期待的类型被称为目标类型。就是说我们传入的参数可以无需写类型了！</code></pre><p>六、demo<br>1.使用lambda表达式实现Runnable</p><pre><code>package com.lz.test;/** * 使用lambda表达式替换Runnable匿名内部类 * @author MingChenchen * */public class RunableTest {    /**     * 普通的Runnable     */    public static void runSomeThing(){        //new Runnable()实际上实现的接口的匿名子类;        Runnable runnable = new Runnable() {            @Override            public void run() {                System.out.println(&quot;I am running&quot;);            }        };        new Thread(runnable).start();    }    /**     * 使用lambda后的     */    public static void runSomeThingByLambda(){        //此处期待的是一个函数式类型的参数，因此可以使用lambda表达式进行替换;        new Thread(() -&gt; System.out.println(&quot;I am running&quot;)).start();    }    public static void main(String[] args) {        //runSomeThing();     runSomeThingByLambda();    }}</code></pre><blockquote><p>上述代码中：<br>() -&gt; System.out.println(“I am running”)就是一个lambda表达式，<br>可以看出，它是替代了new Runnable(){}这个匿名内部类。</p></blockquote><p>2.使用lambda表达式实现Comparator</p><pre><code>Students.java----------package com.lz.test;/** * Lambda表达式测试实体; * @author JunZhou * @Time 2018年1月29日下午10:44:56 */public class Students {    private int age;    private int score;    public Students(int age, int score) {        super();        this.age = age;        this.score = score;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public int getScore() {        return score;    }    public void setScore(int score) {        this.score = score;    }}</code></pre><pre><code>package com.lz.test;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class LambdaTestDemo {    public static void main(String[] args) {        List&lt;Students&gt; students = new ArrayList&lt;Students&gt;();        students.add(new Students(23, 100));        students.add(new Students(27, 98));        students.add(new Students(29, 99));        students.add(new Students(29, 98));        students.add(new Students(22, 89));        // 未使用lambda表达式之前的代码;        /*         * Collections.sort(students, new Comparator&lt;Students&gt;() {         *          * @Override public int compare(Students o1, Students o2) { int i =         * o1.getScore() - o2.getScore(); if(i == 0){ return o1.getAge() -         * o2.getAge(); } return i; } });         */        // 使用lambda表达式替换之后的代码;        Collections.sort(students, (Students o1, Students o2) -&gt; {            int i = o1.getScore() - o2.getScore();            if (i == 0) {                return o1.getAge() - o2.getAge();            }            return i;        });        for (Students stu : students) {            System.out.println(&quot;score:&quot; + stu.getScore() + &quot;:age&quot; + stu.getAge());        }    }}</code></pre><p>7、参考文章<br> <a href="http://blog.csdn.net/jinzhencs/article/details/50748202" target="_blank" rel="noopener">JAVA8之lambda表达式详解，及stream中的lambda使用</a></p><p><a href="https://juejin.im/entry/5763b1e1d342d30058de759e" target="_blank" rel="noopener">30 分钟入门 Java8 之 lambda 表达式</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Java 对象的存储区域</title>
      <link href="/2018/12/04/lao-bo-ke/java-dui-xiang-de-cun-chu-qu-yu/"/>
      <url>/2018/12/04/lao-bo-ke/java-dui-xiang-de-cun-chu-qu-yu/</url>
      
        <content type="html"><![CDATA[<p>程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据：<br>       转载自：<a href="https://blog.csdn.net/kdnuggets/article/details/1901144" target="_blank" rel="noopener">Java 对象的存储区域</a><br>  (1)寄存器；<br>    这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。<br>    (2)堆栈；<br>        驻留于常规RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管有些Java数据要保存在堆栈里——特别是对象句柄，但Java对象并不放到其中。<br>    (3) 堆；<br>       一种常规用途的内存池（也在RAM区域），其中保存了Java对象。和堆栈不同，“内存堆”或“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！<br>    (4)静态存储；<br>        这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM里）。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但Java对象本身永远都不会置入静态存储空间。<br>    (5)常数存储；<br>      常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。<br>    (6)非RAM存储；<br>       若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复成普通的、基于RAM的对象。Java 1.1提供了对Lightweight persistence的支持。未来的版本甚至可能提供更完整的方案。</p><p>《Think in Java》Chapter 2</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>J2EE中连接池的深入理解</title>
      <link href="/2018/12/04/lao-bo-ke/j2ee-zhong-lian-jie-chi-de-shen-ru-li-jie/"/>
      <url>/2018/12/04/lao-bo-ke/j2ee-zhong-lian-jie-chi-de-shen-ru-li-jie/</url>
      
        <content type="html"><![CDATA[<hr><p>  <em>首先介绍使用连接池的好处</em><br>      在WEB开发中，使用连接池相对于普通的jdbc方式访问数据库可以成倍的增加数据库的访问效率。</p><p>   <em>JDBC方式访问数据库较慢的原因</em><br>   使用JDBC方式访问数据库的时候，每次访问都必须要和数据库建立连接，而连接是可以被复用的，因此，JDBC方式在这个过程中浪费了时间，从而访问效率降低.</p><p> <em>连接池增加数据访问效率的原理</em><br>      使用连接池的时候，可以通过配置web.xml文件使得服务器在启动的时候即创建一定数量的连接【相当于设计模式中的饿汉模式】并存储于连接池中【一块存储区域，这里只是有个名称而已，没有特殊的含义】，因此当需要使用的时候可以直接从连接池中获取实例，用完后必须要释放连接实例【只是将连接放回了连接池，并没有真正的关闭这个和数据库的连接】，因为数据库的连接是有限的;</p><hr><p><em>使用连接池时需要注意的问题</em></p><p><em>使用连接池的时候需要手动关闭连接？</em><br>    首先确定以下几个概念:<br>1、连接池即使回收Connection，也不是马上释放，而是会过一阵子才释放；<br>2、连接池概念本身是代为管理Connection,当我们使用close()关闭连接时，只是把该连接放回了连接池中，并没有真正的关闭这个连接；<br>3、Connection Pool在有外来请求，而没有空闲的Connection时，会按照时间顺序回收Connection,而不是全部回收；<br>因此，基于连接池数量有限的前提，即使是连接池中的连接，在使用完毕之后也要手动进行关闭。</p><p><em>下面将通过图解的方式对连接池和JDBC两种方式进行说明</em><br><img src="http://img.blog.csdn.net/20170525215239419?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>案例链接：<a href="http://download.csdn.net/my" target="_blank" rel="noopener">Oracel连接池案例代码</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>J2EE中session的深入理解</title>
      <link href="/2018/12/04/lao-bo-ke/j2ee-zhong-session-de-shen-ru-li-jie/"/>
      <url>/2018/12/04/lao-bo-ke/j2ee-zhong-session-de-shen-ru-li-jie/</url>
      
        <content type="html"><![CDATA[<hr><p>在学习J2EE的过程中,session和cookie是极为重要的部分，下面谈谈我对session和cookie的理解：<br> <em>首先介绍两者的相同点</em><br><strong>相同点</strong><br>1.session和cookie都是生存周期有限的数据存储方式【此处不考虑生命周期无限大的情况】，即临时数据文件;<br>2.session和cookie都是由服务器端控制和产生的;</p><ol start="3"><li>session和cookie都可以理解为<code>Map&lt;name,value&gt;</code>，都采用键值对的方式存储数据；</li><li>不同的网站session和cookie是不能通用的，根本原因是：cookie在生成的时候有效作用范围是被限定的，所以说在一定的成都上cookie和session是安全的。</li></ol><hr><p><strong>不同点</strong><br>1.session和cookie的存储位置是不同的，session存在于服务器端，而cookie存在于客户端，cookie可以被用户手动清理掉，所以，重要的不可或缺的数据一般不会保存在cookie中;<br>2.创建cookie和session时生成的数据不同，在创建cookie的时候，仅仅在客户端生成cookie形式的<code>Map&lt;name,value&gt;</code>的键值对，而在生成session的形式，会在客户端生成cookie用于保存sessionID并且在服务器端生成session数据【这两者的本质都是<code>Map&lt;name,value&gt;</code>】;<br>3.两者的访问形式不一样;<br><em>详细解见下图</em><br><img src="http://img.blog.csdn.net/20170525121244032?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Intellij Idea 创建Web项目入门(非Maven项目)</title>
      <link href="/2018/12/04/lao-bo-ke/intellij-idea-chuang-jian-web-xiang-mu-ru-men-fei-maven-xiang-mu/"/>
      <url>/2018/12/04/lao-bo-ke/intellij-idea-chuang-jian-web-xiang-mu-ru-men-fei-maven-xiang-mu/</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong></p><p>最近公司开发项目中使用到了Intellij Idea（一款非常智能化的IDE），刚开始的时候还不大习惯，感觉操作太麻烦，后来渐渐适应，终于渐渐的开始尝到甜头了。</p><p><strong>相关软件</strong></p><blockquote><p>Intellij Idea14：<a href="http://pan.baidu.com/s/1nu16VyD" target="_blank" rel="noopener">http://pan.baidu.com/s/1nu16VyD</a><br>JDK7：<a href="http://pan.baidu.com/s/1dEstJ5f" target="_blank" rel="noopener">http://pan.baidu.com/s/1dEstJ5f</a><br>Tomcat（apache-tomcat-6.0.43）：<a href="http://pan.baidu.com/s/1kUwReQF" target="_blank" rel="noopener">http://pan.baidu.com/s/1kUwReQF</a><br>Intellij Idea的安装非常简单，一步一步安装即可。<br>JDK的安装也挺简单的，重要的是配置环境。在环境变量Path里面添上Java的安装路径即可。<br>Tomcat文件夹不用安装，直接解压放在C盘下即可，或者放在其他文件夹下也可以，但是文件夹的名字最好不要带中文~~~不信？祝你好运</p></blockquote><p><strong>名词解释</strong><br>Project:在IDE中，project相当于eclipse中的一个Working Sets<br>Module:在IDE中，module相当于eclipse中的一个项目;<br>如下图所示：<br><img src="http://img.blog.csdn.net/20170901202203222?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><p>Idea创建Web项目步骤：</p><p><strong>1、创建一个空的项目Project</strong><br>        如下图所示：<br>       <img src="http://img.blog.csdn.net/20170901204052575?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><blockquote><p>创建好Project之后可能需要进行相关设置，这些设置是针对Module的全局设置，毕竟Project是Modulede的容器，具体操作如下图所示：</p></blockquote><p><img src="http://img.blog.csdn.net/20170901204612874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><pre><code>**2、创建一个项目Module**![这里写图片描述](http://img.blog.csdn.net/20170901205740972?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</code></pre><p><strong>3、创建好的web项目</strong><br>       <img src="http://img.blog.csdn.net/20170901210054332?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>4、在web/WEB-INF下创建两个文件夹：classes和lib<br>classes用来存放编译后输出的class文件，lib用于存放第三方jar包。</strong></p><p><img src="http://img.blog.csdn.net/20170901210252754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>5、配置文件夹路径(上面新建了文件夹，但是没有给系统指定，所以在这里需要开发者自己指定)</strong></p><p>File -&gt; Project Structure (快捷键：Ctrl + Shift + Alt + S) -&gt; 选择Module ：<br> 选择 Paths -&gt; 选择”Use module compile output path” -&gt; 将Output path和Test output path都选择刚刚创建的classes文件夹。<br><img src="http://img.blog.csdn.net/20170901211245690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>6.配置置Dependencies，选择Dependencies -&gt;  将Module SDK选择为1.7 -&gt; 点击右边的“+”号  -&gt; 选择1 “Jars or Directories”</strong></p><p><img src="http://img.blog.csdn.net/20170901222958531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>7.配置Tomcat容器</strong></p><p>打开菜单Run -&gt; 选择Edit Configuration<br><img src="http://img.blog.csdn.net/20170901225011838?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><strong>点击“+”号</strong> -&gt; 选择“Tomcat Server” -&gt; 选择“Local”<br><img src="http://img.blog.csdn.net/20170901225050645?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>在”Name”处输入新的服务名，点击”Application server”后面的”Configure…”，弹出Tomcat Server窗口，选择本地安装的Tomcat目录 -&gt; OK </p><p> <img src="http://img.blog.csdn.net/20170901225109444?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在”Run/Debug Configurations”窗口的”Server”选项板中，取消勾选”After launch”，设置”HTTP port”和”JMX port”（默认值即可），点击 Apply -&gt; OK， 至此Tomcat配置完成。</p><p><img src="http://img.blog.csdn.net/20170901225125004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>8、在Tomcat中部署并运行项目</strong> </p><p>Run -&gt; Edit Configurations，进入”Run/Debug Configurations”窗口 -&gt; 选择刚刚建立的Tomcat容器 -&gt; 选择Deployment -&gt; 点击右边的“+”号 -&gt; 选择Artifact<br><img src="http://img.blog.csdn.net/20170901225320240?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>-&gt;选择web项目 -&gt; Application context可以填“/hello”(其实也可以不填的~~) -&gt; OK<br><img src="http://img.blog.csdn.net/20170901225409103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>9.编辑index.jsp文件</strong><br><img src="http://img.blog.csdn.net/20170901225607221?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>10、运行Tomcat,在浏览器中查看运行结果</strong> </p><p><img src="http://img.blog.csdn.net/20170901225845994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20170901230000801?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><p>友情链接：<a href="http://www.cnblogs.com/yangyquin/p/5285272.html" target="_blank" rel="noopener">http://www.cnblogs.com/yangyquin/p/5285272.html</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Http状态码详解</title>
      <link href="/2018/12/04/lao-bo-ke/http-zhuang-tai-ma-xiang-jie/"/>
      <url>/2018/12/04/lao-bo-ke/http-zhuang-tai-ma-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>工作中经常遇到http状态码，因此摘抄别人的文章作为笔记，方便自己查找。</p><table class="toolTable table" width="100%" cellspacing="0" cellpadding="0">    <tbody><tr>        <th class="separateColor" width="60px;">状态码</th>        <th>含义</th>    </tr>    <tr>        <td>100</td>        <td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>    </tr>    <tr>        <td>101</td>        <td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。<br>　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>    </tr>    <tr>        <td>102</td>        <td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>    </tr>    <tr>        <td>200</td>        <td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>    </tr>    <tr>        <td>201</td>        <td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td>    </tr>    <tr>        <td>202</td>        <td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。<br>　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>    </tr>    <tr>        <td>203</td>        <td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>    </tr>    <tr>        <td>204</td>        <td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。<br>　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。<br>　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>    </tr>    <tr>        <td>205</td>        <td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<br>　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>    </tr>    <tr>        <td>206</td>        <td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。<br>　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。<br>　　响应必须包含如下的头部域：<br>　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。<br>　　Date<br>　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。<br>　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。<br>　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。<br>　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>    </tr>    <tr>        <td>207</td>        <td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>    </tr>    <tr>        <td>300</td>        <td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<br>　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。<br>　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>    </tr>    <tr>        <td>301</td>        <td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<br>　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>    </tr>    <tr>        <td>302</td>        <td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>    </tr>        <tr>        <td>303</td>        <td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。<br>　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>    </tr>        <tr>        <td>304</td>        <td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。<br>　　该响应必须包含以下的头信息：<br>　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。<br>　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。<br>　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。<br>　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。<br>　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>    </tr>        <tr>        <td>305</td>        <td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。<br>　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>    </tr>        <tr>        <td>306</td>        <td>在最新版的规范中，306状态码已经不再被使用。</td>    </tr>        <tr>        <td>307</td>        <td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。<br>　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>    </tr>        <tr>        <td>400</td>        <td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>　　2、请求参数有误。</td>    </tr>            <tr>        <td>401</td>        <td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>    </tr>        <tr>        <td>402</td>        <td>该状态码是为了将来可能的需求而预留的。</td>    </tr>        <tr>        <td>403</td>        <td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>    </tr>        <tr>        <td>404</td>        <td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>    </tr>        <tr>        <td>405</td>        <td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。<br>　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>    </tr>        <tr>        <td>406</td>        <td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<br>　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>    </tr>        <tr>        <td>407</td>        <td>　与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>    </tr>        <tr>        <td>408</td>        <td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>    </tr>        <tr>        <td>409</td>        <td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。<br>　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>    </tr>        <tr>        <td>410</td>        <td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。<br>　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>    </tr>        <tr>        <td>411</td>        <td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>    </tr>        <tr>        <td>412</td>        <td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>    </tr>        <tr>        <td>413</td>        <td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br>　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>    </tr>        <tr>        <td>414</td>        <td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：<br>　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。<br>　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。<br>　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>    </tr>        <tr>        <td>415</td>        <td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>    </tr>        <tr>        <td>416</td>        <td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。<br>　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>    </tr>        <tr>        <td>417</td>        <td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>    </tr>        <tr>        <td>421</td>        <td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>    </tr>        <tr>        <td>422</td>        <td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>    </tr>        <tr>        <td>422</td>        <td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked<br>　　当前资源被锁定。（RFC 4918 WebDAV）</td>    </tr>        <tr>        <td>424</td>        <td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>    </tr>        <tr>        <td>425</td>        <td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>    </tr>        <tr>        <td>426</td>        <td>客户端应当切换到TLS/1.0。（RFC 2817）</td>    </tr>        <tr>        <td>449</td>        <td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>    </tr>        <tr>        <td>500</td>        <td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>    </tr>        <tr>        <td>501</td>        <td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>    </tr>        <tr>        <td>502</td>        <td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>    </tr>        <tr>        <td>503</td>        <td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。<br>　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>    </tr>        <tr>        <td>504</td>        <td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。<br>　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>    </tr>        <tr>        <td>505</td>        <td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>    </tr>        <tr>        <td>506</td>        <td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>    </tr>    <tr>        <td>507</td>        <td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>    </tr>        <tr>        <td>509</td>        <td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>    </tr>        <tr>        <td>510</td>        <td>获取资源所需要的策略并没有没满足。（RFC 2774）</td>    </tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>html 文本框onfocus（获得焦点） 执行了多次原因</title>
      <link href="/2018/12/04/lao-bo-ke/html-wen-ben-kuang-onfocus-huo-de-jiao-dian-zhi-xing-liao-duo-ci-yuan-yin/"/>
      <url>/2018/12/04/lao-bo-ke/html-wen-ben-kuang-onfocus-huo-de-jiao-dian-zhi-xing-liao-duo-ci-yuan-yin/</url>
      
        <content type="html"><![CDATA[<p>代码如下，非常的简单：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;文本框获得焦点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input id=&quot;text&quot; type=&quot;text&quot;onfocus=&quot;alert(&#39;你点击了&#39;)&quot; &gt;&lt;/input&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果图如下：<br><img src="http://img.blog.csdn.net/20180303102426403?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>实际上运行的效果并不是我想的那样，而是一直都在弹出 alert（）提示框</p><p>终于知道什么原因了，都是我的这个alert() 写的，因为我的 onfocus =” “ 这个属性是文本框获得焦点的属性，而alert 这个是</p><p>弹出对话框，当你点击弹出框的“确定”时，你的文本框就失去焦点了，而你点击了之后文本框又获得焦点了，这个时候就陷入死循环了</p><p>解决的办法： 不用这个onfocus =” “ 属性，换成 onclick=””属性，就O了。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/04/lao-bo-ke/hello-world/"/>
      <url>/2018/12/04/lao-bo-ke/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>flux中Cannot dispatch in the middle of a dispatch问题的解决方案</title>
      <link href="/2018/12/04/lao-bo-ke/flux-dispatch.dispatch-cannot-dispatch-in-the-middle-of-a-dispatch/"/>
      <url>/2018/12/04/lao-bo-ke/flux-dispatch.dispatch-cannot-dispatch-in-the-middle-of-a-dispatch/</url>
      
        <content type="html"><![CDATA[<p>在使用flux进行数据交互的时候，出现了一个问题<code>Flux Dispatch.dispatch(…): Cannot dispatch in the middle of a dispatch</code>，在国内竟然没有找到解决方案，最后在<a href="https://stackoverflow.com上找到了解决方案，但是原理不清楚【这不是我的风格，空下来一定搞懂】。" target="_blank" rel="noopener">https://stackoverflow.com上找到了解决方案，但是原理不清楚【这不是我的风格，空下来一定搞懂】。</a></p><p>解决方案：</p><p>老外是这么说的:<br>You can make it work by “scheduling” the next action instead of calling it directly, here is an example code:<br>译：你可以在指定的时间调度一个action而不是直接调用它。</p><pre><code>// instead of doing thisDispatcher.dispatch(...);// go like thissetTimeout(function() {  Dispatcher.dispatch(...);}, 1);</code></pre><p>我的解决方案:</p><pre><code>setTimeout(function () {      Actions.synchronizePanekeyToStore(currenPaneKey);    }, 1);</code></pre><p>这样就可以了，真心感觉老外很热心。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello JunZhou</title>
      <link href="/2018/12/04/lao-bo-ke/firstblog/"/>
      <url>/2018/12/04/lao-bo-ke/firstblog/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Des加密中错误Input length not multiple of 8 bytes的解决办法</title>
      <link href="/2018/12/04/lao-bo-ke/des-jia-mi-zhong-cuo-wu-input-length-not-multiple-of-8-bytes-de-jie-jue-ban-fa/"/>
      <url>/2018/12/04/lao-bo-ke/des-jia-mi-zhong-cuo-wu-input-length-not-multiple-of-8-bytes-de-jie-jue-ban-fa/</url>
      
        <content type="html"><![CDATA[<p>1、最近在使用des加密的过程中出现了如下错误：<br><img src="http://img.blog.csdn.net/20180119105544192?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>错误提示的意思是：输入的加密源数据不足8个字节,推测是加密的填充模式不对；<br>2、错误原因:</p><pre><code>DES、AES 或者 3DES 属于块加密算法，一般来说原文必须是 8 的整数倍，所以块加密算法除子加密模式之外，还涉及到一个填充模式。如果一定要用 NoPadding 的话，那么必须保证原文字节是 8 的倍数，否则的话需要使用其他的填充模式。在 Sun JCE 中默认的填充模式除了 NoPadding 之外，还有：PKCS5Padding 和 ISO10126PaddingPKCS5Padding 的填充规则是：填充至符合块大小的整数倍，填充值为填充数量数。例如：原始：FF FF FF FF FF FF FF FF FF填充：FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07ISO10126Padding 的填充规则是：填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节随机处理。例如：原始：FF FF FF FF FF FF FF FF FF填充：FF FF FF FF FF FF FF FF FF 3F 7A B4 09 14 36 07使用填充模式后原文字节并不需要是 8 的整数倍，采用填充模式之后，块加密的密文长度为：(N / 8 * 8) + 8如上，假如原文长度为 15 个字节，密文长度就是 16 个字节。假如原文长度为 16 个字节，密文长度就为 24 个字节。也就是说，采用填充模式后必须进行填充，哪怕是 8 的整数倍。</code></pre><p><strong>注意点:</strong>2.1使用哪一种填充模式加密的，也必须采用哪种填充模式解密;<br>             2.2CBC 加密模式需要有一个 IV 参数（也就是初始化向量），这个值在加    密时会随机生成，但必须保存下来，否则无法完成解密工作。<br>            2.3建议采用 ECB 模式，或者在使用 CBC 时将初始化向量保存，在解密时使用。 </p><p>3、解决方案:</p><pre><code>//算法名称/加密模式/填充方式     //DES共有四种工作模式--&gt;&gt;ECB：电子密码本模式、CBC：加密分组链接模式、CFB：加密反馈模式、OFB：输出反馈模式    //此处应该注意加密模式的取值,建议使用ebc模式下的PKCS5Padding自动填充形式;    [修改前的模式]    //public static final String CIPHER_ALGORITHM = &quot;DES/ECB/NoPadding&quot;;    [修改后的模式]    public static final String CIPHER_ALGORITHM = &quot;DES/ECB/PKCS5Padding &quot;;</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>DES加密算法探究【Java版本】</title>
      <link href="/2018/12/04/lao-bo-ke/des-jia-mi-suan-fa-tan-jiu-java-ban-ben/"/>
      <url>/2018/12/04/lao-bo-ke/des-jia-mi-suan-fa-tan-jiu-java-ban-ben/</url>
      
        <content type="html"><![CDATA[<p>1、参考文章:<br>1.1<a href="http://blog.csdn.net/chengzi28/article/details/51086252" target="_blank" rel="noopener">对称加密算法;</a><br>1.2<a href="http://blog.csdn.net/mingyf/article/details/78168106" target="_blank" rel="noopener">DES算法详细设计;</a><br>2、参考代码<br>2.1、<a href="https://github.com/idsyn/Encrypt/blob/master/java/src/com/jm/DESUtil.java" target="_blank" rel="noopener">DESUtils</a><br>2.2、<a href="https://github.com/LiuJunb/Encryp-Demo/blob/master/src/com/xmg/EncryptUtil.java" target="_blank" rel="noopener">Encryp-Demo</a><br>3.对称加密算法<br>3.1 定义</p><p>对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥（mi yue）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。</p><p>3.2 优缺点</p><pre><code>     优点：算法公开、计算量小、加密速度快、加密效率高。     缺点：</code></pre><p>（1）交易双方都使用同样钥匙，安全性得不到保证。</p><p>（2）每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。</p><p>3.3 常用对称加密算法</p><p>基于“对称密钥”的加密算法主要有DES、3DES（TripleDES）、AES、RC2、RC4、RC5和Blowfish等。本文只介绍最常用的对称加密算法DES、3DES（TripleDES）和AES。<br>3.4、DES加密算法的几种模式:<br>3.4.1、<a href="http://blog.csdn.net/chy555chy/article/details/51821938" target="_blank" rel="noopener">参考文章 ;</a></p><pre><code>    AES/CBC/NoPadding (128)     AES/CBC/PKCS5Padding (128)     AES/ECB/NoPadding (128)     AES/ECB/PKCS5Padding (128)     DES/CBC/NoPadding (56)     DES/CBC/PKCS5Padding (56)     DES/ECB/NoPadding (56)     DES/ECB/PKCS5Padding (56)     （DESede实际上是3-DES）     DESede/CBC/NoPadding (168)     DESede/CBC/PKCS5Padding (168)     DESede/ECB/NoPadding (168)     DESede/ECB/PKCS5Padding (168) </code></pre><p>3.4.2:需要留意的坑:</p><blockquote><p>由于加密时会自动填充到8字节(64bit),那么在我们进行字节数组到字串的转化过程中，可以把它填补的不可见字符改变了,所以解密时会导致异常,用base64解决</p></blockquote><p>4、代码:</p><pre><code>package com.jm;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import javax.crypto.spec.IvParameterSpec;import org.apache.commons.codec.binary.Hex;/** * @Createtime 2014年12月5日 14:22:00 * @author Lxz *  */public class DESUtil {    /**     * UTF-8编码     */    public static final String ENCODED_UTF8 = &quot;UTF-8&quot;;    /**     * GBK编码     */    public static final String ENCODED_GBK = &quot;GBK&quot;;    /**     * GB2312编码     */    public static final String ENCODED_GB2312 = &quot;GB2312&quot;;    /**     * ISO8859-1编码     */    public static final String ENCODED_ISO88591 = &quot;ISO8859-1&quot;;    /**     * ASCII编码     */    public static final String ENCODED_ASCII = &quot;ASCII&quot;;    /**     * UNICODE编码     */    public static final String ENCODED_UNICODE = &quot;UNICODE&quot;;    /**     * CBC加密模式     */    public static final String CIPHER_INSTANCE_CBC = &quot;DES/CBC/PKCS5Padding&quot;;    /**     * ECB加密模式     */    public static final String CIPHER_INSTANCE_ECB = &quot;DES/ECB/PKCS5Padding&quot;;    /**     * DES加密     *      * @param HexString     *            字符串（16位16进制字符串）     * @param keyStr     *            密钥16个1     * @throws Exception     */    public static String ENCRYPTMethod(String HexString, String keyStr)            throws Exception {        String jmstr = &quot;&quot;;        try {            byte[] theKey = null;            //从给定的密钥中截取生成真正的密钥来源，保证加密解密算法的唯一性，避免数据的轻易可逆;            String jqstr = getstrByte(keyStr).substring(0,8).toUpperCase();            theKey = jqstr.getBytes(ENCODED_ASCII);            //Ciper[名词]:零、暗号、密码本;            //获取CIPHER_INSTANCE_CBC模式下的密码本;            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE_CBC);            //生成secrecKey;            DESKeySpec desKeySpec = new DESKeySpec(theKey);            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);            SecretKey secretKey = keyFactory.generateSecret(desKeySpec);            IvParameterSpec iv = new IvParameterSpec(theKey);            cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);            byte[] theCph = cipher.doFinal(HexString.getBytes(ENCODED_GB2312));            jmstr = toHexString(theCph).toUpperCase();            jmstr = toHexString(theCph);        } catch (Exception e) {            e.printStackTrace();            return null;        }        return jmstr;    }    public static String getstrByte(String str){        if(null == str){            throw new IllegalArgumentException(            &quot;str is null!&quot;);        }        MessageDigest messageDigest = getMessageDigest();        byte[] digest;        try {            digest = messageDigest.digest(str.getBytes(&quot;ASCII&quot;));        } catch (UnsupportedEncodingException e) {            throw new IllegalStateException(&quot;ASCII not supported!&quot;);        }        return new String(Hex.encodeHex(digest));    }    protected static final MessageDigest getMessageDigest() {        String algorithm = &quot;MD5&quot;;        try {            return MessageDigest.getInstance(algorithm);        } catch (NoSuchAlgorithmException e) {            throw new IllegalArgumentException(&quot;No such algorithm [&quot;                    + algorithm + &quot;]&quot;);        }    }    /**     * DES加密     * @param HexString 字符串（16位16进制字符串）     * @param keyStr 密钥16个1     * @param keyENCODED  Keybyte转换编码     * @param HexStringENCODED 要加密值的转换byte编码     * @param CipherInstanceType 需要加密类型     * @return     * @throws Exception     */    public static String ENCRYPTMethod(String HexString, String keyStr,String keyENCODED,String HexStringENCODED,String CipherInstanceType)            throws Exception {        String jmstr = &quot;&quot;;        try {            byte[] theKey = null;            String jqstr = getstrByte(keyStr).substring(0,8).toUpperCase();            theKey = jqstr.getBytes(keyENCODED);            Cipher cipher = Cipher.getInstance(CipherInstanceType);            DESKeySpec desKeySpec = new DESKeySpec(theKey);            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);            SecretKey secretKey = keyFactory.generateSecret(desKeySpec);            IvParameterSpec iv = new IvParameterSpec(theKey);            cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);            byte[] theCph = cipher.doFinal(HexString.getBytes(HexStringENCODED));            jmstr = toHexString(theCph).toUpperCase();            jmstr = toHexString(theCph);        } catch (Exception e) {            e.printStackTrace();            return null;        }        return jmstr;    }    public static String toHexString(byte b[]) {        StringBuffer hexString = new StringBuffer();        for (int i = 0; i &lt; b.length; i++) {            String plainText = Integer.toHexString(0xff &amp; b[i]);            if (plainText.length() &lt; 2)                plainText = &quot;0&quot; + plainText;            hexString.append(plainText);        }        return hexString.toString();    }    /**     * DES解密方法     * @param message 需要解密字符串     * @param key 解密需要的KEY     * @param keyENCODED  解密KEY转换编码     * @param HexStringENCODED  解密字符串转换编码     * @param CipherInstanceType 解密类型     * @return     * @throws Exception     */    public static String decrypt(String message, String key,String keyENCODED,String HexStringENCODED,String CipherInstanceType) throws Exception {        byte[] bytesrc = convertHexString(message);        byte[] theKey = null;        String jqstr = getstrByte(key).substring(0,                8).toUpperCase();        theKey = jqstr.getBytes(keyENCODED);        Cipher cipher = Cipher.getInstance(CipherInstanceType);        DESKeySpec desKeySpec = new DESKeySpec(theKey);        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);        SecretKey secretKey = keyFactory.generateSecret(desKeySpec);        IvParameterSpec iv = new IvParameterSpec(theKey);        cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);        byte[] retByte = cipher.doFinal(bytesrc);        return new String(retByte,HexStringENCODED);    }    /**     * DES解密方法,解密方法和加密方法应该是对称的;     * @param message     * @param key     * @return     * @throws Exception     */    public static String decrypt(String message, String key) throws Exception {        byte[] bytesrc = convertHexString(message);        byte[] theKey = null;        String jqstr = getstrByte(key).substring(0,                8).toUpperCase();        theKey = jqstr.getBytes(ENCODED_ASCII);        Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE_CBC);        DESKeySpec desKeySpec = new DESKeySpec(theKey);        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);        SecretKey secretKey = keyFactory.generateSecret(desKeySpec);        IvParameterSpec iv = new IvParameterSpec(theKey);        cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);        byte[] retByte = cipher.doFinal(bytesrc);        return new String(retByte,ENCODED_GB2312);    }    public static byte[] convertHexString(String ss) {        byte digest[] = new byte[ss.length() / 2];        for (int i = 0; i &lt; digest.length; i++) {            String byteString = ss.substring(2 * i, 2 * i + 2);            int byteValue = Integer.parseInt(byteString, 16);            digest[i] = (byte) byteValue;        }        return digest;    }    public static void main(String[] args) throws Exception {        String key = &quot;27650099-564A-4869-99B3-363F8129C0CD&quot;;        String value = &quot;张三内部购房百分点办法对你表白&quot;;        String jiami = value;        System.out.println(&quot;加密数据:&quot; + jiami);        String a = ENCRYPTMethod(jiami, key).toUpperCase();        System.out.println(&quot;加密后的数据为:&quot; + a);        String b = decrypt(a, key);        System.out.println(&quot;解密后的数据:&quot; + b);    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CSS中margin边界叠加问题及解决方案【转载】</title>
      <link href="/2018/12/04/lao-bo-ke/css-zhong-margin-bian-jie-die-jia-wen-ti-ji-jie-jue-fang-an-zhuan-zai/"/>
      <url>/2018/12/04/lao-bo-ke/css-zhong-margin-bian-jie-die-jia-wen-ti-ji-jie-jue-fang-an-zhuan-zai/</url>
      
        <content type="html"><![CDATA[<p>边界重叠是指两个或多个盒子(可能相邻也可能嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界。<br>详情看这里：<a href="http://ghmagical.com/article/page/id/amUEblPe63x4" target="_blank" rel="noopener">他已经写的够清楚的了</a>。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>create-reate-app项目中proxy代理的配置</title>
      <link href="/2018/12/04/lao-bo-ke/create-reate-app-xiang-mu-zhong-proxy-dai-li-de-pei-zhi/"/>
      <url>/2018/12/04/lao-bo-ke/create-reate-app-xiang-mu-zhong-proxy-dai-li-de-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>最近在写react项目遇到了前后端交互跨域的问题，好在使用create-react-app这个脚手架【<em>脚手架是什么？联想的建房子的时候搭建的脚手架的功能，构建一个房子的基本骨架，后续的搭建只要在这个架子下进行就好了，所以这里的脚手架的功能和现实中的类似:可以理解为脚手架是一个工具，它可以帮我们构建一个版本号为0的项目版本，这个版本中已经包含了项目开发的必要排至和结构分配，可以大大方便我们的开发</em>】中已经包含了代理功能，<br><strong>我们只要在package.json文件中添加如下配置就好了:</strong><br>   <img src="http://img.blog.csdn.net/20180106170109610?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemoyMDE0MjIxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>代码如下:</p><pre><code>{  &quot;name&quot;: &quot;myproject1&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;private&quot;: true,  &quot;proxy&quot;: &quot;http://localhost:9090&quot;,  &quot;dependencies&quot;: {    &quot;antd&quot;: &quot;^3.0.3&quot;,    &quot;fetch&quot;: &quot;^1.1.0&quot;,    &quot;flux&quot;: &quot;^3.1.3&quot;,    &quot;react&quot;: &quot;^15.4.1&quot;,    &quot;react-addons-css-transition-group&quot;: &quot;^15.6.2&quot;,    &quot;react-dom&quot;: &quot;^15.4.1&quot;,    &quot;react-router&quot;: &quot;^3.0.0&quot;,    &quot;react-scripts&quot;: &quot;1.0.17&quot;  },  &quot;scripts&quot;: {    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  },  &quot;devDependencies&quot;: {    &quot;reqwest&quot;: &quot;^2.0.5&quot;  }}</code></pre><p>调用的代码:</p><pre><code>import React from &#39;react&#39;;import {Row, Col, BackTop} from &#39;antd&#39;;class PCNewsDetails extends React.Component {    constructor() {        super();        this.state = {            newsItem:[        {          &quot;uuid&quot;: &quot;&quot;,          &quot;code&quot;: &quot;&quot;,          &quot;age&quot;: 21,          &quot;className&quot;: &quot;&quot;,          &quot;name&quot;: &quot;&quot;,          &quot;major&quot;: &quot;&quot;,          &quot;createTime&quot;: &quot;&quot;,          &quot;editeTime&quot;:&quot;&quot;        }      ]        };    };    componentDidMount() {    //this.setState({newsItem: json.object.list})      var filter={            object:{              object:{                &#39;uuid&#39;:&#39;11BG13AT4J4M4001&#39;              }            }          };            var myFetchOptions = {                       method: &#39;POST&#39;,                       headers:{                      &#39;Content-Type&#39;:&#39;application/json&#39;                      },                      body:JSON.stringify(filter) };        fetch(&quot;/mongo/student/selectByCondition&quot;, myFetchOptions).then(response =&gt; response.json()).then(json=&gt;this.setState({newsItem: json.object.list}));  };    render() {        return (            &lt;div&gt;                {console.log(this.state.newsItem[0].name)}        网络请求测试.            &lt;/div&gt;        );    };}export default PCNewsDetails;</code></pre><hr><p><strong>浅显的原理:</strong><br>     当浏览器检测到前端页面中发出的请求并非同域请求时，会自动请求proxy配置中的url,从而发送请求。</p><p><strong>需要留意的坑:</strong><br>     注意在更改了配置文件后重启项目，因为热更新并不会更新对项目中配置文件的更改，如果不重启的话，package.json文件中的更改可能无法生效，将会报40错误.</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>cookie、localStorage和sessionStorage 三者之间的区别以及存储、获取、删除等使用方式</title>
      <link href="/2018/12/04/lao-bo-ke/cookie-localstorage-he-sessionstorage-san-zhe-zhi-jian-de-qu-bie-yi-ji-cun-chu-huo-qu-shan-chu-deng-shi-yong-fang-shi/"/>
      <url>/2018/12/04/lao-bo-ke/cookie-localstorage-he-sessionstorage-san-zhe-zhi-jian-de-qu-bie-yi-ji-cun-chu-huo-qu-shan-chu-deng-shi-yong-fang-shi/</url>
      
        <content type="html"><![CDATA[<p><a href="http://obkoro1.com/2017/11/25/cookie%E3%80%81localStorage%E5%92%8CsessionStorage%20%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E3%80%81%E8%8E%B7%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%89%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">cookie、localStorage和sessionStorage 三者之间的区别以及存储、获取、删除等使用方式</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>最近工作中的感悟</title>
      <link href="/2018/12/04/sui-bi/zui-jin-gong-zuo-zhong-de-gan-wu/"/>
      <url>/2018/12/04/sui-bi/zui-jin-gong-zuo-zhong-de-gan-wu/</url>
      
        <content type="html"><![CDATA[<p>最近到一个新的部门，听到一个讨厌的词“甩锅”。我不知道这个词这个部门的人如何理解，反正我是非常反感的。在我的心目中，每个人都应该是有担当的，遇到问题不逞能、不退缩，敢于承担自己的责任。通过这个词，我能预测到在这个部门里职责不清、领导混乱的一些情况，希望情况比我想象的要好。我相信我不会被他们所影响。<br><img src="https://user-images.githubusercontent.com/25767073/49681196-8d948180-fad8-11e8-8341-3f62f46fcee7.gif" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单页面面应用【SPA】和多页面应用【MPA】之间的区别</title>
      <link href="/2018/12/02/lao-bo-ke/dan-ye-mian-mian-ying-yong-spa-he-duo-ye-mian-ying-yong-mpa-zhi-jian-de-qu-bie/"/>
      <url>/2018/12/02/lao-bo-ke/dan-ye-mian-mian-ying-yong-spa-he-duo-ye-mian-ying-yong-mpa-zhi-jian-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>单页面面应用【SPA】和多页面应用【MPA】之间的区别：<br><img src="https://img-blog.csdnimg.cn/20181028110437546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqMjAxNDIyMTM=,size_27,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 老博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/02/hello-world/"/>
      <url>/2018/12/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>软件程序设计原则</title>
      <link href="/2018/11/24/ruan-jian-she-ji/ruan-jian-cheng-xu-she-ji-yuan-ze/"/>
      <url>/2018/11/24/ruan-jian-she-ji/ruan-jian-cheng-xu-she-ji-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据<code>Robert Martin</code>的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、通用设计原则"><a href="#二、通用设计原则" class="headerlink" title="二、通用设计原则"></a>二、通用设计原则</h2><h3 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h3><p>所谓<code>KISS</code>原则，即：<code>Keep It Simple,Stupid</code>，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><blockquote><p>Everything should be made as simple as possible, but not simpler. - Albert Einstein</p></blockquote><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><blockquote><p><strong>我的理解</strong>：保持简单但不能掩盖软件丰富的内涵。即<strong>简约而不简单</strong>！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</p></blockquote><h3 id="2-DRY"><a href="#2-DRY" class="headerlink" title="2. DRY"></a>2. DRY</h3><p>所谓<code>DRY</code>原则，即：<code>Don&#39;t Repeat Yourself</code>，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。<code>DRY</code>并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三</strong>法则。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><blockquote><p><strong>我的理解</strong>：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是<strong>立即行动</strong>去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</p></blockquote><h3 id="3-Maximize-Cohesion，-Minimize-Coupling"><a href="#3-Maximize-Cohesion，-Minimize-Coupling" class="headerlink" title="3. Maximize Cohesion， Minimize Coupling"></a>3. Maximize Cohesion， Minimize Coupling</h3><p>所谓<code>Maximize Cohesion,Minimize Coupling</code>原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低。</strong></p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用<code>public</code>，多用<code>private</code>关键字，</li><li>多用设计模式，比如采用<code>MVC</code>的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-SOC"><a href="#4-SOC" class="headerlink" title="4. SOC"></a>4. SOC</h3><p>所谓<code>SOC</code>原则，即：<strong>关注点分离</strong>（<code>Separation of Concerns</code>）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成。</strong>关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p><code>MVC</code>就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。<code>MVC</code>的基本结构：</p><ul><li><code>Model</code>层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li><code>View</code>是应用程序的显示层，通常是依据模型的数据而建立。</li><li><code>Controller</code>是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（<code>Model</code>层）发送数据。</li></ul><p><code>MVC</code>的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><blockquote><p>好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》)</p></blockquote><h4 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h4><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（<code>log</code>），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联<code>customer</code>类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做<code>CreateNewCustomer()</code>，那么<code>CreateNewCustomer()</code>的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如<code>Spring</code>、<code>Guice</code>等等，这些帮助我们做依赖反转，从而倒置依赖关系。</li></ul><h3 id="5-YAGNI"><a href="#5-YAGNI" class="headerlink" title="5. YAGNI"></a>5. YAGNI</h3><p>所谓<code>YAGNI</code>原则，即：<code>You Ain’t Gonna Need It</code>，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。<code>YAGNI</code>很像<code>KISS</code>原则，因为它也是致力于构建简单的方案。然而，<code>KISS</code>是通过尽可能容易的完成某件事情来实现精简方案；但<code>YAGNI</code>是通过根本就不实现它来达到精简。<code>YAGNI</code>的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><blockquote><p>只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries</p></blockquote><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><blockquote><p><strong>我的理解</strong>：YAGNI 原则，本质上是告诫我们<strong>写代码不要画蛇添足，否则就会弄巧成拙了</strong>。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</p></blockquote><h3 id="6-Boy-Scout-Rule"><a href="#6-Boy-Scout-Rule" class="headerlink" title="6. Boy-Scout Rule"></a>6. Boy-Scout Rule</h3><p><code>Boy-Scout Rule</code>，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(<code>Always leave the campground cleaner than you found it</code>)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要<strong>始终保持代码整洁</strong>。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>关于童子军规则中所提倡的<strong>对代码坏味道的尽早修复</strong>，我也想起来了我们所熟知的“<strong>破窗效应</strong>”和“<strong>讳疾忌医</strong>”的典故：</p><h4 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h4><blockquote><p>如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论</p></blockquote><ul><li>“环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”</li><li>“这个代码以前的其他人也都是这样写的。”</li><li>“反正也不是只有我才这么写代码的。”</li></ul><p>不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“<strong>千里之堤，溃于蚁穴</strong>”、<strong>勿以善小而不为，勿以恶小而为之</strong>。</p><h4 id="讳疾忌医的典故"><a href="#讳疾忌医的典故" class="headerlink" title="讳疾忌医的典故"></a>讳疾忌医的典故</h4><p><img src="http://static.blinkfox.com/20181123-hjjy.png" alt="扁鹊三连"></p><p>《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><blockquote><p>所以，请记住童子军规则对我们的启示：<strong>始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治</strong>。</p></blockquote><h3 id="其他原则："><a href="#其他原则：" class="headerlink" title="其他原则："></a>其他原则：</h3><ul><li><strong>避免过早优化</strong>（<code>Avoid Premature Optimization</code>）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“<strong>过早的优化是一切罪恶之源</strong>。”——Donald Knuth</li><li><strong>最小惊讶原则</strong>(<code>Principle of least astonishment</code>): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li><strong>代码重用原则</strong>（<code>Code Reuse is Good</code>）: 重用代码能提高代码的可读性，缩短开发时间。</li><li><strong>别让我思考</strong>(<code>Don’t Make Me Think</code>): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li><strong>为维护者写代码</strong>(<code>Write Code for the Maintainer</code>): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li><strong>正交原则(Orthogonality)</strong>: 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：<code>CSS</code>)。</li><li><strong>做最简单的事儿就让代码可运行</strong>（<code>Do the simplest thing that could possibly work</code>）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li><strong>隐藏实现细节</strong>（<code>Hide Implementation Details</code>）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li><strong>科里定律</strong>(<code>Curly&#39;s Law</code>): 是为任何特定的代码选择一个明确定义的目标：<strong>只做一件事</strong>。</li><li><strong>墨菲定律</strong>（<code>Murphy&#39;s Law</code>）:根本内容是：<strong>如果事情有变坏的可能，不管这种可能性有多小，它总会发生</strong>。主要内容如下：<ul><li>任何事都没有表面看起来那么简单；</li><li>所有的事都会比你预计的时间长；</li><li>会出错的事总会出错；</li><li>如果你担心某种情况发生，那么它就更有可能发生。</li></ul></li></ul><h2 id="三、面向对象设计原则"><a href="#三、面向对象设计原则" class="headerlink" title="三、面向对象设计原则"></a>三、面向对象设计原则</h2><h3 id="1-SRP"><a href="#1-SRP" class="headerlink" title="1. SRP"></a>1. SRP</h3><p>所谓<code>SRP</code>原则，即：<code>Single Responsibility Principle</code>，<strong>单一职责原则</strong>。原始定义如下：</p><blockquote><p>There should never be more than one reason for a class to change.(<strong>只有一个引起类改变的原因</strong>)</p></blockquote><p>在面向对象编程领域中，单一职责原则（<code>Single responsibility principle</code>）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是<strong>解耦</strong>和<strong>增强内聚性</strong>。</p><h4 id="单一职责的好处："><a href="#单一职责的好处：" class="headerlink" title="单一职责的好处："></a>单一职责的好处：</h4><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义;</li><li>可读性提高，复杂性降低，可维护性提高;</li><li>变更引起的风险降低。</li></ul><h4 id="单一职责原则的注意点："><a href="#单一职责原则的注意点：" class="headerlink" title="单一职责原则的注意点："></a>单一职责原则的注意点：</h4><ul><li>单一职责最难划分的是<strong>职责</strong>。</li><li>单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。</li><li>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。</li></ul><h3 id="2-LSP"><a href="#2-LSP" class="headerlink" title="2. LSP"></a>2. LSP</h3><p>所谓<code>LSP</code>原则，即：<code>Liskov Substitution principle</code>，<strong>里氏替换原则</strong>。原始定义如下：</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>）</p></blockquote><p>更通俗的定义即为：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。里氏替换原则包含了一下4层含义：</p><ul><li>子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了<code>LSP</code>原则。</li><li>子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。</li><li>覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</li><li>覆盖或实现父类的方法时输出结果可以被缩小。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>提高代码的重用性，子类拥有父类的方法和属性；</li><li>提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；</li><li>增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。</li></ul><h3 id="3-ISP"><a href="#3-ISP" class="headerlink" title="3. ISP"></a>3. ISP</h3><p>所谓<code>ISP</code>原则，即：<code>Interface Segregation Principle</code>，<strong>接口隔离原则</strong>。原始定义如下：</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)</p></blockquote><blockquote><p>The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。)</p></blockquote><p>即，<strong>接口尽量细化，接口中的方法尽量少</strong>。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="4-OCP"><a href="#4-OCP" class="headerlink" title="4. OCP"></a>4. OCP</h3><p>所谓<code>OCP</code>原则，即：<code>Open Closed Principle</code>，<strong>开闭原则</strong>。原始定义如下：</p><blockquote><p>software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭)</p></blockquote><p>开闭原则（<code>OCP</code>）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：<strong>对扩展开放，对修改关闭</strong>。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。</p><p>软件系统中包含的各种组件，例如模块（<code>Module</code>）、类（<code>Class</code>）以及功能（<code>Function</code>）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的。</p><p>实现开闭原则的关键就在于“<strong>抽象</strong>”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。</p><p>开闭原则的好处：</p><ul><li>可复用性好;</li><li>可维护性好。</li></ul><h3 id="5-DIP"><a href="#5-DIP" class="headerlink" title="5. DIP"></a>5. DIP</h3><p>所谓<code>DIP</code>原则，即：<code>Dependency Inversion Principle</code>，<strong>依赖倒置原则</strong>。原始定义如下：</p><blockquote><p>High-level modules should not depend on low-level modules. Both should depend on abstractions.(<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象</strong>)</p></blockquote><blockquote><p>Abstractions should not depend on details. Details should depend on abstractions.(<strong>抽象不应该依赖细节；细节应该依赖抽象</strong>)</p></blockquote><p>面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><p>依赖倒置原则主要有以下三层含义：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）；</li><li>抽象不应该依赖细节（具体实现）；  </li><li>细节（具体实现）应该依赖抽象。</li></ul><p>依赖倒置原则基于这样一个事实：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。<strong>依赖倒置原则的核心思想就是面向接口编程</strong>。</p><h3 id="6-LOD-LKP"><a href="#6-LOD-LKP" class="headerlink" title="6. LOD | LKP"></a>6. LOD | LKP</h3><p>所谓<code>LOD</code>原则，即：<code>Law of Demeter</code>，<strong>迪米特法则</strong>，又叫<strong>最少知识原则</strong>（<code>Least Knowledge Principle</code>，简写<code>LKP</code>），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下：</p><blockquote><p>talk only to your immediate friends.(<strong>只与直接的朋友通信</strong>)</p></blockquote><p><strong>迪米特法则的初衷在于降低类之间的耦合</strong>。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。</p><h3 id="7-CRP"><a href="#7-CRP" class="headerlink" title="7. CRP"></a>7. CRP</h3><p>所谓<code>CRP</code>原则，即：<code>Composite Reuse Principle</code>，<strong>组合复用原则</strong>。</p><p>组合复用原则的核心思想是：<strong>尽量使用对象组合，而不是继承来达到复用的目的</strong>。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p><p>继承的缺点主要有以下几点：</p><ul><li>继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。</li><li>基类的实现发生了改变，派生类的实现也不得不改变。</li><li>从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</li></ul><p>由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处：</p><ul><li>新对象存取<code>组成对象</code>的唯一方法是通过<code>组成对象</code>的<code>getter/setter</code>方法。</li><li>组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。</li><li>组合复用所需要的依赖较少。</li><li>每一个新的类可以将焦点集中到一个任务上。</li><li>组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。</li></ul><p>组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。</p><p>组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><p>使用继承时必须满足<code>Is-A</code>的关系是才能使用继承，而组合却是一种<code>Has-A</code>的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把<code>Has-A</code>当成了<code>Is-A</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GitLab CI/CD 介绍和使用</title>
      <link href="/2018/11/22/ruan-jian-gong-ju/devops/gitlab-ci-jie-shao-he-shi-yong/"/>
      <url>/2018/11/22/ruan-jian-gong-ju/devops/gitlab-ci-jie-shao-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="一、持续集成介绍"><a href="#一、持续集成介绍" class="headerlink" title="一、持续集成介绍"></a>一、持续集成介绍</h2><blockquote><p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。—— Martin Fowler</p></blockquote><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><ul><li><strong>持续集成</strong>(<code>Continuous Integration</code>)：<strong>频繁地(一天多次)将代码集成到主干。</strong>让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。“持续集成并不能消除 Bug，而是让它们非常容易发现和改正。”</li><li><strong>持续交付</strong>(<code>Continuous Delivery</code>)：<strong>频繁地将软件的新版本，交付给质量团队或者用户，以供评审。</strong>如果评审通过，代码就进入生产阶段。持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</li><li><strong>持续部署</strong>(<code>continuous Deployment</code>)：<strong>代码通过评审以后，自动部署到生产环境。</strong>是持续部署是持续交付的下一步，持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</li></ul><h3 id="2-持续集成的好处"><a href="#2-持续集成的好处" class="headerlink" title="2 持续集成的好处"></a>2 持续集成的好处</h3><ul><li><strong>自动化构建且状态对每个人可见</strong>。可以使用<code>Maven</code>、<code>Gradle</code>等来实现自动化构建，可以在构建过程中实现自动化测试（前提是有写单元测试用例）。集成服务器在持续集成过程中发现问题可以及时发送警告给相关的干系人。</li><li><strong>解放了重复性劳动。</strong>自动化部署工作可以解放集成、测试、部署等重复性劳动，而机器集成的频率明显比手工高很多。</li><li><strong>更快地发现和修复问题。</strong>持续集成更早的获取变更，更早的进入测试，更早的发现问题，解决问题的成本显著下降。</li><li><strong>更快的交付成果。</strong>更早发现错误减少解决错误所需的工作量。集成服务器在构建环节发现错误可以及时通知开发人员修复。集成服务器在部署环节发现错误可以回退到上一版本，服务器始终有一个可用的版本。</li><li><strong>减少手工的错误。</strong>在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。</li><li><strong>减少了等待时间。</strong>缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间可以出现的等待时机。持续集成，意味着开发、集成、测试、部署也得以持续。</li><li><strong>更高的产品质量。</strong>集成服务器往往提供代码质量检测等功能，对不规范或有错误的地方会进行标致，也可以设置邮件和短信等进行警告。</li></ul><h3 id="3-常用持续集成工具"><a href="#3-常用持续集成工具" class="headerlink" title="3 常用持续集成工具"></a>3 常用持续集成工具</h3><ul><li><a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a></li><li><a href="https://docs.gitlab.com/ee/ci/README.html" target="_blank" rel="noopener">GitLab CI</a></li><li><a href="https://www.jetbrains.com/teamcity/" target="_blank" rel="noopener">TeamCity</a></li><li><a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a></li><li><a href="https://www.atlassian.com/software/bamboo" target="_blank" rel="noopener">Bamboo</a></li><li><a href="https://circleci.com/" target="_blank" rel="noopener">CircleCI</a></li><li>…</li></ul><h2 id="二、Gitlab-持续集成"><a href="#二、Gitlab-持续集成" class="headerlink" title="二、Gitlab 持续集成"></a>二、Gitlab 持续集成</h2><p><img src="https://docs.gitlab.com/ee/ci/img/cicd_pipeline_infograph.png" alt="GitLab CI/CD"></p><h3 id="1-概念介绍"><a href="#1-概念介绍" class="headerlink" title="1 概念介绍"></a>1 概念介绍</h3><h4 id="1-GitLab"><a href="#1-GitLab" class="headerlink" title="(1) GitLab"></a>(1) GitLab</h4><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">GitLab</a> 是一个利用<code>Ruby on Rails</code>开发的开源应用程序，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。</p><h4 id="2-GitLab-CI-CD"><a href="#2-GitLab-CI-CD" class="headerlink" title="(2) GitLab CI/CD"></a>(2) GitLab CI/CD</h4><p><a href="https://docs.gitlab.com/ee/ci/README.html" target="_blank" rel="noopener">GitLab CI/CD</a> 是<code>GitLab Continuous Integration</code>（Gitlab持续集成）的简称。GitLab 自<code>GitLab 8.0</code>开始提供了持续集成的功能，且对所有项目默认开启。只要在项目仓库的根目录添加<code>.gitlab-ci.yml</code>文件，并且配置了Runner（运行器），那么每一次<code>push</code>或者合并请求（<code>Merge Request</code>）都会触发<a href="https://docs.gitlab.com/ce/ci/pipelines.html" target="_blank" rel="noopener">CI Pipeline</a>。</p><h4 id="3-GitLab-Runner"><a href="#3-GitLab-Runner" class="headerlink" title="(3) GitLab Runner"></a>(3) GitLab Runner</h4><p><a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">GitLab Runner</a> <code>GitLab Runner</code>是一个开源项目，可以运行在 GNU / Linux，macOS 和 Windows 操作系统上。每次<code>push</code>的时候 GitLab CI 会根据<code>.gitlab-ci.yml</code>配置文件运行你流水线（<code>Pipeline</code>）中各个阶段的任务（<code>Job</code>），并将结果发送回 GitLab。GitLab Runner 是基于 Gitlab CI 的 API 进行构建的相互隔离的机器（或虚拟机）。GitLab Runner 不需要和 Gitlab 安装在同一台机器上，且考虑到 GitLab Runner 的资源消耗问题和安全问题，也不建议这两者安装在同一台机器上。</p><p>Gitlab Runner 分为三种：</p><ul><li>共享Runner(<code>Shared runners</code>)</li><li>专享Runner(<code>Specific runners</code>)</li><li>分组Runner(<code>Group Runners</code>)</li></ul><h4 id="4-Pipelines"><a href="#4-Pipelines" class="headerlink" title="(4) Pipelines"></a>(4) Pipelines</h4><p><a href="https://docs.gitlab.com/ce/ci/pipelines.html" target="_blank" rel="noopener">Pipelines</a> 中文称为流水线，是分阶段执行的构建任务。如：安装依赖、运行测试、打包、部署开发服务器、部署生产服务器等流程。每一次<code>push</code>或者<code>Merge Request</code>都会触发生成一条新的Pipeline。</p><p>下面是流水线示例图：</p><p><img src="https://docs.gitlab.com/ce/ci/img/pipelines_index.png" alt="Pipeline Status"></p><h4 id="5-Stages"><a href="#5-Stages" class="headerlink" title="(5) Stages"></a>(5) Stages</h4><p><a href="https://docs.gitlab.com/ce/ci/yaml/README.html#stages" target="_blank" rel="noopener">Stages</a> 表示构建阶段，可以理解为上面所说“安装依赖”、“运行测试”等环节的流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点：</p><ul><li>所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始（当然可以在<code>.gitlab-ci.yml</code>文件中配置上一阶段失败时下一阶段也执行）</li><li>只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功</li><li>如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败</li></ul><p>下面是一个流水线内的阶段任务示例图：</p><p><img src="https://docs.gitlab.com/ce/ci/img/pipelines.png" alt="Job Status"></p><h4 id="6-Jobs"><a href="#6-Jobs" class="headerlink" title="(6) Jobs"></a>(6) Jobs</h4><p><a href="https://docs.gitlab.com/ce/ci/pipelines.html#jobs" target="_blank" rel="noopener">Jobs</a> 表示构建的作业（或称之为任务），表示某个 Stage 里面执行的具体任务。我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：</p><ul><li>相同 Stage 中的 Jobs 无执行顺序要求，会并行执行</li><li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功</li><li>如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 也失败（可以在<code>.gitlab-ci.yml</code>文件中配置允许某 Job 可以失败，也算该 Stage 成功）</li></ul><h4 id="7-gitlab-ci-yml"><a href="#7-gitlab-ci-yml" class="headerlink" title="(7) .gitlab-ci.yml"></a>(7) .gitlab-ci.yml</h4><p>GitLab 中默认开启了 Gitlab CI/CD 的支持，且使用<a href="http://yaml.org/" target="_blank" rel="noopener">YAML</a>文件<a href="https://docs.gitlab.com/ee/ci/yaml/README.html#examples" target="_blank" rel="noopener">.gitlab-ci.yml</a>来管理项目构建配置。该文件需要存放于项目仓库的根目录（默认路径，可在 GitLab 中修改），它定义该项目的 CI/CD 如何配置。所以，我们只需要在<code>.gitlab-ci.yml</code>配置文件中定义流水线的各个阶段，以及各个阶段中的若干作业（任务）即可。</p><p>下面是<code>.gitlab-ci.yml</code>文件的一个简单的<code>Hello World</code>示例：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 定义 test 和 package 两个 Stages</span><span class="token key atrule">stages</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> test  <span class="token punctuation">-</span> package<span class="token comment" spellcheck="true"># 定义 package 阶段的一个 job</span><span class="token key atrule">package-job</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> package  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> echo "Hello<span class="token punctuation">,</span> package<span class="token punctuation">-</span>job"    <span class="token punctuation">-</span> echo "I am in package stage"<span class="token comment" spellcheck="true"># 定义 test 阶段的一个 job</span><span class="token key atrule">test-job</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> test  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> echo "Hello<span class="token punctuation">,</span> test<span class="token punctuation">-</span>job"    <span class="token punctuation">-</span> echo "I am in test stage"</code></pre><p>以上配置中，用 stages 关键字来定义 Pipeline 中的各个构建阶段，然后用一些非关键字来定义 jobs。每个 job 中可以可以再用 stage 关键字来指定该 job 对应哪个 stage。job 里面的<code>script</code>关键字是每个 job 中必须要包含的，它表示每个 job 要执行的命令。</p><blockquote><p><strong>注</strong>：猜猜上面例子的运行结果？</p></blockquote><h4 id="8-Badges"><a href="#8-Badges" class="headerlink" title="(8) Badges"></a>(8) Badges</h4><p><a href="https://docs.gitlab.com/ce/ci/pipelines.html#badges" target="_blank" rel="noopener">Badges</a> 即：<strong>徽章</strong>，当 Pipelines 执行过程中或者执行完成时会生成徽章，你可以将这些徽章加入到你的<code>README.md</code>文件中，便于从仓库主页看到最新的构建状态。</p><p>徽章的链接形如下：</p><pre class=" language-bash"><code class="language-bash">http://example.gitlab.com/namespace/project/badges/branch/build.svg </code></pre><p>我们用 GitLab 项目的徽章作为例子，效果如下：</p><p><img src="https://gitlab.com/gitlab-org/gitlab-ce/badges/master/build.svg" alt="Gitlab build badges"> <img src="https://gitlab.com/gitlab-org/gitlab-ce/badges/master/coverage.svg?job=coverage" alt="Gitlab coverage badges"></p><h3 id="2-安装-GitLab-Runner"><a href="#2-安装-GitLab-Runner" class="headerlink" title="2 安装 GitLab Runner"></a>2 安装 GitLab Runner</h3><p><a href="https://docs.gitlab.com/runner/install/index.html" target="_blank" rel="noopener">这里</a>有 GitLab Runner安装相关的资源和文档可供大家参考。以下仅以咱们公司常用的<code>Centos</code>为例来做安装说明。</p><h4 id="1-在线安装"><a href="#1-在线安装" class="headerlink" title="(1) 在线安装"></a>(1) 在线安装</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加官方的repo.</span>curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">bash</span><span class="token comment" spellcheck="true"># yum 安装Gtilab Runner.</span><span class="token function">sudo</span> yum <span class="token function">install</span> gitlab-runner</code></pre><h4 id="2-离线安装"><a href="#2-离线安装" class="headerlink" title="(2) 离线安装"></a>(2) 离线安装</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装Git</span><span class="token function">sudo</span> yum –y <span class="token function">install</span> <span class="token function">git</span><span class="token comment" spellcheck="true"># rpm离线安装事先下载好的 Gitlab Runner rpm包.</span>rpm -ivh gitlab-runner-10.5.0-1.x86_64.rpm</code></pre><blockquote><p><strong>注</strong>：Gitlab Runner 依赖了<code>Git</code>，所以，离线安装 Gitlab Runner 之前得首先安装Git，离线安装包可以从<a href="https://packages.gitlab.com/runner/gitlab-runner" target="_blank" rel="noopener">这里</a>下载。</p></blockquote><h3 id="3-注册-Gitlab-Runner"><a href="#3-注册-Gitlab-Runner" class="headerlink" title="3 注册 Gitlab Runner"></a>3 注册 Gitlab Runner</h3><p>安装了 GitLab Runner 之后,就可以为 GitLab 中的仓库<a href="https://docs.gitlab.com/runner/register/index.html" target="_blank" rel="noopener">注册一个 Runner</a>，注册的交互式命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> gitlab-runner register</code></pre><p>命令的交互式的过程如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 输入注册命令</span><span class="token function">sudo</span> gitlab-runner register<span class="token comment" spellcheck="true"># 输入 GitLab 网站地址</span>Please enter the gitlab-ci coordinator URL <span class="token punctuation">(</span>e.g. https://gitlab.com <span class="token punctuation">)</span>http://gitlab.thunisoft.com/<span class="token comment" spellcheck="true"># 你项目仓库的token，token可以在 Settings -> CI/CD -> Runners settings 中找到.</span>Please enter the gitlab-ci token <span class="token keyword">for</span> this runnerxxx<span class="token comment" spellcheck="true"># 输入描述这个 runner 的名称</span>Please enter the gitlab-ci description <span class="token keyword">for</span> this runner<span class="token punctuation">[</span>hostame<span class="token punctuation">]</span> my-runner<span class="token comment" spellcheck="true"># 输入 runner 的标签</span>Please enter the gitlab-ci tags <span class="token keyword">for</span> this runner <span class="token punctuation">(</span>comma separated<span class="token punctuation">)</span>:my-tag,another-tag<span class="token comment" spellcheck="true"># 输入 runner 的执行器.</span>Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:shell</code></pre><p>以上流程注册成功之后，就可以在你的项目仓库中 <code>Settings</code> -&gt; <code>CI/CD</code> -&gt; <code>Runners settings</code> 看到这个 Runner 了。</p><h3 id="4-Gitlab-Runner-常用命令汇总"><a href="#4-Gitlab-Runner-常用命令汇总" class="headerlink" title="4 Gitlab Runner 常用命令汇总"></a>4 Gitlab Runner 常用命令汇总</h3><p>下面的表格中列出了一些常用的<a href="https://docs.gitlab.com/runner/commands/README.html#gitlab-runner-list" target="_blank" rel="noopener">Gitlab Runner命令</a>，以供参考：</p><table><thead><tr><th>命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>gitlab-runner run</td><td style="text-align:left">运行一个runner服务</td></tr><tr><td>gitlab-runner register</td><td style="text-align:left">注册一个新的runner</td></tr><tr><td>gitlab-runner start</td><td style="text-align:left">启动服务</td></tr><tr><td>gitlab-runner stop</td><td style="text-align:left">关闭服务</td></tr><tr><td>gitlab-runner restart</td><td style="text-align:left">重启服务</td></tr><tr><td>gitlab-runner status</td><td style="text-align:left">查看各个runner的状态</td></tr><tr><td>gitlab-runner unregister</td><td style="text-align:left">注销掉某个runner</td></tr><tr><td>gitlab-runner list</td><td style="text-align:left">显示所有运行着的runner</td></tr><tr><td>gitlab-runner verify</td><td style="text-align:left">检查已注册的运行程序是否可以连接到GitLab，但它不验证GitLab Runner服务是否正在使用运行程序。</td></tr></tbody></table><h2 id="三、一个Web项目-CI-CD-简单示例"><a href="#三、一个Web项目-CI-CD-简单示例" class="headerlink" title="三、一个Web项目 CI/CD 简单示例"></a>三、一个Web项目 CI/CD 简单示例</h2><p>接下来，用一个实际项目来演示 GitLab CI/CD 的配置和使用，其中主要包括：编译测试、项目打包、部署服务、Sonar手动检查、Sonar定时检查五个阶段。</p><p>下面用一个传统的 Java web 项目(这里称之为<code>cidemo</code>)和<code>Tomcat</code>来作为示例，并用来展示常用配置的使用。当我每次<code>push</code>代码或者<code>Merge Request</code>时，都会生成一条流水线，且会自动执行我们上面所说的一些阶段，而Sonar手动检查我们设置为手动操作，且再额外配置Sonar定时检查的任务。</p><blockquote><p><strong>注</strong>：我 Gitlab Runner 是安装在<code>Centos</code>环境中，并使用的<code>shell</code>执行器。</p></blockquote><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 定义stages</span><span class="token key atrule">stages</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> test  <span class="token punctuation">-</span> install  <span class="token punctuation">-</span> run  <span class="token punctuation">-</span> sonar<span class="token comment" spellcheck="true"># 定义安装包的存放位置和Tomcat服务器的地址的变量，便于后续部署使用.</span><span class="token key atrule">variables</span><span class="token punctuation">:</span>  <span class="token key atrule">CIDEMO_PACKAGE_DIR</span><span class="token punctuation">:</span> <span class="token string">'/home/gitlab-runner/packages/cidemo/'</span>  <span class="token key atrule">SERVER_HOME_DIR</span><span class="token punctuation">:</span> <span class="token string">'/home/gitlab-runner/tomcat/cidemo-tomcat/'</span><span class="token comment" spellcheck="true">###################### 构建编译和单元测试的job. #######################</span><span class="token key atrule">编译测试任务</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> test  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> branches  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> mvn clean test<span class="token comment" spellcheck="true">###################### Maven安装得到war包的job. #######################</span><span class="token key atrule">打包任务</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> install  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> develop  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> mvn install    <span class="token punctuation">-</span> echo '准备将最新的war包复制、保存到某个目录里面供后续使用.'    <span class="token punctuation">-</span> rm <span class="token punctuation">-</span>rf $CIDEMO_PACKAGE_DIR/*.war    <span class="token punctuation">-</span> cp target/*.war $CIDEMO_PACKAGE_DIR/cidemo.war<span class="token comment" spellcheck="true">####################### 部署运行war包的job. #######################</span><span class="token key atrule">部署运行任务</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> run  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> develop  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> echo '准备部署和运行war包！(为了方便部署到了Tomcat中运行)'    <span class="token punctuation">-</span> cd $SERVER_HOME_DIR    <span class="token punctuation">-</span> sh bin/shutdown.sh    <span class="token punctuation">-</span> rm <span class="token punctuation">-</span>rf webapps/cidemo.war    <span class="token punctuation">-</span> cp $CIDEMO_PACKAGE_DIR/cidemo.war $SERVER_HOME_DIR/webapps/cidemo.war    <span class="token punctuation">-</span> nohup sh ./bin/startup.sh <span class="token punctuation">></span> logs/cidemo_nohup.log 2<span class="token punctuation">></span><span class="token important">&amp;1</span> &amp;<span class="token comment" spellcheck="true">###################### Sonar手动构建的job. #######################</span><span class="token key atrule">Sonar手动检查</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> sonar  <span class="token key atrule">when</span><span class="token punctuation">:</span> manual  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> develop  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> echo '准备对项目代码做sonar的质量检查！'    <span class="token punctuation">-</span> mvn compile &amp;&amp; mvn sonar<span class="token punctuation">:</span>sonar <span class="token punctuation">-</span>Dsonar.host.url=http<span class="token punctuation">:</span>//172.16.34.102<span class="token punctuation">:</span>9000 <span class="token punctuation">-</span>Dsonar.login=497a0e0e2fc07f64c4b54edc17bb47dfa251ba34<span class="token comment" spellcheck="true">###################### Sonar每晚定时构建的job. #######################</span><span class="token key atrule">Sonar定时检查</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> sonar  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> schedules  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> echo '开始定时对项目代码做sonar的质量检查！'    <span class="token punctuation">-</span> mvn compile &amp;&amp; mvn sonar<span class="token punctuation">:</span>sonar <span class="token punctuation">-</span>Dsonar.host.url=http<span class="token punctuation">:</span>//172.16.34.102<span class="token punctuation">:</span>9000 <span class="token punctuation">-</span>Dsonar.login=497a0e0e2fc07f64c4b54edc17bb47dfa251ba34</code></pre><h2 id="四、Gitlab-CI-CD-yaml-常用配置介绍"><a href="#四、Gitlab-CI-CD-yaml-常用配置介绍" class="headerlink" title="四、Gitlab CI/CD yaml 常用配置介绍"></a>四、Gitlab CI/CD yaml 常用配置介绍</h2><p>开始构建之前<code>.gitlab-ci.yml</code>文件定义了一系列带有约束说明的任务。这些任务都是以任务名开始并且至少要包含script部分，<code>.gitlab-ci.yml</code>允许指定无限量 jobs。每个 jobs 必须有一个唯一的名字，且名字不能是下面列出的保留字段：</p><ul><li><code>image</code></li><li><code>services</code></li><li><code>stages</code></li><li><code>types</code></li><li><code>before_script</code></li><li><code>after_script</code></li><li><code>variables</code></li><li><code>cache</code></li></ul><p>job由一列参数来定义 jobs 的行为：</p><table><thead><tr><th>Keyword</th><th>Required</th><th>Description</th></tr></thead><tbody><tr><td>script</td><td>yes</td><td>Runner执行的命令或脚本</td></tr><tr><td>extends</td><td>no</td><td>定义此作业将继承的配置条目</td></tr><tr><td>image</td><td>no</td><td>所使用的docker镜像，查阅<a href="https://docs.gitlab.com/ce/ci/docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml" target="_blank" rel="noopener">使用docker镜像</a></td></tr><tr><td>services</td><td>no</td><td>所使用的docker服务，查阅<a href="https://docs.gitlab.com/ce/ci/docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml" target="_blank" rel="noopener">使用docker镜像</a></td></tr><tr><td>stage</td><td>no</td><td>定义job stage（默认：<code>test</code>）</td></tr><tr><td>type</td><td>no</td><td><code>stage</code>的别名（已弃用）</td></tr><tr><td>variables</td><td>no</td><td>定义job级别的变量</td></tr><tr><td>only</td><td>no</td><td>定义一列git分支，并为其创建job</td></tr><tr><td>except</td><td>no</td><td>定义一列git分支，不创建job</td></tr><tr><td>tags</td><td>no</td><td>定义一列tags，用来指定选择哪个Runner（同时Runner也要设置tags）</td></tr><tr><td>allow_failure</td><td>no</td><td>允许job失败。失败的job不影响commit状态</td></tr><tr><td>when</td><td>no</td><td>定义何时开始job。可以是<code>on_success</code>，<code>on_failure</code>，<code>always</code>或者<code>manual</code></td></tr><tr><td>dependencies</td><td>no</td><td>定义job依赖关系，这样他们就可以互相传递artifacts</td></tr><tr><td>cache</td><td>no</td><td>定义应在后续运行之间缓存的文件列表</td></tr><tr><td>before_script</td><td>no</td><td>重写一组在作业前执行的命令</td></tr><tr><td>after_script</td><td>no</td><td>重写一组在作业后执行的命令</td></tr><tr><td>environment</td><td>no</td><td>定义此作业完成部署的环境名称</td></tr><tr><td>coverage</td><td>no</td><td>定义给定作业的代码覆盖率设置</td></tr><tr><td>etry</td><td>no</td><td>定义在发生故障时可以自动重试作业的时间和次数</td></tr><tr><td>parallel</td><td>no</td><td>定义应并行运行的作业实例数</td></tr></tbody></table><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><blockquote><p>是在 GitLab 11.3 中引入的。</p></blockquote><p><code>extends</code>定义了一个使用<code>extends</code>的作业将继承的条目名称。它是使用<a href="https://docs.gitlab.com/ee/ci/yaml/README.html#anchors" target="_blank" rel="noopener">YAML锚点</a>的替代方案，并且更加灵活和可读：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">.tests</span><span class="token punctuation">:</span>  <span class="token key atrule">script</span><span class="token punctuation">:</span> rake test  <span class="token key atrule">stage</span><span class="token punctuation">:</span> test  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token key atrule">refs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> branches<span class="token key atrule">rspec</span><span class="token punctuation">:</span>  <span class="token key atrule">extends</span><span class="token punctuation">:</span> .tests  <span class="token key atrule">script</span><span class="token punctuation">:</span> rake rspec  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token key atrule">variables</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> $RSPEC</code></pre><p>在上面的示例中，<code>rspec</code>作业继承自<code>.tests</code>模板作业。 GitLab 将根据键执行反向深度合并。 GitLab将：</p><ul><li>将<code>rspec</code>内容以递归方式合并到<code>.tests</code>中。</li><li>不合并键的值。</li></ul><p>这实际生成的是以下<code>rspec</code>作业：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">rspec</span><span class="token punctuation">:</span>  <span class="token key atrule">script</span><span class="token punctuation">:</span> rake rspec  <span class="token key atrule">stage</span><span class="token punctuation">:</span> test  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token key atrule">refs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> branches    <span class="token key atrule">variables</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> $RSPEC</code></pre><blockquote><p><strong>注</strong>: <code>rake test</code>已被<code>rake rspec</code>脚本覆盖。</p></blockquote><h3 id="image-和-services"><a href="#image-和-services" class="headerlink" title="image 和 services"></a>image 和 services</h3><p>这两个关键字允许使用一个自定义的 Docker 镜像和一系列的服务，并且可以用于整个 job 周期。详细配置文档请查看<a href="https://docs.gitlab.com/ee/ci/docker/README.html" target="_blank" rel="noopener">a separate document</a>。</p><h3 id="before-script-和-after-script"><a href="#before-script-和-after-script" class="headerlink" title="before_script 和 after_script"></a>before_script 和 after_script</h3><p><code>before_script</code>用来定义所有 job 之前运行的命令，<code>after_script</code>用来定义所有 job 之后运行的命令。它们可以是一个数组或者是多行字符串。</p><h3 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h3><p>stages 用来定义可以被 job 调用的 stages。stages 的规范允许有灵活的多级 pipelines。</p><p>stages中的元素顺序决定了对应job的执行顺序：</p><ol><li>相同 stage 的 job 可以平行执行。</li><li>下一个 stage 的 job 会在前一个 stage 的 job 成功后开始执行。</li></ol><p>接下仔细看看这个例子，它包含了3个 stage：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">stages</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> build <span class="token punctuation">-</span> test <span class="token punctuation">-</span> deploy</code></pre><ol><li>首先，所有 build 的 jobs 都是并行执行的。</li><li>所有 build 的 jobs 执行成功后，test 的 jobs 才会开始并行执行。</li><li>所有 test 的 jobs 执行成功，deploy 的 jobs 才会开始并行执行。</li><li>所有的 deploy 的 jobs 执行成功，<code>commit</code>才会标记为<code>success</code>。</li><li>任何一个前置的 jobs 失败了，<code>commit</code>会标记为<code>failed</code>并且下一个 stages 的 jobs 都不会执行。</li></ol><p>这有两个特殊的例子值得一提：</p><ol><li>如果<code>.gitlab-ci.yml</code>中没有定义stages，那么 job’s stages 会默认定义为<code>build</code>，<code>test</code>和<code>deploy</code>。</li><li>如果一个 job 没有指定 stage，那么这个任务会分配到 test stage。</li></ol><h3 id="only-和-except"><a href="#only-和-except" class="headerlink" title="only 和 except"></a>only 和 except</h3><p><code>only</code>和<code>except</code>是两个参数用分支策略来限制 jobs 构建：</p><ul><li><code>only</code>定义哪些分支和标签的git项目将会被job执行。</li><li><code>except</code>定义哪些分支和标签的git项目将不会被job执行。</li></ul><p>下面是refs策略的使用规则：</p><ul><li>only 和 except 可同时使用。如果<code>only</code>和<code>except</code>在一个 job 配置中同时存在，则以 only 为准，跳过 except(从下面示例中得出)。</li><li>only 和 except 可以使用正则表达式。</li><li>only 和 except 允许使用特殊的关键字：<code>branches</code>，<code>tags</code>和<code>triggers</code>。</li><li>only 和 except 允许使用指定仓库地址但不是forks的仓库(查看示例3)。</li></ul><p>在下面这个例子中，job 将只会运行以<code>issue-</code>开始的refs(分支)，然而<code>except</code>中设置将被跳过。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">job</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># use regexp</span>  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> /^issue<span class="token punctuation">-</span>.*$/  <span class="token comment" spellcheck="true"># use special keyword</span>  <span class="token key atrule">except</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> branches</code></pre><p>在下面这个例子中，job 将只会执行有<code>tags</code>的refs，或者通过<code>API</code>触发器明确地请求构建。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">job</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># use special keywords</span>  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> tags    <span class="token punctuation">-</span> triggers</code></pre><p>下面这个例子将会为所有的分支执行job，但 master 分支除外。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">job</span><span class="token punctuation">:</span>  <span class="token key atrule">only</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> branches@gitlab<span class="token punctuation">-</span>org/gitlab<span class="token punctuation">-</span>ce  <span class="token key atrule">except</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> master@gitlab<span class="token punctuation">-</span>org/gitlab<span class="token punctuation">-</span>ce</code></pre><h3 id="variables"><a href="#variables" class="headerlink" title="variables"></a>variables</h3><p>GItLab CI 允许在<code>.gitlab-ci.yml</code>文件中添加变量，并在 job 环境中起作用。因为这些配置是存储在 git 仓库中，所以<strong>最好是存储项目的非敏感配置</strong>，例如：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">variables</span><span class="token punctuation">:</span>  DATABASE_URL<span class="token punctuation">:</span><span class="token string">"postgres://postgres@postgres/my_database"</span></code></pre><p>这些变量可以被后续的命令和脚本使用。</p><p>除了用户自定义的变量外，Runner 也可以定义它自己的变量。<code>CI_COMMIT_REG_NAME</code>就是一个很好的例子，它的值表示用于构建项目的分支或tag名称。除了在<code>.gitlab-ci.yml</code>中设置变量外，还有可以通过 GitLab 的界面上设置私有变量。</p><p>这里有更多关于<a href="https://docs.gitlab.com/ce/ci/variables/README.html" target="_blank" rel="noopener">variables</a>的介绍。</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><h4 id="cache-paths"><a href="#cache-paths" class="headerlink" title="cache: paths"></a>cache: paths</h4><p>使用<code>paths</code>指令选择要缓存的文件或目录。也可以使用通配符。</p><p>如果 cache 定义在 jobs 的作用域之外，那么它就是全局缓存，所有 jobs 都可以使用该缓存。</p><p>缓存<code>binaries</code>和<code>.config</code>中的所有文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">rspec</span><span class="token punctuation">:</span>  <span class="token key atrule">script</span><span class="token punctuation">:</span> test  <span class="token key atrule">cache</span><span class="token punctuation">:</span>    <span class="token key atrule">paths</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> binaries/    <span class="token punctuation">-</span> .config</code></pre><p>缓存<code>git</code>中没有被跟踪的文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">rspec</span><span class="token punctuation">:</span>  <span class="token key atrule">script</span><span class="token punctuation">:</span> test  <span class="token key atrule">cache</span><span class="token punctuation">:</span>    <span class="token key atrule">untracked</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>缓存<code>binaries</code>下没有被<code>git</code>跟踪的文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">rspec</span><span class="token punctuation">:</span>  <span class="token key atrule">script</span><span class="token punctuation">:</span> test  <span class="token key atrule">cache</span><span class="token punctuation">:</span>    <span class="token key atrule">untracked</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">paths</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> binaries/</code></pre><p>job 中优先级高于全局的。下面这个<code>rspec</code> job中将只会缓存<code>binaries/</code>下的文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">cache</span><span class="token punctuation">:</span>  <span class="token key atrule">paths</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> my/files<span class="token key atrule">rspec</span><span class="token punctuation">:</span>  <span class="token key atrule">script</span><span class="token punctuation">:</span> test  <span class="token key atrule">cache</span><span class="token punctuation">:</span>    <span class="token key atrule">key</span><span class="token punctuation">:</span> rspec    <span class="token key atrule">paths</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> binaries/</code></pre><p>注意，缓存是在 jobs 之前进行共享的。如果你不同的 jobs 缓存不同的文件路径，必须设置不同的<code>cache:key</code>，否则缓存内容将被重写。缓存只是尽力而为之，所以别期望缓存会一直存在。</p><h4 id="cache-key"><a href="#cache-key" class="headerlink" title="cache: key"></a>cache: key</h4><p><code>key</code>指令允许我们定义缓存的作用域(亲和性)，可以是所有 jobs 的单个缓存，也可以是每个 job，也可以是每个分支或者是任何你认为合适的地方。它也可以让你很好的调整缓存，允许你设置不同 jobs 的缓存，甚至是不同分支的缓存。</p><p><code>cache:key</code>可以使用任何的<a href="https://docs.gitlab.com/ce/ci/variables/README.html" target="_blank" rel="noopener">预定义变量</a>。</p><p>默认key是默认设置的这个项目缓存，因此默认情况下，从GitLab 9.0开始，每个 pipelines 和 jobs 中可以共享一切。</p><p>配置示例</p><p>缓存每个job：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">cache</span><span class="token punctuation">:</span>  <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"$CI_JOB_NAME"</span>  <span class="token key atrule">untracked</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>缓存每个分支：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">cache</span><span class="token punctuation">:</span>  <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"$CI_COMMIT_REF_NAME"</span>  <span class="token key atrule">untracked</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>缓存每个 job 且每个分支：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">cache</span><span class="token punctuation">:</span>  <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"$CI_JOB_NAME/$CI_COMMIT_REF_NAME"</span>  <span class="token key atrule">untracked</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>缓存每个分支且每个stage：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">cache</span><span class="token punctuation">:</span>  <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"$CI_JOB_STAGE/$CI_COMMIT_REF_NAME"</span>  <span class="token key atrule">untracked</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>如果使用的Windows Batch(windows批处理)来跑脚本需要用%替代$：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">cache</span><span class="token punctuation">:</span>  <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"%CI_JOB_STAGE%/%CI_COMMIT_REF_NAME%"</span>  <span class="token key atrule">untracked</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h3 id="allow-failure"><a href="#allow-failure" class="headerlink" title="allow_failure"></a>allow_failure</h3><p><code>allow_failure</code>可以用于当你想设置一个 job 失败的之后并不影响后续的CI组件的时候。失败的 jobs 不会影响到<code>commit</code>状态。</p><p>当开启了允许 job 失败，所有的 intents 和 purposes 里的 pipeline 都是成功/绿色，但是也会有一个”<code>CI build passed with warnings</code>“信息显示在<code>Merge Request</code>或<code>commit</code>或<code>job page</code>。这被允许失败的作业使用，但是如果失败表示其他地方应采取其他（手动）步骤。</p><p>下面的这个例子中，job1和job2将会并列进行，如果job1失败了，它也不会影响进行中的下一个 stage，因为这里有设置了<code>allow_failure: true</code>。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">job1</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> test  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> execute_script_that_will_fail  <span class="token key atrule">allow_failure</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">job2</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> test  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> execute_script_that_will_succeed<span class="token key atrule">job3</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> deploy  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> deploy_to_staging</code></pre><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p><code>when</code>用于实现在发生故障或尽管失败时运行的作业。when可以设置以下值：</p><ul><li><code>on_success</code> - 只有前面 stages 的所有工作成功时才执行。这是默认值。</li><li><code>on_failure</code> - 当前面 stages 中任意一个jobs失败后执行。</li><li><code>always</code> - 无论前面 stages 中 jobs 状态如何都执行。</li><li><code>manual</code> - 手动执行(GitLab8.10增加)。更多请查看手动操作。</li></ul><h3 id="artifacts"><a href="#artifacts" class="headerlink" title="artifacts"></a>artifacts</h3><p><code>artifacts</code>用于指定成功后应附加到 job 的文件和目录的列表。只能使用项目工作间内的文件或目录路径。在job成功完成后artifacts将会发送到GitLab中，同时也会在 GitLab UI 中提供下载。如果想要在不通的 job 之间传递<code>artifacts</code>，请查阅<a href="https://docs.gitlab.com/ce/ci/yaml/README.html#dependencies" target="_blank" rel="noopener">依赖关系</a>。以下是一些例子：</p><p>发送<code>binaries</code>和<code>.config</code>中的所有文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">artifacts</span><span class="token punctuation">:</span>  <span class="token key atrule">paths</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> binaries/  <span class="token punctuation">-</span> .config</code></pre><p>发送所有没有被Git跟踪的文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">artifacts</span><span class="token punctuation">:</span>  <span class="token key atrule">untracked</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>发送没有被Git跟踪和<code>binaries</code>中的所有文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">artifacts</span><span class="token punctuation">:</span>  <span class="token key atrule">untracked</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">paths</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> binaries/</code></pre><h2 id="五、其他相关内容"><a href="#五、其他相关内容" class="headerlink" title="五、其他相关内容"></a>五、其他相关内容</h2><h3 id="1-API触发器-Triggers"><a href="#1-API触发器-Triggers" class="headerlink" title="1 API触发器 Triggers"></a>1 API触发器 Triggers</h3><p>Triggers 可用于强制使用API调用重建特定分支，<code>tag</code>或<code>commits</code>。API的使用示例可以在<code>Settings</code> -&gt; <code>CI/CD</code> -&gt; <code>Pipeline triggers</code>中找到。</p><p>在<code>triggers</code>文档中<a href="https://docs.gitlab.com/ce/ci/triggers/README.html" target="_blank" rel="noopener">查看更多</a>。</p><h3 id="2-配置定时任务"><a href="#2-配置定时任务" class="headerlink" title="2 配置定时任务"></a>2 配置定时任务</h3><p>GitLab CI 中可以在 GitLab <code>Settings</code> -&gt; <code>CI/CD</code> -&gt; <code>Schedules</code>中配置定时任务，点击<code>New Schedule</code>按钮，可以配置你流水线的定时执行任务，包括：描述信息、定时的Cron表达式、目标分支、变量等信息。</p><p>然后在需要定时执行的作业的<code>only</code>分支写上<code>schedules</code>即可。</p><h3 id="3-校验-gitlab-ci-yml"><a href="#3-校验-gitlab-ci-yml" class="headerlink" title="3 校验 .gitlab-ci.yml"></a>3 校验 .gitlab-ci.yml</h3><p>GitLab CI 的每个实例都有一个名为<code>Lint</code>的嵌入式调试工具。 你可以在 GitLab 实例的<code>-/ci/lint</code>下找到该链接。</p><h3 id="4-配置邮件发送"><a href="#4-配置邮件发送" class="headerlink" title="4 配置邮件发送"></a>4 配置邮件发送</h3><p>如果希望在每次构建完成后（或者在仅构建失败的情况下），想邮件发送给相关开发人员，则可以在 GitLab <code>Settings</code> -&gt; <code>Integrations</code> 中找到<code>Pipelines emails</code>，点击进去就可以配置邮件发送相关的内容了。</p><h3 id="5-GitLab-Pages"><a href="#5-GitLab-Pages" class="headerlink" title="5 GitLab Pages"></a>5 GitLab Pages</h3><p><a href="https://gitlab.com/pages/" target="_blank" rel="noopener">GitLab Pages</a>是用于托管静态文件的服务。而<code>pages</code>是一个特殊的job，用于将静态的内容上传到GitLab，可用于为您的网站提供服务。它有特殊的语法，因此必须满足以下两个要求：</p><ul><li>任何静态内容必须放在<code>public/</code>目录下</li><li>artifacts必须定义在<code>public/</code>目录下</li></ul><p>下面的这个例子是将所有文件从项目根目录移动到<code>public/</code>目录。<code>.public</code>工作流是<code>cp</code>，并且它不会循环复制<code>public/</code>本身。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">pages</span><span class="token punctuation">:</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> deploy  <span class="token key atrule">script</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> mkdir .public  <span class="token punctuation">-</span> cp <span class="token punctuation">-</span>r * .public  <span class="token punctuation">-</span> mv .public public  <span class="token key atrule">artifacts</span><span class="token punctuation">:</span>    <span class="token key atrule">paths</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> public  <span class="token key atrule">only</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> master</code></pre><p>更多内容请查看<a href="https://docs.gitlab.com/ce/user/project/pages/index.html" target="_blank" rel="noopener">GitLab Pages用户文档</a>。</p><h3 id="6-跳过-jobs"><a href="#6-跳过-jobs" class="headerlink" title="6 跳过 jobs"></a>6 跳过 jobs</h3><p>如果你的<code>commit</code>信息中包含<code>[ci skip]</code>或者<code>[skip ci]</code>，不论大小写，那么这个<code>commit</code>将会创建但是 jobs 也会跳过。</p><h3 id="7-runner配置注意点"><a href="#7-runner配置注意点" class="headerlink" title="7 runner配置注意点"></a>7 runner配置注意点</h3><p>有些版本的gitlab在注册的时候不会提示设置“Can run untagged jobs    为 Yes/no”,那么在后面运行流水线job的时候可能会出现“This job is stuck, because you don’t have any active runners that can run this job.”,参考解决方案：<br>    1）<a href="https://www.jianshu.com/p/d91387b9a79b【针对安装有提示的版本】" target="_blank" rel="noopener">https://www.jianshu.com/p/d91387b9a79b【针对安装有提示的版本】</a><br>    2）<a href="https://user-images.githubusercontent.com/25767073/52898304-10436680-3217-11e9-8fdc-f1baa1ec5a35.gif【针对安装无提示的版本】" target="_blank" rel="noopener">https://user-images.githubusercontent.com/25767073/52898304-10436680-3217-11e9-8fdc-f1baa1ec5a35.gif【针对安装无提示的版本】</a></p><hr><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="noopener">官方文档地址</a></li><li><a href="https://segmentfault.com/a/1190000010442764#articleHeader24" target="_blank" rel="noopener">segmentfault yaml配置中文翻译</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitLab CI </tag>
            
            <tag> DevOps </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue 文档风格的 Typora 主题</title>
      <link href="/2018/11/19/ruan-jian-gong-ju/markdown/vue-wen-dang-feng-ge-de-typora-zhu-ti/"/>
      <url>/2018/11/19/ruan-jian-gong-ju/markdown/vue-wen-dang-feng-ge-de-typora-zhu-ti/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/blinkfox/typora-vue-theme" target="_blank" rel="noopener">typora-vue-theme</a> 是 Typora Markdown 文档编辑器中一款类似<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>文档风格的主题。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>是一款支持实时预览的 Markdown 编辑器和阅读器，支持<code>Windows</code>、<code>macOS</code>、<code>Linux</code>三大平台。Typora 作为一款合格的 Markdown 编辑器，支持图片、列表、表格、代码、公式、目录等功能，同时这款软件还支持（一键）动态预览功能，让一切都变得如此干净、纯粹。并且有多种主题模板。<strong>typora-vue-theme 就是参考了 Vue 文档风格而开发的一个 Typora 自定义主题</strong>。</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><ol><li>下载本主题中的<code>vue.css</code>文件和包含字体的<code>vue</code>文件夹；</li><li>打开 Typora，点击“<strong>偏好设置</strong>” =&gt; “<strong>打开主题文件夹</strong>”按钮，将弹出 Typora 的主题文件夹；</li><li>将下载好的<code>vue.css</code>文件和包含字体的<code>vue</code>文件夹放到 Typora 的主题文件夹中；</li><li>关闭并重新打开 Typora，从菜单栏中选择 “<strong>主题</strong>” =&gt; “<strong>Vue</strong>” 即可。</li></ol><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://static.blinkfox.com/typora_vue_theme_screen_01.png" alt="vue主题效果图1"></p><p><img src="http://static.blinkfox.com/typora_vue_theme_screen_02.png" alt="vue主题效果图2"></p><p><img src="http://static.blinkfox.com/typora_vue_theme_screen_03.png" alt="vue主题效果图3"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CPU多级缓存</title>
      <link href="/2018/11/18/ruan-jian-gong-ju/cpu-duo-ji-huan-cun/"/>
      <url>/2018/11/18/ruan-jian-gong-ju/cpu-duo-ji-huan-cun/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是CPU缓存"><a href="#一、什么是CPU缓存" class="headerlink" title="一、什么是CPU缓存"></a>一、什么是CPU缓存</h2><h3 id="1-CPU缓存的来历"><a href="#1-CPU缓存的来历" class="headerlink" title="1. CPU缓存的来历"></a>1. CPU缓存的来历</h3><p>众所周知,CPU是计算机的大脑，它负责执行程序的指令，而内存负责存数据, 包括程序自身的数据。在很多年前，CPU的频率与内存总线的频率在同一层面上。内存的访问速度仅比寄存器慢一些。但是，这一局面在上世纪90年代被打破了。CPU的频率大大提升，但内存总线的频率与内存芯片的性能却没有得到成比例的提升。并不是因为造不出更快的内存，只是因为太贵了。内存如果要达到目前CPU那样的速度，那么它的造价恐怕要贵上好几个数量级。所以，CPU的运算速度要比内存读写速度快很多，这样会使CPU花费很长的时间等待数据的到来或把数据写入到内存中。所以，<strong>为了解决CPU运算速度与内存读写速度不匹配的矛盾</strong>，就出现了CPU缓存。</p><h3 id="2-CPU缓存的概念"><a href="#2-CPU缓存的概念" class="headerlink" title="2. CPU缓存的概念"></a>2. CPU缓存的概念</h3><p><strong>CPU缓存是位于CPU与内存之间的临时数据交换器，它的容量比内存小的多但是交换速度却比内存要快得多。CPU缓存一般直接跟CPU芯片集成或位于主板总线互连的独立芯片上</strong>。</p><p>为了简化与内存之间的通信，高速缓存控制器是针对数据块，而不是字节进行操作的。高速缓存其实就是一组称之为<strong>缓存行</strong>(Cache Line)的固定大小的数据块组成的，典型的一行是<code>64</code>字节。</p><h3 id="3-CPU缓存的意义"><a href="#3-CPU缓存的意义" class="headerlink" title="3. CPU缓存的意义"></a>3. CPU缓存的意义</h3><p>CPU往往需要重复处理相同的数据、重复执行相同的指令，如果这部分数据、指令CPU能在CPU缓存中找到，CPU就不需要从内存或硬盘中再读取数据、指令，从而减少了整机的响应时间。所以，缓存的意义满足以下两种<strong>局部性原理</strong>：</p><ul><li><strong>时间局部性（Temporal Locality）</strong>：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</li><li><strong>空间局部性（Spatial Locality）</strong>：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</li></ul><h2 id="二、CPU的三级缓存"><a href="#二、CPU的三级缓存" class="headerlink" title="二、CPU的三级缓存"></a>二、CPU的三级缓存</h2><h3 id="1-CPU的三级缓存"><a href="#1-CPU的三级缓存" class="headerlink" title="1. CPU的三级缓存"></a>1. CPU的三级缓存</h3><p>随着多核CPU的发展，CPU缓存通常分成了三个级别：<code>L1</code>，<code>L2</code>，<code>L3</code>。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。L1 是最接近CPU的, 它容量最小（例如：<code>32K</code>），速度最快，每个核上都有一个 L1 缓存，L1 缓存每个核上其实有两个 L1 缓存, 一个用于存数据的 L1d Cache（Data Cache），一个用于存指令的 L1i Cache（Instruction Cache）。L2 缓存 更大一些（例如：<code>256K</code>），速度要慢一些, 一般情况下每个核上都有一个独立的L2 缓存; L3 缓存是三级缓存中最大的一级（例如3MB），同时也是最慢的一级, 在同一个CPU插槽之间的核共享一个 L3 缓存。</p><p>下面是三级缓存的处理速度参考表：</p><table><thead><tr><th>从CPU到</th><th>大约需要的CPU周期</th><th>大约需要的时间(单位ns)</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle</td><td></td></tr><tr><td>L1 Cache</td><td>~3-4 cycles</td><td>~0.5-1 ns</td></tr><tr><td>L2 Cache</td><td>~10-20 cycles</td><td>~3-7 ns</td></tr><tr><td>L3 Cache</td><td>~40-45 cycles</td><td>~15 ns</td></tr><tr><td>跨槽传输</td><td></td><td>~20 ns</td></tr><tr><td>内存</td><td>~120-240 cycles</td><td>~60-120ns</td></tr></tbody></table><p>下图是Intel Core i5-4285U的CPU三级缓存示意图：</p><p><img src="http://static.blinkfox.com/javabf_cpu_01.png" alt="CPU三级缓存"></p><p>就像数据库缓存一样，获取数据时首先会在最快的缓存中找数据，如果缓存没有命中(Cache miss) 则往下一级找, 直到三级缓存都找不到时，那只有向内存要数据了。一次次地未命中，代表取数据消耗的时间越长。</p><h3 id="2-带有高速缓存CPU执行计算的流程"><a href="#2-带有高速缓存CPU执行计算的流程" class="headerlink" title="2. 带有高速缓存CPU执行计算的流程"></a>2. 带有高速缓存CPU执行计算的流程</h3><ol><li>程序以及数据被加载到主内存</li><li>指令和数据被加载到CPU的高速缓存</li><li>CPU执行指令，把结果写到高速缓存</li><li>高速缓存中的数据写回主内存</li></ol><p>目前流行的多级缓存结构如下图：</p><p><img src="http://static.blinkfox.com/javabf_cpu_02.png" alt="多级缓存结构"></p><h2 id="三、CPU缓存一致性协议-MESI"><a href="#三、CPU缓存一致性协议-MESI" class="headerlink" title="三、CPU缓存一致性协议(MESI)"></a>三、CPU缓存一致性协议(MESI)</h2><p><strong>MESI</strong>（<code>Modified Exclusive Shared Or Invalid</code>）(也称为<strong>伊利诺斯协议</strong>，是因为该协议由伊利诺斯州立大学提出的）是一种广泛使用的支持写回策略的缓存一致性协议。为了保证多个CPU缓存中共享数据的一致性，定义了缓存行(Cache Line)的四种状态，而CPU对缓存行的四种操作可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候，需要对地址一致的缓存行的状态进行一致性修改，从而保证数据在多个缓存之间保持一致性。</p><h3 id="1-MESI协议中的状态"><a href="#1-MESI协议中的状态" class="headerlink" title="1. MESI协议中的状态"></a>1. MESI协议中的状态</h3><p>CPU中每个缓存行（Caceh line)使用<code>4</code>种状态进行标记，使用<code>2bit</code>来表示:</p><table><thead><tr><th>状态</th><th>描述</th><th>监听任务</th><th>状态转换</th></tr></thead><tbody><tr><td>M 修改 (Modified)</td><td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td><td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td><td>当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。</td></tr><tr><td>E 独享、互斥 (Exclusive)</td><td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td><td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td><td>当CPU修改该缓存行中内容时，该状态可以变成Modified状态</td></tr><tr><td>S 共享 (Shared)</td><td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td><td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td><td>当有一个CPU修改该缓存行时，其它CPU中该缓存行可以被作废（变成无效状态 Invalid）。</td></tr><tr><td>I 无效 (Invalid)</td><td>该Cache line无效。</td><td>无</td><td>无</td></tr></tbody></table><blockquote><p><strong>注意</strong>：<br><strong>对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的</strong>。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p></blockquote><p>从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。</p><p>MESI状态转换图：</p><p><img src="http://static.blinkfox.com/javabf_cpu_03.png" alt="MESI状态转换图"></p><p>下图表示了当一个缓存行(Cache line)的调整的状态的时候，另外一个缓存行(Cache line)需要调整的状态。</p><table><thead><tr><th>状态</th><th>M</th><th>E</th><th>S</th><th><strong>I</strong></th></tr></thead><tbody><tr><td><strong>M</strong></td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td><strong>E</strong></td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td><strong>S</strong></td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td><strong>I</strong></td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>举个示例：</p><blockquote><p>假设cache 1 中有一个变量<code>x = 0</code>的 Cache line 处于S状态(共享)。<br>那么其他拥有x变量的 cache 2、cache 3 等<code>x</code>的 Cache line调整为<code>S</code>状态（共享）或者调整为<code>I</code>状态（无效）。</p></blockquote><h3 id="2-多核缓存协同操作"><a href="#2-多核缓存协同操作" class="headerlink" title="2. 多核缓存协同操作"></a>2. 多核缓存协同操作</h3><h4 id="1-内存变量"><a href="#1-内存变量" class="headerlink" title="(1) 内存变量"></a>(1) 内存变量</h4><p>假设有三个CPU A、B、C，对应三个缓存分别是cache a、b、c。在主内存中定义了<code>x</code>的引用值为0。</p><p><img src="http://static.blinkfox.com/javabf_cpu_04.png" alt="内存变量"></p><h4 id="2-单核读取"><a href="#2-单核读取" class="headerlink" title="(2) 单核读取"></a>(2) 单核读取</h4><p>执行流程是：</p><ul><li>CPU A发出了一条指令，从主内存中读取<code>x</code>。</li><li>从主内存通过 bus 读取到 CPU A 的缓存中（远端读取 Remote read）,这时该 Cache line 修改为 E 状态（独享）。</li></ul><p><img src="http://static.blinkfox.com/javabf_cpu_05.png" alt="单核读取"></p><h4 id="3-双核读取"><a href="#3-双核读取" class="headerlink" title="(3) 双核读取"></a>(3) 双核读取</h4><p>执行流程是：</p><ul><li>CPU A发出了一条指令，从主内存中读取<code>x</code>。</li><li>CPU A从主内存通过bus读取到 cache a 中并将该 Cache line 设置为E状态。</li><li>CPU B发出了一条指令，从主内存中读取<code>x</code>。</li><li>CPU B试图从主内存中读取<code>x</code>时，CPU A检测到了地址冲突。这时CPU A对相关数据做出响应。此时<code>x</code>存储于 cache a 和 cache b 中，<code>x</code>在 chche a 和 cache b 中都被设置为S状态(共享)。</li></ul><p><img src="http://static.blinkfox.com/javabf_cpu_06.png" alt="双核读取"></p><h4 id="4-修改数据"><a href="#4-修改数据" class="headerlink" title="(4) 修改数据"></a>(4) 修改数据</h4><p>执行流程是：</p><ul><li>CPU A 计算完成后发指令需要修改<code>x</code>.</li><li>CPU A 将<code>x</code>设置为M状态（修改）并通知缓存了<code>x</code>的 CPU B, CPU B 将本地 cache b 中的<code>x</code>设置为<code>I</code>状态(无效)</li><li>CPU A 对<code>x</code>进行赋值。</li></ul><p><img src="http://static.blinkfox.com/javabf_cpu_07.png" alt="修改数据"></p><h4 id="5-同步数据"><a href="#5-同步数据" class="headerlink" title="(5) 同步数据"></a>(5) 同步数据</h4><p>那么执行流程是：</p><ul><li>CPU B 发出了要读取x的指令。</li><li>CPU B 通知CPU A,CPU A将修改后的数据同步到主内存时cache a 修改为E（独享）</li><li>CPU A同步CPU B的x,将cache a和同步后cache b中的x设置为S状态（共享）。</li></ul><p><img src="http://static.blinkfox.com/javabf_cpu_08.png" alt="同步数据"></p><h3 id="3-CPU-存储模型简介"><a href="#3-CPU-存储模型简介" class="headerlink" title="3. CPU 存储模型简介"></a>3. CPU 存储模型简介</h3><p>MESI协议为了保证多个 CPU cache 中共享数据的一致性，定义了 Cache line 的四种状态，而 CPU 对 cache 的<code>4</code>种操作可能会产生不一致状态，因此 cache 控制器监听到本地操作和远程操作的时候，需要对地址一致的 Cache line 状态做出一定的修改，从而保证数据在多个cache之间流转的一致性。</p><p>但是，缓存的一致性消息传递是要时间的，这就使得状态切换会有更多的延迟。某些状态的切换需要特殊的处理，可能会阻塞处理器。这些都将会导致各种各样的稳定性和性能问题。比如你需要修改本地缓存中的一条信息，那么你必须将<code>I</code>（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。因为这个等待远远比一个指令的执行时间长的多。所以，为了为了避免这种阻塞导致时间的浪费，引入了存储缓存(<code>Store Buffer</code>)和无效队列(<code>Invalidate Queue</code>)。</p><h4 id="1-存储缓存"><a href="#1-存储缓存" class="headerlink" title="(1) 存储缓存"></a>(1) 存储缓存</h4><p>在没有存储缓存时，CPU 要写入一个量，有以下情况：</p><ul><li>量不在该 CPU 缓存中，则需要发送 Read Invalidate 信号，再等待此信号返回，之后再写入量到缓存中。</li><li>量在该 CPU 缓存中，如果该量的状态是 Exclusive 则直接更改。而如果是 Shared 则需要发送 Invalidate 消息让其它 CPU 感知到这一更改后再更改。</li></ul><p>这些情况中，很有可能会触发该 CPU 与其它 CPU 进行通讯，接着需要等待它们回复。这会浪费大量的时钟周期！为了提高效率，可以使用<strong>异步</strong>的方式去处理：先将值写入到一个 Buffer 中，再发送通讯的信号，等到信号被响应，再应用到 cache 中。并且此 Buffer 能够接受该 CPU 读值。这个 Buffer 就是 Store Buffer。而不须要等待对某个量的赋值指令的完成才继续执行下一条指令，直接去 Store Buffer 中读该量的值，这种优化叫<strong>Store Forwarding</strong>。</p><h4 id="2-无效队列"><a href="#2-无效队列" class="headerlink" title="(2) 无效队列"></a>(2) 无效队列</h4><p>同理，解决了主动发送信号端的效率问题，那么，接受端 CPU 接受到 Invalidate 信号后如果立即采取相应行动(去其它 CPU 同步值)，再返回响应信号，则时钟周期也太长了，此处也可优化。接受端 CPU 接受到信号后不是立即采取行动，而是将 Invalidate 信号插入到一个队列 Queue 中，立即作出响应。等到合适的时机，再去处理这个 Queue 中的 Invalidate 信号，并作相应处理。这个 Queue 就是<strong>Invalidate Queue</strong>。</p><h2 id="四、乱序执行"><a href="#四、乱序执行" class="headerlink" title="四、乱序执行"></a>四、乱序执行</h2><p><strong>乱序执行（<code>out-of-orderexecution</code>）</strong>：是指CPU允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。这样将根据各电路单元的状态和各指令能否提前执行的具体情况分析后，将能提前执行的指令立即发送给相应电路。</p><p>这好比请A、B、C三个名人为晚会题写横幅“春节联欢晚会”六个大字，每人各写两个字。如果这时在一张大纸上按顺序由A写好”春节”后再交给B写”联欢”，然后再由C写”晚会”，那么这样在A写的时候，B和C必须等待，而在B写的时候C仍然要等待而A已经没事了。</p><p>但如果采用三个人分别用三张纸同时写的做法， 那么B和C都不必须等待就可以同时各写各的了，甚至C和B还可以比A先写好也没关系（就象乱序执行），但当他们都写完后就必须重新在横幅上（自然可以由别人做，就象CPU中乱序执行后的重新排列单元）按”春节联欢晚会”的顺序排好才能挂出去。</p><p>所以，CPU 为什么会有乱序执行优化？本质原因是<strong>CPU为了效率</strong>，将长费时的操作“异步”执行，排在后面的指令不等前面的指令执行完毕就开始执行后面的指令。而且允许排在前面的长费时指令后于排在后面的指令执行完。</p><p>CPU 执行乱序主要有以下几种：</p><ul><li><strong>写写乱序(store store)</strong>：<code>a=1;b=2; -&gt; b=2;a=1;</code></li><li><strong>写读乱序(store load)</strong>：<code>a=1;load(b); -&gt; load(b);a=1;</code></li><li><strong>读读乱序(load load)</strong>：<code>load(a);load(b); -&gt; load(b);load(a);</code></li><li><strong>读写乱序(load store)</strong>：<code>load(a);b=2; -&gt; b=2;load(a);</code></li></ul><p>总而言之，<strong>CPU的乱序执行优化指的是处理器为提高运算速度而做出违背代码原有顺序的优化</strong>。</p><hr><p>参考文章：</p><ul><li><a href="http://ifeve.com/from-javaeye-cpu-cache/" target="_blank" rel="noopener">从Java视角理解系统结构（二）CPU缓存</a></li><li><a href="http://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="noopener">CPU缓存一致性协议MESI</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单元测试指南</title>
      <link href="/2018/11/15/hou-duan/java/dan-yuan-ce-shi-zhi-nan/"/>
      <url>/2018/11/15/hou-duan/java/dan-yuan-ce-shi-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、必要性"><a href="#一、必要性" class="headerlink" title="一、必要性"></a>一、必要性</h2><p>在我们公司中要做单元测试，确实比较难，因为公司缺少这种氛围，有也只是局部的，大多数工程师没有这方面的习惯和素养，很多人都是有一定的抵触的心理，经过我私下的了解大概有以下几种原因吧。</p><ul><li>写单元测试太<strong>耗费时间</strong>了，项目要赶进度，编写单元测试会导致不能按时完成开发任务，<strong>导致项目延期</strong>；</li><li>做<em>传统xx管理系统</em>的项目，业务逻辑比较简单，主要就是对业务数据做<strong>增删改查</strong>，单元测试意义和价值不高；</li><li>公司有专门的测试人员，很多问题在集成测试时一定能发现。</li><li>以前项目上从没写过单元测试，没有经验，不知道怎么编写单元测试；</li></ul><p>这其中对单元测试就有些误解了，单元测试有几个比较常见的典型场景：</p><ul><li>开发前写单元测试，通过测试描述需求，即<a href="https://www.ibm.com/developerworks/cn/linux/l-tdd/" target="_blank" rel="noopener">测试驱动开发</a>。</li><li>在开发过程中及时得到反馈，提前规避隐患和发现问题。</li><li>应用于自动化构建或持续集成流程，对每次代码修改做回归测试。</li><li>作为重构的基础，验证重构是否可靠。</li></ul><p>还有最重要的一点：<strong>编写单元测试的难易程度能够直接反应出代码的设计水平，能写出单元测试和写不出单元测试之间体现了编程能力上的巨大的鸿沟。无论是什么样的程序员，坚持编写一段时间的单元测试之后，都会明显感受到代码设计能力的巨大提升</strong>。</p><p>公司开发人员的代码质量往往不是很高，尤其是对代码的拆分和逻辑的抽象还处于懵懂阶段。要对这类代码写单测，即使是工作了3，4年的高级码农也是一个挑战，对新人来说几乎是不可能完成的任务。这也让很多开发人员有了<strong>写单元测试很难</strong>的感觉。所以，<strong>写单元测试的难易程度跟代码的质量关系最大，并且是决定性的</strong>。项目里无论用了哪个测试框架都不能解决代码本身难以测试的问题。</p><p>诚然，写单元测试在开发期间的确是会耗费更多时间的，尤其是要追求很高(超过<code>80%</code>，甚至<code>100%</code>)的代码覆盖率，更是需要耗费大量心血才能达到的。对于一些只需一次交付，很少维护的项目来说，意义和价值确实不是很大。但这本质上是属于为了赚快钱，不负责任的行为了，毕竟谁都无法保障自己写的程序，真的没有丝毫问题。这个问题的出现并不是个人的问题，而是反映了公司项目管理中的问题。当然，个人的原因也存在，就是如何在有限的时间里，提高效率。</p><p>目前公司的大多数项目其实都有着至少两年的维护时间的，很多开发人员都不愿意把自己的时间耗在一个代码很烂、没有单元测试保障且经常变更需求的项目里面。总之，包括我本人在内，都是有项目<strong>维护恐惧症</strong>的，更愿意投入到新项目的开发中。但是新项目里面还是没有单元测试的保障，代码质量逐渐低劣，如此就又形成了一个不断的循环之中。无法挣脱这个循环的人员就只能选择离职了，也许不慎又到了新的漩涡里面。</p><blockquote><p>一个 bug 被隐藏的时间越长，修复这个 bug 的代价就越大。</p></blockquote><p>单元测试能帮助我们在早期就规避、发现和修复很多不易察觉的 bug 和漏洞，而且更能保障后期的需求变动和代码重构时所带来的隐患，减少测试成本和维护成本。所以，在新项目中逐步推广和编写单元测试是有必要的，这将大大提高项目中代码的质量和可靠性，有些老项目中就算了吧，往往维护人员的负面情绪可能会更多，一些新的功能特性倒是可以试试。虽然写好单元测试很难，但<strong>写单元测试的难度其实是小于决定写单元测试的勇气的</strong>。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p><strong>单元测试</strong>：单元测试又称模块测试，属于白盒测试，是最小单位的测试。模块分为程序模块和功能模块。功能模块指实现了一个完整功能的模块（单元），一个完整的程序单元具备输入、加工和输出三个环节。而且每个程序单元都应该有正规的规格说明，使之对其输入、加工和输出的关系做出名明确的描述。</p><p><strong>驱动测试</strong>：驱动被测试模块正常运行起来的实体。通俗的说法就是你负责测试模块/方法是中间的，没有<code>main()</code>方法入口，怎么编译，怎么启动呢？就需要写一个带<code>main()</code>的方法来调用你的模块/方法，这个就是驱动测试。</p><p><strong>测试桩</strong>：代替被测模块调用的子模块的实体，该实体一般为桩函数（stub）。通俗的说法就是你负责测试的模块/方法所调用的模块/方法，所以你需要模仿他们做一个返回值（假的，但符合设计）。</p><p><strong>测试覆盖</strong>：评测测试过程中已经执行的代码的多少。</p><p><strong>测试覆盖率</strong>：代码的覆盖程度，一种度量方式。针对代码的测试覆盖率有很多种度量方式，常见的有以下几种:</p><ul><li>语句覆盖</li><li>判定覆盖</li><li>路径覆盖</li></ul><p>测试覆盖率数据到底有多大意义。主要有以下几个观点：</p><ul><li>路径覆盖率 &gt; 判定覆盖 &gt; 语句覆盖</li><li>覆盖率数据只能代表你测试过哪些代码，不能代表你是否测试好这些代码。</li><li>不要过于相信覆盖率数据，100%的测试覆盖率并不能保证bug的不出现。</li><li>代码覆盖率只是一个最基本的前提，一定要保证，但不是意味着达到指标就代表测试的完成</li><li>测试人员不能盲目追求代码覆盖率，而应该想办法设计更多更好的案例，哪怕多设计出来的案例对覆盖率一点影响也没有。</li></ul><h2 id="三、单元测试工具"><a href="#三、单元测试工具" class="headerlink" title="三、单元测试工具"></a>三、单元测试工具</h2><p>在Java中有非常多的单元测试的工具或框架可供选择，我这里只选择一些常用的、主流的单元测试框架或者工具来作介绍和使用。</p><ul><li><a href="https://junit.org/junit5/" target="_blank" rel="noopener">JUnit</a>：Java中最有名、使用最广泛的单元测试框架</li><li><a href="http://site.mockito.org/" target="_blank" rel="noopener">Mockito</a>：模拟框架，可以让你用干净而简单的API编写测试</li><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html" target="_blank" rel="noopener">Spring Test</a>: 使用 Spring Test 来对Spring相关的项目做单元测试，其中会结合或者集成其他测试框架和工具</li><li><a href="https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-testing" target="_blank" rel="noopener">spring-boot-starter-test</a>: SpringBoot项目中的单元测试</li><li><a href="https://www.eclemma.org/jacoco/trunk/index.html" target="_blank" rel="noopener">JaCoCo</a>: 使用离线和运行时字节码工具来收集代码覆盖率指标的框架。</li></ul><h3 id="1-JUnit4"><a href="#1-JUnit4" class="headerlink" title="1. JUnit4"></a>1. JUnit4</h3><p>JUnit 是使用 Java 语言编写的用于编写和运行可重复的自动化测试的开源测试框架。除了 Junit 之外，<a href="http://testng.org/doc/" target="_blank" rel="noopener">TestNg</a>也是Java中非常受欢迎的单元测试框架。两种框架在功能上看起来非常相似，这里有一篇关于<a href="https://www.mkyong.com/unittest/junit-4-vs-testng-comparison/" target="_blank" rel="noopener">JUnit 4 与 TestNG 的对比</a>，还有一篇较为全面的介绍<a href="https://www.guru99.com/all-about-testng-and-selenium.html" target="_blank" rel="noopener">TestNG的教程</a>，总体来说，TestNG 比 Junit4 功能更强大一些，但是相比 Junit5 而言，TestNG 又落后了一代。开源的轮子滚滚向前，都是一代新的轮子超越一代老的轮子。所以，我们这里就只选择 Junit 来作单元测试框架的介绍了吧。</p><p><img src="http://static.blinkfox.com/junitvstestng.jpg" alt="JUnit4 和 TestNG 的功能比较"></p><p>目前最新版本是 JUnit5.2.0，相比 JUnit4 而言有很大的改变，这里主要讲解 JUnit4 的使用(目前的新老项目中应该使用的更多)，并对 JUnit5 做简要介绍。学习了 Junit4 的主要使用方式之后，大家再去看<a href="http://sjyuan.cc/junit5/user-guide-cn/" target="_blank" rel="noopener">JUnit5 用户指南</a>在将来逐渐使用起来更好些。</p><h4 id="1-简单示例"><a href="#1-简单示例" class="headerlink" title="(1). 简单示例"></a>(1). 简单示例</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Assert<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CalculateTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Calculate calculation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> calculation<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> testSum <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@Test sum(): "</span> <span class="token operator">+</span> sum <span class="token operator">+</span> <span class="token string">" = "</span> <span class="token operator">+</span> testSum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> testSum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-注解"><a href="#2-注解" class="headerlink" title="(2). 注解"></a>(2). 注解</h4><ul><li><code>@Test</code>: 测试方法，在这里还可以测试<strong>期望异常</strong>和<strong>超时时间</strong>。</li><li><code>@Before</code>: 每个测试方法执行之前执行的方法。</li><li><code>@BeforeClass</code>: 一个测试类中所有测试方法执行之前执行的方法，只执行一次，且方法必须为<code>static</code>的。</li><li><code>@After</code>: 每个测试方法执行之后执行的方法。</li><li><code>@AfterClass</code>: 一个测试类中所有测试方法执行之后执行的方法，只执行一次，且方法必须为<code>static</code>的。</li><li><code>@Ignore</code>: 忽略的测试方法。</li><li><code>@RunWith</code>: 指定测试类使用某个运行器。</li><li><code>@Parameters</code>: 参数化测试，指定测试类的测试数据集合。</li><li><code>@FixMethodOrder</code>: 注解在测试类上指定测试方法按一定顺序规则来执行，有三种。</li></ul><p>一个测试类单元测试的执行顺序为：</p><blockquote><p>@BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass</p></blockquote><p>每一个测试方法的执行顺序为：</p><blockquote><p>@Before –&gt; @Test –&gt; @After</p></blockquote><p>综合示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Assert<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationsTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ArrayList testList<span class="token punctuation">;</span>    <span class="token annotation punctuation">@BeforeClass</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">onceExecutedBeforeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@BeforeClass: onceExecutedBeforeAll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">executedBeforeEach</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        testList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@Before: executedBeforeEach"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterClass</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">onceExecutedAfterAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@AfterClass: onceExecutedAfterAll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@After</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">executedAfterEach</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        testList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@After: executedAfterEach"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">EmptyCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assertTrue</span><span class="token punctuation">(</span>testList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@Test: EmptyArrayList"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">OneItemCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        testList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"oneItem"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> testList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@Test: OneItemArrayList"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Ignore</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">executionIgnored</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@Ignore: This execution is ignored"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果我们运行上面的测试，控制台输出将是以下几点：</p><pre class=" language-bash"><code class="language-bash">@BeforeClass: onceExecutedBeforeAll@Before: executedBeforeEach@Test: EmptyArrayList@After: executedAfterEach@Before: executedBeforeEach@Test: OneItemArrayList@After: executedAfterEach@AfterClass: onceExecutedAfterAll</code></pre><h4 id="3-断言"><a href="#3-断言" class="headerlink" title="(3). 断言"></a>(3). 断言</h4><p>断言是编写测试用例的核心实现方式，即期望值是多少，测试的结果是多少，以此来判断测试是否通过。JUnit4.x中的断言核心方法如下：</p><ul><li><code>assertArrayEquals(expecteds, actuals)</code>: 查看两个数组是否相等。</li><li><code>assertEquals(expected, actual)</code>: 查看两个对象是否相等。类似于字符串比较使用的equals()方法。</li><li><code>assertNotEquals(first, second)</code>: 查看两个对象是否不相等。</li><li><code>assertNull(object)</code>: 查看对象是否为空。</li><li><code>assertNotNull(object)</code>: 查看对象是否不为空。</li><li><code>assertSame(expected, actual)</code>: 查看两个对象的引用是否相等。类似于使用“==”比较两个对象。</li><li><code>assertNotSame(unexpected, actual)</code>: 查看两个对象的引用是否不相等。类似于使用“!=”比较两个对象。</li><li><code>assertTrue(condition)</code>: 查看运行结果是否为true。</li><li><code>assertFalse(condition)</code>: 查看运行结果是否为false。</li><li><code>assertThat(actual, matcher)</code>: 查看实际值是否满足指定的条件。</li><li><code>fail()</code>: 让测试失败。</li></ul><h4 id="4-套件测试"><a href="#4-套件测试" class="headerlink" title="(4). 套件测试"></a>(4). 套件测试</h4><p>测试套件意味着捆绑几个单元测试用例并且一起执行他们。在 JUnit 中，<code>@RunWith</code>和<code>@Suite</code>注释用来运行套件测试。简单示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJunit1</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPrint1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Test Junit 1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJunit2</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPrint2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Test Junit 2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>Suite<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Suite</span><span class="token punctuation">.</span><span class="token function">SuiteClasses</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   TestJunit1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>   TestJunit2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JunitTestSuite</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h4 id="5-参数化测试"><a href="#5-参数化测试" class="headerlink" title="(5). 参数化测试"></a>(5). 参数化测试</h4><p>一个测试类也可以被看作是一个参数化测试类。但它要满足下列所有要求：</p><ul><li>该类被注解为<code>@RunWith(Parameterized.class)</code>。</li><li>这个类有一个构造函数，存储测试数据。</li><li>这个类有一个静态方法生成并返回测试数据，并注明<code>@Parameters</code>注解。</li><li>这个类有一个测试，它需要注解<code>@Test</code>到方法。</li></ul><p>简单示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Assert<span class="token punctuation">.</span>assertEquals<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunWith<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runners<span class="token punctuation">.</span>Parameterized<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runners<span class="token punctuation">.</span>Parameterized<span class="token punctuation">.</span>Parameters<span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>Parameterized<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CalculateTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> expected<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> second<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CalculateTest</span><span class="token punctuation">(</span><span class="token keyword">int</span> expectedResult<span class="token punctuation">,</span> <span class="token keyword">int</span> firstNumber<span class="token punctuation">,</span> <span class="token keyword">int</span> secondNumber<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>expected <span class="token operator">=</span> expectedResult<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> firstNumber<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> secondNumber<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Parameters</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Collection <span class="token function">addedNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Calculate add <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Addition with parameters : "</span> <span class="token operator">+</span> first <span class="token operator">+</span> <span class="token string">" and "</span> <span class="token operator">+</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> add<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行<code>CalculateTest</code>测试用例，控制台输出如下：</p><pre class=" language-bash"><code class="language-bash">Addition with parameters <span class="token keyword">:</span> 1 and 2Adding values: 1 + 2Addition with parameters <span class="token keyword">:</span> 2 and 3Adding values: 2 + 3Addition with parameters <span class="token keyword">:</span> 3 and 4Adding values: 3 + 4Addition with parameters <span class="token keyword">:</span> 4 and 5Adding values: 4 + 5</code></pre><h4 id="6-忽略测试"><a href="#6-忽略测试" class="headerlink" title="(6). 忽略测试"></a>(6). 忽略测试</h4><p>有时可能会发生我们的代码还没有准备好的情况，这时测试用例去测试这个方法或代码的时候会造成失败。<code>@Ignore</code>注释会在这种情况时帮助我们。</p><ul><li>一个含有<code>@Ignore</code>注释的测试方法将不会被执行。</li><li>如果一个测试类有<code>@Ignore</code>注释，则它的测试方法将不会执行</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JunitTest3</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token annotation punctuation">@Ignore</span><span class="token punctuation">(</span><span class="token string">"该测试方法还没准备好运行."</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在上面的示例中，JUnit将不会执行<code>testHello()</code>方法。</p><h4 id="7-异常测试"><a href="#7-异常测试" class="headerlink" title="(7). 异常测试"></a>(7). 异常测试</h4><p>它用于测试由方法抛出的异常。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JunitTest4</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span><span class="token punctuation">(</span>expected <span class="token operator">=</span> ArithmeticException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testWithException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在上面的示例中，<code>testWithException()</code>方法将抛出<code>ArithmeticException</code>异常，因为这是一个预期的异常，因此单元测试会通过。</p><h4 id="8-超时测试"><a href="#8-超时测试" class="headerlink" title="(8). 超时测试"></a>(8). 超时测试</h4><p><strong>超时测试</strong>是指，一个单元测试运行时间是否超过指定的毫秒数，测试将终止并标记为失败。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JunitTest5</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span><span class="token punctuation">(</span>timeout <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// do nothing.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在上面的示例中，<code>testTimeout()</code>方法将不会返回，因此JUnit引擎会将其标记为失败，并抛出一个异常。<code>java.lang.Exception:test timed out after 1000 milliseconds</code>。</p><h4 id="9-Hamcrest"><a href="#9-Hamcrest" class="headerlink" title="(9). Hamcrest"></a>(9). Hamcrest</h4><p>在实际开发中，一些基本的断言，如<code>eqaul</code>, <code>null</code>, <code>true</code>它们的可读性并不是很好。而且很多时候我们要比较对象、集合、Map等数据结构。这样我们要么进行大段的字段获取再断言。或者干脆自己编写表达式并断言其结果。JUnit4.4 引入了 Hamcrest 框架，Hamcest 提供了一套匹配符 Matcher，这些匹配符更接近自然语言，可读性高，更加灵活。</p><p><a href="http://hamcrest.org/" target="_blank" rel="noopener">Hamcrest</a>提供了大量被称为“匹配器”的方法。其中每个匹配器都设计用于执行特定的比较操作。Hamcrest 的可扩展性很好，让你能够创建自定义的匹配器。最重要的是，JUnit 也包含了 Hamcrest 的核心，提供了对 Hamcrest 的原生支持，可以直接使用 Hamcrest。当然要使用功能齐备的Hamcrest，还是要引入对它的依赖。</p><p>看个对比例子，前者使用Junit的 断言，后者使用 Hamcrest 的断言。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test_with_junit_assert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> expected <span class="token operator">=</span> <span class="token number">51</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> actual <span class="token operator">=</span> <span class="token number">51</span><span class="token punctuation">;</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"failure - They are not same!"</span><span class="token punctuation">,</span> expected<span class="token punctuation">,</span> actual<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test_with_hamcrest_assertThat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> expected <span class="token operator">=</span> <span class="token number">51</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> actual <span class="token operator">=</span> <span class="token number">51</span><span class="token punctuation">;</span>    <span class="token function">assertThat</span><span class="token punctuation">(</span><span class="token string">"failure - They are not same!"</span><span class="token punctuation">,</span> actual<span class="token punctuation">,</span> <span class="token function">equalTo</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 联合匹配符not和equalTo表示“不等于”</span><span class="token function">assertThat</span><span class="token punctuation">(</span> something<span class="token punctuation">,</span> <span class="token function">not</span><span class="token punctuation">(</span> <span class="token function">equalTo</span><span class="token punctuation">(</span> <span class="token string">"developer"</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 联合匹配符not和containsString表示“不包含子字符串”</span><span class="token function">assertThat</span><span class="token punctuation">(</span> something<span class="token punctuation">,</span> <span class="token function">not</span><span class="token punctuation">(</span> <span class="token function">containsString</span><span class="token punctuation">(</span> <span class="token string">"Works"</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 联合匹配符anyOf和containsString表示“包含任何一个子字符串”</span><span class="token function">assertThat</span><span class="token punctuation">(</span>something<span class="token punctuation">,</span> <span class="token function">anyOf</span><span class="token punctuation">(</span><span class="token function">containsString</span><span class="token punctuation">(</span><span class="token string">"developer"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">containsString</span><span class="token punctuation">(</span><span class="token string">"Works"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用 assertThat 的优点：</p><ol><li>Hamcrest 一条 assertThat 即可以替代其他所有的 assertion 语句，这样可以在所有的单元测试中只使用一个断言方法，使得编写测试用例变得简单，代码风格变得统一，测试代码也更容易维护。</li><li>assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活</li><li>assertThat 不再像 assertEquals 那样，使用比较难懂的“谓宾主”语法模式（如：<code>assertEquals(3, x);</code>），相反，assertThat 使用了类似于“主谓宾”的易读语法模式（如：<code>assertThat(x,is(3));</code>），使得代码更加直观、易读。</li><li>可以将这些 Matcher 匹配符联合起来灵活使用，达到更多目的。</li></ol><p>JUnit 4.4 自带了一些 Hamcrest 的匹配符 Matcher，但是只有有限的几个，在类<code>org.hamcrest.CoreMatchers</code>中定义，要想使用他们，必须导入包 <code>org.hamcrest.CoreMatchers.*</code>。</p><p>Hamcrest 提供了很强大的一些api 供我们进行测试断言。</p><pre class=" language-bash"><code class="language-bash">核心：    anything - 总是匹配,如果你不关心测试下的对象是什么是有用的    describedAs - 添加一个定制的失败表述装饰器    is - 改进可读性装饰器 - 见下 “Sugar”逻辑：    allOf - 如果所有匹配器都匹配才匹配,像Java里的<span class="token operator">&amp;&amp;</span>    anyOf - 如果任何匹配器匹配就匹配,像Java里的<span class="token operator">||</span>    not - 如果包装的匹配器不匹配器时匹配,反之亦然对象：    equalTo - 测试对象相等使用Object.equals方法    hasToString - 测试Object.toString方法    instanceOf, isCompatibleType - 测试类型    notNullValue, nullValue - 测试null    sameInstance - 测试对象实例Beans：    hasProperty - 测试JavaBeans属性集合：    array - 测试一个数组元素test an array’s elements against an array of matchers    hasEntry, hasKey, hasValue - 测试一个Map包含一个实体,键或者值    hasItem, hasItems - 测试一个集合包含一个元素    hasItemInArray - 测试一个数组包含一个元素数字：    closeTo - 测试浮点值接近给定的值    greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo - 测试次序文本：    equalToIgnoringCase - 测试字符串相等忽略大小写    equalToIgnoringWhiteSpace - 测试字符串忽略空白    containsString, endsWith, startsWith - 测试字符串匹配</code></pre><p>以下示例代码列举了大部分 assertThat 的使用例子，供大家学习使用时参考：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//---------------- 字符相关匹配符 ----------------</span><span class="token comment" spellcheck="true">/**equalTo匹配符断言被测的testedValue等于expectedValue，* equalTo可以断言数值之间，字符串之间和对象之间是否相等，相当于Object的equals方法*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedValue<span class="token punctuation">,</span> <span class="token function">equalTo</span><span class="token punctuation">(</span>expectedValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**equalToIgnoringCase匹配符断言被测的字符串testedString*在忽略大小写的情况下等于expectedString*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedString<span class="token punctuation">,</span> <span class="token function">equalToIgnoringCase</span><span class="token punctuation">(</span>expectedString<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**equalToIgnoringWhiteSpace匹配符断言被测的字符串testedString*在忽略头尾的任意个空格的情况下等于expectedString，*注意：字符串中的空格不能被忽略*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedString<span class="token punctuation">,</span> <span class="token function">equalToIgnoringWhiteSpace</span><span class="token punctuation">(</span>expectedString<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**containsString匹配符断言被测的字符串testedString包含子字符串subString**/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedString<span class="token punctuation">,</span> <span class="token function">containsString</span><span class="token punctuation">(</span>subString<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**endsWith匹配符断言被测的字符串testedString以子字符串suffix结尾*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedString<span class="token punctuation">,</span> <span class="token function">endsWith</span><span class="token punctuation">(</span>suffix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**startsWith匹配符断言被测的字符串testedString以子字符串prefix开始*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedString<span class="token punctuation">,</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ---------------- 一般匹配符 ----------------</span><span class="token comment" spellcheck="true">/**nullValue()匹配符断言被测object的值为null*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span><span class="token function">nullValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**notNullValue()匹配符断言被测object的值不为null*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span><span class="token function">notNullValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**is匹配符断言被测的object等于后面给出匹配表达式*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedString<span class="token punctuation">,</span> <span class="token function">is</span><span class="token punctuation">(</span><span class="token function">equalTo</span><span class="token punctuation">(</span>expectedValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**is匹配符简写应用之一，is(equalTo(x))的简写，断言testedValue等于expectedValue*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedValue<span class="token punctuation">,</span> <span class="token function">is</span><span class="token punctuation">(</span>expectedValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**is匹配符简写应用之二，is(instanceOf(SomeClass.class))的简写，*断言testedObject为Cheddar的实例*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedObject<span class="token punctuation">,</span> <span class="token function">is</span><span class="token punctuation">(</span>Cheddar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**not匹配符和is匹配符正好相反，断言被测的object不等于后面给出的object*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedString<span class="token punctuation">,</span> <span class="token function">not</span><span class="token punctuation">(</span>expectedString<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**allOf匹配符断言符合所有条件，相当于“与”（&amp;&amp;）*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedNumber<span class="token punctuation">,</span> <span class="token function">allOf</span><span class="token punctuation">(</span><span class="token function">greaterThan</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lessThan</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**anyOf匹配符断言符合条件之一，相当于“或”（||）*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedNumber<span class="token punctuation">,</span> <span class="token function">anyOf</span><span class="token punctuation">(</span><span class="token function">greaterThan</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lessThan</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ---------------- 数值相关匹配符 ----------------</span><span class="token comment" spellcheck="true">/**closeTo匹配符断言被测的浮点型数testedDouble在20.0¡À0.5范围之内*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedDouble<span class="token punctuation">,</span> <span class="token function">closeTo</span><span class="token punctuation">(</span><span class="token number">20.0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**greaterThan匹配符断言被测的数值testedNumber大于16.0*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedNumber<span class="token punctuation">,</span> <span class="token function">greaterThan</span><span class="token punctuation">(</span><span class="token number">16.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** lessThan匹配符断言被测的数值testedNumber小于16.0*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedNumber<span class="token punctuation">,</span> <span class="token function">lessThan</span> <span class="token punctuation">(</span><span class="token number">16.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** greaterThanOrEqualTo匹配符断言被测的数值testedNumber大于等于16.0*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedNumber<span class="token punctuation">,</span> <span class="token function">greaterThanOrEqualTo</span> <span class="token punctuation">(</span><span class="token number">16.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** lessThanOrEqualTo匹配符断言被测的testedNumber小于等于16.0*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>testedNumber<span class="token punctuation">,</span> <span class="token function">lessThanOrEqualTo</span> <span class="token punctuation">(</span><span class="token number">16.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ---------------- 集合相关匹配符 ----------------</span><span class="token comment" spellcheck="true">/**hasEntry匹配符断言被测的Map对象mapObject含有一个键值为"key"对应元素值为"value"的Entry项*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>mapObject<span class="token punctuation">,</span> <span class="token function">hasEntry</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**hasItem匹配符表明被测的迭代对象iterableObject含有元素element项则测试通过*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>iterableObject<span class="token punctuation">,</span> <span class="token function">hasItem</span> <span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** hasKey匹配符断言被测的Map对象mapObject含有键值“key”*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>mapObject<span class="token punctuation">,</span> <span class="token function">hasKey</span> <span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** hasValue匹配符断言被测的Map对象mapObject含有元素值value*/</span><span class="token function">assertThat</span><span class="token punctuation">(</span>mapObject<span class="token punctuation">,</span> <span class="token function">hasValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-JUnit5"><a href="#2-JUnit5" class="headerlink" title="2. JUnit5"></a>2. JUnit5</h3><h4 id="1-Junit5简介"><a href="#1-Junit5简介" class="headerlink" title="(1). Junit5简介"></a>(1). Junit5简介</h4><p>JUnit 5 跟以前的JUnit版本不一样，它由几大不同的模块组成，这些模块分别来自三个不同的子项目。</p><blockquote><p>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</p></blockquote><p><code>JUnit Platform</code>是在JVM上 启动测试框架 的基础平台。它还定义了<code>TestEngine API</code>，该API可用于开发在平台上运行的测试框架。此外，平台还提供了一个从命令行或者 Gradle 和 Maven 插件来启动的 控制台启动器 ，它就好比一个 基于 JUnit4 的 Runner 在平台上运行任何<code>TestEngine</code>。</p><p><code>JUnit Jupiter</code>是一个组合体，它是由在JUnit 5中编写测试和扩展的新 编程模型 和 扩展模型 组成。另外，<code>Jupiter</code>子项目还提供了一个TestEngine，用于在平台上运行基于Jupiter的测试。</p><p><code>JUnit Vintage</code> 提供了一个<code>TestEngine</code>，用于在平台上运行基于JUnit 3和JUnit 4的测试。</p><p>JUnit 5需要<code>Java 8</code>（或更高）的运行时环境。不过，你仍然可以测试那些由老版本JDK编译的代码。</p><h4 id="2-简单示例"><a href="#2-简单示例" class="headerlink" title="(2). 简单示例"></a>(2). 简单示例</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span>Assertions<span class="token punctuation">.</span>assertEquals<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">FirstJUnit5Tests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">myFirstTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>表面上来看，使用方式和 Junit4 差别不大，但是与 JUnit4 比较起来还是有些不同的。</p><ol><li>导入测试测试注解（<code>@Test</code>）和断言方法（<code>assertEquals</code>）的包路径不同。</li><li>不需要手动把测试和测试方法声明为<code>public</code>了。</li></ol><h4 id="3-注解"><a href="#3-注解" class="headerlink" title="(3). 注解"></a>(3). 注解</h4><p><code>JUnit Jupiter</code>支持使用下面表格中的注解来配置测试和扩展框架。</p><p>所有的核心注解都位于<code>junit-jupiter-api</code>模块的org.junit.jupiter.api`包中。</p><ul><li><code>@Test</code>: 表示该方法是一个测试方法。与JUnit 4的@Test注解不同的是，它没有声明任何属性，因为JUnit Jupiter中的测试扩展是基于它们自己的专用注解来完成的。这样的方法会被继承，除非它们被覆盖。</li><li><code>@ParameterizedTest</code>: 表示该方法是一个参数化测试（可以用不同的参数多次运行试）。这样的方法会被继承，除非它们被覆盖。</li><li><code>@RepeatedTest</code>: 表示该方法是一个重复测试的测试模板(让某个测试方法运行多次)。这样的方法会被继承，除非它们被覆盖。</li><li><code>@TestFactory</code>: 表示该方法是一个动态测试的测试工厂。这样的方法会被继承，除非它们被覆盖。</li><li><code>@TestInstance</code>: 用于配置所标注的测试类的测试实例生命周期。这些注解会被继承。</li><li><code>@TestTemplate</code>: 表示该方法是一个测试模板，它会依据注册的提供者所返回的调用上下文的数量被多次调用。这样的方法会被继承，除非它们被覆盖。</li><li><code>@DisplayName</code>: 为测试类或测试方法声明一个自定义的显示名称(空格、特殊字符甚至是emojis表情)。该注解不能被继承。</li><li><code>@BeforeEach</code>: 表示使用了该注解的方法应该在当前类中每一个使用了<code>@Test</code>、<code>@RepeatedTest</code>、<code>@ParameterizedTest</code>或者<code>@TestFactory</code>注解的方法之前执行；类似于 JUnit4 的<code>@Before</code>。这样的方法会被继承，除非它们被覆盖。</li><li><code>@AfterEach</code>: 表示使用了该注解的方法应该在当前类中每一个使用了<code>@Test</code>、<code>@RepeatedTest</code>、<code>@ParameterizedTest</code>或者<code>@TestFactory</code>注解的方法之后执行；类似于 JUnit4 的<code>@After</code>。这样的方法会被继承，除非它们被覆盖。</li><li><code>@BeforeAll</code>: 表示使用了该注解的方法应该在当前类中所有使用了<code>@Test</code>、<code>@RepeatedTest</code>、<code>@ParameterizedTest</code>或者<code>@TestFactory</code>注解的方法之前执行；类似于 JUnit4 的<code>@BeforeClass</code>。这样的方法会被继承（除非它们被隐藏或覆盖），并且它必须是<code>static</code>方法（除非”per-class” 测试实例生命周期被使用）。</li><li><code>@AfterAll</code>: 表示使用了该注解的方法应该在当前类中所有使用了<code>@Test</code>、<code>@RepeatedTest</code>、<code>@ParameterizedTest</code>或者<code>@TestFactory</code>注解的方法之后执行；类似于 JUnit4 的<code>@AfterClass</code>。这样的方法会被继承（除非它们被隐藏 或覆盖），并且它必须是<code>static</code>方法（除非”per-class” 测试实例生命周期被使用）。</li><li><code>@Nested</code>: 表示使用了该注解的类是一个内嵌、非静态的测试类(让测试编写者能够表示出几组测试用例之间的关系)。<code>@BeforeAll</code>和@<code>AfterAll</code>方法不能直接在<code>@Nested</code>测试类中使用，（除非”per-class”测试实例生命周期被使用）。该注解不能被继承。</li><li><code>@Tag</code>: 用于声明过滤测试的tags，该注解可以用在方法或类上；类似于<code>TesgNG</code>的测试组或 JUnit4 的分类。该注解能被继承，但仅限于类级别，而非方法级别。</li><li><code>@Disable</code>: 用于禁用一个测试类或测试方法；类似于 JUnit4 的<code>@Ignore</code>。该注解不能被继承。</li><li><code>@ExtendWith</code>: 用于注册自定义扩展。该注解不能被继承。</li></ul><blockquote><p><strong>注</strong>：被@Test、@TestTemplate、@RepeatedTest、@BeforeAll、@AfterAll、@BeforeEach 或 @AfterEach 注解标注的方法不可以有返回值。</p></blockquote><p>在 JUnit5 中的一个测试类的基本生命周期示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"Junit5的测试示例类"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">LifecycleTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@BeforeAll</span>    <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"资源初始化方法"</span><span class="token punctuation">)</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">initializeExternalResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Initializing external resources..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@BeforeEach</span>    <span class="token keyword">void</span> <span class="token function">initializeMockObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Initializing mock objects..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">someTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Running some test..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">otherTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assumeTrue</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Running another test..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertNotEquals</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"Why wouldn't these be the same?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token annotation punctuation">@Disabled</span>    <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"该方法先不执行."</span><span class="token punctuation">)</span>    <span class="token keyword">void</span> <span class="token function">disabledTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterEach</span>    <span class="token keyword">void</span> <span class="token function">tearDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Tearing down..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterAll</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">freeExternalResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Freeing external resources..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>由于 JUnit5 中的新特性很多，限于篇幅就简单介绍到这里了，如想详细了解 Junit5 的更多特性，请前往<a href="https://junit.org/junit5/" target="_blank" rel="noopener">Junit5官网</a>和<a href="http://sjyuan.cc/junit5/user-guide-cn/" target="_blank" rel="noopener">JUnit5用户指南中文版</a>去查看。</p><h3 id="3-Mockito"><a href="#3-Mockito" class="headerlink" title="3. Mockito"></a>3. Mockito</h3><p>在软件开发中提及<strong>Mock</strong>，通常理解为模拟对象。为什么需要模拟? 在我们一开始学编程时,我们所写的对象通常都是独立的，并不依赖其他的类，也不会操作别的类。但实际上，软件中是充满依赖关系的，比如我们会基于 service 业务操作类,而 service 类又是基于数据访问类(DAO)的，依次下去，形成复杂的依赖关系。</p><p>单元测试的思路就是我们想在不涉及依赖关系的情况下测试代码。这种测试可以让你无视代码的依赖关系去测试代码的有效性。核心思想就是如果代码按设计正常工作，并且依赖关系也正常，那么他们应该会同时工作正常。</p><p>有些时候，我们代码所需要的依赖可能尚未开发完成，甚至还不存在，那如何让我们的开发进行下去呢？使用mock可以让开发进行下去，mock技术的目的和作用就是<strong>模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试与测试边界以外的对象隔离开</strong>。</p><p>我们可以自己编写自定义的 Mock 对象实现 Mock 技术，但是编写自定义的 Mock 对象需要额外的编码工作，同时也可能引入错误。现在实现 Mock 技术的优秀开源框架有很多，<a href="http://site.mockito.org/" target="_blank" rel="noopener">Mockito</a>就是一个优秀的用于单元测试的 Mock 框架。</p><p>除了Mockito以外，还有一些类似的框架，比如：</p><ul><li><strong><a href="http://easymock.org/" target="_blank" rel="noopener">EasyMock</a></strong>：早期比较流行的 MocK 测试框架。它提供对接口的模拟，能够通过录制、回放、检查三步来完成大体的测试过程，可以验证方法的调用种类、次数、顺序，可以令 Mock 对象返回指定的值或抛出指定异常。</li><li><strong><a href="https://github.com/powermock/powermock" target="_blank" rel="noopener">PowerMock</a></strong>：这个工具是在 EasyMock 和 Mockito 上扩展出来的，目的是为了解决 EasyMock 和 Mockito 不能解决的问题（比如对<code>static</code>, <code>final</code>, <code>private</code>方法均不能 Mock）。其实测试架构设计良好的代码，一般并不需要这些功能，但如果是在已有项目上增加单元测试，老代码有问题且不能改时，就不得不使用这些功能了。</li><li><strong><a href="http://jmockit.org/" target="_blank" rel="noopener">JMockit</a></strong>：JMockit 是一个轻量级的mock框架是用以帮助开发人员编写测试程序的一组工具和API，该项目完全基于<code>Java 5 SE</code>的 java.lang.instrument<code>包开发，内部使用</code>ASM<code>库来修改Java的</code>Bytecode`。</li><li><strong><a href="http://wiremock.org/" target="_blank" rel="noopener">WireMock</a></strong>: 模拟您的API以进行快速、可靠和全面的测试。<code>WireMock</code>是一个基于 HTTP 的 API 的模拟器。有些人可能认为它是一个服务虚拟化工具或模拟服务器。</li></ul><p>Mockito 已经被广泛应用，所以这里重点介绍 Mockito，其他的Mock框架也各自有自己的特点，大家下来自己学习或者分享，参考的<a href="https://github.com/hehonghui/mockito-doc-zh" target="_blank" rel="noopener">Mockito中文文档</a>在这里。</p><p>下面的例子大多都会模拟一个 List，因为大多数人都熟悉它（比如<code>add()</code>，<code>get()</code>，<code>clear()</code>等方法）。实际上，请不要模拟List类，改用真实的实例。</p><h4 id="1-验证行为"><a href="#1-验证行为" class="headerlink" title="(1). 验证行为"></a>(1). 验证行为</h4><p>一旦创建，mock会记录所有交互，你可以验证所有你想要验证的东西。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 静态导入会使代码更简洁</span><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>mockito<span class="token punctuation">.</span>Mockito<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建mock对象</span>List mockedList <span class="token operator">=</span> <span class="token function">mock</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用mock对象</span>mockedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mockedList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 验证行为</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Mock一旦创建，模拟对象将记住你的所有的交互。然后，您可以选择性地验证您感兴趣的任何行为。</p><h4 id="2-如何做一些测试打桩-stubbing"><a href="#2-如何做一些测试打桩-stubbing" class="headerlink" title="(2). 如何做一些测试打桩(stubbing)"></a>(2). 如何做一些测试打桩(stubbing)</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 你可以mock具体的类型,不仅只是接口</span>LinkedList mockedList <span class="token operator">=</span> <span class="token function">mock</span><span class="token punctuation">(</span>LinkedList<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 测试桩</span><span class="token function">when</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">when</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenThrow</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出“first”</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 抛出异常</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 因为get(999) 没有打桩，因此输出null</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 验证get(0)被调用的次数</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>默认情况下，所有的函数都有返回值。mock函数默认返回的是null，一个空的集合或者一个被对象类型包装的内置类型，例如<code>0</code>、<code>false</code>对应的对象类型为<code>Integer</code>、<code>Boolean</code>；</li><li>测试桩函数可以被覆写: 例如常见的测试桩函数可以用于初始化夹具，但是测试函数能够覆写它。请注意，覆写测试桩函数是一种可能存在潜在问题的做法；</li><li>一旦测试桩函数被调用，该函数将会一致返回固定的值；</li><li>上一次调用测试桩函数有时候极为重要，当你调用一个函数很多次时，最后一次调用可能是你所感兴趣的。</li></ul><h4 id="3-参数匹配器-matchers"><a href="#3-参数匹配器-matchers" class="headerlink" title="(3). 参数匹配器(matchers)"></a>(3). 参数匹配器(matchers)</h4><p>Mockito以自然的java风格来验证参数值: 使用<code>equals()</code>函数。有时，当需要额外的灵活性时你可能需要使用参数匹配器，也就是<code>argument matchers</code>:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用内置的anyInt()参数匹配器</span><span class="token function">when</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token function">anyInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span><span class="token string">"element"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用自定义的参数匹配器( 在isValid()函数中返回你自己的匹配器实现 )</span><span class="token function">when</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token function">argThat</span><span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span><span class="token string">"element"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出element</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 你也可以验证参数匹配器</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token function">anyInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>参数匹配器使验证和测试桩变得更灵活。点击<a href="https://static.javadoc.io/org.mockito/mockito-core/2.18.3/org/mockito/Matchers.html" target="_blank" rel="noopener">这里</a>可以查看更多内置的匹配器以及自定义参数匹配器或者hamcrest 匹配器的示例。</p><h4 id="4-验证函数的确切、最少、从未调用次数"><a href="#4-验证函数的确切、最少、从未调用次数" class="headerlink" title="(4). 验证函数的确切、最少、从未调用次数"></a>(4). 验证函数的确切、最少、从未调用次数</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用模拟对象</span>mockedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"once"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mockedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"twice"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mockedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"twice"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mockedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"three times"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mockedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"three times"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mockedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"three times"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 下面的两个验证函数效果一样,因为verify默认验证的就是times(1)</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"once"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">,</span> <span class="token function">times</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"once"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 验证具体的执行次数</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">,</span> <span class="token function">times</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"twice"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">,</span> <span class="token function">times</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"three times"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用never()进行验证,never相当于times(0)</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">,</span> <span class="token function">never</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"never happened"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用atLeast()/atMost()</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">,</span> <span class="token function">atLeastOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"three times"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">,</span> <span class="token function">atLeast</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"five times"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">,</span> <span class="token function">atMost</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"three times"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>verify</code>函数默认验证的是执行了<code>times(1)</code>，也就是某个测试函数是否执行了1次.因此，<code>times(1)</code>通常被省略了。</p><h4 id="5-为返回值为void的函数通过Stub抛出异常"><a href="#5-为返回值为void的函数通过Stub抛出异常" class="headerlink" title="(5). 为返回值为void的函数通过Stub抛出异常"></a>(5). 为返回值为void的函数通过Stub抛出异常</h4><pre class=" language-java"><code class="language-java"><span class="token function">doThrow</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">when</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用这句代码会抛出异常</span>mockedList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当你调用<code>doThrow()</code>, <code>doAnswer()</code>, <code>doNothing()</code>, <code>doReturn()</code> and <code>doCallRealMethod()</code> 这些函数时可以在适当的位置调用<code>when()</code>函数. 当你需要下面这些功能时这是必须的:</p><ul><li>测试void函数</li><li>在受监控的对象上测试函数</li><li>不知一次的测试为同一个函数，在测试过程中改变mock对象的行为。</li></ul><p>但是在调用<code>when()</code>函数时你可以选择是否调用这些上述这些函数。</p><h4 id="6-验证执行执行顺序"><a href="#6-验证执行执行顺序" class="headerlink" title="(6). 验证执行执行顺序"></a>(6). 验证执行执行顺序</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// A. 验证mock一个对象的函数执行顺序</span><span class="token comment" spellcheck="true">// 创建Mock对象</span>List singleMock <span class="token operator">=</span> <span class="token function">mock</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用mock对象</span>singleMock<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"was added first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>singleMock<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"was added second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 为该mock对象创建一个inOrder对象</span>InOrder inOrder <span class="token operator">=</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>singleMock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 确保add函数首先执行的是add("was added first"),然后才是add("was added second")</span>inOrder<span class="token punctuation">.</span><span class="token function">verify</span><span class="token punctuation">(</span>singleMock<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"was added first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>inOrder<span class="token punctuation">.</span><span class="token function">verify</span><span class="token punctuation">(</span>singleMock<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"was added second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// B .验证多个mock对象的函数执行顺序</span>List firstMock <span class="token operator">=</span> <span class="token function">mock</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List secondMock <span class="token operator">=</span> <span class="token function">mock</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用mock对象</span>firstMock<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"was called first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>secondMock<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"was called second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 为这两个Mock对象创建inOrder对象</span>InOrder inOrder <span class="token operator">=</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>firstMock<span class="token punctuation">,</span> secondMock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 验证它们的执行顺序</span>inOrder<span class="token punctuation">.</span><span class="token function">verify</span><span class="token punctuation">(</span>firstMock<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"was called first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>inOrder<span class="token punctuation">.</span><span class="token function">verify</span><span class="token punctuation">(</span>secondMock<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"was called second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>验证执行顺序是非常灵活的。你不需要一个一个的验证所有交互,只需要验证你感兴趣的对象即可。另外，你可以仅通过那些需要验证顺序的mock对象来创建<code>InOrder</code>对象。</p><h4 id="7-确保交互-interaction-操作不会执行在mock对象上"><a href="#7-确保交互-interaction-操作不会执行在mock对象上" class="headerlink" title="(7). 确保交互(interaction)操作不会执行在mock对象上"></a>(7). 确保交互(interaction)操作不会执行在mock对象上</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用Mock对象</span>mockOne<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 普通验证</span><span class="token function">verify</span><span class="token punctuation">(</span>mockOne<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 验证某个交互是否从未被执行</span><span class="token function">verify</span><span class="token punctuation">(</span>mockOne<span class="token punctuation">,</span> <span class="token function">never</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 验证mock对象没有交互过</span><span class="token function">verifyZeroInteractions</span><span class="token punctuation">(</span>mockTwo<span class="token punctuation">,</span> mockThree<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="8-查找冗余的调用"><a href="#8-查找冗余的调用" class="headerlink" title="(8). 查找冗余的调用"></a>(8). 查找冗余的调用</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用mock对象</span>mockedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mockedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">verify</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 下面的验证将会失败</span><span class="token function">verifyNoMoreInteractions</span><span class="token punctuation">(</span>mockedList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>一些用户可能会在频繁地使用<code>verifyNoMoreInteractions()</code>，甚至在每个测试函数中都用。但是<code>verifyNoMoreInteractions()</code>并不建议在每个测试函数中都使用。<code>verifyNoMoreInteractions()</code>在交互测试套件中只是一个便利的验证，它的作用是当你需要验证是否存在冗余调用时。滥用它将导致测试代码的可维护性降低。你可以阅读这篇文档来了解更多相关信息。</p><h4 id="9-简化mock对象的创建"><a href="#9-简化mock对象的创建" class="headerlink" title="(9). 简化mock对象的创建"></a>(9). 简化mock对象的创建</h4><ul><li>最小化重复的创建代码;</li><li>使测试类的代码可读性更高;</li><li>使验证错误更易于阅读，因为字段名可用于标识mock对象;</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArticleManagerTest</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Mock</span> <span class="token keyword">private</span> ArticleCalculator calculator<span class="token punctuation">;</span>   <span class="token annotation punctuation">@Mock</span> <span class="token keyword">private</span> ArticleDatabase database<span class="token punctuation">;</span>   <span class="token annotation punctuation">@Mock</span> <span class="token keyword">private</span> UserProvider userProvider<span class="token punctuation">;</span>   <span class="token keyword">private</span> ArticleManager manager<span class="token punctuation">;</span></code></pre><p>注意！下面这句代码需要在运行测试函数之前被调用,一般放到测试类的基类或者test runner中:</p><pre class=" language-java"><code class="language-java">MockitoAnnotations<span class="token punctuation">.</span><span class="token function">initMocks</span><span class="token punctuation">(</span>testClass<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>关于mock注解的更多信息可以阅读<a href="https://static.javadoc.io/org.mockito/mockito-core/2.18.3/org/mockito/MockitoAnnotations.html" target="_blank" rel="noopener">MockitoAnnotations文档</a>。</p><h4 id="10-为连续的调用做测试打桩-stub"><a href="#10-为连续的调用做测试打桩-stub" class="headerlink" title="(10). 为连续的调用做测试打桩 (stub)"></a>(10). 为连续的调用做测试打桩 (stub)</h4><p>有时我们需要为同一个函数调用的不同的返回值或异常做测试桩。</p><pre class=" language-java"><code class="language-java"><span class="token function">when</span><span class="token punctuation">(</span>mock<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token string">"some arg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">thenThrow</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 第一次调用 : 抛出运行时异常</span>mock<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token string">"some arg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 第二次调用 : 输出"foo"</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mock<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token string">"some arg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 后续调用 : 也是输出"foo"</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mock<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token string">"some arg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>另外，连续调用的另一种更简短的版本 :</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 第一次调用时返回"one",第二次返回"two",第三次返回"three"</span><span class="token function">when</span><span class="token punctuation">(</span>mock<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token string">"some arg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="11-为回调做测试桩"><a href="#11-为回调做测试桩" class="headerlink" title="(11). 为回调做测试桩"></a>(11). 为回调做测试桩</h4><pre class=" language-java"><code class="language-java"><span class="token function">when</span><span class="token punctuation">(</span>mock<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token function">anyString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAnswer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Answer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     Object <span class="token function">answer</span><span class="token punctuation">(</span>InvocationOnMock invocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>         Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         Object mock <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getMock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token string">"called with arguments: "</span> <span class="token operator">+</span> args<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出 : "called with arguments: foo"</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mock<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="12-监控真实对象"><a href="#12-监控真实对象" class="headerlink" title="(12). 监控真实对象"></a>(12). 监控真实对象</h4><p>你可以为真实对象创建一个监控(spy)对象。当你使用这个<code>spy</code>对象时真实的对象也会也调用，除非它的函数被stub了。<strong>尽量少使用spy对象</strong>，使用时也需要小心形式，例如spy对象可以用来处理遗留代码。</p><pre class=" language-java"><code class="language-java">List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List spy <span class="token operator">=</span> <span class="token function">spy</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 你可以为某些函数打桩</span><span class="token function">when</span><span class="token punctuation">(</span>spy<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 通过spy对象调用真实对象的函数</span>spy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>spy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出第一个元素</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>spy<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 因为size()函数被打桩了,因此这里返回的是100</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>spy<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 交互验证</span><span class="token function">verify</span><span class="token punctuation">(</span>spy<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">verify</span><span class="token punctuation">(</span>spy<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Mockito 并不会为真实对象代理函数调用，实际上它会拷贝真实对象。因此如果你保留了真实对象并且与之交互，不要期望从监控对象得到正确的结果。当你在监控对象上调用一个没有被stub的函数时并不会调用真实对象的对应函数，你不会在真实对象上看到任何效果。</p><p>因此结论就是: 当你在监控一个真实对象时，你想在stub这个真实对象的函数，那么就是在自找麻烦。或者你根本不应该验证这些函数。</p><h4 id="13-重置mocks对象"><a href="#13-重置mocks对象" class="headerlink" title="(13). 重置mocks对象"></a>(13). 重置mocks对象</h4><p>聪明的 Mockito 使用者很少会用到这个特性，因为他们知道这是出现糟糕测试单元的信号。通常情况下你不会需要重设你的测试单元，只需要为每一个测试方法重新创建一个测试单元就可以了。</p><p>如果你真的想通过<code>reset()</code>方法满足某些需求的话，请考虑实现简单，小而且专注于测试方法而不是冗长，精确的测试。首先可能出现的代码异味就是测试方法中间那的<code>reset()</code>方法。这可能意味着你已经过度测试了。</p><p>添加 reset() 方法的唯一原因就是让它能与容器注入的测试单元协作。</p><pre class=" language-java"><code class="language-java">List mock <span class="token operator">=</span> <span class="token function">mock</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">when</span><span class="token punctuation">(</span>mock<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mock<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">reset</span><span class="token punctuation">(</span>mock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//at this point the mock forgot any interactions &amp; stubbing</span></code></pre><h4 id="14-更多的注解"><a href="#14-更多的注解" class="headerlink" title="(14). 更多的注解"></a>(14). 更多的注解</h4><ul><li><code>@Captor</code>: 创建<code>ArgumentCaptor</code>。</li><li><code>@Spy</code>: 可以代替<code>spy(Object)</code>。</li><li><code>@InjectMocks</code>: 如果此注解声明的变量需要用到mock对象，mockito会自动注入mock或spy成员。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//可以这样写</span><span class="token annotation punctuation">@Spy</span>BeerDrinker drinker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeerDrinker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//也可以这样写，mockito会自动实例化drinker.</span><span class="token annotation punctuation">@Spy</span>BeerDrinker drinker<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//会自动实例化LocalPub</span><span class="token annotation punctuation">@InjectMocks</span>LocalPub pub<span class="token punctuation">;</span></code></pre><h4 id="15-BDD-风格的验证-Since-1-10-0"><a href="#15-BDD-风格的验证-Since-1-10-0" class="headerlink" title="(15). BDD 风格的验证(Since 1.10.0)"></a>(15). BDD 风格的验证(Since 1.10.0)</h4><p>开启<code>Behavior Driven Development</code>(BDD，即行为驱动开发)风格的验证可以通过<code>BBD</code>的关键词<code>then</code>开始验证。</p><pre class=" language-java"><code class="language-java"><span class="token function">given</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">willReturn</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// when</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">should</span><span class="token punctuation">(</span><span class="token function">times</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ride</span><span class="token punctuation">(</span>bike<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上就是 Mockito 的主要使用方式，关于更详细的介绍可参考<a href="https://static.javadoc.io/org.mockito/mockito-core/2.18.3/org/mockito/Mockito.html" target="_blank" rel="noopener">Mockito官方文档</a>和<a href="https://github.com/hehonghui/mockito-doc-zh" target="_blank" rel="noopener">Mockito中文文档</a>。</p><h3 id="4-Spring-Test"><a href="#4-Spring-Test" class="headerlink" title="4. Spring Test"></a>4. Spring Test</h3><p>目前几乎大多数 Java web 项目都是有基于 Spring 来开发的。通过 Spring 进行 bean 管理后，仅仅通过 JUnit 来做测试会有各种麻烦，比如：Spring容器初始化问题、使用硬编码方式手工获取Bean、不方便对数据操作的正确性做检查等。这时我们就可以通过 Spring 全家桶中的另一位成员<strong>spring-test</strong>来帮助我们在 Spring 工程中做单元测试了。以下通过简单的示例来演示其使用。</p><h4 id="1-加入依赖包"><a href="#1-加入依赖包" class="headerlink" title="(1). 加入依赖包"></a>(1). 加入依赖包</h4><p>通过Maven加入<code>JUnit</code>、<code>spring-test</code>的Jar包(最好其他Spring包版本一致)。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>xxxx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h4 id="2-创建测试类"><a href="#2-创建测试类" class="headerlink" title="(2). 创建测试类"></a>(2). 创建测试类</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringJUnit4ClassRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ContextConfiguration</span><span class="token punctuation">(</span><span class="token string">"/application-context-test.xml"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDaoTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 自动注入baseDao,默认按名称. */</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> IBaseDao baseDao<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token annotation punctuation">@Transactional</span>    <span class="token annotation punctuation">@Rollback</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String sql <span class="token operator">=</span> <span class="token string">"INSERT INTO t_user(c_name, c_password) values(?, ?)"</span><span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        baseDao<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>sql <span class="token punctuation">,</span> objs<span class="token punctuation">)</span><span class="token punctuation">;</span>        String sql2 <span class="token operator">=</span> <span class="token string">"SELECT * FROM t_user WHERE c_name = ? and c_password = ?"</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">>></span> list <span class="token operator">=</span> baseDao<span class="token punctuation">.</span><span class="token function">queryForList</span><span class="token punctuation">(</span>sql1<span class="token punctuation">,</span> objs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertTrue</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>使用Spring Test 可以使用<code>@Autowired</code>自动注入相关的bean信息，而不需要自己手动通过<code>getBean</code>去获取相应的bean信息。</li><li>使用Spring Test 测试，可以<code>@Transaction</code>注解，表示该方法使用spring的事务，在单元测试中，执行完毕后默认会回滚。</li><li>使用<code>@Rollback</code>注解，标明使用完此方法后事务回滚，可以<code>@Rollback(false)</code>这个注解来使对数据库操作的测试结果不回滚。</li></ul><h4 id="3-对-Spring-MVC-的测试"><a href="#3-对-Spring-MVC-的测试" class="headerlink" title="(3). 对 Spring MVC 的测试"></a>(3). 对 Spring MVC 的测试</h4><p>为了测试 web 项目，需要一些 Servlet 相关的模拟对象，比如：<code>MockMVC</code>/<code>MockHttpServletRequest</code>/<code>MockHttpServletResponse</code>/<code>MockHttpSession</code>。使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>request<span class="token punctuation">.</span>MockMvcRequestBuilders<span class="token punctuation">.</span>get<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>result<span class="token punctuation">.</span>MockMvcResultMatchers<span class="token punctuation">.</span>content<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>result<span class="token punctuation">.</span>MockMvcResultMatchers<span class="token punctuation">.</span>forwardedUrl<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>result<span class="token punctuation">.</span>MockMvcResultMatchers<span class="token punctuation">.</span>model<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>result<span class="token punctuation">.</span>MockMvcResultMatchers<span class="token punctuation">.</span>status<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>result<span class="token punctuation">.</span>MockMvcResultMatchers<span class="token punctuation">.</span>view<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Before<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunWith<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>mock<span class="token punctuation">.</span>web<span class="token punctuation">.</span>MockHttpServletRequest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>mock<span class="token punctuation">.</span>web<span class="token punctuation">.</span>MockHttpSession<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ContextConfiguration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span>SpringJUnit4ClassRunner<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>web<span class="token punctuation">.</span>WebAppConfiguration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>MockMvc<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>setup<span class="token punctuation">.</span>MockMvcBuilders<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>context<span class="token punctuation">.</span>WebApplicationContext<span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringJUnit4ClassRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ContextConfiguration</span><span class="token punctuation">(</span><span class="token string">"/application-context-test.xml"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@WebAppConfiguration</span><span class="token punctuation">(</span><span class="token string">"src/main/resources"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 此注解指定web资源的位置，默认为src/main/webapp</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestControllerIntegrationTests</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> MockMvc mockMvc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模拟MVC对象</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> DemoService demoService<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在测试用例注入spring的bean</span>    <span class="token annotation punctuation">@Autowired</span>    WebApplicationContext wac<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注入WebApplicationContext</span>    <span class="token annotation punctuation">@Autowired</span>    MockHttpSession session<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注入模拟的http session</span>    <span class="token annotation punctuation">@Autowired</span>    MockHttpServletRequest request<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模拟request</span>    <span class="token annotation punctuation">@Before</span> <span class="token comment" spellcheck="true">// 测试开始前的初始化工作</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mockMvc <span class="token operator">=</span> MockMvcBuilders<span class="token punctuation">.</span><span class="token function">webAppContextSetup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>wac<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testNormalController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        String exp_str <span class="token operator">=</span> demoService<span class="token punctuation">.</span><span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// expect str</span>        mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/normal"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 模拟GET /normal</span>            <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 预期返回状态为200</span>            <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">view</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"page"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 预期view的名称</span>            <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">forwardedUrl</span><span class="token punctuation">(</span><span class="token string">"/WEB-INF/classes/views/page.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 预期页面转向的真正路径</span>            <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">model</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> exp_str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 预期model里的值</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testRestController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/testRest"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// HTTP GET 方法</span>            <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token string">"text/plain;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//14</span>            <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span>demoService<span class="token punctuation">.</span><span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//15</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>: <code>demoService</code>及相关方法的调用，也可以通过<code>Mockito</code>工具Mock出来，更符合单元测试对<strong>单元性</strong>的要求，否则这些测试又额外附带了一定集成测试的性质了。</p></blockquote><h3 id="4-spring-boot-starter-test"><a href="#4-spring-boot-starter-test" class="headerlink" title="4. spring-boot-starter-test"></a>4. spring-boot-starter-test</h3><h4 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="(1). 简单介绍"></a>(1). 简单介绍</h4><p>现在越来越多的应用都采用SpringBoot的方式来构建，在SpringBoot应用中单元测试变得更加容易了，只需要加入<code>spring-boot-starter-test</code>的 Starter 即可，其中默认导入了 Spring Boot 测试模块以及<code>JUnit</code>，<code>AssertJ</code>，<code>Hamcrest</code>和其他一些有用的库。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><code>spring-boot-starter-test</code>的 Starter (Scope为test)，包括了以下提供的类库：</p><ul><li><a href="https://junit.org/" target="_blank" rel="noopener">JUnit</a>：单元测试Java应用程序的事实标准。</li><li><a href="https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/testing.html#integration-testing" target="_blank" rel="noopener">Spring Test</a> 和 Spring Boot Test：Spring Boot应用程序的实用程序和集成测试支持。</li><li><a href="https://joel-costigliola.github.io/assertj/" target="_blank" rel="noopener">AssertJ</a>：流畅的断言库。</li><li><a href="http://hamcrest.org/JavaHamcrest/" target="_blank" rel="noopener">Hamcrest</a>：匹配器对象库。</li><li><a href="http://mockito.org/" target="_blank" rel="noopener">Mockito</a>：Java Mock 框架。</li><li><a href="https://github.com/skyscreamer/JSONassert" target="_blank" rel="noopener">JSONassert</a>：JSON的断言库。</li><li><a href="JsonPath">JsonPath</a>：JSON的XPath。</li></ul><p>我们通常在编写测试时发现这些通用库都是比较有用的。如果这些库还不适合您的需求，您还可以添加您自己的附加测试依赖库。</p><p>Spring Boot 提供了一个<code>@SpringBootTest</code>注释，当您需要 Spring Boot 功能时，它可以用作标准 spring-test <code>@ContextConfiguration</code>注释的替代方法。注解的工作原理是通过<code>SpringApplication</code>创建用于测试的<code>ApplicationContext</code>。除了<code>@SpringBootTest</code>之外，还提供了许多其他注释来测试应用程序的更具体的切片。</p><blockquote><p><strong>提示</strong>：不要忘记在测试中添加<code>@RunWith(SpringRunner.class)</code>，否则注释将被忽略。</p></blockquote><h4 id="2-一个简单示例"><a href="#2-一个简单示例" class="headerlink" title="(2). 一个简单示例"></a>(2). 一个简单示例</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${msg}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String msg<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">selectByKey</span><span class="token punctuation">(</span>20180302325L<span class="token punctuation">)</span><span class="token punctuation">;</span>        Assert<span class="token punctuation">.</span><span class="token function">assertThat</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">is</span><span class="token punctuation">(</span><span class="token string">"Blinkfox"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"获取的配置信息为:"</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面就是最简单的单元测试写法，测试类上只需要<code>@RunWith(SpringRunner.class)</code>和<code>@SpringBootTest</code>两个注解即可测试任何类和方法。</p><h4 id="3-web模块的单元测试"><a href="#3-web模块的单元测试" class="headerlink" title="(3). web模块的单元测试"></a>(3). web模块的单元测试</h4><p>要测试 Spring MVC 控制器是否按预期工作，请使用<code>@WebMvcTest</code>注释。<code>@WebMvcTest</code>自动配置<code>Spring MVC</code>基础结构，并将扫描的bean限制为<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>，<code>GenericConverter</code>，<code>Filter</code>，<code>WebMvcConfigurer</code>和<code>HandlerMethodArgumentResolver</code>。 使用此注释时，不会扫描常规的<code>@Component</code> bean。</p><p>您还可以使用<code>@AutoConfigureMockMvc</code>对其进行注释，从而在非<code>@WebMvcTest</code>（如<code>@SpringBootTest</code>）中自动配置<code>MockMvc</code>。 以下示例使用MockMvc：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@WebMvcTest</span><span class="token punctuation">(</span>UserVehicleController<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyControllerTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> MockMvc mvc<span class="token punctuation">;</span>    <span class="token annotation punctuation">@MockBean</span>    <span class="token keyword">private</span> UserVehicleService userVehicleService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token function">given</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>userVehicleService<span class="token punctuation">.</span><span class="token function">getVehicleDetails</span><span class="token punctuation">(</span><span class="token string">"sboot"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">willReturn</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VehicleDetails</span><span class="token punctuation">(</span><span class="token string">"Honda"</span><span class="token punctuation">,</span> <span class="token string">"Civic"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/sboot/vehicle"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>TEXT_PLAIN<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Honda Civic"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>SpringBoot对各种单元测试的场景支持的比较全，更多的示例可直接在<a href="https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-testing" target="_blank" rel="noopener">Spiring Boot Test 官方指南</a>中去查看，这里就不再一一列举了。</p><h3 id="5-JaCoCo"><a href="#5-JaCoCo" class="headerlink" title="5. JaCoCo"></a>5. JaCoCo</h3><p>在做单元测试时，代码覆盖率常常被拿来作为衡量测试好坏的指标，甚至，用代码覆盖率来考核测试任务完成情况，比如，代码覆盖率必须达到80％或 90％。<br>目前Java常用覆盖率工具<a href="https://www.atlassian.com/software/clover" target="_blank" rel="noopener">clover</a>、<a href="http://www.eclemma.org/jacoco/" target="_blank" rel="noopener">Jacoco</a>和<a href="https://cobertura.github.io/cobertura/" target="_blank" rel="noopener">Cobertura</a>等。关于这些代码覆盖率工具的对比可参看<a href="https://confluence.atlassian.com/clover/comparison-of-code-coverage-tools-681706101.html?_ga=2.7075890.1253300005.1526228675-143716968.1468426926" target="_blank" rel="noopener">这里</a>。这里我们就选取 Jacoco 来作为代码覆盖率工具来做介绍。</p><p>Jacoco 是一个开源的覆盖率工具。Jacoco 可以嵌入到Ant 、Maven中，并提供了 Eclipse、IDEA 插件,也可以使用Java Agent技术监控Java程序。很多第三方的工具提供了对 Jacoco 的集成，如sonar、Jenkins。</p><p>Jacoco与Maven的集成很简单，只需要在plugins中添加如下插件即可。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.jacoco<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jacoco-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.7.7.201606060606<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>destFile</span><span class="token punctuation">></span></span>target/coverage-reports/jacoco-unit.exec<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>destFile</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataFile</span><span class="token punctuation">></span></span>target/coverage-reports/jacoco-unit.exec<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataFile</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>jacoco-initialize<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>prepare-agent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>jacoco-site<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>report<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span></code></pre><p>做单元测试时，测试覆盖率是不是越高代表代码质量越好呢？Martin Fowler（重构那本书的作者）曾经写过一篇博客来讨论这个问题，他指出：<strong>把测试覆盖作为质量目标没有任何意义，而我们应该把它作为一种发现未被测试覆盖的代码的手段</strong>。</p><p>所以，代码覆盖率统计是用来发现没有被测试覆盖的代码；代码覆盖率统计不能完全用来衡量代码质量。</p><hr><p>参考资料</p><ul><li><a href="https://blog.csdn.net/vincetest/article/details/1378507" target="_blank" rel="noopener">单元测试大揭密</a></li><li><a href="https://www.yiibai.com/junit/" target="_blank" rel="noopener">JUnit教程</a></li><li><a href="http://sjyuan.cc/junit5/user-guide-cn/" target="_blank" rel="noopener">JUnit5用户指南中文版</a></li><li><a href="https://blog.csdn.net/bboyfeiyu/article/details/52127551" target="_blank" rel="noopener">Mockito中文文档</a></li><li><a href="https://github.com/yangyubo/zh-unit-testing-guidelines/blob/master/readme.rst" target="_blank" rel="noopener">单元测试准则</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java8新特性及使用(二)</title>
      <link href="/2018/11/14/hou-duan/java/java8-xin-te-xing-ji-shi-yong-er/"/>
      <url>/2018/11/14/hou-duan/java/java8-xin-te-xing-ji-shi-yong-er/</url>
      
        <content type="html"><![CDATA[<h2 id="扩展注解的支持"><a href="#扩展注解的支持" class="headerlink" title="扩展注解的支持"></a>扩展注解的支持</h2><p>Java 8扩展了注解的上下文。<strong>现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解</strong>。下面演示几个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Annotations</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE_PARAMETER <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">NonEmpty</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span><span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token annotation punctuation">@NonEmpty</span> Object <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@NonEmpty</span> Exception <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token annotation punctuation">@NonEmpty</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@NonEmpty</span> Collection<span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> String<span class="token operator">></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>在Java 8中，Base64编码已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>StandardCharsets<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Base64<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base64s</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> String text <span class="token operator">=</span> <span class="token string">"Base64 finally in Java 8!"</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> String encoded <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> String decoded <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>Base64<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decoded<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>程序在控制台上输出了编码后的字符与解码后的字符：</p><pre class=" language-bash"><code class="language-bash">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ<span class="token operator">==</span>Base64 finally <span class="token keyword">in</span> Java 8<span class="token operator">!</span></code></pre><p>Base64类同时还提供了对URL、MIME友好的编码器与解码器（<code>Base64.getUrlEncoder() / Base64.getUrlDecoder()</code>, <code>Base64.getMimeEncoder() / Base64.getMimeDecoder()</code>）。</p><h2 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h2><p><code>JavaFX</code>是一个强大的图形和多媒体处理工具包集合，它允许开发者来设计、创建、测试、调试和部署富客户端程序，并且和Java一样跨平台。从Java8开始，JavaFx已经内置到了JDK中。关于JavaFx更详细的文档可参考<a href="http://www.javafxchina.net/blog/docs/" target="_blank" rel="noopener">JavaFX中文文档</a>。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="1-JDBC4-2规范"><a href="#1-JDBC4-2规范" class="headerlink" title="1. JDBC4.2规范"></a>1. JDBC4.2规范</h3><p>JDBC4.2主要有以下几点改动：</p><ul><li>增加了对<code>REF Cursor</code>的支持</li><li>修改返回值大小范围（update count）</li><li>增加了<code>java.sql.DriverAction</code>接口</li><li>增加了<code>java.sql.SQLType</code>接口</li><li>增加了<code>java.sql.JDBCtype</code>枚举</li><li>对<code>java.time</code>包时间类型的支持</li></ul><h3 id="2-更好的类型推测机制"><a href="#2-更好的类型推测机制" class="headerlink" title="2. 更好的类型推测机制"></a>2. 更好的类型推测机制</h3><p>Java 8在类型推测方面有了很大的提高。在很多情况下，编译器可以推测出确定的参数类型，这样就能使代码更整洁。让我们看一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span><span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">defaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">getOrDefault</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> T defaultValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> value <span class="token operator">:</span> defaultValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里是<code>Value&lt;String&gt;</code>类型的用法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TypeInference</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Value<span class="token operator">&lt;</span>String<span class="token operator">></span> value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        value<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token string">"22"</span><span class="token punctuation">,</span> Value<span class="token punctuation">.</span><span class="token function">defaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Value.defaultValue()</code>的参数类型可以被推测出，所以就不必明确给出。在Java 7中，相同的例子将不会通过编译，正确的书写方式是<code>Value.&lt;String&gt;defaultValue()</code>。</p><h3 id="3-HashMap性能提升"><a href="#3-HashMap性能提升" class="headerlink" title="3. HashMap性能提升"></a>3. HashMap性能提升</h3><p>Java8中，HashMap内部实现又引入了红黑树，使得HashMap的总体性能相较于Java7有比较明显的提升。以下是对Hash均匀和不均匀的情况下的性能对比</p><h4 id="1-Hash较均匀的情况"><a href="#1-Hash较均匀的情况" class="headerlink" title="(1). Hash较均匀的情况"></a>(1). Hash较均匀的情况</h4><p><img src="http://tech.meituan.com/img/java-hashmap/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A81.png" alt="Hash较均匀时的性能对比"></p><h4 id="2-Hash极不均匀的情况"><a href="#2-Hash极不均匀的情况" class="headerlink" title="(2). Hash极不均匀的情况"></a>(2). Hash极不均匀的情况</h4><p><img src="http://tech.meituan.com/img/java-hashmap/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A82.png" alt="Hash极不均匀时的性能对比"></p><h3 id="4-IO-NIO-的改进"><a href="#4-IO-NIO-的改进" class="headerlink" title="4. IO/NIO 的改进"></a>4. IO/NIO 的改进</h3><p>Java8 对<code>IO/NIO</code>也做了一些改进。主要包括：改进了<code>java.nio.charset.Charset</code>的实现，使编码和解码的效率得以提升，也精简了<code>jre/lib/charsets.jar</code>包；优化了<code>String(byte[], *)</code>构造方法和<code>String.getBytes()</code>方法的性能；还增加了一些新的<code>IO/NIO</code>方法，使用这些方法可以从文件或者输入流中获取流（<code>java.util.stream.Stream</code>），通过对流的操作，可以简化文本行处理、目录遍历和文件查找。</p><p>新增的 API 如下：</p><ul><li><code>BufferedReader.line()</code>: 返回文本行的流<code>Stream&lt;String&gt;</code></li><li><code>File.lines(Path, Charset)</code>: 返回文本行的流<code>Stream&lt;String&gt;</code></li><li><code>File.list(Path)</code>: 遍历当前目录下的文件和目录</li><li><code>File.walk(Path, int, FileVisitOption)</code>: 遍历某一个目录下的所有文件和指定深度的子目录</li><li><code>File.find(Path, int, BiPredicate, FileVisitOption...)</code>: 查找相应的文件</li></ul><p>下面就是用流式操作列出当前目录下的所有文件和目录：</p><pre class=" language-java"><code class="language-java">Files<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="5-JavaScript引擎Nashorn"><a href="#5-JavaScript引擎Nashorn" class="headerlink" title="5. JavaScript引擎Nashorn"></a>5. JavaScript引擎Nashorn</h3><p>Java 8提供了一个新的<code>Nashorn javascript</code>引擎，它允许我们在JVM上运行特定的javascript应用。Nashorn javascript引擎只是<code>javax.script.ScriptEngine</code>另一个实现，而且规则也一样，允许Java和JavaScript互相操作。这里有个小例子：</p><pre class=" language-java"><code class="language-java">ScriptEngineManager manager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScriptEngineManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ScriptEngine engine <span class="token operator">=</span> manager<span class="token punctuation">.</span><span class="token function">getEngineByName</span><span class="token punctuation">(</span><span class="token string">"JavaScript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>engine<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result:"</span> <span class="token operator">+</span> engine<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"function f(){return 1;}; f() + 1;"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出如下：</p><pre class=" language-bash"><code class="language-bash">jdk.nashorn.api.scripting.NashornScriptEngineResult: 2</code></pre><h3 id="6-并发（Concurrency）"><a href="#6-并发（Concurrency）" class="headerlink" title="6. 并发（Concurrency）"></a>6. 并发（Concurrency）</h3><p>在新增<code>Stream</code>机制与<code>Lambda</code>的基础之上，在<code>java.util.concurrent.ConcurrentHashMap</code>中加入了一些新方法来支持聚集操作。同时也在<code>java.util.concurrent.ForkJoinPool</code>类中加入了一些新方法来支持共有资源池（common pool）（请查看我们关于Java 并发的免费课程）。</p><p>新增的<code>java.util.concurrent.locks.StampedLock</code>类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的<code>java.util.concurrent.locks.ReadWriteLock</code>类的替代者）。</p><p>在<code>java.util.concurrent.atomic</code>包中还增加了下面这些类：</p><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><h3 id="7-类依赖分析器jdeps"><a href="#7-类依赖分析器jdeps" class="headerlink" title="7. 类依赖分析器jdeps"></a>7. 类依赖分析器jdeps</h3><p><code>Jdeps</code>是一个功能强大的命令行工具，它可以帮我们显示出包层级或者类层级java类文件的依赖关系。它接受class文件、目录、jar文件作为输入，默认情况下，<code>jdeps</code>会输出到控制台。</p><p>作为例子，让我们看看现在很流行的Spring框架的库的依赖关系报告。为了让报告短一些，我们只分析一个jar: <code>org.springframework.core-3.0.5.RELEASE.jar</code>.</p><p><code>jdeps org.springframework.core-3.0.5.RELEASE.jar</code>这个命令输出内容很多，我们只看其中的一部分，这些依赖关系根绝包来分组，如果依赖关系在classpath里找不到，就会显示not found.</p><pre class=" language-bash"><code class="language-bash">C:\Program Files\Java\jdk1.8.0\jre\lib\rt.jar   org.springframework.core <span class="token punctuation">(</span>org.springframework.core-3.0.5.RELEASE.jar<span class="token punctuation">)</span>      -<span class="token operator">></span> java.io      -<span class="token operator">></span> java.lang      -<span class="token operator">></span> java.lang.annotation      -<span class="token operator">></span> java.lang.ref      -<span class="token operator">></span> java.lang.reflect      -<span class="token operator">></span> java.util      -<span class="token operator">></span> java.util.concurrent      -<span class="token operator">></span> org.apache.commons.logging                         not found      -<span class="token operator">></span> org.springframework.asm                            not found      -<span class="token operator">></span> org.springframework.asm.commons                    not found   org.springframework.core.annotation <span class="token punctuation">(</span>org.springframework.core-3.0.5.RELEASE.jar<span class="token punctuation">)</span>      -<span class="token operator">></span> java.lang      -<span class="token operator">></span> java.lang.annotation      -<span class="token operator">></span> java.lang.reflect      -<span class="token operator">></span> java.util</code></pre><h3 id="8-JVM的PermGen空间被移除"><a href="#8-JVM的PermGen空间被移除" class="headerlink" title="8. JVM的PermGen空间被移除"></a>8. JVM的PermGen空间被移除</h3><p><code>PermGen</code>空间被移除了，取而代之的是<code>Metaspace（JEP 122）</code>。JVM选项<code>-XX:PermSize</code>与<code>-XX:MaxPermSize</code>分别被<code>-XX:MetaSpaceSize</code>与<code>-XX:MaxMetaspaceSize</code>所代替。</p><hr><p>参考文档：</p><ul><li><a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">What’s New in JDK 8</a></li><li><a href="http://www.importnew.com/11908.html" target="_blank" rel="noopener">Java 8新特性终极指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java8新特性及使用(一)</title>
      <link href="/2018/11/13/hou-duan/java/java8-xin-te-xing-ji-shi-yong-yi/"/>
      <url>/2018/11/13/hou-duan/java/java8-xin-te-xing-ji-shi-yong-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>以下是Java8中的引入的部分新特性。关于Java8新特性更详细的介绍可参考<a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">这里</a>。</p><ul><li>接口默认方法和静态方法</li><li>Lambda 表达式</li><li>函数式接口</li><li>方法引用</li><li>Stream</li><li>Optional</li><li>Date/Time API</li><li>重复注解</li><li>扩展注解的支持</li><li>Base64</li><li>JavaFX</li><li>其它<ul><li>JDBC4.2规范</li><li>更好的类型推测机制</li><li>HashMap性能提升</li><li>IO/NIO 的改进</li><li>JavaScript引擎Nashorn</li><li>并发（Concurrency）</li><li>类依赖分析器jdeps</li><li>JVM的PermGen空间被移除</li></ul></li></ul><h2 id="一、接口默认方法和静态方法"><a href="#一、接口默认方法和静态方法" class="headerlink" title="一、接口默认方法和静态方法"></a>一、接口默认方法和静态方法</h2><p>Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。</p><h3 id="1-接口默认方法"><a href="#1-接口默认方法" class="headerlink" title="1. 接口默认方法"></a>1. 接口默认方法</h3><p>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Interfaces now allow default methods, the implementer may or</span>    <span class="token comment" spellcheck="true">// may not implement (override) them.</span>    <span class="token keyword">default</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Default implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OverridableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Overridden implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Defaulable</code>接口用关键字<code>default</code>声明了一个默认方法<code>notRequired()</code>，<code>Defaulable</code>接口的实现者之一<code>DefaultableImpl</code>实现了这个接口，并且让默认方法保持原样。<code>Defaulable</code>接口的另一个实现者<code>OverridableImpl</code>用自己的方法覆盖了默认方法。</p><h4 id="1-多重继承的冲突说明"><a href="#1-多重继承的冲突说明" class="headerlink" title="(1). 多重继承的冲突说明"></a>(1). 多重继承的冲突说明</h4><p>由于同一个方法可以从不同的接口引入，自然而然的会有冲突的现象，规则如下：</p><ul><li>一个声明在类里面的方法优先于任何默认方法</li><li>优先选取最具体的实现</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">implements</span> <span class="token class-name">A</span><span class="token punctuation">,</span> B <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 Hello B</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="(2). 优缺点"></a>(2). 优缺点</h4><ul><li><strong>优点</strong>: 可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。</li><li><strong>缺点</strong>: 使得<strong>接口作为协议，类作为具体实现</strong>的界限开始变得有点模糊。</li></ul><h4 id="3-接口默认方法不能重载Object类的任何方法"><a href="#3-接口默认方法不能重载Object类的任何方法" class="headerlink" title="(3). 接口默认方法不能重载Object类的任何方法"></a>(3). 接口默认方法不能重载Object类的任何方法</h4><p><strong>接口不能提供对Object类的任何方法的默认实现</strong>。简单地讲，每一个java类都是Object的子类，也都继承了它类中的<code>equals()</code>/<code>hashCode()</code>/<code>toString()</code>方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。</p><p>在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到<code>java.util.Collection</code>接口中去：<code>stream()</code>，<code>parallelStream()</code>，<code>forEach()</code>，<code>removeIf()</code>等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。</p><h3 id="2-接口静态方法"><a href="#2-接口静态方法" class="headerlink" title="2. 接口静态方法"></a>2. 接口静态方法</h3><p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。在接口中定义静态方法，使用<code>static</code>关键字，例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StaticInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是Java8接口中的静态方法!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面的一小段代码是上面静态方法的使用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StaticInterface<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 这是Java8接口中的静态方法!</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Java支持一个实现类可以实现多个接口，如果多个接口中存在同样的<code>static</code>方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。</p><p>二、Lambda 表达式</p><p><code>Lambda</code>表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（即：<strong>行为参数化</strong>，函数作为参数传递进方法中）。</p><p>一个<code>Lambda</code>可以由用逗号分隔的参数列表、<code>–&gt;</code>符号与函数体三部分表示。</p><p>首先看看在老版本的Java中是如何排列字符串的：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"peter"</span><span class="token punctuation">,</span> <span class="token string">"anna"</span><span class="token punctuation">,</span> <span class="token string">"mike"</span><span class="token punctuation">,</span> <span class="token string">"xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>只需要给静态方法<code>Collections.sort</code>传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对于函数体只有一行代码的，你可以去掉大括号<code>{}</code>以及<code>return</code>关键字，但是你还可以写得更短点：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。</p><h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><p><code>Lambda</code>表达式是如何在Java的类型系统中表示的呢？每一个Lambda表达式都对应一个类型，通常是接口类型。而<strong>函数式接口</strong>是指仅仅只包含一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。因为<strong>默认方法</strong>不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将Lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加<code>@FunctionalInterface</code>注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><p>示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">interface</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>F<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    T <span class="token function">convert</span><span class="token punctuation">(</span>F from<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Converter<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> converter <span class="token operator">=</span> <span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>Integer converted <span class="token operator">=</span> converter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>converted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span></code></pre><blockquote><p><strong>注</strong>：如果<code>@FunctionalInterface</code>如果没有指定，上面的代码也是对的。</p></blockquote><p>Java8 API包含了很多内建的函数式接口，在老Java中常用到的比如<code>Comparator</code>或者<code>Runnable</code>接口，这些接口都增加了<code>@FunctionalInterface</code>注解以便能用在<code>Lambda</code>上。</p><p>Java8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p><h3 id="1-Comparator-比较器接口"><a href="#1-Comparator-比较器接口" class="headerlink" title="1. Comparator (比较器接口)"></a>1. Comparator (比较器接口)</h3><p><code>Comparator</code>是老Java中的经典接口， Java 8在此之上添加了多种默认方法。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>T o1<span class="token punctuation">,</span> T o2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Comparator<span class="token operator">&lt;</span>Person<span class="token operator">></span> comparator <span class="token operator">=</span> <span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> p1<span class="token punctuation">.</span>firstName<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span>Person p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Doe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Person p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token string">"Wonderland"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// > 0</span>comparator<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// &lt; 0</span></code></pre><h3 id="2-Consumer-消费型接口"><a href="#2-Consumer-消费型接口" class="headerlink" title="2. Consumer (消费型接口)"></a>2. Consumer (消费型接口)</h3><p><code>Consumer</code>接口表示执行在单个参数上的操作。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Consumer<span class="token operator">&lt;</span>Person<span class="token operator">></span> greeter <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span>greeter<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Luke"</span><span class="token punctuation">,</span> <span class="token string">"Skywalker"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="更多的Consumer接口"><a href="#更多的Consumer接口" class="headerlink" title="更多的Consumer接口"></a>更多的Consumer接口</h4><ul><li><code>BiConsumer：void accept(T t, U u);</code>: 接受两个参数的二元函数</li><li><code>DoubleConsumer：void accept(double value);</code>: 接受一个double参数的一元函数</li><li><code>IntConsumer：void accept(int value);</code>: 接受一个int参数的一元函数</li><li><code>LongConsumer：void accept(long value);</code>: 接受一个long参数的一元函数</li><li><code>ObjDoubleConsumer：void accept(T t, double value);</code>: 接受一个泛型参数一个double参数的二元函数</li><li><code>ObjIntConsumer：void accept(T t, int value);</code>: 接受一个泛型参数一个int参数的二元函数</li><li><code>ObjLongConsumer：void accept(T t, long value);</code>: 接受一个泛型参数一个long参数的二元函数</li></ul><h3 id="3-Supplier-供应型接口"><a href="#3-Supplier-供应型接口" class="headerlink" title="3. Supplier (供应型接口)"></a>3. Supplier (供应型接口)</h3><p><code>Supplier</code>接口是不需要参数并返回一个任意范型的值。其简洁的声明，会让人以为不是函数。这个抽象方法的声明，同Consumer相反，是一个只声明了返回值，不需要参数的函数。也就是说Supplier其实表达的不是从一个参数空间到结果空间的映射能力，而是表达一种生成能力，因为我们常见的场景中不止是要consume（Consumer）或者是简单的map（Function），还包括了new这个动作。而Supplier就表达了这种能力。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Supplier</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Supplier<span class="token operator">&lt;</span>Person<span class="token operator">></span> personSupplier <span class="token operator">=</span> Person<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">;</span>personSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// new Person</span></code></pre><h4 id="更多Supplier接口"><a href="#更多Supplier接口" class="headerlink" title="更多Supplier接口"></a>更多Supplier接口</h4><ul><li><code>BooleanSupplier：boolean getAsBoolean();</code>: 返回boolean的无参函数</li><li><code>DoubleSupplier：double getAsDouble();</code>: 返回double的无参函数</li><li><code>IntSupplier：int getAsInt();</code>: 返回int的无参函数</li><li><code>LongSupplier：long getAsLong();</code>: 返回long的无参函数</li></ul><h3 id="4-Predicate-断言型接口"><a href="#4-Predicate-断言型接口" class="headerlink" title="4. Predicate (断言型接口)"></a>4. Predicate (断言型接口)</h3><p><code>Predicate</code>接口只有一个参数，返回<code>boolean</code>类型。该接口包含多种默认方法来将<code>Predicate</code>组合成其他复杂的逻辑（比如：<strong>与</strong>，<strong>或</strong>，<strong>非</strong>）。<code>Stream</code>的<code>filter</code>方法就是接受<code>Predicate</code>作为入参的。这个具体在后面使用<code>Stream</code>的时候再分析深入。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> predicate <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>predicate<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// true</span>predicate<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// false</span>Predicate<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> nonNull <span class="token operator">=</span> Objects<span class="token operator">:</span><span class="token operator">:</span>nonNull<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> isNull <span class="token operator">=</span> Objects<span class="token operator">:</span><span class="token operator">:</span>isNull<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> isEmpty <span class="token operator">=</span> String<span class="token operator">:</span><span class="token operator">:</span>isEmpty<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> isNotEmpty <span class="token operator">=</span> isEmpty<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="更多的Predicate接口"><a href="#更多的Predicate接口" class="headerlink" title="更多的Predicate接口"></a>更多的Predicate接口</h4><ul><li><code>BiPredicate：boolean test(T t, U u);</code>: 接受两个参数的二元断言函数</li><li><code>DoublePredicate：boolean test(double value);</code>: 入参为double的断言函数</li><li><code>IntPredicate：boolean test(int value);</code>: 入参为int的断言函数</li><li><code>LongPredicate：boolean test(long value);</code>: 入参为long的断言函数</li></ul><h3 id="5-Function-功能型接口"><a href="#5-Function-功能型接口" class="headerlink" title="5. Function (功能型接口)"></a>5. Function (功能型接口)</h3><p><code>Function</code>接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（<code>compose</code>, <code>andThen</code>）。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span> <span class="token punctuation">{</span>    R <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Function<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> toInteger <span class="token operator">=</span> Integer<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">;</span>Function<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> backToString <span class="token operator">=</span> toInteger<span class="token punctuation">.</span><span class="token function">andThen</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">)</span><span class="token punctuation">;</span>backToString<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// "123"</span></code></pre><h4 id="更多的Function接口"><a href="#更多的Function接口" class="headerlink" title="更多的Function接口"></a>更多的Function接口</h4><ul><li><code>BiFunction ：R apply(T t, U u);</code>: 接受两个参数，返回一个值，代表一个二元函数；</li><li><code>DoubleFunction ：R apply(double value);</code>: 只处理double类型的一元函数；</li><li><code>IntFunction ：R apply(int value);</code>: 只处理int参数的一元函数；</li><li><code>LongFunction ：R apply(long value);</code>: 只处理long参数的一元函数；</li><li><code>ToDoubleFunction：double applyAsDouble(T value);</code>: 返回double的一元函数；</li><li><code>ToDoubleBiFunction：double applyAsDouble(T t, U u);</code>: 返回double的二元函数；</li><li><code>ToIntFunction：int applyAsInt(T value);</code>: 返回int的一元函数；</li><li><code>ToIntBiFunction：int applyAsInt(T t, U u);</code>: 返回int的二元函数；</li><li><code>ToLongFunction：long applyAsLong(T value);</code>: 返回long的一元函数；</li><li><code>ToLongBiFunction：long applyAsLong(T t, U u);</code>: 返回long的二元函数；</li><li><code>DoubleToIntFunction：int applyAsInt(double value);</code>: 接受double返回int的一元函数；</li><li><code>DoubleToLongFunction：long applyAsLong(double value);</code>: 接受double返回long的一元函数；</li><li><code>IntToDoubleFunction：double applyAsDouble(int value);</code>: 接受int返回double的一元函数；</li><li><code>IntToLongFunction：long applyAsLong(int value);</code>: 接受int返回long的一元函数；</li><li><code>LongToDoubleFunction：double applyAsDouble(long value);</code>: 接受long返回double的一元函数；</li><li><code>LongToIntFunction：int applyAsInt(long value);</code>: 接受long返回int的一元函数；</li></ul><h3 id="6-Operator"><a href="#6-Operator" class="headerlink" title="6. Operator"></a>6. Operator</h3><p><code>Operator</code>其实就是<code>Function</code>，函数有时候也叫作算子。算子在Java8中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。算子Operator包括：<code>UnaryOperator</code>和<code>BinaryOperator</code>。分别对应单（一）元算子和二元算子。</p><p>算子的接口声明如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UnaryOperator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> UnaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> t <span class="token operator">-</span><span class="token operator">></span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BinaryOperator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">BiFunction</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token punctuation">,</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">minBy</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">maxBy</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Operator</code>只需声明一个泛型参数T即可。对应的使用示例如下：</p><pre class=" language-java"><code class="language-java">UnaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> increment <span class="token operator">=</span> x <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"递增:"</span> <span class="token operator">+</span> increment<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 递增:3</span>BinaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> add <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"相加:"</span> <span class="token operator">+</span> add<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 相加:5</span>BinaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> min <span class="token operator">=</span> BinaryOperator<span class="token punctuation">.</span><span class="token function">minBy</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> o1 <span class="token operator">-</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最小值:"</span> <span class="token operator">+</span> min<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 最小值:2</span></code></pre><h4 id="更多的Operator接口"><a href="#更多的Operator接口" class="headerlink" title="更多的Operator接口"></a>更多的Operator接口</h4><ul><li><code>LongUnaryOperator：long applyAsLong(long operand);</code>: 对long类型做操作的一元算子</li><li><code>IntUnaryOperator：int applyAsInt(int operand);</code>: 对int类型做操作的一元算子</li><li><code>DoubleUnaryOperator：double applyAsDouble(double operand);</code>: 对double类型做操作的一元算子</li><li><code>DoubleBinaryOperator：double applyAsDouble(double left, double right);</code>: 对double类型做操作的二元算子</li><li><code>IntBinaryOperator：int applyAsInt(int left, int right);</code>: 对int类型做操作的二元算子</li><li><code>LongBinaryOperator：long applyAsLong(long left, long right);</code>: 对long类型做操作的二元算子</li></ul><h3 id="6-其它函数式接口"><a href="#6-其它函数式接口" class="headerlink" title="6. 其它函数式接口"></a>6. 其它函数式接口</h3><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.security.PrivilegedAction</li><li>java.io.FileFilter</li><li>java.nio.file.PathMatcher </li><li>java.lang.reflect.InvocationHandler</li><li>java.beans.PropertyChangeListener</li><li>java.awt.event.ActionListener  </li><li>javax.swing.event.ChangeListener</li></ul><h2 id="四、方法引用"><a href="#四、方法引用" class="headerlink" title="四、方法引用"></a>四、方法引用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>在学习了Lambda表达式之后，我们通常使用Lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下：</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在Java8中，我们可以直接通过方法引用来简写Lambda表达式中已经存在的方法。</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>compareToIgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种特性就叫做<strong>方法引用</strong>(<code>Method Reference</code>)。</p><p><strong>方法引用</strong>是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。</p><blockquote><p><strong>注意</strong>: 方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号<code>::</code>。</p></blockquote><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><p>方法引用的标准形式是：<code>类名::方法名</code>。（注意：只需要写方法名，不需要写括号）</p><p>有以下四种形式的方法引用：</p><ul><li>引用静态方法: ContainingClass::staticMethodName</li><li>引用某个对象的实例方法: containingObject::instanceMethodName</li><li>引用某个类型的任意对象的实例方法:ContainingType::methodName</li><li>引用构造方法: ClassName::new</li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    LocalDate birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> LocalDate birthday<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> LocalDate <span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compareByAge</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>birthday<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodReferenceTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Person<span class="token punctuation">[</span><span class="token punctuation">]</span> pArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"003"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"001"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"004"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用匿名类</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用lambda表达式</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用方法引用，引用的是类的静态方法</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> Person<span class="token operator">:</span><span class="token operator">:</span>compareByAge<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、Stream"><a href="#五、Stream" class="headerlink" title="五、Stream"></a>五、Stream</h2><p>Java8添加的<code>Stream API(java.util.stream)</code>把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为<code>Stream API</code>可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>流可以是无限的、有状态的，可以是顺序的，也可以是并行的。在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。中间操作包括<code>filter</code>、<code>map</code>、<code>flatMap</code>、<code>peel</code>、<code>distinct</code>、<code>sorted</code>、<code>limit</code>和<code>substream</code>。终止操作包括<code>forEach</code>、<code>toArray</code>、<code>reduce</code>、<code>collect</code>、<code>min</code>、<code>max</code>、<code>count</code>、<code>anyMatch</code>、<code>allMatch</code>、<code>noneMatch</code>、<code>findFirst</code>和<code>findAny</code>。 <code>java.util.stream.Collectors</code>是一个非常有用的实用类。该类实现了很多归约操作，例如将流转换成集合和聚合元素。</p><h3 id="1-一些重要方法说明"><a href="#1-一些重要方法说明" class="headerlink" title="1. 一些重要方法说明"></a>1. 一些重要方法说明</h3><ul><li><code>stream</code>: 返回数据流，集合作为其源</li><li><code>parallelStream</code>: 返回并行数据流， 集合作为其源</li><li><code>filter</code>: 方法用于过滤出满足条件的元素</li><li><code>map</code>: 方法用于映射每个元素对应的结果</li><li><code>forEach</code>: 方法遍历该流中的每个元素</li><li><code>limit</code>: 方法用于减少流的大小</li><li><code>sorted</code>: 方法用来对流中的元素进行排序</li><li><code>anyMatch</code>: 是否存在任意一个元素满足条件（返回布尔值）</li><li><code>allMatch</code>: 是否所有元素都满足条件（返回布尔值）</li><li><code>noneMatch</code>: 是否所有元素都不满足条件（返回布尔值）</li><li><code>collect</code>: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束</li></ul><h3 id="2-一些使用示例"><a href="#2-一些使用示例" class="headerlink" title="2. 一些使用示例"></a>2. 一些使用示例</h3><h4 id="1-Filter-过滤"><a href="#1-Filter-过滤" class="headerlink" title="(1). Filter 过滤"></a>(1). Filter 过滤</h4><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-Sort-排序"><a href="#2-Sort-排序" class="headerlink" title="(2). Sort 排序"></a>(2). Sort 排序</h3><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-Map-映射"><a href="#3-Map-映射" class="headerlink" title="(3). Map 映射"></a>(3). Map 映射</h3><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="4-Match-匹配"><a href="#4-Match-匹配" class="headerlink" title="(4). Match 匹配"></a>(4). Match 匹配</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> anyStartsWithA <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>anyStartsWithA<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// true</span><span class="token keyword">boolean</span> allStartsWithA <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>allStartsWithA<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// false</span><span class="token keyword">boolean</span> noneStartsWithZ <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"z"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>noneStartsWithZ<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// true</span></code></pre><h3 id="5-Count-计数"><a href="#5-Count-计数" class="headerlink" title="(5). Count 计数"></a>(5). Count 计数</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">long</span> startsWithB <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>startsWithB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3</span></code></pre><h3 id="6-Reduce-规约"><a href="#6-Reduce-规约" class="headerlink" title="(6). Reduce 规约"></a>(6). Reduce 规约</h3><p>这是一个最终操作，允许通过指定的函数来将<code>stream</code>中的多个元素规约为一个元素，规越后的结果是通过<code>Optional</code>接口表示的。代码如下:</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> reduced <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> <span class="token string">"#"</span> <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>reduced<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="六、Optional"><a href="#六、Optional" class="headerlink" title="六、Optional"></a>六、Optional</h2><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的<code>Guava</code>项目引入了<code>Optional</code>类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，<code>Optional</code>类已经成为Java 8类库的一部分。</p><p><code>Optional</code>实际上是个容器：它可以保存类型T的值，或者仅仅保存null。<code>Optional</code>提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> fullName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name is set? "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name: "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fullName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果<code>Optional</code>类的实例为非空值的话，<code>isPresent()</code>返回<code>true</code>，否从返回<code>false</code>。为了防止Optional为空值，<code>orElseGet()</code>方法通过回调函数来产生一个默认值。<code>map()</code>函数对当前<code>Optional</code>的值进行转化，然后返回一个新的<code>Optional</code>实例。<code>orElse()</code>方法和<code>orElseGet()</code>方法类似，但是<code>orElse</code>接受一个默认值而不是一个回调函数。下面是这个程序的输出：</p><pre class=" language-bash"><code class="language-bash">Full Name is set? <span class="token boolean">false</span>Full Name: <span class="token punctuation">[</span>none<span class="token punctuation">]</span>Hey Stranger<span class="token operator">!</span></code></pre><p>让我们来看看另一个例子：</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> firstName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name is set? "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name: "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面是程序的输出：</p><pre class=" language-bash"><code class="language-bash">First Name is set? <span class="token boolean">true</span>First Name: TomHey Tom<span class="token operator">!</span></code></pre><h2 id="七、Date-Time-API"><a href="#七、Date-Time-API" class="headerlink" title="七、Date/Time API"></a>七、Date/Time API</h2><p>Java 8 在包<code>java.time</code>下包含了一组全新的时间日期API。新的日期API和开源的<code>Joda-Time</code>库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p><h3 id="1-Clock-时钟"><a href="#1-Clock-时钟" class="headerlink" title="1. Clock 时钟"></a>1. Clock 时钟</h3><p><code>Clock</code>类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代<code>System.currentTimeMillis()</code>来获取当前的微秒数。某一个特定的时间点也可以使用<code>Instant</code>类来表示，<code>Instant</code>类也可以用来创建老的<code>java.util.Date</code>对象。代码如下:</p><pre class=" language-java"><code class="language-java">Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> millis <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Instant instant <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">instant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// legacy java.util.Date</span></code></pre><h3 id="2-Timezones-时区"><a href="#2-Timezones-时区" class="headerlink" title="2. Timezones 时区"></a>2. Timezones 时区</h3><p>在新API中时区使用<code>ZoneId</code>来表示。时区可以很方便的使用静态方法<code>of</code>来获取到。时区定义了到UTS时间的时间差，在<code>Instant</code>时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下:</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">getAvailableZoneIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// prints all available timezone ids</span>ZoneId zone1 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Europe/Berlin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ZoneId zone2 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Brazil/East"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone1<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone2<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=+01:00]</span><span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=-03:00]</span></code></pre><h3 id="3-LocalTime-本地时间"><a href="#3-LocalTime-本地时间" class="headerlink" title="3. LocalTime 本地时间"></a>3. LocalTime 本地时间</h3><p><code>LocalTime</code>定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下:</p><pre class=" language-java"><code class="language-java">LocalTime now1 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone1<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime now2 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now1<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>now2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false</span><span class="token keyword">long</span> hoursBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> minutesBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hoursBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// -3</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minutesBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// -239</span></code></pre><p><code>LocalTime</code>提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下:</p><pre class=" language-java"><code class="language-java">LocalTime late <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>late<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 23:59:59</span>DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofLocalizedTime</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>SHORT<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime leetTime <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"13:37"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leetTime<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 13:37</span></code></pre><h3 id="4-LocalDate-本地日期"><a href="#4-LocalDate-本地日期" class="headerlink" title="4. LocalDate 本地日期"></a>4. LocalDate 本地日期</h3><p><code>LocalDate</code>表示了一个确切的日期，比如<code>2014-03-11</code>。该对象值是不可变的，用起来和<code>LocalTime</code>基本一致。下面的例子展示了如何给<code>Date</code>对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下:</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate tomorrow <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate yesterday <span class="token operator">=</span> tomorrow<span class="token punctuation">.</span><span class="token function">minusDays</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate independenceDay <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>JULY<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DayOfWeek dayOfWeek <span class="token operator">=</span> independenceDay<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// FRIDAY</span></code></pre><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单。代码如下:</p><pre class=" language-java"><code class="language-java">DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofLocalizedDate</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate xmas <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"24.12.2014"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>xmas<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2014-12-24</span></code></pre><h3 id="5-LocalDateTime-本地日期时间"><a href="#5-LocalDateTime-本地日期时间" class="headerlink" title="5. LocalDateTime 本地日期时间"></a>5. LocalDateTime 本地日期时间</h3><p><code>LocalDateTime</code>同时表示了时间和日期，相当于前两节内容合并到一个对象上了。<code>LocalDateTime</code>和<code>LocalTime</code>还有<code>LocalDate</code>一样，都是不可变的。<code>LocalDateTime</code>提供了一些能访问具体字段的方法。代码如下:</p><pre class=" language-java"><code class="language-java">LocalDateTime sylvester <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>DECEMBER<span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DayOfWeek dayOfWeek <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// WEDNESDAY</span>Month month <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// DECEMBER</span><span class="token keyword">long</span> minuteOfDay <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>ChronoField<span class="token punctuation">.</span>MINUTE_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minuteOfDay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1439</span></code></pre><p>只要附加上时区信息，就可以将其转换为一个时间点<code>Instant</code>对象，<code>Instant</code>时间点对象可以很容易的转换为老式的<code>java.util.Date</code>。代码如下:</p><pre class=" language-java"><code class="language-java">Instant instant <span class="token operator">=</span> sylvester        <span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>legacyDate<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Wed Dec 31 23:59:59 CET 2014</span></code></pre><p>格式化<code>LocalDateTime</code>和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下:</p><pre class=" language-java"><code class="language-java">DateTimeFormatter formatter <span class="token operator">=</span>    DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd, yyyy - HH:mm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDateTime parsed <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"Nov 03, 2014 - 07:13"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>String string <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parsed<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Nov 03, 2014 - 07:13</span></code></pre><p>和<code>java.text.NumberFormat</code>不一样的是新版的<code>DateTimeFormatter</code>是不可变的，所以它是线程安全的。</p><p>关于Java8中日期API更多的使用示例可以参考<a href="http://blinkfox.com/java-8zhong-guan-yu-ri-qi-he-shi-jian-apide-20ge-shi-yong-shi-li/" target="_blank" rel="noopener">Java 8中关于日期和时间API的20个使用示例</a>。</p><h2 id="八、重复注解"><a href="#八、重复注解" class="headerlink" title="八、重复注解"></a>八、重复注解</h2><p>自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。</p><p>重复注解机制本身必须用<code>@Repeatable</code>注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Repeatable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RepeatingAnnotations</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filters</span> <span class="token punctuation">{</span>        Filter<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Filters<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>        String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter1"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filterable</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Filter filter<span class="token operator">:</span> Filterable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>Filter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>正如我们看到的，这里有个使用<code>@Repeatable(Filters.class)</code>注解的注解类<code>Filter</code>，<code>Filters</code>仅仅是<code>Filter</code>注解的数组，但Java编译器并不想让程序员意识到<code>Filters</code>的存在。这样，接口<code>Filterable</code>就拥有了两次<code>Filter</code>（并没有提到<code>Filter</code>）注解。</p><p>同时，反射相关的API提供了新的函数<code>getAnnotationsByType()</code>来返回重复注解的类型（请注意<code>Filterable.class.getAnnotation(Filters.class</code>)`经编译器处理后将会返回Filters的实例）。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java7新特性及使用</title>
      <link href="/2018/11/12/hou-duan/java/java7-xin-te-xing-ji-shi-yong/"/>
      <url>/2018/11/12/hou-duan/java/java7-xin-te-xing-ji-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>以下是Java7中的引入的部分新特性。关于Java7更详细的介绍可参考<a href="http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html" target="_blank" rel="noopener">这里</a>。</p><ul><li>switch支持String</li><li>try-with-resources</li><li>catch多个异常</li><li>实例创建类型推断</li><li>数字字面量下划线分割</li><li>二进制字面量</li><li>增强的文件系统</li><li>Fork/Join框架</li><li>其它<ul><li>JDBC4.1规范</li><li>支持动态类型语言</li><li>JSR341-Expression Language Specification</li><li>JSR203-More New I/O APIs for the Java Platform</li><li>桌面客户端增强</li></ul></li></ul><h2 id="一、switch支持String"><a href="#一、switch支持String" class="headerlink" title="一、switch支持String"></a>一、switch支持String</h2><p><code>switch</code>现在可以接受<code>String</code>类型的参数。示例代码如下：</p><pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">switch</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token string">"quux"</span><span class="token operator">:</span>    <span class="token function">processQuux</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// fall-through</span><span class="token keyword">case</span> <span class="token string">"foo"</span><span class="token operator">:</span><span class="token keyword">case</span> <span class="token string">"bar"</span><span class="token operator">:</span>    <span class="token function">processFooOrBar</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token string">"baz"</span><span class="token operator">:</span>    <span class="token function">processBaz</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// fall-through</span><span class="token keyword">default</span><span class="token operator">:</span>    <span class="token function">processDefault</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="二、try-with-resources"><a href="#二、try-with-resources" class="headerlink" title="二、try-with-resources"></a>二、try-with-resources</h2><p>Java中某些资源是需要手动关闭的，如<code>InputStream</code>，<code>Writer</code>，<code>Sockets</code>，<code>Connection</code>等。这个新的语言特性允许try语句本身申请更多的资源，这些资源作用于try代码块，并自动关闭。</p><p>Java7之前的写法：</p><pre class=" language-java"><code class="language-java">BufferedReader br <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"BufferedReader Exception"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>br <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"BufferedReader close Exception"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Java7及之后的写法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span>BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"BufferedReader Exception"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="三、catch多个异常"><a href="#三、catch多个异常" class="headerlink" title="三、catch多个异常"></a>三、catch多个异常</h2><p>自Java7开始，<code>catch</code>中可以一次性捕捉多个异常做统一处理。示例如下：</p><p>Java7之前的写法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ExceptionThrower thrower <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionThrower</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        thrower<span class="token punctuation">.</span><span class="token function">manyExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionA</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionB</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionC</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Java7及之后的写法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ExceptionThrower thrower <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionThrower</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        thrower<span class="token punctuation">.</span><span class="token function">manyExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionA</span> <span class="token operator">|</span> ExceptionB ab<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ab<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionC</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="四、实例创建类型推断"><a href="#四、实例创建类型推断" class="headerlink" title="四、实例创建类型推断"></a>四、实例创建类型推断</h2><p>从Java7开始，泛型类的实例化也不用繁琐的将泛型声明再写一遍。示例如下：</p><p>Java7之前的写法：</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Java7及之后的写法：</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="五、数字字面量下划线分割"><a href="#五、数字字面量下划线分割" class="headerlink" title="五、数字字面量下划线分割"></a>五、数字字面量下划线分割</h2><p>很长的数字可读性不好，在Java 7中可以使用下划线分隔长<code>int</code>以及<code>long</code>型整数了。如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">long</span> creditCardNumber <span class="token operator">=</span> 1234_5678_9012_3456L<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ONE_MILLION <span class="token operator">=</span> 1_000_000<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> PI <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">.</span>14_15F<span class="token punctuation">;</span></code></pre><h2 id="六、二进制字面量"><a href="#六、二进制字面量" class="headerlink" title="六、二进制字面量"></a>六、二进制字面量</h2><p>现在可以使用0b前缀创建二进制字面量：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> binary <span class="token operator">=</span> 0b1001_1001<span class="token punctuation">;</span></code></pre><p>使用二进制字面量这种表示方式，使用非常简短的代码就可将二进制字符转换为数据类型，如在<code>byte</code>或<code>short</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span> aByte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0b001</span><span class="token punctuation">;</span><span class="token keyword">short</span> aShort <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span> <span class="token number">0b010</span><span class="token punctuation">;</span></code></pre><h2 id="七、增强的文件系统"><a href="#七、增强的文件系统" class="headerlink" title="七、增强的文件系统"></a>七、增强的文件系统</h2><p>Java7 推出了全新的<code>NIO2.0 API</code>以此改变针对文件管理的不便，使得在<code>java.nio.file</code>包下使用<code>Path</code>、<code>Paths</code>、<code>Files</code>、<code>WatchService</code>、<code>FileSystem</code>等常用类型可以很好的简化开发人员对文件管理的编码工作。</p><h3 id="1-Path接口和Paths类"><a href="#1-Path接口和Paths类" class="headerlink" title="1. Path接口和Paths类"></a>1. Path接口和Paths类</h3><p><code>Path</code>接口的某些功能其实可以和<code>java.io</code>包下的<code>File</code>类等价，当然这些功能仅限于只读操作。在实际开发过程中，开发人员可以联用<code>Path</code>接口和<code>Paths</code>类，从而获取文件的一系列上下文信息。</p><ul><li><code>int getNameCount()</code>: 获取当前文件节点数</li><li><code>Path getFileName()</code>: 获取当前文件名称</li><li><code>Path getRoot()</code>: 获取当前文件根目录</li><li><code>Path getParent()</code>: 获取当前文件上级关联目录</li></ul><p>联用<code>Path</code>接口和<code>Paths</code>类型获取文件信息：</p><pre class=" language-java"><code class="language-java">Path path <span class="token operator">=</span> Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"G:/test/test.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文件节点数:"</span> <span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getNameCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文件名称:"</span> <span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文件根目录:"</span> <span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文件上级关联目录:"</span> <span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-Files类"><a href="#2-Files类" class="headerlink" title="2. Files类"></a>2. Files类</h3><p>联用<code>Path</code>接口和<code>Paths</code>类可以很方便的访问到目标文件的上下文信息。当然这些操作全都是只读的，如果开发人员想对文件进行其它非只读操作，比如文件的创建、修改、删除等操作，则可以使用<code>Files</code>类型进行操作。</p><p>Files类型常用方法如下：</p><ul><li><code>Path createFile()</code>: 在指定的目标目录创建新文件</li><li><code>void delete()</code>: 删除指定目标路径的文件或文件夹</li><li><code>Path copy()</code>: 将指定目标路径的文件拷贝到另一个文件中</li><li><code>Path move()</code>: 将指定目标路径的文件转移到其他路径下，并删除源文件</li></ul><p>使用<code>Files</code>类型复制、粘贴文件示例：</p><pre class=" language-java"><code class="language-java">Files<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/test/src.xml"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/test/target.xml"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用<code>Files</code>类型来管理文件，相对于传统的I/O方式来说更加方便和简单。因为具体的操作实现将全部移交给<code>NIO2.0 API</code>，开发人员则无需关注。</p><h3 id="3-WatchService"><a href="#3-WatchService" class="headerlink" title="3. WatchService"></a>3. WatchService</h3><p>Java7 还为开发人员提供了一套全新的文件系统功能，那就是文件监测。在此或许有很多朋友并不知晓文件监测有何意义及目，那么请大家回想下调试成热发布功能后的Web容器。当项目迭代后并重新部署时，开发人员无需对其进行手动重启，因为Web容器一旦监测到文件发生改变后，便会自动去适应这些“变化”并重新进行内部装载。Web容器的热发布功能同样也是基于文件监测功能，所以不得不承认，文件监测功能的出现对于Java文件系统来说是具有重大意义的。</p><p>文件监测是基于事件驱动的，事件触发是作为监测的先决条件。开发人员可以使用<code>java.nio.file</code>包下的<code>StandardWatchEventKinds</code>类型提供的3种字面常量来定义监测事件类型，值得注意的是监测事件需要和<code>WatchService</code>实例一起进行注册。</p><p><code>StandardWatchEventKinds</code>类型提供的监测事件：</p><ul><li><code>ENTRY_CREATE</code>：文件或文件夹新建事件；</li><li><code>ENTRY_DELETE</code>：文件或文件夹删除事件；</li><li><code>ENTRY_MODIFY</code>：文件或文件夹粘贴事件；</li></ul><p>使用<code>WatchService</code>类实现文件监控完整示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 监控目标路径 */</span>    Path path <span class="token operator">=</span> Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"G:/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 创建文件监控对象. */</span>        WatchService watchService <span class="token operator">=</span> FileSystems<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newWatchService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 注册文件监控的所有事件类型. */</span>        path<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>watchService<span class="token punctuation">,</span> StandardWatchEventKinds<span class="token punctuation">.</span>ENTRY_CREATE<span class="token punctuation">,</span> StandardWatchEventKinds<span class="token punctuation">.</span>ENTRY_DELETE<span class="token punctuation">,</span>                StandardWatchEventKinds<span class="token punctuation">.</span>ENTRY_MODIFY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 循环监测文件. */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            WatchKey watchKey <span class="token operator">=</span> watchService<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 迭代触发事件的所有文件 */</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>WatchEvent<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> event <span class="token operator">:</span> watchKey<span class="token punctuation">.</span><span class="token function">pollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 事件类型："</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>watchKey<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过上述程序示例我们可以看出，使用<code>WatchService</code>接口进行文件监控非常简单和方便。首先我们需要定义好目标监控路径，然后调用<code>FileSystems</code>类型的<code>newWatchService()</code>方法创建<code>WatchService</code>对象。接下来我们还需使用<code>Path</code>接口的<code>register()</code>方法注册<code>WatchService</code>实例及监控事件。当这些基础作业层全部准备好后，我们再编写外围实时监测循环。最后迭代<code>WatchKey</code>来获取所有触发监控事件的文件即可。</p><h2 id="八、Fork-Join框架"><a href="#八、Fork-Join框架" class="headerlink" title="八、Fork/Join框架"></a>八、Fork/Join框架</h2><h3 id="1-什么是Fork-Join框架"><a href="#1-什么是Fork-Join框架" class="headerlink" title="1. 什么是Fork/Join框架"></a>1. 什么是Fork/Join框架</h3><p>Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>Fork/Join的运行流程图如下：</p><p><img src="https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png" alt="Fork/Join的运行流程图"></p><h3 id="2-工作窃取算法"><a href="#2-工作窃取算法" class="headerlink" title="2. 工作窃取算法"></a>2. 工作窃取算法</h3><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p><p><img src="https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png" alt="工作窃取的运行流程图"></p><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><h3 id="3-Fork-Join框架的介绍"><a href="#3-Fork-Join框架的介绍" class="headerlink" title="3. Fork/Join框架的介绍"></a>3. Fork/Join框架的介绍</h3><p>设计一个Fork/Join框架，主要有以下两步骤：</p><p>第一步分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</p><p>第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p><p>Fork/Join使用两个类来完成以上两件事情：</p><p>ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：<br>RecursiveAction：用于没有返回结果的任务。<br>RecursiveTask ：用于有返回结果的任务。<br>ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p><h3 id="4-Fork-Join框架使用示例"><a href="#4-Fork-Join框架使用示例" class="headerlink" title="4. Fork/Join框架使用示例"></a>4. Fork/Join框架使用示例</h3><p>让我们通过一个简单的需求来使用下<code>Fork／Join</code>框架，需求是：计算<code>1 + 2 + 3 + 4</code>的结果。</p><p>使用<code>Fork/Join</code>框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是<code>2</code>，由于是<code>4</code>个数字相加，所以<code>Fork/Join</code>框架会把这个任务<code>fork</code>成两个子任务，子任务一负责计算<code>1 + 2</code>，子任务二负责计算<code>3 + 4</code>，然后再<code>join</code>两个子任务的结果。</p><p>因为是有结果的任务，所以必须继承<code>RecursiveTask</code>，实现代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>test<span class="token punctuation">.</span>other<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ForkJoinPool<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>RecursiveTask<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * CountTask. * * @author blinkfox on 2018-01-03. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 阈值. */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 计算的开始值. */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 计算的结束值. */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param start 计算的开始值     * @param end 计算的结束值     */</span>    <span class="token keyword">public</span> <span class="token function">CountTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 执行计算的方法.     *     * @return int型结果     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果任务足够小就计算任务.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果任务大于阈值，就分裂成两个子任务来计算.</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            CountTask leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>            CountTask rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 等待子任务执行完，并得到结果，再合并执行结果.</span>            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        ForkJoinPool fkPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CountTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> fkPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result:"</span> <span class="token operator">+</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="九、其它"><a href="#九、其它" class="headerlink" title="九、其它"></a>九、其它</h2><h3 id="1-JDBC4-1规范"><a href="#1-JDBC4-1规范" class="headerlink" title="1. JDBC4.1规范"></a>1. JDBC4.1规范</h3><p>JDBC4.1主要更新了两个新特性，分别是：</p><h4 id="1-Connection，ResultSet-和-Statement-都实现了Closeable-接口"><a href="#1-Connection，ResultSet-和-Statement-都实现了Closeable-接口" class="headerlink" title="(1). Connection，ResultSet 和 Statement 都实现了Closeable 接口"></a>(1). Connection，ResultSet 和 Statement 都实现了Closeable 接口</h4><p><code>Connection</code>，<code>ResultSet</code>和<code>Statement</code>都实现了<code>Closeable</code>接口，所有在<code>try-with-resources</code>语句中调用，就可以自动关闭相关资源了。</p><h4 id="2-RowSet-1-1"><a href="#2-RowSet-1-1" class="headerlink" title="(2). RowSet 1.1"></a>(2). RowSet 1.1</h4><p>引入<code>RowSetFactory</code>接口和<code>RowSetProvider</code>类，可以创建JDBC driver支持的各种`Rowsets。</p><pre class=" language-java"><code class="language-java">RowSetFactory myRowSetFactory <span class="token operator">=</span> null<span class="token punctuation">;</span>JdbcRowSet jdbcRs <span class="token operator">=</span> null<span class="token punctuation">;</span>ResultSet rs <span class="token operator">=</span> null<span class="token punctuation">;</span>Statement stmt <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>  myRowSetFactory <span class="token operator">=</span> RowSetProvider<span class="token punctuation">.</span><span class="token function">newFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用缺省的RowSetFactory 实现</span>  jdbcRs <span class="token operator">=</span> myRowSetFactory<span class="token punctuation">.</span><span class="token function">createJdbcRowSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建一个 JdbcRowSet 对象，配置数据库连接属性</span>  jdbcRs<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:myDriver:myAttribute"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  jdbcRs<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>  jdbcRs<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>  jdbcRs<span class="token punctuation">.</span><span class="token function">setCommand</span><span class="token punctuation">(</span><span class="token string">"select ID from TEST"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  jdbcRs<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>RowSetFactory</code>接口包括了创建不同类型的RowSet的方法：</p><ul><li>createCachedRowSet</li><li>createFilteredRowSet</li><li>createJdbcRowSet</li><li>createJoinRowSet</li><li>createWebRowSet</li></ul><h3 id="2-略"><a href="#2-略" class="headerlink" title="2. 略"></a>2. 略</h3><hr><p>参考文档：</p><ul><li><a href="http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html" target="_blank" rel="noopener">JavaSE7 Features and Enhancements</a></li><li><a href="https://segmentfault.com/a/1190000004417830" target="_blank" rel="noopener">Java7的新特性</a></li><li><a href="http://www.infoq.com/cn/articles/fork-join-introduction" target="_blank" rel="noopener">Fork/Join框架介绍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java6新特性及使用</title>
      <link href="/2018/11/11/hou-duan/java/java6-xin-te-xing-ji-shi-yong/"/>
      <url>/2018/11/11/hou-duan/java/java6-xin-te-xing-ji-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>以下是Java6中的引入的部分新特性，相比Java5的新特性就少了很多了。关于Java6更详细的介绍可参考<a href="http://www.oracle.com/technetwork/java/javase/features-141434.html" target="_blank" rel="noopener">这里</a>。</p><ul><li>Web Services Metadata</li><li>Scripting</li><li>Compiler API</li><li>Light-weight HTTP server</li><li>Common annotations(JSR 250)</li><li>StAX</li><li>JAXB2</li><li>Console</li><li>Java DB(Derby)</li><li>JDBC 4.0</li><li>值得关注的<ul><li>集合框架增强</li></ul></li><li>其它<ul><li>GUI增强</li></ul></li></ul><h2 id="一、Web-Services-Metadata"><a href="#一、Web-Services-Metadata" class="headerlink" title="一、Web Services Metadata"></a>一、Web Services Metadata</h2><p><code>WebService</code>是一种独立于特定语言、特定平台，基于网络的、分布式的模块化组件。是一个能够使用<code>xml</code>消息通过网络来访问的接口，这个接口描述了一组可访问的操作。在Java6中，在想要发布为<code>WebService</code>的类上加上<code>@WebService</code>的注解，这个类的方法就变为<code>WebService</code>方法了，再通过<code>Endpoint.publish()</code>方法发布这个服务。到此，一个最简单的<code>WebService</code>搞定。运行<code>main</code>方法，在浏览器里输入<code>http://localhost:8080/com.thunisoft.sacweq.dataflow.organ.test.Hello?wsdl</code>，即可查看你WebService的WSDL信息。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> javax<span class="token punctuation">.</span>jws<span class="token punctuation">.</span>WebService<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>ws<span class="token punctuation">.</span>Endpoint<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Hello. * @author blinkfox on 2017-11-28. */</span><span class="token annotation punctuation">@WebService</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>Hello<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * sayHello.     * @param name 名称     * @return 结果     */</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello "</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @param args     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Endpoint<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8080/com.thunisoft.sacweq.dataflow.organ.test.Hello"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"调用成功!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Java 自从JDK5中添加了元数据功能(注解)之后,SUN几乎重构了整个J2EE体系，由于变化很大，干脆将名字也重构为Java EE，Java EE(当前版本为5.0)将元数据纳入很多规范当中，这其中就包括<code>Web Services</code>的相关规范，这显然比以前的JAX-RPC编程模型简单(当然, Axis的编程模型也很简单)。这里要谈的Web服务元数据(JSR 181)只是Java Web 服务规范中的一个,它跟Common Annotations, JAXB2, StAX, SAAJ和JAX-WS等共同构成Java EE 5的Web Services技术堆栈。</p><p>下面介绍<code>JSR-181</code>里面各个元数据的相关参数及用途。</p><table><thead><tr><th>Annotation</th><th>Retention</th><th>Target</th><th>Description</th></tr></thead><tbody><tr><td>WebService</td><td>Runtime</td><td>Type</td><td>标注要暴露为Web Services的类或接口</td></tr><tr><td>WebParam</td><td>Runtime</td><td>Parameter</td><td>自定义服务方法参数到WSDL的映射</td></tr><tr><td>WebResult</td><td>Runtime</td><td>Method</td><td>自定义服务方法返回值到WSDL的映射</td></tr><tr><td>WebMethod</td><td>Runtime</td><td>Method</td><td>自定义单个服务方法到WSDL的映射</td></tr><tr><td>Oneway</td><td>Runtime</td><td>Method</td><td>必须与@WebMethod连用,表明被标注方法只有输入没有输出,这就要求被标注方法不能有返回值,也不能声明checked exception</td></tr><tr><td>HandlerChain</td><td>Runtime</td><td>Type,Method,Field</td><td>将Web服务与外部Handler chain关联起来</td></tr><tr><td>SOAPBinding</td><td>Runtime</td><td>Type,Method</td><td>自定义<code>SOAPBinding</code></td></tr></tbody></table><h2 id="二、Scripting"><a href="#二、Scripting" class="headerlink" title="二、Scripting"></a>二、Scripting</h2><p>Java6增加了对动态语言的支持，原理上是将脚本语言编译成字节码，这样脚本语言也能享用Java平台的诸多优势，包括可移植性，安全等。另外由于现在是编译成字节码后再执行，所以比原来边解释边执行效率要高很多。可以很好的利用脚本语言的动态特性，主要支持的有<code>JavaSrcipt</code>、<code>Ruby</code>、<code>Python</code>等。</p><p>以下使用<code>JavaScript</code>的脚本，代码示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>Invocable<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>ScriptEngine<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>ScriptEngineManager<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span>ScriptException<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * JsTest. * @author blinkfox * @version 1.0 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JsTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>Hello<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * main方法.     * @param args 数组参数     * @throws ScriptException 脚本异常     * @throws NoSuchMethodException 无方法异常     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ScriptException<span class="token punctuation">,</span> NoSuchMethodException <span class="token punctuation">{</span>        ScriptEngineManager enjineManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScriptEngineManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ScriptEngine engine <span class="token operator">=</span> enjineManager<span class="token punctuation">.</span><span class="token function">getEngineByName</span><span class="token punctuation">(</span><span class="token string">"JavaScript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String script<span class="token operator">=</span><span class="token string">"function hello(name){return 'Hello ' + name}"</span><span class="token punctuation">;</span>        engine<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>        Invocable inv<span class="token operator">=</span><span class="token punctuation">(</span>Invocable<span class="token punctuation">)</span> engine<span class="token punctuation">;</span>        String result <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> inv<span class="token punctuation">.</span><span class="token function">invokeFunction</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"blinkfox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"脚本执行结果:{}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="三、Compiler-API"><a href="#三、Compiler-API" class="headerlink" title="三、Compiler API"></a>三、Compiler API</h2><p>在Java6中提供了一套<code>Compiler API</code>，定义在<code>JSR199</code>中, 提供在运行期动态编译java代码为字节码的功能。一套API就好比是在java程序中模拟javac程序，将Java源文件编译为class文件；其提供的默认实现也正是在文件系统上进行查找、编译工作的。<code>Compiler API</code>结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。</p><p>基本使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaCompilerAPICompiler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">compile</span><span class="token punctuation">(</span>Path src<span class="token punctuation">,</span> Path output<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        JavaCompiler compiler <span class="token operator">=</span> ToolProvider<span class="token punctuation">.</span><span class="token function">getSystemJavaCompiler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>StandardJavaFileManager fileManager <span class="token operator">=</span> compiler<span class="token punctuation">.</span><span class="token function">getStandardFileManager</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Iterable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">JavaFileObject</span><span class="token operator">></span> compilationUnits <span class="token operator">=</span> fileManager<span class="token punctuation">.</span><span class="token function">getJavaFileObjects</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Iterable<span class="token operator">&lt;</span>String<span class="token operator">></span> options <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"-d"</span><span class="token punctuation">,</span> output<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            JavaCompiler<span class="token punctuation">.</span>CompilationTask task <span class="token operator">=</span> compiler<span class="token punctuation">.</span><span class="token function">getTask</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> fileManager<span class="token punctuation">,</span> null<span class="token punctuation">,</span> options<span class="token punctuation">,</span> null<span class="token punctuation">,</span> compilationUnits<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="四、轻量级HTTP-server"><a href="#四、轻量级HTTP-server" class="headerlink" title="四、轻量级HTTP server"></a>四、轻量级HTTP server</h2><p>JDK6提供了一个轻量级的<code>Http Server API</code>，据此我们可以构建自己的嵌入式Http Server，它支持<code>Http</code>和<code>Https</code>协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现，程序员必须自己实现<code>HttpHandler</code>接口，HttpServer会调用<code>HttpHandler</code>实现类的回调方法来处理客户端请求，在这里，我们把一个Http请求和它的响应称为一个交换,包装成<code>HttpExchange</code>类,HttpServer负责将<code>HttpExchange</code>传给<code>HttpHandler</code>实现类的回调方法。</p><p>以下是通过JDK6新特性能够实现的HttpServer的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>net<span class="token punctuation">.</span>httpserver<span class="token punctuation">.</span>HttpExchange<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>net<span class="token punctuation">.</span>httpserver<span class="token punctuation">.</span>HttpHandler<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>net<span class="token punctuation">.</span>httpserver<span class="token punctuation">.</span>HttpServer<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>net<span class="token punctuation">.</span>httpserver<span class="token punctuation">.</span>spi<span class="token punctuation">.</span>HttpServerProvider<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetSocketAddress<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 自定义的http服务器. * * @author blinkfox on 2017-12-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyHttpServer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 启动服务，监听来自客户端的请求.     *     * @throws IOException IO异常     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">httpserverService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        HttpServerProvider provider <span class="token operator">=</span> HttpServerProvider<span class="token punctuation">.</span><span class="token function">provider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpServer httpserver <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">createHttpServer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 监听端口8888,能同时接受100个请求</span>        httpserver<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">"/mytest"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MyHttpHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        httpserver<span class="token punctuation">.</span><span class="token function">setExecutor</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        httpserver<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"server started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Http请求处理类.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyHttpHandler</span> <span class="token keyword">implements</span> <span class="token class-name">HttpHandler</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>HttpExchange httpExchange<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>            String responseMsg <span class="token operator">=</span> <span class="token string">"ok"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//响应信息</span>            InputStream in <span class="token operator">=</span> httpExchange<span class="token punctuation">.</span><span class="token function">getRequestBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获得输入流</span>            BufferedReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String temp <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"client request:"</span> <span class="token operator">+</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            httpExchange<span class="token punctuation">.</span><span class="token function">sendResponseHeaders</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> responseMsg<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置响应头属性及响应信息的长度</span>            OutputStream out <span class="token operator">=</span> httpExchange<span class="token punctuation">.</span><span class="token function">getResponseBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//获得输出流</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>responseMsg<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            httpExchange<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token function">httpserverService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>HttpURLConnection<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Http服务器测试类. * * @author blinkfox on 2017-12-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService exec <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 测试并发对MyHttpServer的影响</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Runnable run <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token function">startWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            exec<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>run<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        exec<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 关闭线程池</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">startWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        URL url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"http://127.0.0.1:8888/mytest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpURLConnection urlConn <span class="token operator">=</span> <span class="token punctuation">(</span>HttpURLConnection<span class="token punctuation">)</span> url<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        urlConn<span class="token punctuation">.</span><span class="token function">setDoOutput</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        urlConn<span class="token punctuation">.</span><span class="token function">setDoInput</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        urlConn<span class="token punctuation">.</span><span class="token function">setRequestMethod</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 测试内容包</span>        String teststr <span class="token operator">=</span> <span class="token string">"this is a test message"</span><span class="token punctuation">;</span>        OutputStream out <span class="token operator">=</span> urlConn<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>teststr<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>urlConn<span class="token punctuation">.</span><span class="token function">getContentLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>urlConn<span class="token punctuation">.</span><span class="token function">getResponseCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                InputStream in <span class="token operator">=</span> urlConn<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                BufferedReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String temp <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>temp <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"server response:"</span> <span class="token operator">+</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 打印收到的信息</span>                <span class="token punctuation">}</span>                reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                urlConn<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、Common-annotations"><a href="#五、Common-annotations" class="headerlink" title="五、Common annotations"></a>五、Common annotations</h2><p><code>Common annotations</code>原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。</p><p>下面列举出<code>Common Annotations 1.0</code>里面的10个<code>Annotations</code>：</p><table><thead><tr><th style="text-align:left"><strong>Annotation</strong></th><th style="text-align:center"><strong>Retention</strong></th><th style="text-align:left"><strong>Target</strong></th><th style="text-align:left"><strong>Description</strong></th></tr></thead><tbody><tr><td style="text-align:left">Generated</td><td style="text-align:center">Source</td><td style="text-align:left">ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE</td><td style="text-align:left">用于标注生成的源代码</td></tr><tr><td style="text-align:left">Resource</td><td style="text-align:center">Runtime</td><td style="text-align:left">TYPE, METHOD, FIELD</td><td style="text-align:left">用于标注所依赖的资源,容器据此注入外部资源依赖，有基于字段的注入和基于setter方法的注入两种方式</td></tr><tr><td style="text-align:left">Resources</td><td style="text-align:center">Runtime</td><td style="text-align:left">TYPE</td><td style="text-align:left">同时标注多个外部依赖，容器会把所有这些外部依赖注入</td></tr><tr><td style="text-align:left">PostConstruct</td><td style="text-align:center">Runtime</td><td style="text-align:left">METHOD</td><td style="text-align:left">标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostConstruct</td></tr><tr><td style="text-align:left">PreDestroy</td><td style="text-align:center">Runtime</td><td style="text-align:left">METHOD</td><td style="text-align:left">当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy</td></tr><tr><td style="text-align:left">RunAs</td><td style="text-align:center">Runtime</td><td style="text-align:left">TYPE</td><td style="text-align:left">用于标注用什么安全角色来执行被标注类的方法，这个安全角色必须和Container 的Security角色一致的</td></tr><tr><td style="text-align:left">RolesAllowed</td><td style="text-align:center">Runtime</td><td style="text-align:left">TYPE, METHOD</td><td style="text-align:left">用于标注允许执行被标注类或方法的安全角色，这个安全角色必须和Container 的Security角色一致的</td></tr><tr><td style="text-align:left">PermitAll</td><td style="text-align:center">Runtime</td><td style="text-align:left">TYPE, METHOD</td><td style="text-align:left">允许所有角色执行被标注的类或方法</td></tr><tr><td style="text-align:left">DenyAll</td><td style="text-align:center">Runtime</td><td style="text-align:left">TYPE, METHOD</td><td style="text-align:left">不允许任何角色执行被标注的类或方法，表明该类或方法不能在Java EE容器里面运行</td></tr><tr><td style="text-align:left">DeclareRoles</td><td style="text-align:center">Runtime</td><td style="text-align:left">TYPE</td><td style="text-align:left">用来定义可以被应用程序检验的安全角色，通常用isUserInRole来检验安全角色</td></tr></tbody></table><h2 id="六、StAX"><a href="#六、StAX" class="headerlink" title="六、StAX"></a>六、StAX</h2><p>StAX(JSR 173)是JDK6中新增的除了DOM和SAX之外的又一种处理XML文档的API。</p><p><code>StAX</code>是<code>The Streaming API for XML</code>的缩写，一种利用拉模式解析(pull-parsing)XML文档的API。StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。</p><p>下面是这几种XML解析API的特性比较：</p><table><thead><tr><th>Feature</th><th>StAX</th><th>SAX</th><th>DOM</th><th>TrAX</th></tr></thead><tbody><tr><td>API Type</td><td>Pull, streaming</td><td>Push, streaming</td><td>In memory tree</td><td>XSLT Rule</td></tr><tr><td>Ease of Use</td><td>High</td><td>Medium</td><td>High</td><td>Medium</td></tr><tr><td>XPath Capability</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>CPU and Memory Efficiency</td><td>Good</td><td>Good</td><td>Varies</td><td>Varies</td></tr><tr><td>Forward Only</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>Read XML</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Write XML</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>Create, Read, Update, Delete</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr></tbody></table><p>下面代码演示了如何通过StAX读取xml文档和生成xml文档：</p><p>需要读取的xml文件：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>catalogs</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>catalog</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>001<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Book<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>catalog</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>catalog</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>002<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Video<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>catalog</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>catalogs</span><span class="token punctuation">></span></span></code></pre><p>读和写XML文件的Java代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileInputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>namespace<span class="token punctuation">.</span>QName<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>events<span class="token punctuation">.</span>StartElement<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>events<span class="token punctuation">.</span>XMLEvent<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Stax测试类. * * @author blinkfox on 2017-12-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaxTester</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 根据StAX读取XML文件.     *     * @throws XMLStreamException XML流异常     * @throws FileNotFoundException 文件未找到异常     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">readXxmlByStax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> XMLStreamException<span class="token punctuation">,</span> FileNotFoundException <span class="token punctuation">{</span>        XMLInputFactory xmlif <span class="token operator">=</span> XMLInputFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        XMLEventReader xmler <span class="token operator">=</span> xmlif<span class="token punctuation">.</span><span class="token function">createXMLEventReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"G:\\test\\test.xml"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        XMLEvent event<span class="token punctuation">;</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>xmler<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            event <span class="token operator">=</span> xmler<span class="token punctuation">.</span><span class="token function">nextEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">isStartElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果解析的是起始标记</span>                StartElement element <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">asStartElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&lt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>element<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>element<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLocalPart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"catalog"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" id=/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>element<span class="token punctuation">.</span><span class="token function">getAttributeByName</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">QName</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">">"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">isCharacters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果解析的是文本内容</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">asCharacters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">isEndElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果解析的是结束标记</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&lt;/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">asEndElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">">"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 根据StAX写入XML文件.     *     * @throws XMLStreamException XML流异常     * @throws FileNotFoundException 文件未找到异常     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeXmlByStax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> XMLStreamException<span class="token punctuation">,</span> FileNotFoundException <span class="token punctuation">{</span>        XMLOutputFactory xmlof <span class="token operator">=</span> XMLOutputFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        XMLStreamWriter xmlw <span class="token operator">=</span> xmlof<span class="token punctuation">.</span><span class="token function">createXMLStreamWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"G:\\test\\output.xml"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写入默认的 XML 声明到xml文档</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeStartDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeCharacters</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写入注释到xml文档</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeComment</span><span class="token punctuation">(</span><span class="token string">"testing comment"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeCharacters</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写入一个catalogs根元素</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeStartElement</span><span class="token punctuation">(</span><span class="token string">"catalogs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeNamespace</span><span class="token punctuation">(</span><span class="token string">"myNS"</span><span class="token punctuation">,</span> <span class="token string">"http://blinkfox.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeAttribute</span><span class="token punctuation">(</span><span class="token string">"owner"</span><span class="token punctuation">,</span><span class="token string">"Chinajash"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeCharacters</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写入子元素catalog</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeCharacters</span><span class="token punctuation">(</span><span class="token string">"    "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeStartElement</span><span class="token punctuation">(</span><span class="token string">"http://blinkfox.com"</span><span class="token punctuation">,</span> <span class="token string">"catalog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeAttribute</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span><span class="token string">"007"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeCharacters</span><span class="token punctuation">(</span><span class="token string">"Apparel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写入catalog元素的结束标签</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeEndElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写入catalogs元素的结束标签</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeCharacters</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeEndElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 结束 XML 文档</span>        xmlw<span class="token punctuation">.</span><span class="token function">writeEndDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xmlw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生成xml文件成功!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     * @throws XMLStreamException XML流异常     * @throws FileNotFoundException 文件未找到异常     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> XMLStreamException<span class="token punctuation">,</span> FileNotFoundException <span class="token punctuation">{</span>        <span class="token function">readXxmlByStax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">writeXmlByStax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行上面程序后，控制台输出如下:</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>catalogs<span class="token operator">></span>    <span class="token operator">&lt;</span>catalog id<span class="token operator">=</span>/001/<span class="token operator">></span>Book<span class="token operator">&lt;</span>/catalog<span class="token operator">></span>    <span class="token operator">&lt;</span>catalog id<span class="token operator">=</span>/002/<span class="token operator">></span>Video<span class="token operator">&lt;</span>/catalog<span class="token operator">></span><span class="token operator">&lt;</span>/catalogs<span class="token operator">></span>生成xml文件成功<span class="token operator">!</span></code></pre><p>产生的<code>output.xml</code>文件如下:</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" ?></span><span class="token comment" spellcheck="true">&lt;!--testing comment--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>catalogs</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>myNS</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://blinkfox.com<span class="token punctuation">"</span></span> <span class="token attr-name">owner</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Chinajash<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">myNS:</span>catalog</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>007<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Apparel<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">myNS:</span>catalog</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>catalogs</span><span class="token punctuation">></span></span></code></pre><h2 id="七、JAXB2"><a href="#七、JAXB2" class="headerlink" title="七、JAXB2"></a>七、JAXB2</h2><p><code>JAXB</code>是<code>Java Architecture for XML Binding</code>的缩写，可以将一个Java对象转变成为XML格式，反之亦然。我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为<code>OXM</code>(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性<code>Annotation</code>来标识要作绑定的类和属性等，这就极大简化了开发的工作量。实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。 下面用代码演示在JDK6中如何来用<code>JAXB2</code>：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Gender性别枚举类. * * @author blinkfox on 2017-12-04. */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Gender <span class="token punctuation">{</span>    <span class="token function">MALE</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">FEMALE</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> code<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     * @param code 性别值     */</span>    <span class="token function">Gender</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>XmlAttribute<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>XmlElement<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Address地址类. * * @author blinkfox on 2017-12-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@XmlAttribute</span>    String country<span class="token punctuation">;</span>    <span class="token annotation punctuation">@XmlElement</span>    String state<span class="token punctuation">;</span>    <span class="token annotation punctuation">@XmlElement</span>    String city<span class="token punctuation">;</span>    <span class="token annotation punctuation">@XmlElement</span>    String street<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 由于没有添加@XmlElement,所以该元素不会出现在输出的xml中. */</span>    String zipcode<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 默认的空构造方法.     */</span>    <span class="token keyword">public</span> <span class="token function">Address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Address</span><span class="token punctuation">(</span>String country<span class="token punctuation">,</span> String state<span class="token punctuation">,</span> String city<span class="token punctuation">,</span> String street<span class="token punctuation">,</span> String zipcode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>country <span class="token operator">=</span> country<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>street <span class="token operator">=</span> street<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>zipcode <span class="token operator">=</span> zipcode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * country的getter方法.     *     * @return country     */</span>    <span class="token keyword">public</span> String <span class="token function">getCountry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> country<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Calendar<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>XmlAttribute<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>XmlElement<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>XmlRootElement<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Person类. * * @author blinkfox on 2017-12-04. */</span><span class="token annotation punctuation">@XmlRootElement</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** birthday将作为person的子元素. */</span>    <span class="token annotation punctuation">@XmlElement</span>    Calendar birthDay<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** name将作为person的的一个属性. */</span>    <span class="token annotation punctuation">@XmlAttribute</span>    String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** address将作为person的子元素. */</span>    <span class="token annotation punctuation">@XmlElement</span>    Address address<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** gender将作为person的子元素. */</span>    <span class="token annotation punctuation">@XmlElement</span>    Gender gender<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** job将作为person的子元素. */</span>    <span class="token annotation punctuation">@XmlElement</span>    String job<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 默认的空构造方法.     */</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>Calendar birthDay<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> Address address<span class="token punctuation">,</span> Gender gender<span class="token punctuation">,</span> String job<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>birthDay <span class="token operator">=</span> birthDay<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * address的getter方法.     * @return address     */</span>    <span class="token keyword">public</span> Address <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileWriter<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Calendar<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>JAXBContext<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>Marshaller<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>Unmarshaller<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOUtils<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * JAXB2测试类. * * @author blinkfox on 2017-12-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JAXB2Test</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>JAXB2Test<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Address address <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token string">"中国"</span><span class="token punctuation">,</span> <span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上地"</span><span class="token punctuation">,</span> <span class="token string">"100080"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"JAXB2"</span><span class="token punctuation">,</span> address<span class="token punctuation">,</span> Gender<span class="token punctuation">.</span>MALE<span class="token punctuation">,</span> <span class="token string">"软件工程师"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileReader reader <span class="token operator">=</span> null<span class="token punctuation">;</span>        FileWriter writer <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 生成xml文件.</span>            JAXBContext context <span class="token operator">=</span> JAXBContext<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"G:/test/person.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Marshaller m <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">createMarshaller</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m<span class="token punctuation">.</span><span class="token function">marshal</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> writer<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"生成person.xml文件成功!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 读取xml文件.</span>            reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"G:/test/person.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Unmarshaller um <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">createUnmarshaller</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Person p2 <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> um<span class="token punctuation">.</span><span class="token function">unmarshal</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Country:{}"</span><span class="token punctuation">,</span> p2<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCountry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"生成和读取XML文件出错！"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            IOUtils<span class="token punctuation">.</span><span class="token function">closeQuietly</span><span class="token punctuation">(</span>writer<span class="token punctuation">)</span><span class="token punctuation">;</span>            IOUtils<span class="token punctuation">.</span><span class="token function">closeQuietly</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行该程序，我们会得到一个<code>person.xml</code>的文件，内容如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>person</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JAXB2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>birthDay</span><span class="token punctuation">></span></span>2017-12-04T17:16:19.226+08:00<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>birthDay</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>address</span> <span class="token attr-name">country</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>中国<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">></span></span>北京<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>city</span><span class="token punctuation">></span></span>北京<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>city</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>street</span><span class="token punctuation">></span></span>上地<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>street</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>address</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gender</span><span class="token punctuation">></span></span>MALE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gender</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>job</span><span class="token punctuation">></span></span>软件工程师<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>job</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>person</span><span class="token punctuation">></span></span></code></pre><h2 id="八、Console"><a href="#八、Console" class="headerlink" title="八、Console"></a>八、Console</h2><p>JDK6中提供了<code>java.io.Console</code>类专用来访问基于字符的控制台设备。你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用。如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的Console实例。下面代码演示了Console类的用法:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Console<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Jdk6之Console测试类. * * @author blinkfox on 2017-12-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsoleTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获得Console实例，并判断console是否可用</span>        Console console <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">console</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>console <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 读取整行字符和密码，密码输入时不会显示</span>            String user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token string">"请输入用户名:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String pwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span><span class="token function">readPassword</span><span class="token punctuation">(</span><span class="token string">"再输入密码:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"用户名是:"</span> <span class="token operator">+</span> user <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"密码是:"</span> <span class="token operator">+</span> pwd <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Console不可用!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编译该代码，并在命令行中输入：<code>java ConsoleTest</code>，然后即可运行，运行示例如下：</p><pre class=" language-bash"><code class="language-bash">请输入用户名:张三再输入密码:打印出的用户名是:张三打印出的密码是:123456</code></pre><blockquote><p><strong>注</strong>: 在这里可以看到输入密码时,控制台时不显示这些密码字符的,但是程序可以得到输入的密码字符串,这与Linux下面输入密码的情况是一样的。</p></blockquote><h2 id="九、Java-DB-Derby"><a href="#九、Java-DB-Derby" class="headerlink" title="九、Java DB(Derby)"></a>九、Java DB(Derby)</h2><p>从JDK6开始，JDK目录中新增了一个名为<code>db</code>的目录。这便是 Java 6 的新成员：Java DB。这是一个纯 Java 实现、开源的数据库管理系统（DBMS），源于 Apache 软件基金会（ASF）名下的项目<code>Derby</code>。它只有 2MB 大小，对比动辄上 G 的数据库来说可谓袖珍。但这并不妨碍 Derby 功能齐备，支持几乎大部分的数据库应用所需要的特性。JDK6.0里面带的这个Derby的版本是10.2.1.7,支持存储过程和触发器；有两种运行模式，一种是作为嵌入式数据库，另一种是作为网络数据库。前者的数据库服务器和客户端都在同一个JVM里面运行，后者允许数据库服务器端和客户端不在同一个JVM里面，而且允许这两者在不同的物理机器上。值得注意的是JDK6里面的这个Derby支持JDK6的新特性<code>JDBC 4.0</code>规范(JSR 221)。</p><p>下面分两种情况演示一下如何用代码操作Derby数据库，一种是嵌入式数据库，一种是网络数据库。</p><h3 id="1-嵌入式数据库"><a href="#1-嵌入式数据库" class="headerlink" title="1. 嵌入式数据库"></a>1. 嵌入式数据库</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>learn<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>JdbcDaoHelper<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Derby内嵌数据库测试示例. * * @author blinkfox on 2017-12-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmbeddedDerbyTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>EmbeddedDerbyTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Derby驱动,在derby.jar里面. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DRIVER <span class="token operator">=</span> <span class="token string">"org.apache.derby.jdbc.EmbeddedDriver"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 连接Derby的url，create=true表示当数据库不存在时就创建它. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String URL <span class="token operator">=</span> <span class="token string">"jdbc:derby:EmbeddedDB;create=true"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>        Statement st <span class="token operator">=</span> null<span class="token punctuation">;</span>        ResultSet rs <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>DRIVER<span class="token punctuation">)</span><span class="token punctuation">;</span>            conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//启动嵌入式数据库</span>            st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token string">"create table foo (FOOID INT NOT NULL, FOONAME VARCHAR(30) NOT NULL)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建foo表</span>            st<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token string">"insert into foo(FOOID,FOONAME) values (1, 'blinkfox')"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//插入一条数据</span>            rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token string">"select * from foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//读取刚插入的数据</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> id <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"查询结果：id = {}; name = {}"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"使用Derby数据库出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            JdbcDaoHelper<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span><span class="token punctuation">;</span>            JdbcDaoHelper<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>            JdbcDaoHelper<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行上面程序后，会在当前目录生成名为<code>EmbeddedDB</code>的文件夹，既是<code>EmbeddedDB</code>数据库的数据文件存放的地方，控制台将输出：</p><pre class=" language-bash"><code class="language-bash">查询结果：id <span class="token operator">=</span> 1<span class="token punctuation">;</span> name <span class="token operator">=</span> blinkfox</code></pre><h3 id="2-网络数据库"><a href="#2-网络数据库" class="headerlink" title="2. 网络数据库"></a>2. 网络数据库</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>PrintWriter<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>DriverManager<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>derby<span class="token punctuation">.</span>drda<span class="token punctuation">.</span>NetworkServerControl<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Derby网络数据库测试示例. * * @author blinkfox on 2017-12-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NetworkServerDerbyTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>NetworkServerDerbyTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Derby驱动,在derbyclient.jar里面. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DRIVER <span class="token operator">=</span> <span class="token string">"org.apache.derby.jdbc.ClientDriver"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 连接Derby的url. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String URL <span class="token operator">=</span> <span class="token string">"jdbc:derby://localhost:1527/NetworkDB;create=true"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * main方法.     * &lt;p>创建Derby网络服务器,默认端口是1527,也可以通过运行&lt;Derby_Home>/frameworks/NetworkServer/bin/startNetworkServer.bat     来创建并启动Derby网络服务器,如果是Unix,用startNetworkServer.ksh&lt;/p>     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        NetworkServerControl derbyServer <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//NetworkServerControl类在derbynet.jar里面</span>            derbyServer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NetworkServerControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            PrintWriter pw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用系统输出作为Derby数据库的输出</span>            derbyServer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//启动Derby服务器</span>            Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>DRIVER<span class="token punctuation">)</span><span class="token punctuation">;</span>            DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"操作Derby网络数据库异常!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>derbyServer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    derbyServer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"关闭Derby网络数据库异常!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行上面程序后,会在当前目录生成名为<code>NetworkDB</code>的文件夹。关于<code>Derby</code>的详细情况,请参考<a href="http://db.apache.org/derby" target="_blank" rel="noopener">http://db.apache.org/derby</a>。</p><h2 id="十、JDBC-4-0"><a href="#十、JDBC-4-0" class="headerlink" title="十、JDBC 4.0"></a>十、JDBC 4.0</h2><p>在 Java SE 6 所提供的诸多新特性和改进中，值得一提的是为 Java 程序提供数据库访问机制的 JDBC 版本升级到了 4.0, 这个以 JSR-221 为代号的版本，提供了更加便利的代码编写机制及柔性，并且支持更多的数据类型。JDBC4.0 主要有以下改进和新特性。</p><ul><li>自动加载<code>java.sql.Driver</code>，而不需要再调用<code>class.forName</code>；</li><li>添加了<code>java.sql.RowId</code>数据类型用来可以访问<code>sql rowid</code>；</li><li>添加了<code>National Character Set</code>的支持；</li><li>增强了<code>BLOB</code>和<code>CLOB</code>的支持功能；</li><li><code>SQL/XML</code>和<code>XML</code>支持；</li><li><code>Wrapper Pattern</code>；</li><li><code>SQLException</code>增强；</li><li><code>Connection</code>和<code>Statement</code>接口增强；</li><li><code>New Scalar Funtions</code>；</li><li><code>JDBC API changes</code>。</li></ul><h2 id="十一、值得关注的"><a href="#十一、值得关注的" class="headerlink" title="十一、值得关注的"></a>十一、值得关注的</h2><h3 id="1-集合框架增强"><a href="#1-集合框架增强" class="headerlink" title="1. 集合框架增强"></a>1. 集合框架增强</h3><p>Jdk6中的集合框架的API更改数量要少于JDK5，更多地关注了规范的准确性和清晰度。即使在编写旧版本的程序时，我们也建议使用Java SE 6规范。<br>API更改的主要主题是更好的双向收集访问。</p><p>新增了以下几个接口：</p><ul><li><code>Deque</code>: 双端队列接口，继承了Queue接口，队列两头都可以实现入队和出队。</li><li><code>BlockingDeque</code>: 双端阻塞队列接口，继承了BlockingQueue、Deque接口。</li><li><code>NavigableSet</code>: 可导航Set接口，继承自SortedSet接口。</li><li><code>NavigableMap</code>: 可导航Map接口，继承自SortedMap接口。</li><li><code>ConcurrentNavigableMap</code>: 支持并发的可导航Map，继承自<code>ConcurrentMap</code>接口和<code>NavigableMap</code>接口。</li></ul><p>新增了以下几个实现类：</p><ul><li><code>ArrayDeque</code>: 底层采用了循环数组的方式来完成双端队列的实现，无限扩展且可选容量。Java已不推荐使用Stack，而是推荐使用更高效的<code>ArrayDeque</code>来实现栈的功能，非线程安全。</li><li><code>ConcurrentSkipListSet</code>: 底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeSet功能相似，线程安全。</li><li><code>ConcurrentSkipListMap</code>: 底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeMap功能相似，是一个并发的、可排序的Map，线程安全。因此它可以在多线程环境中弥补ConcurrentHashMap不支持排序的问题。</li><li><code>LinkedBlockingDeque</code>: 底层采用了双向链表实现的双端阻塞并发队列，无限扩展且可选容量。该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。</li><li><code>AbstractMap.SimpleEntry</code>: <code>Map.Entry</code>的简单可变实现。</li><li><code>AbstractMap.SimpleImmutableEntry</code>: <code>Map.Entry</code>的简单不可变实现。</li></ul><p>以下的类已经被改进来用来实现新的接口：</p><ul><li><code>LinkedList</code>: 改进以实现Deque接口。</li><li><code>TreeSet</code>: 改进以实现NavigableSet接口。</li><li><code>TreeMap</code>: 改进以实现NavigableMap接口。</li></ul><p>新增了两个新的方法到<code>Collections</code>的工具类中：</p><ul><li><code>newSetFromMap(Map)</code>: 从通用的Map实现中创建一个通用的Set实现。Java集合中有<code>IdentityHashMap</code>，但是没有<code>IdentityHashSet</code>类，我们可以通过这样的方式来实现：</li></ul><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Object<span class="token operator">></span> identityHashSet <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">newSetFromMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IdentityHashMap</span><span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Boolean<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><code>asLifoQueue(Deque)</code>: 通过传入<code>Deque</code>得到一个后进先出(LIFO)的队列。</li></ul><p>现在<code>Arrays</code>工具类，具有<code>copyOf</code>和<code>copyOfRange</code>方法，可以有效地调整，截断或复制所有类型的数组的子数组。</p><p>以前是这样实现的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>newLength<span class="token punctuation">]</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>oldArray<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newArray<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>现在可以这样实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArray <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><p>参考文档：</p><p>-<a href="http://www.oracle.com/technetwork/java/javase/features-141434.html" target="_blank" rel="noopener">JavaSE6 Features and Enhancements</a><br>-<a href="https://segmentfault.com/a/1190000004417536" target="_blank" rel="noopener">Java6的新特性</a><br>-<a href="http://my.csdn.net/Chinajash" target="_blank" rel="noopener">chinajash</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java5新特性及使用</title>
      <link href="/2018/11/09/hou-duan/java/java5-xin-te-xing-ji-shi-yong/"/>
      <url>/2018/11/09/hou-duan/java/java5-xin-te-xing-ji-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>以下是Java5中的引入的部分新特性，关于更详细的新特性了解，可参考<a href="https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html" target="_blank" rel="noopener">这里</a>。</p><ul><li>泛型(Generics)</li><li>增强for循环(Enhanced for Loop)</li><li>自动装箱拆箱(Autoboxing/Unboxing)</li><li>枚举(Enums)</li><li>可变参数(Varargs)</li><li>静态导入(Static Import)</li><li>注解(Annotations)</li><li>值得关注<ul><li>进程构建器(ProcessBuilder)</li><li>格式化(Formatter)</li><li>扫描器(Scanner)</li><li>反射(Reflection)</li><li>集合框架(Collections Framework)</li><li>并发工具类(Concurrency Utilities)</li><li>StringBuilder</li></ul></li><li>其它(others)</li></ul><h2 id="一、泛型-Generics"><a href="#一、泛型-Generics" class="headerlink" title="一、泛型(Generics)"></a>一、泛型(Generics)</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>Java语言引入泛型的好处是安全简单。可以将运行时错误提前到编译时错误。在Java5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的<strong>任意化</strong>，<strong>任意化</strong>带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</p><p>泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法中，分别称为泛型类、泛型接口、泛型方法。</p><h3 id="2-泛型类、泛型接口"><a href="#2-泛型类、泛型接口" class="headerlink" title="2. 泛型类、泛型接口"></a>2. 泛型类、泛型接口</h3><p>泛型类中的类型参数几乎可以用于任何可以使用接口名、类名的地方。以下是Jdk中Map接口的定义：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span><span class="token punctuation">;</span>    V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当声明或者实例化一个泛型的对象时，必须指定类型参数的值：</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对于常见的泛型模式，推荐的名称是：</p><ul><li>K: 键</li><li>V: 值</li><li>E: 异常类</li><li>T: 泛型</li></ul><h3 id="3-泛型方法"><a href="#3-泛型方法" class="headerlink" title="3. 泛型方法"></a>3. 泛型方法</h3><h4 id="1-定义泛型方法"><a href="#1-定义泛型方法" class="headerlink" title="(1). 定义泛型方法"></a>(1). 定义泛型方法</h4><p>泛型方法使得该方法能独立于类而产生变化。以下是一个基本的指导原则：<strong>无论何时，只要你能做到，你就应该尽量使用泛型方法</strong>。也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。要定义泛型方法，只需<strong>将泛型参数列表置于返回值之前</strong>，就像下面这样：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericMethods</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//当方法操作的引用数据类型不确定的时候，可以将泛型定义在方法上</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        GenericMethods gm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gm<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gm<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-可变参数泛型方法"><a href="#2-可变参数泛型方法" class="headerlink" title="(2). 可变参数泛型方法"></a>(2). 可变参数泛型方法</h4><p>泛型方法与可变参数列表能很好地共存。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericVarargs</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">makeList</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>T<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>T item<span class="token operator">:</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List ls <span class="token operator">=</span> <span class="token function">makeList</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span>        ls <span class="token operator">=</span> <span class="token function">makeList</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span>        ls <span class="token operator">=</span> <span class="token function">makeList</span><span class="token punctuation">(</span><span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：静态方法无法访问类上定义的泛型。如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</p></blockquote><h3 id="4-泛型擦除"><a href="#4-泛型擦除" class="headerlink" title="4. 泛型擦除"></a>4. 泛型擦除</h3><p>看以下一段代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ErasedTypeEquivalence</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Class <span class="token class-name">c1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">c2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c1 <span class="token operator">==</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出true.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从以上代码的执行结果可以知道，<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>是相同的类型。Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p><p>要想在表达式中使用类型，需要显式地传递类型的class对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Building</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">House</span> <span class="token keyword">extends</span> <span class="token class-name">Building</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassTypeCapture</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span>T<span class="token operator">></span> kind<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ClassTypeCapture</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>kind <span class="token operator">=</span> kind<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">f</span><span class="token punctuation">(</span>Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> kind<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ClassTypeCapture<span class="token operator">&lt;</span>Building<span class="token operator">></span> ctt1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassTypeCapture</span><span class="token operator">&lt;</span>Building<span class="token operator">></span><span class="token punctuation">(</span>Building<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ctt1<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Building</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ctt1<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">House</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>        ClassTypeCapture<span class="token operator">&lt;</span>House<span class="token operator">></span> ctt2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassTypeCapture</span><span class="token operator">&lt;</span>House<span class="token operator">></span><span class="token punctuation">(</span>House<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ctt2<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Building</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ctt2<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">House</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-通配符及泛型边界"><a href="#5-通配符及泛型边界" class="headerlink" title="5. 通配符及泛型边界"></a>5. 通配符及泛型边界</h3><ul><li>通配符(<code>?</code>): 当操作类型时，不需要使用类型的具体功能时，只使用<code>Object</code>类中的功能。那么可以用<code>?</code>通配符来表未知类型。例如：<code>Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;);</code>。</li><li>上界(<code>? extends T</code>): 可以接收<code>T</code>类型或者其子类型的对象。</li><li>下界(<code>? super E</code>): 可以接收<code>T</code>类型或者其父类型的对象。</li></ul><h3 id="6-泛型总结"><a href="#6-泛型总结" class="headerlink" title="6. 泛型总结"></a>6. 泛型总结</h3><ul><li>泛型的类型参数只能是类类型，不能是基本数据类型。</li><li>泛型的类型参数可以有多个。</li><li>所有泛型类的类型参数在编译时都会被擦除。</li><li>创建泛型对象时请指明类型，让编译器尽早的做参数检查。</li><li>不能创建泛型数组。如果想要创建泛型数组，建议使用<code>ArrayList</code>。</li><li>使用带泛型的类创建对象时，等式两边指定的泛型必须一致。</li><li>泛型的好处：<ul><li>类型安全。</li><li>消除强制类型转换。</li><li>提高性能。</li></ul></li></ul><h2 id="二、增强for循环-Enhanced-for-Loop"><a href="#二、增强for循环-Enhanced-for-Loop" class="headerlink" title="二、增强for循环(Enhanced for Loop)"></a>二、增强for循环(Enhanced for Loop)</h2><p>在Java5中，引入了另一种形式的for循环来对集合、数组、Map等进行遍历。如以下示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> integers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 开始遍历 */</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> integers<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 依次输出“1”、“2”、“3”、“4” */</span><span class="token punctuation">}</span></code></pre><p>借助增强for循环，可以用一种更简单地方式来完成遍历。能用这种方法遍历的对象的类型，可以是数组、<code>Collection</code>、<code>Map</code>或者任何其它实现了<code>java.lang.Iterable</code>接口的类。通过跟同样是在Java5中引入的泛型机制配合使用，可以精确的控制能采用的循环变量的类型。而且，因为这么编写的代码，会在编译期间被自动当成是和传统写法相同的形式，所以不必担心要额外付出性能方面的代价。</p><blockquote><p><strong>注</strong>：Java采用<code>for</code>（而不是意义更明确的<code>foreach</code>）来引导这种一般被叫做<strong>for-each循环</strong>的循环，并使用<code>:</code>（而不是意义更明确的<code>in</code>）来分割循环变量名称和要被遍历的对象。这样做的主要原因，是为了避免因为引入新的关键字，造成兼容性方面的问题——在Java语言中，不允许把关键字当作变量名来使用，虽然使用<code>foreach</code>这名字的情况并不是非常多，但是<code>in</code>却是一个经常用来表示输入流的名字（例如<code>java.lang.System</code>类里，就有一个名字叫做<code>in</code>的<code>static</code>属性，表示<strong>标准输入流</strong>）。</p></blockquote><h2 id="三、自动装箱拆箱-Autoboxing-Unboxing"><a href="#三、自动装箱拆箱-Autoboxing-Unboxing" class="headerlink" title="三、自动装箱拆箱(Autoboxing/Unboxing)"></a>三、自动装箱拆箱(Autoboxing/Unboxing)</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将<code>int</code>的变量转换成<code>Integer</code>对象，这个过程叫做装箱，反之将<code>Integer</code>对象转换成<code>int</code>类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型<code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>和<code>boolean</code>对应的封装类分别为<code>Byte</code>, <code>Short</code>, <code>Character</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code>。</p><p>自动装箱时编译器调用<code>valueOf</code>将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似<code>intValue()</code>, <code>doubleValue()</code>这类的方法将对象转换成原始类型值。自动装箱和拆箱在Java中很常见，比如我们有一个方法，接受一个对象类型的参数，如果我们传递一个原始类型值，那么Java会自动将这个原始类型值转换成与之对应的对象。最经典的一个场景就是当我们向<code>ArrayList</code>这样的容器中增加原始类型数据时，就会发生自动装箱。代码示例如下：</p><pre class=" language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> intList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//自动装箱</span>intList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 自动装箱</span><span class="token keyword">int</span> number <span class="token operator">=</span> intList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 自动拆箱</span></code></pre><h3 id="2-对象相等的比较"><a href="#2-对象相等的比较" class="headerlink" title="2. 对象相等的比较"></a>2. 对象相等的比较</h3><p>这是一个比较容易出错的地方，<code>==</code>可以用于原始值进行比较，也可以用于对象进行比较，当用于对象与对象之间比较时，比较的不是对象代表的值，而是检查两个对象是否是同一对象，这个比较过程中<strong>没有自动装箱</strong>发生。进行对象值比较不应该使用<code>==</code>，而应该使用对象对应的<code>equals</code>方法。看一个能说明问题的例子。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoboxingTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 示例 1: 使用'=='号进行原始类型的比较(没有自动装箱)</span>        <span class="token keyword">int</span> i1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1==i2 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>        <span class="token comment" spellcheck="true">// 示例 2: 使用'=='号进行原始类型和对象类型混合的比较(自动装箱)</span>        Integer num1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num1 == num2 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>        <span class="token comment" spellcheck="true">// 示例 3: 使用'=='号进行Integer对象类型的比较(会有缓存的特殊情况)</span>        Integer obj1 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 自动装箱将调用`Integer.valueOf()`且缓存该对象，以便重用</span>        Integer obj2 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取已经缓存过的对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"obj1 == obj2 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>obj1 <span class="token operator">==</span> obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>       <span class="token comment" spellcheck="true">// 示例 4: 使用'=='号进行Integer对象类型的比较(不会缓存)</span>        Integer obj3 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 自动装箱将调用`Integer.valueOf()`不缓存该对象</span>        Integer obj4 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同样是自动装箱将调用`Integer.valueOf()`</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"obj3 == obj4 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>obj3 <span class="token operator">==</span> obj4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>        <span class="token comment" spellcheck="true">// 示例 5: 使用'=='号进行`new`出来的新`Integer`对象类型的比较</span>        Integer one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// no autoboxing</span>        Integer anotherOne <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"one == anotherOne : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>one <span class="token operator">==</span> anotherOne<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-缓存部分对象"><a href="#3-缓存部分对象" class="headerlink" title="3. 缓存部分对象"></a>3. 缓存部分对象</h3><p>输出结果：</p><pre class=" language-bash"><code class="language-bash">i1<span class="token operator">==</span>i2 <span class="token keyword">:</span> <span class="token boolean">true</span>num1 <span class="token operator">==</span> num2 <span class="token keyword">:</span> <span class="token boolean">true</span>obj1 <span class="token operator">==</span> obj2 <span class="token keyword">:</span> <span class="token boolean">true</span>obj3 <span class="token operator">==</span> obj4 <span class="token keyword">:</span> <span class="token boolean">false</span>one <span class="token operator">==</span> anotherOne <span class="token keyword">:</span> <span class="token boolean">false</span></code></pre><p>在 Java5 中，为<code>Integer</code>的操作引入了一个新的特性，会对<code>-128</code>到<code>127</code>的<code>Integer</code>对象进行缓存，当创建新的<code>Integer</code>对象时，如果符合这个这个范围，并且已有存在的相同值的对象，则返回这个对象，否则创建新的<code>Integer</code>对象。这种<code>Integer</code>缓存策略仅在<strong>自动装箱（autoboxing）</strong>的时候有用，使用构造器创建的<code>Integer</code>对象不能被缓存。</p><p><code>Integer</code>类中有一个专门的私有静态内部类<code>IntegerCache</code>来负责<code>Integer</code>的缓存。代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage.  The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size>} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// high value may be configured by property</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>        String integerCacheHighPropValue <span class="token operator">=</span>            sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>                h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> NumberFormatException nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// If the property cannot be parsed into an int, ignore it.</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        high <span class="token operator">=</span> h<span class="token punctuation">;</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// range [-128, 127] must be interned (JLS7 5.1.7)</span>        <span class="token keyword">assert</span> IntegerCache<span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Javadoc详细的说明这个类是用来实现缓存支持，并支持<code>-128</code>到<code>127</code>之间的自动装箱过程。最大值<code>127</code>可以通过JVM的启动参数<code>-XX:AutoBoxCacheMax=size</code>修改。 缓存通过一个<code>for</code>循环实现。从小到大的创建尽可能多的整数并存储在一个名为<code>cache</code>的整数数组中。这个缓存会在<code>Integer</code>类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。</p><p>这种缓存行为不仅适用于<code>Integer</code>对象。我们针对所有整数类型的类都有类似的缓存机制。</p><ul><li><code>ByteCache</code>用于缓存<code>Byte</code>对象</li><li><code>ShortCache</code>用于缓存<code>Short</code>对象</li><li><code>LongCache</code>用于缓存<code>Long</code>对象</li><li><code>CharacterCache</code>用于缓存<code>Character</code>对象</li></ul><p><code>Byte</code>，<code>Short</code>，<code>Long</code>有固定范围:<code>-128</code>到<code>127</code>。对于<code>Character</code>, 范围是<code>0</code>到<code>127</code>。除了<code>Integer</code>可以通过参数改变范围外，其它的都不行。</p><blockquote><p><strong>注</strong>：在Java中另一个节省内存的例子就是<strong>字符串常量池</strong>。</p></blockquote><h3 id="4-自动装箱拆箱的隐患"><a href="#4-自动装箱拆箱的隐患" class="headerlink" title="4. 自动装箱拆箱的隐患"></a>4. 自动装箱拆箱的隐患</h3><p>另一个需要避免的问题就是混乱使用对象和原始数据值，一个具体的例子就是当我们在一个原始数据值与一个对象进行比较时，如果这个对象没有进行初始化或者为<code>null</code>，在自动拆箱过程中<code>obj.xxxValue</code>，会抛出<code>NullPointerException</code>，如下面的代码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Integer count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//NullPointerException on unboxing</span><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Count is not started yet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>因为自动装箱会隐式地创建对象，像前面提到的那样，如果在一个循环体中，会创建无用的中间对象，这样会增加GC压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。</p><h2 id="四、枚举-Enums"><a href="#四、枚举-Enums" class="headerlink" title="四、枚举(Enums)"></a>四、枚举(Enums)</h2><p>枚举（<code>enum</code>全称为<code>enumeration</code>）类型是 Java5 新增的类型，存放在<code>java.lang</code>包中，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。</p><p>关于枚举的介绍，这里就不再细讲了，请参考我以前所整理的<a href="http://blinkfox.com/java-mei-ju-zhi-shi-zheng-li/" target="_blank" rel="noopener">Java 枚举知识整理</a>一文。</p><h2 id="五、可变参数-Varargs"><a href="#五、可变参数-Varargs" class="headerlink" title="五、可变参数(Varargs)"></a>五、可变参数(Varargs)</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h3><p>在 Java5 中提供了可变参数（<code>Varargs</code>），也就是在方法定义中可以使用个数不确定的参数，对于同一方法可以使用不同个数的参数调用，例如<code>print(&quot;hello&quot;);</code>、<code>print(&quot;hello&quot;,&quot;lisi&quot;);</code>等。下面介绍如何定义可变长参数以及如何使用可变长参数。</p><p>使用<code>...</code>表示可变长参数，例如：</p><pre class=" language-java"><code class="language-java"><span class="token function">print</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 方法代码</span><span class="token punctuation">}</span></code></pre><p>在具有可变长参数的方法中可以把参数当成数组使用，例如可以循环输出所有的参数值。</p><pre class=" language-java"><code class="language-java"><span class="token function">print</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>String temp<span class="token operator">:</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>调用的时候可以给出任意多个参数也可不给参数，例如：</p><pre class=" language-java"><code class="language-java"><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-可变参数的使用规则"><a href="#2-可变参数的使用规则" class="headerlink" title="2. 可变参数的使用规则"></a>2. 可变参数的使用规则</h3><ul><li>拥有可变参数的方法可以被重载，在调用方法的时候，如果能够和固定参数的方法匹配，也能够与可变参数的方法匹配，则执行时会选择固定参数的方法。</li><li>如果要调用的方法可以和两个可变参数匹配，则编译不会通过。</li><li>一个方法只能有一个可变参数，并且这个可变参数必须是该方法的最后一个参数。</li><li>可变参数可以兼容数组参数，但数组参数无法兼容可变参数。即在方法中定义可变参数后，我们可以像操作数组一样操作该参数；</li></ul><h3 id="3-可变参数的使用规范"><a href="#3-可变参数的使用规范" class="headerlink" title="3. 可变参数的使用规范"></a>3. 可变参数的使用规范</h3><ul><li>避免带有可变参数的方法重载，容易让人陷入调用的陷阱及误区。</li><li>别让<code>null</code>值和空值威胁到可变参数的方法。</li><li>覆写可变参数方法也要满足以下的条件:<ul><li>重写方法不能缩小访问权限。</li><li>参数列表必须与被重写方法相同（包括显示形式）。</li><li>返回类型必须与被重写方法的相同或是其子类。</li><li>重写方法不能抛出新的异常，或者超过了父类范围的异常，但是可以抛出更少、更有限的异常，或者不抛出异常。</li></ul></li></ul><h2 id="六、静态导入-Static-Import"><a href="#六、静态导入-Static-Import" class="headerlink" title="六、静态导入(Static Import)"></a>六、静态导入(Static Import)</h2><p><code>import static</code>，即静态导入是JDK5中的新特性。一般我们导入一个类都用<code>import com.xxx.ClassName;</code>，而静态导入是这样的：<code>import static com.xxx.ClassName.*;</code>。这里多了个<code>static</code>，还有就是类名<code>ClassName</code>后面多了个<code>.*</code>，意思是导入这个类里的所有静态方法。当然，也可以只导入某个静态方法，只要把<code>.*</code>换成具体的静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用<code>ClassName.方法名</code>的方式来调用。</p><p>静态导入之前的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">double</span> r <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> theta<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用静态导入之后的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>PI <span class="token operator">*</span> theta<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>当你需要频繁访问一个或两个类的静态成员、静态方法时才使用静态导入</strong>。如果您过度的使用了静态导入功能，则可能导致您的程序无法读取且无法维护，从而导致您导入的所有静态成员和方法污染其名称空间。你的代码读者（包括你，在你写了几个月后）不会知道静态成员来自哪个类。从类中导入所有静态成员对可读性尤其有害，如果您只需要一个或两个成员，请单独导入它们。使用适当的，静态导入可以使您的程序更具可读性，通过删除重复的类名称，来减少样板代码。</p><h2 id="七、注解-Annotations"><a href="#七、注解-Annotations" class="headerlink" title="七、注解(Annotations)"></a>七、注解(Annotations)</h2><p>关于注解的介绍，这里就不再细讲了，请参考我前段时间所写的<a href="http://blinkfox.com/javazhu-jie-de-li-jie-he-ying-yong/" target="_blank" rel="noopener">Java注解的理解和应用</a>一文。</p><h2 id="八、值得关注"><a href="#八、值得关注" class="headerlink" title="八、值得关注"></a>八、值得关注</h2><h3 id="1-新增ProcessBuilder类"><a href="#1-新增ProcessBuilder类" class="headerlink" title="1. 新增ProcessBuilder类"></a>1. 新增ProcessBuilder类</h3><p><code>ProcessBuilder</code>类是Java5在<code>java.lang</code>包中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在此之前，都是由<code>Process</code>类处来实现进程的控制管理。每个<code>ProcessBuilder</code>实例管理一个进程属性集。它的<code>start()</code>方法利用这些属性创建一个新的<code>Process</code>实例。<code>start()</code>方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p><p><code>ProcessBuilder</code>是一个<code>final</code>类，有两个带参数的构造方法，你可以通过构造方法来直接创建<code>ProcessBuilder</code>的对象。而<code>Process</code>是一个抽象类，一般都通过<code>Runtime.exec()</code>和<code>ProcessBuilder.start()</code>来间接创建其实例。<code>ProcessBuilder</code>为进程提供了更多的控制，例如，可以设置当前工作目录，还可以改变环境参数。而<code>Process</code>类的功能相对来说简单的多。<code>ProcessBuilder</code>类不是同步的。如果多个线程同时访问一个<code>ProcessBuilder</code>，而其中至少一个线程从结构上修改了其中一个属性，它必须保持外部同步。</p><p>若要使用<code>ProcessBuilder</code>创建一个进程，只需要创建<code>ProcessBuilder</code>的一个实例，指定该进程的名称和所需参数。要执行此程序，调用该实例上的<code>start()</code>即可。下面是一个执行打开<code>Windows</code>记事本的例子。注意它将要编辑的文件名指定为一个参数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">PBDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ProcessBuilder proc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"notepad.exe"</span><span class="token punctuation">,</span> <span class="token string">"testfile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            proc<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error executing notepad."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-新增Formatter格式化器-Formatter"><a href="#2-新增Formatter格式化器-Formatter" class="headerlink" title="2. 新增Formatter格式化器(Formatter)"></a>2. 新增Formatter格式化器(Formatter)</h3><p><code>Formatter</code>类是Java5中新增的<code>printf-style</code>格式化字符串的解释器，它提供对布局和对齐的支持，提供了对数字，字符串和日期/时间数据的常用格式以及特定于语言环境的输出。常见的Java类型，如<code>byte</code>，<code>java.math.BigDecimal</code>和<code>java.util.Calendar</code>都支持。 通过<code>java.util.Formattable</code>接口提供了针对任意用户类型的有限格式定制。</p><p>更详细的介绍见<a href="https://docs.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html" target="_blank" rel="noopener">这里</a>。主要使用方法的代码示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>MessageFormat<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>SimpleDateFormat<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 格式化测试使用的示例类. * * @author blinkfox on 2017-11-28. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FormatTester</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>FormatTester<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 格式化.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">formatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Formatter formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Formatter</span><span class="token punctuation">(</span>sb<span class="token punctuation">,</span> Locale<span class="token punctuation">.</span>US<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 可重新排序输出.</span>        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%n%4$2s %3$2s %2$2s %1$2s %n"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> " d  c  b  a"</span>        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>FRANCE<span class="token punctuation">,</span> <span class="token string">"e = %+10.4f"</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> "e =    +2,7183"</span>        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%nAmount gained or lost since last statement: $ %(,.2f"</span><span class="token punctuation">,</span> <span class="token number">6217.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// -> "Amount gained or lost since last statement: $ 6,217.58"</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"打印出格式化后的字符串:{}"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>        formatter<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * printf打印.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String filename <span class="token operator">=</span> <span class="token string">"testfile"</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>FileReader fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            BufferedReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>fileReader<span class="token punctuation">)</span><span class="token punctuation">;</span>            String line<span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Line %d: %s%n"</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unable to open file named '%s': %s"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * stringFormat使用.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stringFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 格式化日期.</span>        Calendar c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GregorianCalendar</span><span class="token punctuation">(</span><span class="token number">1995</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MAY<span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Duke's Birthday: %1$tm %1$te,%1$tY"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// -> s == "Duke's Birthday: May 23, 1995"</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 格式化消息.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">messageFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String msg <span class="token operator">=</span> <span class="token string">"欢迎光临，当前（{0}）等待的业务受理的顾客有{1}位，请排号办理业务！"</span><span class="token punctuation">;</span>        MessageFormat mf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageFormat</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        String fmsg <span class="token operator">=</span> mf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>fmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 格式化日期.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"2010-1-10 17:39:21"</span><span class="token punctuation">;</span>        SimpleDateFormat format <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyyMMddHHmmss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"格式化后的日期:{}"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>format<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"日期格式化出错！"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">formatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">stringFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">messageFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-新增Scanner类-Scanner"><a href="#3-新增Scanner类-Scanner" class="headerlink" title="3. 新增Scanner类(Scanner)"></a>3. 新增Scanner类(Scanner)</h3><p><code>java.util.Scanner</code>是Java5的新特征，主要功能是简化文本扫描，但这个类最实用的地方还是在获取控制台输入。</p><h4 id="1-Scanner概述"><a href="#1-Scanner概述" class="headerlink" title="(1). Scanner概述"></a>(1). Scanner概述</h4><p>可以从字符串(<code>Readable</code>)、输入流、文件、Channel等来直接构造Scanner对象，有了Scanner了，就可以逐段（根据正则分隔式）来扫描整个文本，并对扫描后的结果做想要的处理。</p><p><code>Scanner</code>默认使用<strong>空格</strong>作为分割符来分隔文本，但允许你使用<code>useDelimiter(Pattern pattern)</code>或<code>useDelimiter(String pattern)</code>方法来指定新的分隔符。</p><p>主要API如下：</p><ul><li><code>delimiter()</code>: 返回此<code>Scanner</code>当前正在用于匹配分隔符的<code>Pattern</code>。</li><li><code>hasNext()</code>: 判断扫描器中当前扫描位置后是否还存在下一段。</li><li><code>hasNextLine()</code>: 如果在此扫描器的输入中存在另一行，则返回true。</li><li><code>next()</code>: 查找并返回来自此扫描器的下一个完整标记。</li><li><code>nextLine()</code>: 此扫描器执行当前行，并返回跳过的输入信息。</li></ul><h4 id="2-扫描控制台输入"><a href="#2-扫描控制台输入" class="headerlink" title="(2). 扫描控制台输入"></a>(2). 扫描控制台输入</h4><p>当通过<code>new Scanner(System.in)</code>创建了一个<code>Scanner</code>实例时，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给<code>Scanner</code>，作为扫描对象。如果要获取输入的内容，则只需要调用<code>Scanner</code>的<code>nextLine()</code>方法即可。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 扫描控制台输入.** @author blinkfox 2017-11-28*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScannerTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Scanner s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入字符串："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String line <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"exit"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">">>>"</span> <span class="token operator">+</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="3-其它示例"><a href="#3-其它示例" class="headerlink" title="(3).其它示例"></a>(3).其它示例</h4><p>该示例中会从<code>myNumbers</code>文件中读取长整型<code>long</code>的数据。</p><pre class=" language-java"><code class="language-java">Scanner sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"myNumbers"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">hasNextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> aLong <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以下示例可以使用除空格之外的分隔符来从一个字符串中读取几个条目：</p><pre class=" language-java"><code class="language-java">String input <span class="token operator">=</span> <span class="token string">"1 fish 2 fish red fish blue fish"</span><span class="token punctuation">;</span>Scanner s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">useDelimiter</span><span class="token punctuation">(</span><span class="token string">"\\s*fish\\s*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将输出：</p><pre class=" language-bash"><code class="language-bash">12redblue</code></pre><h3 id="4-增强反射功能-Reflection"><a href="#4-增强反射功能-Reflection" class="headerlink" title="4. 增强反射功能(Reflection)"></a>4. 增强反射功能(Reflection)</h3><p>Java5反射功能方面的增强主要在<code>java.lang.Class</code>和<code>java.lang.reflect</code>类中。</p><p>主要有以下内容增强：</p><ul><li><strong>支持泛型</strong>: 可以检查类型、方法、构造方法或字段的声明并获取泛型所对应的类型信息。</li><li><strong>支持注解</strong>: 通过使用<code>getAnnotation()</code>方法获取已经在运行时标记为可用的方法和构造方法的类型，方法，字段，构造方法和形式参数的注释。人们还可以确定一个接口是否是一个注解类型。</li><li><strong>支持枚举</strong>: 可以确定一个类是否是一个枚举，以及一个字段是否代表一个枚举常量。</li><li><strong>支持可变参数</strong>: 可以确定一个方法或构造方法是否是可变参数方法。</li><li><strong>便利的方法</strong>: 用于确定一个类是否是本地的、匿名的还是成员类，以及一个类型的简单名称是什么。</li><li><strong>java.lang.Class类型标记</strong>: 允许使用<code>java.lang.Class</code>的实例作为类型标记。</li></ul><h3 id="5-增强集合框架-Collections-Framework"><a href="#5-增强集合框架-Collections-Framework" class="headerlink" title="5. 增强集合框架(Collections Framework)"></a>5. 增强集合框架(Collections Framework)</h3><p>在Java5中<a href="https://docs.oracle.com/javase/1.5.0/docs/guide/collections/changes5.html" target="_blank" rel="noopener">集合框架的增强</a>主要在以下几个方面：</p><ul><li>三种新语言特性都有针对集合，包括<strong>泛型</strong>，<strong>增强for循环</strong>和<strong>自动装箱</strong>。</li><li>三个新的接口已被添加到集合框架中，分别是：<code>Queue</code>，<code>BlockingQueue</code>和<code>ConcurrentMap</code>（后两个位于<code>java.util.concurrent</code>包中）。</li><li>提供了两个新的具体队列实现(<code>PriorityQueue</code>、<code>ConcurrentLinkedQueue</code>)，一个现有的列表实现已经被改造来实现队列(<code>LinkedList</code>)，并且提供了一个抽象队列实现(<code>AbstractQueue</code>)。</li><li>已经添加了五个阻塞队列实现，以及一个ConcurrentMap实现，分别是：<code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>, <code>PriorityBlockingQueue</code>, <code>DelayQueue</code>, <code>SynchronousQueue</code>、<code>ConcurrentHashMap</code>。</li><li>为类型安全的枚举提供了特殊用途的Map和Set实现。(<code>EnumMap</code>和<code>EnumSet</code>)</li><li>添加了特殊用途的<code>copy-on-write</code>List和Set实现，分别是：<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。</li><li>提供了包装器的实现来对大多数<code>Collection</code>接口添加动态类型安全性的检查(<code>Collections.checkedInterface</code>)。检查要添加的元素的类型并返回结果。任何尝试添加非法类型的变量都会抛出一个<code>ClassCastException</code>异常。这个功能可以防止在运行的时候出错。</li><li>提供了几个新的算法来处理集合。<ul><li><code>frequency(Collection&lt;?&gt; c, Object o)</code> - 计算指定集合中指定元素出现的次数。</li><li><code>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</code> - 判断两个集合是否不相交，换句话说，是否它们不包含任何共同的元素。</li><li><code>addAll(Collection&lt;? super T&gt; c, T... a)</code> - 将指定数组中的所有元素添加到指定的集合中。</li><li><code>Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp)</code> - 返回一个比较器，表示指定比较器的反向排序。</li></ul></li><li>提供了计算哈希代码和字符串表示的方法。<code>Arrays</code>工具类已经为所有类型的数组提供了基于内容的<code>hashCode</code>和<code>toString</code>方法。 这些方法补充了现有的<code>equals</code>方法。现在可以打印任何数组的内容。</li></ul><h3 id="6-并发工具类-Concurrency-Utilities"><a href="#6-并发工具类-Concurrency-Utilities" class="headerlink" title="6. 并发工具类(Concurrency Utilities)"></a>6. 并发工具类(Concurrency Utilities)</h3><p><code>java.util.concurrent</code>，<code>java.util.concurrent.atomic</code>和<code>java.util.concurrent.locks</code>包为开发并发类应用程序提供了一个强大的，可扩展的高性能，可伸缩，线程安全构建框架，包括 线程池，线程安全集合，信号量，任务调度框架，任务同步实用程序，原子变量和锁。将这些软件包添加到核心类库可以使程序员免去手工制作这些工具的需要，这与集合框架用于数据结构的方式大致相同。关于并发相关的的介绍会在以后更详细的来讲解。</p><h3 id="7-StringBuilder"><a href="#7-StringBuilder" class="headerlink" title="7. StringBuilder"></a>7. StringBuilder</h3><p><code>StringBuilder</code>也是Java5中新增的类，主要用来代替<code>+</code>号和<code>StringBuffer</code>来更加高效的拼接字符串。<code>StringBuffer</code>与<code>StringBuilder</code>都是继承于<code>AbstractStringBuilder</code>，主要的区别就是<code>StringBuffer</code>的函数上都有<code>synchronized</code>关键字，保证线程安全。</p><p>关于<code>StringBuilder</code>的使用这里就不再详细介绍了，网上文章也有很多。总之，对于<strong>动态字符串</strong>的拼接推荐使用<code>StringBuilder</code>。<strong>静态字符串</strong>的拼接直接使用<code>+</code>号或者字符串的<code>concat(String str)</code>方法，甚至也使用<code>StringBuilder</code>亦可。</p><h2 id="九、其它-others"><a href="#九、其它-others" class="headerlink" title="九、其它(others)"></a>九、其它(others)</h2><ul><li><strong>Instrumentation</strong>: 使用<code>java.lang.instrument</code>，开发者可以构建一个代理，用来监测运行在JVM上的程序。它类似一种更低级，更松耦合的AOP，可以从底层来改变一个类的行为。</li><li><strong>Networking</strong>: 网络编程功能增强。</li><li><strong>Internationalization</strong>: 国际化是设计一个应用程序的过程，以便它可以适应各种语言和地区而无需改变工程。国际化这个术语缩写为<code>i18n</code>，因为在第一个<code>i</code>和最后一个<code>n</code>之间有<code>18</code>个字母。</li><li><strong>改善了环境变量的支持</strong>: <code>System.getenv(String)</code>方法不再被弃用。新的<code>System.getenv()</code>方法允许作为<code>Map &lt;String，String&gt;</code>访问进程环境。</li><li><strong>JAXP</strong>: 用于XML处理的<code>Java API(JAXP)</code>包括通过标准化的Java平台API来处理XML文档的基本设施。</li><li><strong>Serialization</strong>: 已经添加了支持来处理5.0版本中新增的枚举类型。序列化枚举实例的规则与序列化<strong>普通</strong>可序列化对象的规则不同：枚举实例的序列化形式仅由其枚举常量名以及标识其基本枚举类型的信息组成。 反序列化行为也不相同 - 类信息用于查找适当的枚举类，并且<code>Enum.valueOf</code>方法与该类和所接收的常量名称一起被调用，以便获取返回的枚举常量。</li><li><strong>监控和管理</strong>: Java5为Java平台的监视和管理提供了显着的增强。</li><li>…</li></ul><hr><p>参考文档:</p><ul><li><a href="https://segmentfault.com/a/1190000004417288" target="_blank" rel="noopener">Java5的新特性</a></li><li><a href="https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html" target="_blank" rel="noopener">Oracle Java文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java注解的理解和应用</title>
      <link href="/2018/11/08/hou-duan/java/java-zhu-jie-de-li-jie-he-ying-yong/"/>
      <url>/2018/11/08/hou-duan/java/java-zhu-jie-de-li-jie-he-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1. 什么是注解"></a>1. 什么是注解</h3><p>注解(<code>Annotation</code>)是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符，它是一种由JSR-175标准选择用来描述元数据的一种工具。Java从<code>Java5</code>开始引入了注解。在注解出现之前，程序的元数据只是通过java注释和javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。</p><p>比如，下面这段代码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"This is String."</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的代码中，我重写了<code>toString()</code>方法并使用了<code>@Override</code>注解。但是，即使我们不使用<code>@Override</code>注解标记代码，程序也能够正常执行。那么，该注解表示什么？这么写有什么好处吗？事实上，<code>@Override</code>告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果我不小心拼写错误，例如将<code>toString()</code>写成了<code>toStrring(){double r}</code>，而且我也没有使用<code>@Override</code>注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。</p><h3 id="2-为什么要引入注解"><a href="#2-为什么要引入注解" class="headerlink" title="2. 为什么要引入注解"></a>2. 为什么要引入注解</h3><p>使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。</p><p>假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用注解会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p><p>另一个很重要的因素是注解定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记接口，注释，<code>transient</code>关键字等等。每个程序员按照自己的方式定义元数据，而不像注解这种标准的方式。</p><p>目前，许多框架将<code>XML</code>和<code>Annotation</code>两种方式结合使用，平衡两者之间的利弊。</p><h2 id="Java基本注解"><a href="#Java基本注解" class="headerlink" title="Java基本注解"></a>Java基本注解</h2><p>在<code>java.lang</code>包下，JAVA提供了5个基本注解。</p><h3 id="1-Override"><a href="#1-Override" class="headerlink" title="1. @Override"></a>1. @Override</h3><p><code>@Override</code>用于标注重写了父类的方法。对于子类中被<code>@Override</code>修饰的方法，如果存在对应的被重写的父类方法，则正确；如果不存在，则报错。<code>@Override</code>只能作用于方法，不能作用于其他程序元素。</p><h3 id="2-Deprecated"><a href="#2-Deprecated" class="headerlink" title="2. @Deprecated"></a>2. @Deprecated</h3><p><code>@Deprecated</code>用于表示某个程序元素（类、方法等）已过时。如果使用了被<code>@Deprecated</code>修饰的类或方法等，编译器会发出警告。</p><h3 id="3-SuppressWarnings"><a href="#3-SuppressWarnings" class="headerlink" title="3. @SuppressWarnings"></a>3. @SuppressWarnings</h3><p><code>@SuppressWarnings</code>用于抑制编译器的警告。指示被<code>@SuppressWarnings</code>修饰的程序元素（以及该程序元素中的所有子元素，例如类以及该类中的方法）取消显示指定的编译器警告。例如，常见的<code>@SuppressWarnings（value=&quot;unchecked&quot;）</code>。</p><p><code>SuppressWarnings</code>注解的常见参数值主要有以下几种：</p><ul><li><code>deprecation</code>：使用了不赞成使用的类或方法时的警告(使用<code>@Deprecated</code>使得编译器产生的警告)；</li><li><code>unchecked</code>：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告</li><li><code>fallthrough</code>：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;</li><li><code>path</code>：在类路径、源文件路径等中有不存在的路径时的警告;</li><li><code>serial</code>：当在可序列化的类上缺少 serialVersionUID 定义时的警告;</li><li><code>finally</code>：任何 finally 子句不能正常完成时的警告;</li><li><code>all</code>：关于以上所有情况的警告。</li></ul><h3 id="4-SafeVarargs"><a href="#4-SafeVarargs" class="headerlink" title="4. @SafeVarargs"></a>4. @SafeVarargs</h3><p><code>@SafeVarargs</code>是JDK 7 专门为抑制<strong>堆污染</strong>警告提供的。</p><h3 id="5-FunctionalInterface"><a href="#5-FunctionalInterface" class="headerlink" title="5. @FunctionalInterface"></a>5. @FunctionalInterface</h3><p><code>@FunctionalInterface</code>是Java8中新增的函数式接口。Java8规定：如果接口中只有一个抽象方法（可以包含多个默认方法或多个<code>static</code>方法），该接口称为函数式接口。如以下代码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Fun</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"foo类方法"</span><span class="token punctuation">)</span>；    <span class="token punctuation">}</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"bar默认方法"</span><span class="token punctuation">)</span>；    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//只定义了一个抽象方法</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：如在上面的接口中再加一个抽象方法<code>abc()</code>，则会编译出错。</p></blockquote><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p><strong>元注解(<code>meta-annotation</code>)</strong>是指注解的注解。Java5定义了5个标准的元注解类型，它们被用来提供对其它注解的类型作说明。接下来介绍这五个元注解。</p><h3 id="1-Retention"><a href="#1-Retention" class="headerlink" title="1. @Retention"></a>1. @Retention</h3><p><code>@Retention</code>指明了该注解被保留的时间长短。包含一个名为<code>value</code>的成员变量，该value成员变量是<code>RetentionPolicy</code>枚举类型。使用<code>@Retention</code>时，必须为其value指定值。value成员变量的值只能是如下3个：</p><ul><li><code>SOURCE</code>：只保留在源代码中，编译器编译时，直接丢弃这种注解，不记录在<code>.class</code>文件中。</li><li><code>CLASS</code>：编译器把注解记录在<code>class</code>文件中。当运行Java程序时，JVM中不可获取该注解信息，这是默认值。</li><li><code>RUNTIME</code>：编译器把注解记录在<code>class</code>文件中。当运行Java程序时，JVM可获取该注解信息，程序可以通过反射获取该注解的信息。</li></ul><h3 id="2-Target"><a href="#2-Target" class="headerlink" title="2. @Target"></a>2. @Target</h3><p><code>@Target</code>指定注解用于修饰哪些程序元素。<code>@Target</code>也包含一个名为<code>value</code>的成员变量，该value成员变量类型为<code>ElementType[]</code>，<code>ElementType</code>也为枚举类型，值有如下几个：</p><ul><li><code>TYPE</code>：修饰类、接口或枚举类型</li><li><code>FIELD</code>：修饰成员变量（包括枚举常量）</li><li><code>METHOD</code>：修饰方法</li><li><code>PARAMETER</code>：修饰参数</li><li><code>CONSTRUCTOR</code>：修饰构造器</li><li><code>LOCAL_VARIABLE</code>：修饰局部变量</li><li><code>ANNOTATION_TYPE</code>：修饰注解</li><li><code>PACKAGE</code>：修饰包</li><li><code>TYPE_PARAMETER</code>：Java8新增，修饰类型参数。</li><li><code>TYPE_USE</code>：Java8新增，可以在任何类型上使用</li></ul><h4 id="类型注解（Java8新增）"><a href="#类型注解（Java8新增）" class="headerlink" title="类型注解（Java8新增）"></a>类型注解（Java8新增）</h4><p>在 Java8 之前的版本中，只能允许在声明式前使用注解。而在 Java8 版本中，注解可以被用在任何使用 Type 的地方，例如：初始化对象时 (new)，对象类型转化时，使用 implements 表达式时，或者使用 throws 表达式时。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//初始化对象时</span>String myString <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token annotation punctuation">@NotNull</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对象类型转化时</span>myString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> String<span class="token punctuation">)</span> str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用 implements 表达式时</span><span class="token keyword">class</span> <span class="token class-name">MyList</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token annotation punctuation">@ReadOnly</span> List<span class="token operator">&lt;</span><span class="token annotation punctuation">@ReadOnly</span> T<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//使用 throws 表达式时</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">validateValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@Critical</span> ValidationFailedException<span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>定义一个类型的方法与普通的注解类似，只需要指定<code>Target</code>为<code>ElementType.TYPE_PARAMETER</code>或者<code>ElementType.TYPE_USE</code>，或者同时指定这两个<code>Target</code>。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE_PARAMETER<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span>  @<span class="token keyword">interface</span> <span class="token class-name">MyAnnotation</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p><code>ElementType.TYPE_PARAMETER</code>表示这个注解可以用在 Type 的声明式前，而<code>ElementType.TYPE_USE</code>表示这个注解可以用在所有使用 Type 的地方（如：泛型，类型转换等）</p><p>与 Java 8 之前的注解类似的是，类型也可以通过设置 Retention 在编译后保留在 class 文件中（RetentionPolicy.CLASS）或者运行时可访问（RetentionPolicy.RUNTIME）。但是与之前不同的是，类型注解有两个新的特性：在本地变量上的注解可以保留在<code>class</code>文件中，以及泛型类型可以被保留甚至在运行时被访问。</p><p>虽然类型可以保留在 class 文件中，但是它并不会改变程序代码本身的行为。例如在一个方法前加上注解，调用此方法返回的结果和不加注解的时候一致。</p><p>Java8 通过引入类型，使得开发者可以在更多的地方使用注解，从而能够更全面地对代码进行分析以及进行更强的类型检查。</p><h3 id="3-Inherited"><a href="#3-Inherited" class="headerlink" title="3. @Inherited"></a>3. @Inherited</h3><p><code>@Inherited</code>指定注解具有继承性。如果某个类使用了<code>@xxx</code>注解（定义该注解时使用了<code>@Inherited</code>修饰）修饰，则其子类将自动被<code>@xxx</code>修饰。</p><h3 id="4-Documented"><a href="#4-Documented" class="headerlink" title="4. @Documented"></a>4. @Documented</h3><p>如果定义注解A时，使用了<code>@Documented</code>修饰定义，则在用Javadoc命令生成API文档后，所有使用注解A修饰的程序元素，将会包含注解A的说明。</p><h3 id="5-Repeatable（Java8新增）"><a href="#5-Repeatable（Java8新增）" class="headerlink" title="5. @Repeatable（Java8新增）"></a>5. @Repeatable（Java8新增）</h3><p><code>@Repeatable</code>表示可重复注解。在实际应用中，可能会出现需要对同一个声明式或者类型加上相同的注解（包含不同的属性值）的情况。例如系统中除了管理员之外，还添加了超级管理员这一权限，对于某些只能由这两种角色调用的特定方法，可以使用可重复注解。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Access</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"SuperAdministrator"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Access</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"Administrator"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>Java8之前版本的 JDK 并不允许开发者在同一个声明式前加注同样的注解，（即使属性值不同）这样的代码在编译过程中会提示错误。而 Java8 解除了这一限制，开发者可以根据各自系统中的实际需求在所有可以使用注解的地方使用可重复注解。</p><p>由于兼容性的缘故，可重复注解并不是所有新定义的注解的默认特性，需要开发者根据自己的需求决定新定义的注解是否可以重复注解。Java 编译器会自动把可重复注解储存到指定的注解容器中。而为了触发编译器进行这一操作，开发者需要进行以下的定义：</p><p>首先，在需要重复标注特性的注解前加上<code>@Repeatable</code>标签，示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>AccessContainer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Access</span> <span class="token punctuation">{</span>    String <span class="token function">role</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>@Repeatable</code>标签后括号中的值即为指定的注解容器的类型。在这个例子中，注解容器的类型是<code>AccessContainer</code>，Java 编译器会把重复的 Access 对象保存在 AccessContainer 中。</p><p>AccessContainer 中必须定义返回数组类型的 value 方法。数组中元素的类型必须为对应的可重复注解类型。具体示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">AccessContainer</span> <span class="token punctuation">{</span>    Access<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以通过 Java 的反射机制获取注解的 Annotation。一种方式是通过 AnnotatedElement 接口的<code>getAnnotationByType(Class&lt;T&gt;)</code>。首先获得 Container Annotation，然后再通过 Container Annotation 的 value 方法获得可重复注解。另一种方式是用过 AnnotatedElement 接口的<code>getAnnotations(Class&lt;T&gt;)</code>方法一次性返回可重复注解。</p><p>可重复注解使得开发者可以根据具体的需求对同一个声明式或者类型加上同一类型的注解，从而增加代码的灵活性和可读性。</p><h2 id="自定义注解及解析"><a href="#自定义注解及解析" class="headerlink" title="自定义注解及解析"></a>自定义注解及解析</h2><h3 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1. 自定义注解"></a>1. 自定义注解</h3><p>创建Java的自定义注解和创建一个接口相似，但是注解的<code>interface</code>关键字需要以<code>@</code>符号开头。我们可以为注解声明方法。我们先来看看一个自定义注解的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Inherited<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">MethodInfo</span> <span class="token punctuation">{</span>    String <span class="token function">author</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">'blinkfox'</span><span class="token punctuation">;</span>    String <span class="token function">date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">revision</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">1</span><span class="token punctuation">;</span>    String <span class="token function">comments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>自定义注解就需要用到上面所介绍到的几种元注解，可以看出元注解就是用来注解其它注解。自定义注解和接口类似，只能定义<strong>方法</strong>，注解中的<strong>方法</strong>需要遵循以下几种规则：</p><ul><li>注解方法不能带有参数；</li><li>注解方法返回值类型限定为：基本类型、String、Enums、Annotation或者是这些类型的数组；</li><li>注解方法可以有默认值。</li></ul><h3 id="2-注解的解析"><a href="#2-注解的解析" class="headerlink" title="2. 注解的解析"></a>2. 注解的解析</h3><p>要解析Java中的注解需要使用Java反射技术。那么注解的<code>RetentionPolicy</code>应该设置为<code>RUNTIME</code>，否则Java类的注解信息在执行过程中将不可用，我们也就不能从中得到任何和注解有关的数据。以下是解析注解常用的几种方法的示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Annotation<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationParsing</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>AnnotationParsing<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> AnnotationParsing<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'com.journaldev.annotations.AnnotationExample'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// checks if MethodInfo annotation is present for the method</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>com<span class="token punctuation">.</span>journaldev<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>MethodInfo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// iterates all the annotations available in the method</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span>Annotation anno <span class="token operator">:</span> method<span class="token punctuation">.</span><span class="token function">getDeclaredAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'Annotation in Method '</span><span class="token string">'+ method + '</span><span class="token string">' : '</span> <span class="token operator">+</span> anno<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    MethodInfo methodAnno <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>MethodInfo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>methodAnno<span class="token punctuation">.</span><span class="token function">revision</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'Method with revision no 1 = '</span><span class="token operator">+</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"解析Java注解出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="注解的应用之监控方法执行耗时"><a href="#注解的应用之监控方法执行耗时" class="headerlink" title="注解的应用之监控方法执行耗时"></a>注解的应用之监控方法执行耗时</h2><p>通过前面对元注解的介绍，我们就可以自定义我们需要的注解了。假如，我们需要监控某些方法的执行，最原始的办法就是在方法执行的开头和结尾分别记录时间，最后计算前后的时间差即可，但是这些代码与核心业务无关，且大量重复、分散在各处，维护起来也困难。这时我们可以<a href="http://blinkfox.com/shi-yong-spring-aoplai-tong-ji-fang-fa-de-zhi-xing-shi-jian/" target="_blank" rel="noopener">使用Spring AOP来统计方法的执行耗时</a>，同时我们也可以使用注解的方式来实现，更自由灵活。</p><p>首先，定义我们的执行耗时的方法上的注解：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 自定义'统计方法耗时'并打印日志的注解. * * @author blinkfox on 2017-01-04. */</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">CostTime</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 执行超过某毫秒数时数则打印'warn'级别的日志，默认 0ms，即默认都打印.     *     * @return 毫秒数     */</span>    <span class="token keyword">long</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后，书写监控所标注有<code>@CostTime</code>注解的方法代理类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>Enhancer<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodInterceptor<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodProxy<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 被标注为'@CostTime'注解的方法执行耗时的代理方法. * &lt;p>实现了cglib中的`MethodInterceptor`的方法拦截接口.&lt;/p> * * @author blinkfox on 2017-01-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CostTimeProxy</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>CostTimeProxy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取代理类.     *     * @param cls 代理类的class     * @return 代理类实例     */</span>    <span class="token keyword">public</span> Object <span class="token function">getProxy</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 拦截方法,判断是否有'@CostTime'的注解，如果有则拦截执行.     *     * @param o 对象     * @param method 方法     * @param args 参数     * @param methodProxy 代理方法     * @return 对象     * @throws Throwable 问题     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断该方法上是否有 CostTime 注解</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>CostTime<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 获取注解信息</span>        CostTime costTime <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>CostTime<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> limitTime <span class="token operator">=</span> costTime<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 记录方法执行前后的耗时时间，并做差，判断是否需要打印方法执行耗时</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object result <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> diffTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>limitTime <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>diffTime <span class="token operator">>=</span> limitTime<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 打印耗时的信息</span>            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"【CostTime监控】通过注解监控方法'{}'的执行耗时为:{}"</span><span class="token punctuation">,</span> methodName<span class="token punctuation">,</span> diffTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接着，可以写一些业务类及方法，这里就以<code>A</code>类为例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * A类. * * @author blinkfox on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 始终打印方法执行耗时的方法.     */</span>    <span class="token annotation punctuation">@CostTime</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"执行A类中doSomeThing()方法！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 当方法执行耗时大于等于'50ms'时打印出方法执行耗时.     */</span>    <span class="token annotation punctuation">@CostTime</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomeThing2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"执行A类中doSomeThing2()方法！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是用来测试<code>A</code>类某些业务方法执行耗时的测试类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>test<span class="token punctuation">.</span>reflect<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 耗时注解使用测试示例 * Created by blinkfox on 2017-01-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CostTimeTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** A类的全局实例. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> A a<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        CostTimeProxy aproxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CostTimeProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> aproxy<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * main 方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">doSomeThing2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这就完成了对A类被标注了<code>@CostTime</code>注解的方法执行耗时的监控。当然你可以配置需要扫描的包(<code>package</code>)下的所有类中被标注为<code>@CostTime</code>注解的方法的执行耗时，这里就不介绍了。</p><hr><p>参考文档：</p><ul><li><a href="http://www.importnew.com/17413.html" target="_blank" rel="noopener">Java注解教程及自定义注解</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8annotation/" target="_blank" rel="noopener">Java 8 Annotation 新特性在软件质量和开发效率方面的提升</a></li><li><a href="http://blog.csdn.net/u014207606/article/details/52291951" target="_blank" rel="noopener">Java内置系统注解和元注解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射基础</title>
      <link href="/2018/11/07/hou-duan/java/java-fan-she-ji-chu/"/>
      <url>/2018/11/07/hou-duan/java/java-fan-she-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Java反射(<code>Reflection</code>)机制就是在运行状态中，对于任意一个类，都能够知道这个类的属性和方法。对于任意一个对象能够调用它的任意一个属性和方法。这种动态获取的信息和动态调用对象的方法的功能称为Java语言的反射机制。Java程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是JVM在<strong>运行时</strong>才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。反射机制就是通过<code>java.lang.Class</code>类来实现的，在Java中，Object 类是所有类的根类，而Class类就是描述Java类的类。</p><blockquote><p><strong>注</strong>：因为Class类也是类，所以Object也包括Class类。</p></blockquote><h3 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2. 主要功能"></a>2. 主要功能</h3><p>Java反射框架主要提供以下功能：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li><li>在运行时调用任意一个对象的方法；</li><li>修改构造函数、方法、属性的可见性。</li></ul><h3 id="3-主要用途"><a href="#3-主要用途" class="headerlink" title="3. 主要用途"></a>3. 主要用途</h3><p><strong>反射最重要的用途就是开发各种通用框架</strong>。很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。</p><h2 id="二、反射的使用"><a href="#二、反射的使用" class="headerlink" title="二、反射的使用"></a>二、反射的使用</h2><h3 id="1-获取Class对象"><a href="#1-获取Class对象" class="headerlink" title="1. 获取Class对象"></a>1. 获取Class对象</h3><p>反射的各种功能都需要通过Class对象来实现，因此，需要知道如何获取Class对象，主要有以下几种方式。</p><h4 id="使用-Class-forName-的静态方法"><a href="#使用-Class-forName-的静态方法" class="headerlink" title="使用 Class.forName() 的静态方法"></a>使用 Class.forName() 的静态方法</h4><p><code>Class.forName(String className)</code>方法可以通过类或接口的名称（一个字符串或完全限定名）来获取对应的Class对象。</p><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.blinkfox.Zealot"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="直接获取某个类的class-最安全-性能最好"><a href="#直接获取某个类的class-最安全-性能最好" class="headerlink" title="直接获取某个类的class(最安全/性能最好)"></a>直接获取某个类的class(最安全/性能最好)</h4><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span>String<span class="token operator">></span> cls <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span></code></pre><h4 id="调用某个对象的-getClass-方法"><a href="#调用某个对象的-getClass-方法" class="headerlink" title="调用某个对象的 getClass() 方法"></a>调用某个对象的 getClass() 方法</h4><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span>String<span class="token operator">></span> cls <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-判断是否为某个类的实例"><a href="#2-判断是否为某个类的实例" class="headerlink" title="2. 判断是否为某个类的实例"></a>2. 判断是否为某个类的实例</h3><p>一般地，我们用<code>instanceof</code>关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的<code>isInstance()</code>方法来判断是否为某个类的实例，它是一个Native方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-创建实例"><a href="#3-创建实例" class="headerlink" title="3. 创建实例"></a>3. 创建实例</h3><p>通过反射来生成对象主要有两种方式。</p><h4 id="使用Class对象的newInstance-方法"><a href="#使用Class对象的newInstance-方法" class="headerlink" title="使用Class对象的newInstance()方法"></a>使用Class对象的newInstance()方法</h4><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>Object str <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance-方法"><a href="#通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance-方法" class="headerlink" title="通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法"></a>通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取String所对应的Class对象</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取String类带一个String参数的构造器</span>Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 根据构造器创建实例</span>Object obj <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"23333"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注</strong>：这种方法可以用指定的构造器构造类的实例。</p></blockquote><h3 id="4-获取方法"><a href="#4-获取方法" class="headerlink" title="4. 获取方法"></a>4. 获取方法</h3><p>获取某个Class对象的方法集合，主要有以下几个方法：</p><ul><li><code>getDeclaredMethods()</code>方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException</code></pre><ul><li><code>getMethods()</code>方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException</code></pre><ul><li><code>getMethod()</code>方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Method <span class="token function">getMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span></code></pre><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>            InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> MethodClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        Object object <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredMethods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取MethodClass类的add方法</span>        Method method <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//getMethods()方法获取的所有方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getMethods获取的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//getDeclaredMethods()方法获取的所有方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getDeclaredMethods获取的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span> declaredMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MethodClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fuck <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：通过<code>getMethods()</code>获取的方法可以获取到父类的方法,比如<code>java.lang.Object</code>下定义的各个方法。</p></blockquote><h3 id="5-获取构造方法"><a href="#5-获取构造方法" class="headerlink" title="5. 获取构造方法"></a>5. 获取构造方法</h3><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的<code>getConstructor</code>方法得到<code>Constructor</code>类的一个实例，而Constructor类有一个<code>newInstance</code>方法可以创建一个对象实例:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">newInstance</span><span class="token punctuation">(</span>Object <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initargs<span class="token punctuation">)</span></code></pre><blockquote><p><strong>注</strong>：此方法可以根据传入的参数来调用对应的Constructor创建对象实例。</p></blockquote><h3 id="6-获取类的成员变量信息"><a href="#6-获取类的成员变量信息" class="headerlink" title="6. 获取类的成员变量信息"></a>6. 获取类的成员变量信息</h3><p>获取的方法同Method相似，主要是这几个方法，在此不再赘述：</p><ul><li><code>Field getField(String name)</code>: 访问公有的成员变量。</li><li><code>Field[] getDeclaredFields()</code>：所有已声明的成员变量。但不能得到其父类的成员变量。</li><li><code>Field[] getFields()</code>和<code>Field[] getDeclaredFields()</code>用法同上。</li></ul><h3 id="7-调用方法"><a href="#7-调用方法" class="headerlink" title="7. 调用方法"></a>7. 调用方法</h3><p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span> InvocationTargetException</code></pre><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>            InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> klass <span class="token operator">=</span> MethodClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建 MethodClass 的实例</span>        Object obj <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取 MethodClass 类的add方法</span>        Method method <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用 method 对应的方法 => add(1,4)</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MethodClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fuck <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="8-利用反射创建数组"><a href="#8-利用反射创建数组" class="headerlink" title="8. 利用反射创建数组"></a>8. 利用反射创建数组</h3><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个<code>Object Reference</code>。下面我们看一看利用反射创建数组的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用`java.lang.reflect.Array`反射创建长度为25的字符串数组.</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object array <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 往数组里添加内容</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Go"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Scala"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"Clojure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取某一项的内容</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="三、使用反射获取信息"><a href="#三、使用反射获取信息" class="headerlink" title="三、使用反射获取信息"></a>三、使用反射获取信息</h2><p>Class类提供了大量的实例方法来获取该Class对象所对应的详细信息，Class类大致包含如下方法，其中每个方法都包含多个重载版本，因此我们只是做简单的介绍，详细请参考<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">JDK文档</a>。</p><h3 id="1-获取类内信息"><a href="#1-获取类内信息" class="headerlink" title="1. 获取类内信息"></a>1. 获取类内信息</h3><ul><li>构造器: <code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></li><li>包含的方法: <code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></li><li>包含的属性: <code>Field getField(String name)</code></li><li>包含的Annotation: <code>&lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass)</code></li><li>内部类: <code>Class&lt;?&gt;[] getDeclaredClasses()</code></li><li>外部类: <code>Class&lt;?&gt; getDeclaringClass()</code></li><li>所实现的接口: <code>Class&lt;?&gt;[] getInterfaces()</code></li><li>修饰符: <code>int getModifiers()</code></li><li>所在包: <code>Package getPackage()</code></li><li>类名: <code>String getName()</code></li><li>简称: <code>String getSimpleName()</code></li></ul><h3 id="2-判断类本身信息的方法"><a href="#2-判断类本身信息的方法" class="headerlink" title="2. 判断类本身信息的方法"></a>2. 判断类本身信息的方法</h3><ul><li>是否注解类型: <code>boolean isAnnotation()</code></li><li>是否使用了该Annotation修饰: <code>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></li><li>是否匿名类: <code>boolean isAnonymousClass()</code></li><li>是否数组: <code>boolean isArray()</code></li><li>是否枚举: <code>boolean isEnum()</code></li><li>是否原始类型: <code>boolean isPrimitive()</code></li><li>是否接口: <code>boolean isInterface()</code></li><li>obj是否是该Class的实例: <code>boolean isInstance(Object obj)</code></li></ul><h3 id="3-使用反射获取泛型信息"><a href="#3-使用反射获取泛型信息" class="headerlink" title="3. 使用反射获取泛型信息"></a>3. 使用反射获取泛型信息</h3><p>为了通过反射操作泛型以迎合实际开发的需要, Java新增了<code>java.lang.reflect.ParameterizedType</code>、<code>java.lang.reflect.GenericArrayType</code>、<code>java.lang.reflect.TypeVariable</code>、<code>java.lang.reflect.WildcardType</code>几种类型来代表不能归一到Class类型但是又和原始类型同样重要的类型。</p><ul><li><code>ParameterizedType</code>: 一种参数化类型, 比如Collection<string></string></li><li><code>GenericArrayType</code>: 一种元素类型是参数化类型或者类型变量的数组类型</li><li><code>TypeVariable</code>: 各种类型变量的公共接口</li><li><code>WildcardType</code>: 一种通配符类型表达式, 如<code>?</code>、<code>? extends Number</code>、<code>? super Integer</code></li></ul><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> objectMap<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> User<span class="token operator">></span> map<span class="token punctuation">,</span> String string<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>User<span class="token punctuation">,</span> Bean<span class="token operator">></span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试属性类型     *     * @throws NoSuchFieldException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFieldType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException <span class="token punctuation">{</span>        Field field <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"objectMap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type gType <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getGenericType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 打印type与generic type的区别</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gType<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ParameterizedType pType <span class="token operator">=</span> <span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> gType<span class="token punctuation">;</span>            Type<span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> pType<span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> types<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试参数类型     *     * @throws NoSuchMethodException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testParamType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>        Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type<span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> parameterTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"type -> "</span> <span class="token operator">+</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试返回值类型     *     * @throws NoSuchMethodException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>        Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type returnType <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"return type -> "</span> <span class="token operator">+</span> returnType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>returnType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> returnType<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>参考文档：<a href="http://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">Java反射基础</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java IO 知识整理</title>
      <link href="/2018/11/05/hou-duan/java/java-io-zhi-shi-zheng-li/"/>
      <url>/2018/11/05/hou-duan/java/java-io-zhi-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<h2 id="各IO类关系梳理"><a href="#各IO类关系梳理" class="headerlink" title="各IO类关系梳理"></a>各IO类关系梳理</h2><ul><li>InputStream: Java IO中的顶级的字节输入流的抽象类，定义了最基础的输入、读取的相关方法。实现了<code>Closeable</code>接口。<ul><li>FileInputStream: 继承自<code>InputStream</code>的文件输入流类，用于从本地文件中读取字节数据。</li><li>ByteArrayInputStream: 继承自<code>InputStream</code>的字节数组输入流类，它包含一个内部缓冲区，该缓冲区包含从流中读取的字节；通俗点说，它的内部缓冲区就是一个字节数组，而 ByteArrayInputStream 本质就是通过字节数组来实现的。InputStream通过<code>read()</code>向外提供接口，供它们来读取字节数据；而 ByteArrayInputStream 的内部额外的定义了一个计数器，它被用来跟踪<code>read()</code>方法要读取的下一个字节。</li><li>StringBufferInputStream: 继承自<code>InputStream</code>的字节输入流类，其中读取的字节由字符串的内容提供的输入流。该类已过时，不推荐使用，由 StringReader 代替。</li><li>PipedInputStream: 继承自<code>InputStream</code>的管道输入流类，在使用管道通信时，必须与 PipedOutputStream 配合使用。让多线程可以通过管道进行线程间的通讯。</li><li>ObjectInputStream: 继承自<code>InputStream</code>的对象输入流类，实现了 ObjectInput 和 ObjectStreamConstants 接口。作用是从输入流中读取Java对象和基本数据。只有支持 Serializable  或 Externalizable 接口的对象才能被<code>ObjectInputStream/ObjectOutputStream</code>所操作！</li><li>SequenceInputStream: 继承自<code>InputStream</code>的输入合并流类。SequenceInputStream 会将与之相连接的流集组合成一个输入流并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末 尾为止。合并流的作用是将多个源合并合一个源。</li><li>AudioInputStream: 继承自<code>InputStream</code>的音频输入流类。音频输入流是具有指定音频格式和长度的输入流。长度用示例帧表示，不用字节表示。提供几种方法，用于从流读取一定数量的字节，或未指定数量的字节。音频输入流跟踪所读取的最后一个字节。可以跳过任意数量的字节以到达稍后的读取位置。音频输入流可支持标记。设置标记时，会记住当前位置，以便可以稍后返回到该位置。</li><li>FilterInputStream: 继承自<code>InputStream</code>的过滤输入流类（装饰器超类），是用来“封装其它的输入流，并为它们提供额外的功能”。<ul><li>BufferedInputStream: 继承自<code>FilterInputStream</code>的带缓冲区功能的输入流类（装饰器子类），默认缓冲区大小是8K，能够减少访问磁盘的次数，提高文件读取性能。</li><li>DataInputStream: 继承自<code>FilterInputStream</code>的数据输入流类，实现了 DataInput 接口。它允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。</li><li>PushbackInputStream: 继承自<code>FilterInputStream</code>的回退输入流类。允许试探性的读取数据流，如果不是我们想要的则返还回去。</li><li>LineNumberInputStream: 继承自<code>FilterInputStream</code>的行号输入流类。可以获取当前的行号或设置当前行号，已过时，已经被 LineNumberReader 替代。</li><li>CheckedInputStream: 继承自<code>FilterInputStream</code>的校验输入流类。</li><li>CipherInputStream: 继承自<code>FilterInputStream</code>的密钥输入流类。</li><li>DigestInputStream: 继承自<code>FilterInputStream</code>的摘要处理输入流类。</li><li>InflaterInputStream: 继承自<code>FilterInputStream</code>的解压缩处理输入流类。<ul><li>GZIPInputStream: 继承自<code>InflaterInputStream</code>的gzip文件处理输入流类。</li><li>ZipInputStream: 继承自<code>InflaterInputStream</code>的解压缩处理输入流类。<ul><li>JarInputStream: 继承自<code>ZipInputStream</code>的解压缩处理输入流类。</li></ul></li></ul></li><li>DeflaterInputStream: 继承自<code>FilterInputStream</code>的压缩数据输入流类。</li><li>ProgressMonitorInputStream: 继承自<code>FilterInputStream</code>的进度监控输入流类。</li></ul></li></ul></li><li>OutputStream: JavaIO中的顶级的字节输出流的抽象类，定义了最基础的输出、写入的相关方法。实现了<code>Closeable</code>和<code>Flushable</code>接口。<ul><li>FileOutputStream: 继承自<code>OutputStream</code>的文件输出流类，用于向本地文件中写入字节数据。</li><li>ByteArrayOutputStream: 继承自<code>OutputStream</code>的字节数组输出流类，ByteArrayOutputStream 中的数据会被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。</li><li>PipedOutputStream: 继承自<code>OutputStream</code>的管道输出流类，在使用管道通信时，必须与 PipedInputStream 配合使用。让多线程可以通过管道进行线程间的通讯。</li><li>ObjectOutputStream: 继承自<code>OutputStream</code>的对象输出流类，实现了 ObjectOutput 和 ObjectStreamConstants 接口。作用是把Java对象和基本数据写入到对象输出流中。只有支持 Serializable  或 Externalizable 接口的对象才能被<code>ObjectInputStream/ObjectOutputStream</code>所操作！</li><li>FilterOutputStream: 继承自<code>OutputStream</code>的过滤输出流类，是用来“封装其它的输出流，并为它们提供额外的功能”。<ul><li>BufferedOutputStream: 继承自<code>FilterOutputStream</code>的带缓冲区功能的输出流类，默认缓冲区大小是8K，能够提高文件的写入效率。</li><li>DataOutputStream: 继承自<code>FilterOutputStream</code>的数据输出流类，实现了 DataOutput 接口。它允许应用程序以与机器无关方式向底层输入流中写入基本 Java 数据类型。</li><li>PrintStream: 继承自<code>FilterOutputStream</code>的打印输出流类，实现了 Appendable 和 Closeable 接口。使它们能够方便地打印各种数据值表示形式。PrintStream 永远不会抛出 IOException。PrintStream 提供了自动flush 和 字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。</li><li>CheckedOutputStream: 继承自<code>FilterOutputStream</code>的校验输出流类。</li><li>CipherOutputStream: 继承自<code>FilterOutputStream</code>的密钥输出流类。</li><li>DigestOutputStream: 继承自<code>FilterOutputStream</code>的摘要处理输出流类。</li><li>InflaterOutputStream: 继承自<code>FilterOutputStream</code>的解压缩处理输出流类。</li><li>DeflaterOutputStream: 继承自<code>FilterOutputStream</code>的解压缩数据输出流类。<ul><li>GZIPOutputStream: 继承自<code>DeflaterOutputStream</code>的gzip文件解压缩输出流类。</li><li>ZipOutputStream: 继承自<code>DeflaterOutputStream</code>的zip文件解压缩输出流类。<ul><li>JarOutputStream: 继承自<code>ZipOutputStream</code>的zip文件解压缩输出流类。</li></ul></li></ul></li></ul></li></ul></li><li>Reader: JavaIO中的顶级的字符读取的抽象类，定义了最基础的读取方法。实现了 Readable 和 Closeable 接口。<ul><li>BufferedReader: 继承自<code>Reader</code>的带缓冲功能的字符流类，默认缓冲区大小是8K，从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。创建 BufferReader 时，我们会通过它的构造函数指定某个 Reader 为参数。BufferReader 会将该 Reader 中的数据分批读取，每次读取一部分到缓冲中；操作完缓冲中的这部分数据之后，再从 Reader 中读取下一部分的数据。<ul><li>LineNumberReader: 继承自<code>BufferedReader</code>，可以获取当前的行号或设置当前行号。</li></ul></li><li>InputStreamReader: 继承自<code>Reader</code>，用于将从字节流转换成字符流的 Reader。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码。<ul><li>FileReader: 继承自<code>InputStreamReader</code>，用来读取字符文件的便捷类。</li></ul></li><li>StringReader: 继承自<code>Reader</code>，用于字符串读取的字符流。</li><li>CharArrayReader: 继承自<code>Reader</code>的字符数组输入流类。</li><li>FilterReader: 继承自<code>Reader</code>的字符过滤输入流抽象类。<ul><li>PushbackReader: 继承自<code>FilterReader</code>的字符回退输入流类。</li></ul></li><li>PipedReader: 继承自<code>Reader</code>的字符管道输入流类。作用是可以通过管道进行线程间的通讯。必须和 PipedWriter 配合使用。</li></ul></li><li>Writer: JavaIO中的顶级的字符写入的抽象类，定义了最基础的写入方法。实现了 Appendable 、 Closeable 和 Flushable 接口。<ul><li>BufferedWriter: 继承自<code>Writer</code>的带缓冲功能的字符流类，默认缓冲区大小是8K，从字符输出流中写入字符到文本中，缓冲各个字符，从而实现字符、数组和行的高效写入。</li><li>OutputStreamWriter: 继承自<code>Reader</code>，用于将从字节流转换成字符流的 Writer。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码。<ul><li>FileWriter: 继承自<code>OutputStreamWriter</code>，用来向文件中写入字符的便捷类。</li></ul></li><li>FilterWriter: 继承自<code>Writer</code>的字符过滤输出流抽象类。与 FilterOutputStream 功能一样、只是简单重写了父类的方法、目的是为所有装饰类提供标准和基本的方法、要求子类必须实现核心方法、和拥有自己的特色。这里 FilterWriter 没有子类、可能其意义只是提供一个接口、留着以后的扩展，本身是一个抽象类。</li><li>StringWriter: 继承自<code>Writer</code>，用于字符串写入的字符流。</li><li>PipedWriter: 继承自<code>Writer</code>的字符管道输出流类。作用是可以通过管道进行线程间的通讯。必须和 PipedReader 配合使用。</li><li>CharArrayWriter: 继承自<code>Writer</code>的字符数组输出流类。</li><li>PrintWriter: 继承自<code>Writer</code>的打印写入类，提供了PrintStream的所有打印方法，其方法也从不抛出IOException。与PrintStream的区别：作为处理流使用时，PrintStream只能封装OutputStream类型的字节流，而PrintWriter既可以封装OutputStream类型的字节流，还能够封装Writer类型的字符输出流并增强其功能。</li></ul></li></ul><p><img src="http://static.blinkfox.com/Javaio_mind_all.png" alt="Java IO Mind"></p><h2 id="IO-UML类图"><a href="#IO-UML类图" class="headerlink" title="IO UML类图"></a>IO UML类图</h2><p><img src="http://static.blinkfox.com/java_inputstream_uml.png" alt="Java InputStream UML"></p><p><img src="http://static.blinkfox.com/java_outputstream_uml.png" alt="Java OutputStream UML"></p><p><img src="http://static.blinkfox.com/java_reader_uml.png" alt="Java Reader UML"></p><p><img src="http://static.blinkfox.com/java_writer_uml.png" alt="Java Writer UML"></p><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><ul><li>字节流和字符流：<ul><li>字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。</li><li>字符流：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。</li></ul></li><li>输出流和输入流：<ul><li>输入流：从文件读入到内存。只能进行读操作。</li><li>输出流：从内存读出到文件。只能进行写操作。</li></ul></li><li>节点流和处理流：<ul><li>节点流：直接与数据源相连，读入或读出。</li><li>处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li></ul></li></ul><blockquote><p><strong>注</strong>：输入输出流中的入和出，都是相对于系统内存而言的。为什么要有处理流？直接使用节点流，读写不方便，为了更快的读写文件，才有了处理流。</p></blockquote><p><img src="http://static.blinkfox.com/javaio_mind_optype.png" alt="流按类型分类"></p><p><img src="http://static.blinkfox.com/javaio_mind_object.png" alt="流按用途分类"></p><h2 id="流中主要方法梳理"><a href="#流中主要方法梳理" class="headerlink" title="流中主要方法梳理"></a>流中主要方法梳理</h2><h3 id="InputStream中的主要方法"><a href="#InputStream中的主要方法" class="headerlink" title="InputStream中的主要方法"></a>InputStream中的主要方法</h3><ul><li><code>abstract int read()</code>: 从流中读取数据，读取一个字节，返回值为所读得字节</li><li><code>int read(byte b[])</code>: 从流中读取数据，读取多个字节，放置到字节数组 b 中，通常读取的字节数量为 b 的长度，返回值为实际独取的字节的数量。</li><li><code>int read(byte b[], int off, int len)</code>: 从流中读取数据，读取 len 个字节，放置到以下标 off 开始字节数组 b 中，返回值为实际读取的字节的数量。</li><li><code>long skip(long n)</code>: 读指针跳过n个字节不读，返回值为实际跳过的字节数量。</li><li><code>int available()</code>: 返回值为流中尚未读取的字节的数量。</li><li><code>void close()</code>: 关闭输入流。</li><li><code>synchronized void mark(int readlimit)</code>: 记录当前指针的所在位置，<code>readlimit</code>表示读指针读出的<code>readlimit</code>个字节后，所标记的指针位置才实效。</li><li><code>synchronized void reset()</code>: 把读指针重新指向用 mark 方法所记录的位置。</li><li><code>boolean markSupported()</code>: 当前的流是否支持读指针的记录功能。</li></ul><blockquote><p><strong>注</strong>：其中<code>read()</code>返回的是读入的一个字节所对应的 int 值(0-255),而<code>read(byte[] b)</code>和<code>read(byte[] b, int off, int len)</code>返回的是读入的字节数。</p></blockquote><h3 id="OutputStream中的主要方法"><a href="#OutputStream中的主要方法" class="headerlink" title="OutputStream中的主要方法"></a>OutputStream中的主要方法</h3><ul><li><code>abstract void write(int b)</code>: 输出数据，往流中写一个字节 b。</li><li><code>void write(byte b[])</code>: 输出数据，往流中写一个字节数组 b。</li><li><code>void write(byte b[], int off, int len)</code>: 输出数据，把字节数组 b 中从下标 off 开始，长度为 len 的字节写入到流中。</li><li><code>void flush()</code>: 刷空输出流，并输出所有被缓存的字节。由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中。</li><li><code>void close()</code>: 关闭输出流。</li></ul><h3 id="Reader中的主要方法"><a href="#Reader中的主要方法" class="headerlink" title="Reader中的主要方法"></a>Reader中的主要方法</h3><ul><li><code>int read(java.nio.CharBuffer target)</code>: 试图读取字符入指定的字符缓冲区。</li><li><code>int read()</code>: 读取单个字符。</li><li><code>int read(char cbuf[])</code>: 读取字符到一个数组中。</li><li><code>int read(char cbuf[], int off, int len)</code>: 读取字符到一个数组中的一部分。</li><li><code>long skip(long n)</code>: 跳过n个字符。</li><li><code>boolean ready()</code>: 通知此流是否已准备好被读取。</li><li><code>boolean markSupported()</code>: 告诉此流是否支持<code>mark()</code>操作。</li><li><code>void mark(int readAheadLimit)</code>: 标记流中的当前位置。</li><li><code>void reset()</code>: 重置流。</li><li><code>void close()</code>: 关闭该流并释放与之关联的所有系统资源。</li></ul><h3 id="Writer中的主要方法"><a href="#Writer中的主要方法" class="headerlink" title="Writer中的主要方法"></a>Writer中的主要方法</h3><ul><li><code>void write(int c)</code>: 写入单个字符。</li><li><code>void write(char cbuf[])</code>: 写入字符数组。</li><li><code>abstract void write(char cbuf[], int off, int len)</code>: 写入字符数组的一部分。</li><li><code>void write(String str)</code>: 写入一个字符串。</li><li><code>void write(String str, int off, int len)</code>: 写入一个字符串的一部分。</li><li><code>Writer append(CharSequence csq)</code>: 将指定的字符序列追加写到writer中。</li><li><code>Writer append(CharSequence csq, int start, int end)</code>: 将指定的字符序列的子序列追加写入此writer。</li><li><code>Writer append(char c)</code>: 将指定字符追加到这个writer。</li><li><code>abstract void flush()</code>: 刷新流。</li><li><code>abstract void close()</code>: 关闭流，但要先刷新它。</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="FileInputStream-和-FileOutputStream"><a href="#FileInputStream-和-FileOutputStream" class="headerlink" title="FileInputStream 和 FileOutputStream"></a>FileInputStream 和 FileOutputStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试复制文件a.txt中的内容到b.txt文件中. */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testCopyByFileStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>        InputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"G:/test/a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        OutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"G:/test/b.txt"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"文件读取写入失败!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="BufferedInputStream-和-BufferedOutputStream"><a href="#BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="BufferedInputStream 和 BufferedOutputStream"></a>BufferedInputStream 和 BufferedOutputStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试通过 BufferedInputStream 和 BufferedOutputStream 来复制文件a.txt中的内容到b.txt文件中. */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testCopyByBufferedStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>        InputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"G:/test/a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        OutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"G:/test/b.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"通过缓冲区的方式来做文件读取写入失败!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试将内容写入到ByteArrayOutputStream中并打印出来，不需要关闭流. */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testByByteArrayStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ByteArrayOutputStream byteOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        byteOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"写入字节数据出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> byteOut<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">byte</span> b <span class="token operator">:</span> buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="PipedInputStream-和-PipedOutputStream"><a href="#PipedInputStream-和-PipedOutputStream" class="headerlink" title="PipedInputStream 和 PipedOutputStream"></a>PipedInputStream 和 PipedOutputStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 发送消息的线程. * * @author blinkfox on 2017/10/19. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sender</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>Sender<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 管道输出流对象,它和管道输入流(PipedInputStream)对象绑定.从而可以将数据发送给“管道输入流”. */</span>    <span class="token keyword">private</span> PipedOutputStream pipedOut<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Sender</span><span class="token punctuation">(</span>PipedOutputStream pipedOut<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pipedOut <span class="token operator">=</span> pipedOut<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> PipedOutputStream <span class="token function">getPipedOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> pipedOut<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String strInfo <span class="token operator">=</span> <span class="token string">"Hello World!"</span> <span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            pipedOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>strInfo<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pipedOut<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"向管道中写入数据出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 接收消息的线程. * * @author blinkfox on 2017/10/19. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Receiver</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>Receiver<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 管道输入流对象,它和管道输出流(PipedOutputStream)对象绑定.从而可以接收“管道输出流”的数据. */</span>    <span class="token keyword">private</span> PipedInputStream pipedIn<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Receiver</span><span class="token punctuation">(</span>PipedInputStream pipedIn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pipedIn <span class="token operator">=</span> pipedIn<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> PipedInputStream <span class="token function">getPipedIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> pipedIn<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2048</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> pipedIn<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pipedIn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"从管道中读取数据出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * PipedInputStream 和 PipedOutputStream 的测试类. * * @author blinkfox on 2017/10/19. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PipedStreamTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>PipedStreamTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     * @param args 字符串数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Sender sender <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sender</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PipedOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Receiver receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Receiver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PipedInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将管道输入流和管道的输出流进行连接.</span>            receiver<span class="token punctuation">.</span><span class="token function">getPipedIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>sender<span class="token punctuation">.</span><span class="token function">getPipedOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 启动线程</span>            sender<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            receiver<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"发送接收消息出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试使用 testBySequenceStream 合并输入流来统一读取写入. */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testBySequenceStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>        InputStream in1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"G:/test/a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        InputStream in2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"G:/test/b.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        OutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"G:/test/c.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SequenceInputStream seqIn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SequenceInputStream</span><span class="token punctuation">(</span>in1<span class="token punctuation">,</span> in2<span class="token punctuation">)</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> seqIn<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"合并输入流写入失败!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试使用 PrintStream 将数据输出到指定的文件. */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testOutputByPrintStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"G:/test/d.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span><span class="token function">setOut</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这些内容在文件中才能看到哦！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ul><li>单一职责原则：每一个IO类的都具有单独的功能和职责，需要对某种类型的流做修改时，只需要修改具体对应的IO流类即可。</li><li>里氏替换原则：子类完全实现了父类的方法，且有自己的个性，子类覆盖或实现父类的方法时输入参数和返回结果的范围没有变化。</li><li>接口隔离原则：输入输出流所实现的接口有所不同，而且接口比较细化，接口中的方法少。</li><li>依赖倒置原则：Java IO中的各个具体的功能类，都继承或聚合了<code>InputStream/OutputStream</code>的抽象类，都共同依赖了抽象，而不是依赖了某个具体的功能的IO类。</li><li>开闭原则：当用户需要新增一种新特征、新方式的IO流时，可以直接新增一种类的流，让其继承或聚合<code>InputStream/OutputStream/FilterInputStream/FilterOutputStream</code>等类，从而来书写其特有的功能，减少。</li><li>聚合/组合复用原则：就比如<code>FileInputStream</code>中对<code>FileDescriptor</code>和<code>FileChannel</code>的使用，都是采用了聚合的方式，而非继承的方式，从而使类之间的耦合度降低，提高了灵活性。</li></ul><h2 id="使用到的设计模式"><a href="#使用到的设计模式" class="headerlink" title="使用到的设计模式"></a>使用到的设计模式</h2><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>由于java I/O库需要很多性能的各种组合，如果这些性能都是用继承来实现，那么每一种组合都需要一个类，这样就会造成大量行重复的类出现。如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是java I/O库基本模式。装饰模式的引进，造成灵活性和复杂性的提高。因此在使用java IO库时，必须理解java IO库是由一些基本的原始流处理器和围绕它们的装饰流处理器所组成的。</p><p>以字节输入流为例。<code>InputStream</code>是需要被装饰的抽象构件，而其下的<code>FileInputStream</code>、<code>ByteArrayInputStream</code>等是被装饰的具体构件；<code>FilterInputStream</code>是装饰器的父类，<code>BufferedInputStream</code>、<code>DataInputStream</code>则是具体的装饰器类。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式是java IO库中第二个重要的设计模式。如：<code>StringBufferInputStream</code>就是一个适配器类。它继承了<code>InputStream</code>类型，同时持有一个对<code>String</code>类型的引用。这是将<code>String</code>对象适配成<code>InputStream</code>类型的对象形式的适配器模式。<code>PipedOutputStream</code>也是一个适配器类。<code>PipedOutputStream</code>总是和<code>PipedInputStream</code>一起使用，它接收一个类型为<code>PipedInputStream</code>的输入类型，并将之转换成<code>OutputStream</code>类型的输出流，这是一个对象形式的适配器模式应用。</p><h2 id="设计的优缺点"><a href="#设计的优缺点" class="headerlink" title="设计的优缺点"></a>设计的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>功能全面、强大和灵活，同时还防止了过多的类膨胀</li><li>符合开闭原则，开发可以通过各种装配能实现各种功能</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>复杂难记，API使用繁琐。如：<code>Jdk1.6</code>中，从文本文件中读取数据转换为字符串，就得至少10行代码。</li><li>IO流中的绝大多数方法都有<code>IOException</code>的检查异常，导致开发人员不得不在各个使用到的地方捕捉或再抛出异常，代码繁琐，不符合当前的主流设计思路。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之责任链模式</title>
      <link href="/2018/11/04/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ze-ren-lian-mo-shi/"/>
      <url>/2018/11/04/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ze-ren-lian-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如审批工作流等，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>定义</strong>：责任链模式(<code>Chain of Responsibility Pattern</code>)是使多个对象都有机会处理请求，从而避免请求的发送者与请求处理者耦合在一起。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。它是一种对象行为型模式。</p></blockquote><p><strong>实质</strong>：责任链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，从而实现请求发送者与请求处理者的解耦。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Handler</code>（抽象处理者）：处理请求的接口，一般设计为具有抽象请求处理方法的抽象类，以便于不同的具体处理者进行继承，从而实现具体的请求处理方法。此外，由于每一个请求处理者的下家还是一个处理者，因此抽象处理者本身还包含了一个本身的引用(<code>nextHandler</code>)作为其对下家的引用，以便将处理者链成一条链；</li><li><code>ConcreteHandler</code>（具体处理者）：抽象处理者的子类，可以处理用户请求，其实现了抽象处理者中定义的请求处理方法。在具体处理请求时需要进行判断，若其具有相应的处理权限，那么就处理它；否则，其将请求转发给后继者，以便让后面的处理者进行处理。</li></ul><p>在责任链模式里，由每一个请求处理者对象对其下家的引用而连接起来形成一条请求处理链。请求将在这条链上一直传递，直到链上的某一个请求处理者能够处理此请求。<strong>发出这个请求的客户端并不知道链上的哪一个请求处理者将处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任</strong>。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/chain_of_responsibility.png" alt="责任链模式UML类图"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，责任链模式的核心在于对请求处理者的抽象。在实现过程中，抽象处理者一般会被设定为<strong>抽象类</strong>，其典型实现代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 责任连模式的抽象处理者角色. * * Created by blinkfox on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 后继处理者角色. */</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 处理请求的抽象方法.     *     * @param condition 条件     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * nextHandler的Setter方法.     *     * @param nextHandler 后继处理器     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler nextHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler <span class="token operator">=</span> nextHandler<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其次，是若干个具体的处理角色类。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色1. * * Created by blinkfox on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler1</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色1的处理方法.     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色1的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色1 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色2. * * Created by blinkfox on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler2</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色2的处理方法.     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色2的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色2 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色n. * * Created by blinkfox on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandlerN</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这里假设n是链的最后一个节点必须处理掉.     * 在实际情况下，可能出现环，或者是树形，这里并不一定是最后一个节点.     *     * @param condition 参数条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色n的处理方法 结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，代码调用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 责任连模式的客户端场景类. * * Created by blinkfox on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChainClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Handler handler1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handler2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handlern <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handler1<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handler2<span class="token punctuation">)</span><span class="token punctuation">;</span>        handler2<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handlern<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//假设这个请求是ConcreteHandler2的责任</span>        handler1<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：责任链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般由使用该责任链的客户端创建。职责链模式降低了请求的发送者和请求处理者之间的耦合，从而使得多个请求处理者都有机会处理这个请求。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在实际软件开发中，如果遇到有多个对象可以处理同一请求时可以考虑使用职责链模式，最常见的例子包括在 Java Web 应用开发中创建一个过滤器（Filter）链来对请求数据进行过滤（中文字符乱码的处理）、在工作流系统中实现公文的分级审批、在Struts应用中添加不同的拦截器(常用的有类型转化、异常处理，数据校验…)以增强Struts2的功能等。</p><h3 id="纯与不纯的责任链模式"><a href="#纯与不纯的责任链模式" class="headerlink" title="纯与不纯的责任链模式"></a>纯与不纯的责任链模式</h3><ul><li><strong>纯的责任链模式</strong>要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况；</li><li>在纯责任链模式里面，一个请求必须被某一个处理者对象所接收；</li><li>在不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。</li></ul><p>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>降低耦合度，使请求的发送者和接收者解耦，便于灵活的、可插拔的定义请求处理过程；</li><li>简化、封装了请求的处理过程，并且这个过程对客户端而言是透明的，以便于动态地重新组织链以及分配责任，增强请求处理的灵活性；</li><li>可以从职责链任何一个节点开始，也可以随时改变内部的请求处理规则，每个请求处理者都可以去动态地指定他的继任者；</li><li>职责链可简化对象间的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用；</li><li>增加新的请求处理类很方便。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理；</li><li>该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理；</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li><li>职责链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript之再学习</title>
      <link href="/2018/10/30/qian-duan/javascript-zhi-zai-xue-xi/"/>
      <url>/2018/10/30/qian-duan/javascript-zhi-zai-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>JavaScript 是一种面向对象的动态语言，它包含类型、运算符、标准内置（ built-in）对象和方法。它的语法来源于 Java 和 C，所以这两种语言的许多语法特性同样适用于 JavaScript。需要注意的一个主要区别是 JavaScript 不支持类，类这一概念在 JavaScript 通过对象原型（object prototype）得到延续。另一个主要区别是 JavaScript 中的函数也是对象，JavaScript 允许函数在包含可执行代码的同时，能像其他对象一样被传递。</p><h2 id="数据类型和结构"><a href="#数据类型和结构" class="headerlink" title="数据类型和结构"></a>数据类型和结构</h2><h3 id="1-动态类型"><a href="#1-动态类型" class="headerlink" title="1. 动态类型"></a>1. 动态类型</h3><p><code>JavaScript</code>是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// foo is a Number now</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">"bar"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// foo is a String now</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// foo is a Boolean now</span></code></pre><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h3><p>最新的<code>ECMAScript</code>标准定义了 7 种数据类型:</p><ul><li>6 种原始类型<ul><li><code>Null</code> (空, 只有一个值<code>null</code>)</li><li><code>Undefined</code> (未定义, 一个没有被赋值的变量的默认值是<code>undefined</code>):</li><li><code>Boolean</code> (布尔, 可以有两个值：<code>true</code> 和 <code>false</code>)</li><li><code>Number</code> (数字)</li><li><code>String</code> (字符串)</li><li><code>Symbol</code> (符号, ECMAScript 6 新定义的类型，表示独一无二的值)</li></ul></li><li>和 <code>Object</code> (对象)<ul><li><code>Function</code> (函数)</li><li><code>Array</code> (数组)</li><li><code>Date</code> (日期)</li><li><code>JSON</code> (JS对象标识,来序列化对象、数组、数值、字符串、布尔值和 <code>null</code>)</li><li><code>Math</code> (数学方面的计算)</li><li><code>RegExp</code> (正则表达式)</li><li><code>Error</code> (错误)</li><li><code>Map</code></li><li><code>Set</code></li></ul></li></ul><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>这里的<strong>内置对象</strong>指的是在全局作用域(<code>global scope</code>)中的对象，由于很多，不再一一列出说明，更全面的解释在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">这里</a>。</p><p>全局对象本身可通过<code>this</code>操作符在全局作用域中获得。实际上，全局作用域就是由全局对象的各个属性组成的（包括继承来的属性）。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>除了正常运行模式，ECMAscript 5添加了第二种运行模式：”严格模式”（<code>strict mode</code>）。顾名思义，这种模式使得Javascript在更严格的条件下运行。</p><p>严格模式可以应用到整个script标签或个别函数中。设立”严格模式”的目的，主要有以下几个：</p><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><h3 id="为某个script标签开启严格模式"><a href="#为某个script标签开启严格模式" class="headerlink" title="为某个script标签开启严格模式"></a>为某个script标签开启严格模式</h3><p>进入严格模式的标志，是下面这行语句：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'use strict'</span></code></pre><h3 id="为某个函数开启严格模式"><a href="#为某个函数开启严格模式" class="headerlink" title="为某个函数开启严格模式"></a>为某个函数开启严格模式</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">strict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 函数级别严格模式语法</span>  <span class="token string">'use strict'</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token string">"I'm a strict mode function!  "</span> <span class="token operator">+</span> <span class="token function">nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">notStrict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"I'm not strict."</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="相等性判断"><a href="#相等性判断" class="headerlink" title="相等性判断"></a>相等性判断</h2><p>JavaScript提供三种不同的值比较操作：</p><ul><li>严格相等 (“triple equals” 或 “identity”)，使用<code>===</code></li><li>宽松相等 (“double equals”) ，使用<code>==</code></li><li>以及<code>Object.is</code> (ECMAScript 2015/ ES6 新特性)</li></ul><p>简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false );  而<code>Object.is</code>的行为方式与三等号相同，但是对于NaN和-0和+0进行特殊处理，所以最后两个不相同，而<code>Object.is(NaN，NaN)</code>将为 true。</p><p><img src="http://static.blinkfox.com/js_equals.png" alt="各原始类型值的相等比较对照表"></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有<strong>全局作用域</strong>和<strong>局部作用域</strong>两种。</p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域。一般来说以下几种情形：</p><ul><li>最外层函数和在最外层函数外面定义的变量拥有全局作用域。</li><li>所有未定义而直接赋值的变量自动声明为拥有全局作用域。</li><li>所有window对象的属性拥有全局作用域。如：<code>window.name</code>、<code>window.location</code>等。</li></ul><blockquote><p><strong>注</strong>：全局变量存在于程序的整个生命周期。没有块级作用域。</p></blockquote><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>局部作用域一般只在固定的代码片段内可访问到，最常见的是在函数内部，所有在一些地方也会看到有人把这种作用域称为<strong>函数作用域</strong>。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是<code>Scope</code>，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p><p>因为全局变量总是存在于<strong>运行时上下文</strong>作用域链的最末端。所以，在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：<strong>如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用</strong>。</p><p><code>with</code>语句主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。</p><pre class=" language-javascript"><code class="language-javascript">person <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">"yhb"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span><span class="token number">175</span><span class="token punctuation">,</span> wife<span class="token punctuation">:</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">"lwy"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">21</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">with</span> <span class="token punctuation">(</span>person<span class="token punctuation">.</span>wife<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>with语句将<code>person.wife</code>添加到当前作用域链的头部，所以输出的就是：<code>lwy</code>；with语句结束后，作用域链恢复正常。</p><blockquote><p>当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。<br><strong>注</strong>：在程序中应避免使用with语句。</p></blockquote><h2 id="闭包-Closures"><a href="#闭包-Closures" class="headerlink" title="闭包(Closures)"></a>闭包(Closures)</h2><h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><p>如何从外部读取局部变量？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> n<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 999</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（<code>chain scope</code>），子对象会一级一级地向上寻找所有父对象的变量。所以，<strong>父对象的所有变量，对子对象都是可见的，反之则不成立</strong>。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> n<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 999</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> f2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> result<span class="token operator">=</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 999</span></code></pre><h3 id="闭包解释"><a href="#闭包解释" class="headerlink" title="闭包解释"></a>闭包解释</h3><blockquote><p><strong>闭包定义</strong>：闭包是一个函数和函数所声明的词法环境的结合。</p></blockquote><p>在上面的代码中，f2函数就是闭包。<strong>闭包</strong>（<code>closure</code>）定义非常抽象，很难看懂。我的理解是，<strong>闭包就是能够读取其他函数内部变量的函数</strong>。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p>闭包最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在调用结束后被垃圾回收机制（<code>garbage collection</code>）回收。</p><h3 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h3><p>有时你想模拟一个模拟块级作用域，例如你想将变量从全局作用域隔离。完成这个工作的模式叫做<code>IIFE</code>(立即执行函数表达式(<code>Immediately Invoked Function Expression</code>))：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 块开始</span>    <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 非全局变量</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 块结束</span></code></pre><h3 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h3><p>JavaScript 并不提供原生的支持私有方法，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> privateCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">changeBy</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        privateCounter <span class="token operator">+</span><span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        increment<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">changeBy</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        decrement<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">changeBy</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        value<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> privateCounter<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Counter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* logs 0 */</span>Counter<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Counter<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Counter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* logs 2 */</span>Counter<span class="token punctuation">.</span><span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Counter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* logs 1 */</span></code></pre><p>上面创建了一个环境，为三个函数所共享：<code>Counter.increment</code>, <code>Counter.decrement</code>和<code>Counter.value</code>。该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为<code>privateCounter</code>的变量和名为<code>changeBy</code>的函数。这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。</p><p><strong>注意</strong>：</p><ul><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li><li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li></ul><h2 id="内存机制"><a href="#内存机制" class="headerlink" title="内存机制"></a>内存机制</h2><p>首先JavaScript中的变量分为<strong>基本类型</strong>和<strong>引用类型</strong>。</p><ul><li>基本类型就是保存在栈内存中的简单数据段。基本类型有<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>。这些类型在内存中分别占有固定大小的空间，他们的值保存在<strong>栈空间</strong>，我们通过按值来访问的。</li><li>引用类型指的是那些保存在堆内存中的对象。引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。</li></ul><h3 id="为什么会有栈内存和堆内存之分？"><a href="#为什么会有栈内存和堆内存之分？" class="headerlink" title="为什么会有栈内存和堆内存之分？"></a>为什么会有栈内存和堆内存之分？</h3><p>与垃圾回收机制有关，为了使程序运行时占用的内存最小。</p><p>当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；</p><p>当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>Javascript具有自动垃圾回收机制(<code>GC</code>:<code>Garbage Collecation</code>)，也就是说，执行环境会负责管理代码执行过程中使用的内存。</p><p>JavaScript垃圾回收的机制很简单：<strong>找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行</strong>。</p><p>不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。</p><h4 id="清除方式"><a href="#清除方式" class="headerlink" title="清除方式"></a>清除方式</h4><ul><li><strong>标记清除</strong>：垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li><li><strong>引用计数</strong>：引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</li></ul><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型(prototype)"></a>原型(prototype)</h2><p>原型是一个对象，其他对象可以通过它实现属性继承。JavaScript的对象中都包含了一个<code>Prototype</code>内部属性，这个属性所对应的就是该对象的原型。<code>Prototype</code>作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了<code>__proto__</code>这个非标准的访问器。</p><ul><li>所有的对象都有<code>__proto__</code>属性，该属性对应着该对象的原型。</li><li>所有的函数对象都有<code>prototype</code>属性，该属性的值会被赋值给该函数创建的对象的<code>__proto__</code>属性</li><li>所有的原型对象都有<code>constructor</code>属性，该属性对应创建所有指向该原型的实例的构造函数</li><li>函数对象和原型对象通过<code>prototype</code>和<code>constructor</code>属性进行相互关联</li><li><code>Object</code>实例对象的原型<code>obj.__proto__</code>就是<code>Object.prototype</code></li><li><code>hasOwnProperty</code>是<code>Object.prototype</code>的一个方法，该方法能判断一个对象是否包含自定义属性而不是原型链上的属性，因为”hasOwnProperty” 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>因为每个对象和原型都有原型，对象的原型指向对象的父，而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。</p><p>当通过原型链查找一个属性的时候，首先查找的是对象本身的属性，如果找不到才会继续按照原型链进行查找。这样一来，如果想要覆盖原型链上的一些属性，我们就可以直接在对象中引入这些属性，达到属性隐藏的效果。</p><h2 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h2><h3 id="1-Object构造函数方式"><a href="#1-Object构造函数方式" class="headerlink" title="1. Object构造函数方式"></a>1. Object构造函数方式</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Nike'</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span></code></pre><p>这行代码创建了<code>Object</code>引用类型的一个新实例，然后把实例保存在变量<code>Person</code>中。</p><h3 id="2-对象字面量方式"><a href="#2-对象字面量方式" class="headerlink" title="2. 对象字面量方式"></a>2. 对象字面量方式</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Nike'</span><span class="token punctuation">;</span> age<span class="token punctuation">:</span> <span class="token number">29</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性对象的过程。</p><blockquote><p><strong>注</strong>：前两种方法的缺点在于：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有100个对象，那你要输入100次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。</p></blockquote><h3 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    o<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    o<span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    o<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> o<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'Nike'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'teacher'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在使用工厂模式创建对象的时候，我们都可以注意到，在<code>createPerson</code>函数中，返回的是一个对象。但我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式。</p><h3 id="4-构造函数方式"><a href="#4-构造函数方式" class="headerlink" title="4. 构造函数方式"></a>4. 构造函数方式</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nike'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'teacher'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//ture</span></code></pre><p>对比工厂模式，我们可以发现以下区别：</p><ul><li>没有显示地创建对象</li><li>直接将属性和方法赋给了<code>this</code>对象</li><li>没有<code>return</code>语句</li><li>终于可以识别的对象的类型。对于检测对象类型，我们应该使用instanceof操作符，我们来进行自主检测：</li></ul><p>那么构造函数确实挺好用的，但是它也有它的缺点：就是每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法。</p><h3 id="5-原型创建对象模式"><a href="#5-原型创建对象模式" class="headerlink" title="5. 原型创建对象模式"></a>5. 原型创建对象模式</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Nike'</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>jbo <span class="token operator">=</span> <span class="token string">'teacher'</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Greg'</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//'Greg' --来自实例</span><span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//'Nike' --来自原型</span></code></pre><p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。</p><p>这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p><h3 id="6-组合使用构造函数模式和原型模式"><a href="#6-组合使用构造函数模式和原型模式" class="headerlink" title="6. 组合使用构造函数模式和原型模式"></a>6. 组合使用构造函数模式和原型模式</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>    sayName<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nike'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">'teacher'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="7-动态原型模式"><a href="#7-动态原型模式" class="headerlink" title="7. 动态原型模式"></a>7. 动态原型模式</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nike'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">'teacher'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>动态原型模式将所有信息封装在了构造函数中，而通过构造函数中初始化原型（仅第一个对象实例化时初始化原型），这个可以通过判断该方法是否有效而选择是否需要初始化原型。</p><h3 id="8-寄生构造函数方式"><a href="#8-寄生构造函数方式" class="headerlink" title="8. 寄生构造函数方式"></a>8. 寄生构造函数方式</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    o<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    o<span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    o<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> o<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nike'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'teacher'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>寄生模式和工厂模式几乎一样，寄生模式和工厂模式的区别：</p><ul><li>寄生模式创建对象时使用了<code>new</code>关键字</li><li>寄生模式的外部包装函数是一个构造函数</li></ul><blockquote><p><strong>作用</strong>:寄生模式可以在特殊的情况下为对象来创建构造函数,原因在于我们可以通过构造函数重写对象的值，并通过return返回。重写调用构造函数(创建的对象的实例)之后的对象实例的新的值。</p></blockquote><h3 id="9-稳妥构造函数方式"><a href="#9-稳妥构造函数方式" class="headerlink" title="9. 稳妥构造函数方式"></a>9. 稳妥构造函数方式</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    o<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> o<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nike'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">'teacher'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用稳妥构造函数模式只能通过其构造函数内部的方法来获取里面的属性值</span></code></pre><p>道格拉斯·克拉克福德发明了JavaScript中的稳妥对象这个概念。所谓稳妥对象，是指没有公共属性，而且其方法也不引用<code>this</code>对象。稳妥对象最适合在一些安全环境中（这些环境会禁止使用<code>this</code>和<code>new</code>），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循的与寄生构造函数类似的模式，但又两点不同：</p><ul><li>一是新创建对象的实例方法不引用<code>this</code>；</li><li>二是不使用<code>new</code>操作符调用构造函数。</li></ul><blockquote><p><strong>注</strong>：与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间没有什么关系，因此instanceof操作符对这种对象也没有意义。</p></blockquote><h2 id="并发模型和事件循环-event-loop"><a href="#并发模型和事件循环-event-loop" class="headerlink" title="并发模型和事件循环(event loop)"></a>并发模型和事件循环(event loop)</h2><p>JavaScript 的并发模型基于<strong>事件循环</strong>。</p><p><img src="http://static.blinkfox.com/js_event.png" alt="Js堆栈队列图"></p><h3 id="1-运行时概念"><a href="#1-运行时概念" class="headerlink" title="1. 运行时概念"></a>1. 运行时概念</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>函数调用形成了一个栈帧。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当调用 bar 时，创建了第一个帧 ，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 foo 的参数和局部变量。当 foo 返回时，最上层的帧就被弹出栈（剩下 bar 函数的调用帧 ）。当 bar 返回的时候，栈就空了。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都与一个函数相关联。当栈拥有足够内存时，从队列中取出一个消息进行处理。这个处理过程包含了调用与这个消息相关联的函数（以及因而创建了一个初始堆栈帧）。当栈再次为空的时候，也就意味着消息处理结束。</p><h3 id="2-事件循环"><a href="#2-事件循环" class="headerlink" title="2. 事件循环"></a>2. 事件循环</h3><p>之所以称为<strong>事件循环</strong>，是因为它经常被用于类似如下的方式来实现：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">waitForMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  queue<span class="token punctuation">.</span><span class="token function">processNextMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果当前没有任何消息，queue.waitForMessage 会等待着同步将要到来的消息。</p><p>每一个消息完整的执行后，其它消息才会被执行。这个模型的一个缺点在于当一个消息的完成耗时过长，网络应用无法处理用户的交互如点击或者滚动。浏览器用“程序需要过长时间运行”的对话框来缓解这个问题。一个比较好的解决方案是使消息处理变短且如果可能的话，将一个消息拆分成几个消息。</p><p>在浏览器里，当一个事件出现且有一个事件监听器被绑定时，消息会被随时添加。如果没有事件监听器，事件会丢失。所以点击一个附带点击事件处理函数的元素会添加一个消息。其它事件亦然。</p><h3 id="3-绝不阻塞"><a href="#3-绝不阻塞" class="headerlink" title="3. 绝不阻塞"></a>3. 绝不阻塞</h3><p>事件循环(event loop)模型特性在于它<strong>永不阻塞</strong>。通常由事件或者回调函数进行 I/O (input/output)处理 。</p><hr><p>参考文档：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">MDN</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之单例模式</title>
      <link href="/2018/10/29/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-dan-li-mo-shi/"/>
      <url>/2018/10/29/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</p><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>单例模式(<code>Singleton Pattern</code>)</strong>：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种<strong>对象创建型模式</strong>。单例模式又名单件模式或单态模式。</p></blockquote><p>单例模式的要点有三个：</p><ul><li>一是某个类只能有一个实例；</li><li>二是它必须自行创建这个实例；</li><li>三是它必须自行向整个系统提供这个实例。</li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Singleton</code>: 单例</li></ul><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/Java_design_singleton_uml.jpg" alt="单例模式UML类图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/Java_design_singleton_seq.jpg" alt="单例模式时序图"></p><h2 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h2><h3 id="1-饿汉式（推荐使用）"><a href="#1-饿汉式（推荐使用）" class="headerlink" title="1. 饿汉式（推荐使用）"></a>1. 饿汉式（推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 饿汉式单例模式. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 全局唯一实例. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：这种方式避免了多线程的同步问题，但不是懒加载。如果不需要懒加载的方式，推荐使用。</p></blockquote><h3 id="2-非线程安全懒汉式（不推荐使用）"><a href="#2-非线程安全懒汉式（不推荐使用）" class="headerlink" title="2. 非线程安全懒汉式（不推荐使用）"></a>2. 非线程安全懒汉式（不推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 非线程安全的懒汉式. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取实例，但是非线程安全.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，但非线程安全。不推荐使用。</p></blockquote><h3 id="3-低效的线程安全懒汉式（不推荐使用）"><a href="#3-低效的线程安全懒汉式（不推荐使用）" class="headerlink" title="3. 低效的线程安全懒汉式（不推荐使用）"></a>3. 低效的线程安全懒汉式（不推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 低效的线程安全的懒汉式. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，但是效率很低。因为99%的情况下是不需要去同步的。不推荐使用。</p></blockquote><h3 id="4-双重校验锁线程安全懒汉式（不推荐使用）"><a href="#4-双重校验锁线程安全懒汉式（不推荐使用）" class="headerlink" title="4. 双重校验锁线程安全懒汉式（不推荐使用）"></a>4. 双重校验锁线程安全懒汉式（不推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 双重校验锁线程安全懒汉式. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，效率也不错。但受限于Jdk5以前的Java内存模型，仍然会有bug，Java5及之后才能正常达到单例效果。</p></blockquote><h3 id="5-枚举式（强烈推荐使用）"><a href="#5-枚举式（强烈推荐使用）" class="headerlink" title="5. 枚举式（强烈推荐使用）"></a>5. 枚举式（强烈推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 枚举方式的单例. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：在<code>《Effective Java》</code>一书中强烈推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）；线程安全。唯一的缺点是非懒加载方式。</p></blockquote><h3 id="6-静态内部类（推荐使用）"><a href="#6-静态内部类（推荐使用）" class="headerlink" title="6. 静态内部类（推荐使用）"></a>6. 静态内部类（推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 静态内部类.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token function">SingletonHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton4 instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取Singleton唯一实例的方法.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：这种方式利用了<code>ClassLoader</code>的机制保证初始化<code>instance</code>时只有一个线程，其只有显示通过调用<code>getInstance</code>方法时，才会显示装载<code>SingletonHolder</code>类，从而实例化<code>instance</code>。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——<code>Singleton</code>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如<code>Java</code>、<code>C#</code>)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用单例模式：</p><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</li><li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</li><li>实现单例模式，如果不需要懒加载的效果，则推荐使用枚举和饿汉式的方式；如果需要懒加载的效果，则推荐使用静态内部类来实现更好。</li><li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li><li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java异常知识汇总</title>
      <link href="/2018/10/28/hou-duan/java/java-yi-chang-zhi-shi-hui-zong/"/>
      <url>/2018/10/28/hou-duan/java/java-yi-chang-zhi-shi-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="为什么要使用异常"><a href="#为什么要使用异常" class="headerlink" title="为什么要使用异常"></a>为什么要使用异常</h3><p>在我们的程序中，任何时候任何地方因为任何原因都有可能会出现异常，在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：</p><ul><li>容易混淆。如果约定返回值为 -1 时表示出现异常，那么当程序最后的计算结果真的为 -1 呢？</li><li>代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。</li><li>由调用函数来分析异常，这要求程序员对库函数有很深的了解。</li></ul><blockquote><p>在面向对象编程中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。</p></blockquote><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><blockquote><p>异常情形是指阻止当前方法或者作用域继续执行的问题。——《Think in java》</p></blockquote><p>总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。</p><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>在Java中，所有的事件都能由类描述，Java中的异常就是由<code>java.lang</code>包下的异常类来描述的。Java定义了一个异常类的层次结构，其以<code>Throwable</code>（万物即可抛）开始，派生出了<code>Error</code>和<code>Exception</code>，而<code>Exception</code>又派生出了<code>CheckedException</code>和<code>RuntimeException</code>。如下图所示：</p><p><img src="http://static.blinkfox.com/java_exception.png" alt="Java异常体系"></p><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>Throwable（可抛出）是异常类的最终父类，它有两个子类，<code>Error</code>与<code>Exception</code>。</p><p>Throwable 中常用方法有：</p><ul><li><code>synchronized Throwable getCause()</code>：此方法返回异常产生的原因，如果不知道原因的话返回<code>null</code>。</li><li><code>String getMessage()</code>：方法返回<code>Throwable</code>的<code>String</code>型信息，当异常通过构造器创建后可用。</li><li><code>String getLocalizedMessage()</code>：此方法通过被重写来得到用本地语言表示的异常信息返回给调用程序。<code>Throwable</code>类通常只是用<code>getMessage()</code>方法来实现返回异常信息。</li><li><code>void printStackTrace()</code>：该方法打印栈轨迹信息到标准错误流。该方法能接受<code>PrintStream</code>和<code>PrintWriter</code>作为参数实现重载，这样就能实现打印栈轨迹到文件或流中。</li><li><code>String toString()</code>：方法返回<code>String</code>格式的<code>Throwable</code>信息，此信息包括<code>Throwable</code>的名字和本地化信息。</li></ul><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error（错误）：表示程序无法处理的错误，一般与程序员的执行操作无关。理论上这些错误是不允许发生的，如果发生，也不应该试图通过程序去处理，所以 Error 不是<code>try-catch</code>的处理对象，而 JVM 一般的处理方式是终止发生错误的线程。Error 类常见子类有<code>VirtualMachineError</code>、<code>StackOverFlowError</code>、<code>OutOfMemoryError</code>等。</p><p>在Java运行时内存中，除程序计数器外的虚拟机栈、堆、方法区在请求的内存无法被满足时都会抛出<code>OutOfMemoryError</code>；而如果线程请求的栈深度超出虚拟机允许的深度时，就会抛出<code>StackOverFlowError</code>。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>Exception（异常）：出现原因取决于程序，所以程序也理应通过<code>try-catch</code>处理。Exception 异常分为两类：<code>CheckedException</code>和<code>RuntimeException</code>，即<strong>检查异常</strong>与<strong>运行时异常</strong>。</p><ul><li>检查异常：编译器要求必须处理，否则不能通过编译，使用<code>try-catch</code>捕获或者<code>throws</code>抛出。常见的检查异常有<code>IOException</code>及其子类、<code>EOFExcption</code>(文件已结束异常)、<code>FileNotFoundException</code>（文件未找到异常）。</li><li>运行时异常（也叫非检查异常）：编译期不会检查，所以在程序中可不处理，但如果发生，会在运行时抛出。</li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h3><p>在 Java 应用程序中，异常处理机制为：<strong>抛出异常</strong>、<strong>捕捉异常</strong>。</p><ul><li><strong>抛出异常</strong>：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</li><li><strong>捕获异常</strong>：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</li></ul><p>对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。</p><ul><li>对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数 Error 异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</li><li>对于所有的检查异常，Java规定：<strong>一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉检查异常时，它必须声明将抛出异常</strong>。</li><li>对于所有运行时异常，Java规定：<strong>运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常</strong>。</li></ul><p>能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，<strong>一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的</strong>。</p><p>任何Java代码都可以通过 Java 的<code>throw</code>语句抛出异常。</p><p>从方法中抛出的任何异常都必须使用<code>throws</code>子句。</p><p>捕捉异常通过<code>try-catch</code>语句或者<code>try-catch-finally</code>语句实现。</p><blockquote><p>总体来说，Java规定：对于检查异常必须捕捉、或者声明抛出。允许忽略非检查的<code>RuntimeException</code>和<code>Error</code>。</p></blockquote><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><p><code>try-catch</code>语句还可以包括第三部分，就是<code>finally</code>子句。它表示无论是否出现异常，都应当执行的内容。<code>try-catch-finally</code>语句的一般语法形式为：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 可能会发生异常的程序代码</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception1</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 捕获并处理try抛出的异常类型Type1</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception2</span> e2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 捕获并处理try抛出的异常类型Type2</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 无论是否发生异常，都将执行的语句块</span><span class="token punctuation">}</span></code></pre><p>Java7及之后的版本可这样使用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span>MyResource mr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyResource created in try-with-resources"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception1</span> <span class="token operator">|</span> Exception2 e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 捕获并统一处理 try 抛出的多种异常类型，不需要finally块</span><span class="token punctuation">}</span></code></pre><ul><li><code>try</code>块：用于捕获异常。其后可接零个或多个<code>catch</code>块，如果没有<code>catch</code>块，则必须跟一个<code>finally</code>块。</li><li><code>catch</code>块：用于处理<code>try</code>捕获到的异常。</li><li><code>finally</code>块：无论是否捕获或处理异常，<code>finally</code>块里的语句都会被执行。当在<code>try</code>块或<code>catch</code>块中遇到<code>return</code>语句时，<code>finally</code>语句块将在方法返回之前被执行。在以下 4 种特殊情况下，<code>finally</code>块不会被执行：<ul><li>在<code>finally</code>语句块中发生了异常</li><li>在前面的代码中用了<code>System.exit()</code>退出程序</li><li>程序所在的线程死亡</li><li>关闭<code>CPU</code></li></ul></li></ul><h3 id="异常处理语句的语法规则"><a href="#异常处理语句的语法规则" class="headerlink" title="异常处理语句的语法规则"></a>异常处理语句的语法规则</h3><ul><li>必须在<code>try</code>之后添加<code>catch</code>或<code>finally</code>块。<code>try</code>块后可同时接<code>catch</code>和<code>finally</code>块，但至少有一个块。</li><li>必须遵循块顺序：若代码同时使用<code>catch</code>和<code>finally</code>块，则必须将<code>catch</code>块放在<code>try</code>块之后。</li><li><code>catch</code>块与相应的异常类的类型相关。</li><li>一个<code>try</code>块可能有多个<code>catch</code>块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个<code>catch</code>代码块，不会再执行其他的<code>catch</code>代码块。</li><li>可嵌套<code>try-catch-finally</code>结构。</li><li>在<code>try-catch-finally</code>结构中，可重新抛出异常。</li><li>除了下列情况，总将执行<code>finally</code>做为结束：<ul><li>JVM 过早终止（调用 System.exit(int)）；</li><li>在<code>finally</code>块中抛出一个未处理的异常；</li><li>计算机断电、失火、或遭遇病毒攻击。</li></ul></li></ul><h2 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h2><p>任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的<code>throw</code>语句抛出异常。从方法中抛出的任何异常都必须使用<code>throws</code>子句。</p><h3 id="throws抛出异常"><a href="#throws抛出异常" class="headerlink" title="throws抛出异常"></a>throws抛出异常</h3><p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用<code>throws</code>子句来声明抛出异常。<code>throws</code>语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是<code>Exception</code>异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。<code>throws</code>语句的语法格式为：</p><pre class=" language-java"><code class="language-java">methodname <span class="token keyword">throws</span> Exception1<span class="token punctuation">,</span> Exception2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">,</span> ExceptionN <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>方法名后的<code>throws Exception1, Exception2, ... , ExceptionN</code>为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理。使用<code>throws</code>关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。</p><p>throws抛出异常的规则：</p><ul><li>如果是非检查异常（<code>unchecked exception</code>），即<code>Error</code>、<code>RuntimeException</code>或它们的子类，那么可以不使用<code>throws</code>关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何检查异常（<code>checked exception</code>）。即如果一个方法可能出现受检查异常，要么用<code>try-catch</code>语句捕获，要么用<code>throws</code>子句声明将它抛出，否则会导致编译错误。</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何检查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h3 id="使用throw抛出异常"><a href="#使用throw抛出异常" class="headerlink" title="使用throw抛出异常"></a>使用throw抛出异常</h3><p><code>throw</code>总是出现在函数体中，用来抛出一个<code>Throwable</code>类型的异常。程序会在<code>throw</code>语句后立即终止，它后面的语句执行不到，然后在包含它的所有<code>try</code>块中（可能在上层调用函数中）从里向外寻找含有与其匹配的<code>catch</code>子句的<code>try</code>块。异常是异常类的实例对象，我们可以创建异常类的实例对象通过<code>throw</code>语句抛出。该语句的语法格式为：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExceptionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注</strong>：如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。</p></blockquote><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>在设计模式中有一个设计模式叫做<strong>责任链模式</strong>，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：<strong>异常链</strong>。</p><p>我们知道每遇到一个异常信息，我们都需要进行<code>try-catch-finally</code>,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个<code>Exception</code>解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。</p><p>我们有两种方式处理异常，一是<code>throws</code>抛出交给上级处理，二是<code>try-catch</code>做具体处理。但是这个与上面有什么关联呢？<code>try-catch</code>的<code>catch</code>块我们可以不需要做任何处理，仅仅只用<code>throw</code>这个关键字将我们封装异常信息主动抛出来。然后在通过关键字<code>throws</code>继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。</p><p><strong>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性</strong>。</p><p>同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。</p><p>在异常链的使用中，<code>throw</code>抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在<code>Throwable</code>及其子类中的构造器中都可以接受一个<code>cause</code>参数，该参数保存了原有的异常信息，通过<code>getCause()</code>就可以获取该原始异常信息。使用方式如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> MyException<span class="token punctuation">{</span>         <span class="token keyword">try</span> <span class="token punctuation">{</span>             FileReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             Scanner in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//e 保存异常信息</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyException</span><span class="token punctuation">(</span><span class="token string">"文件没有找到--01"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> MyException<span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MyException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//e 保存异常信息</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyException</span><span class="token punctuation">(</span><span class="token string">"文件没有找到--02"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            t<span class="token punctuation">.</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MyException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果在程序中,去掉<code>e</code>，也就是：<code>throw new MyException(“文件没有找到–02″);</code>那么异常信息就保存不了。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>Java确实给我们提供了非常多的异常，但是异常体系是不可能预见所有的希望加以报告的错误。所以，Java允许我们自定义异常来表现程序中可能会遇到的特定问题，总之就是一句话：我们不必拘泥于Java中已有的异常类型。</p><p>Java自定义异常的使用要经历如下四个步骤：</p><ul><li>定义一个类继承<code>Throwable</code>或其子类。</li><li>添加构造方法(当然也可以不用添加，使用默认构造方法)。</li><li>在某个方法类抛出该异常。</li><li>捕捉该异常。</li></ul><p>示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *自定义异常 继承Exception类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">MyException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">MyException</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 测试抛出和捕捉异常的类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">throws</span> MyException<span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyException</span><span class="token punctuation">(</span><span class="token string">"该值不能为0......."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            test<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MyException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>尽可能的减小<code>try</code>块。</li><li>不要在构造函数中抛出异常。</li><li>如果使用Java7及以后的版本，一个catch子句中可以捕获多个异常。</li><li>充分使用<code>finally</code>块，保证所有资源都被正确释放；如果使用Java7及以后的版本，那么更推荐使用<code>try-with-resource</code>语法。</li><li><code>catch</code>语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的<code>Exception</code>类。 不要一个<code>Exception</code>试图处理所有可能出现的异常。</li><li>不要忽略异常。既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。</li><li>在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。</li><li>减轻<code>finally</code>的任务，finally块仅仅用来释放资源是最合适的。不要在<code>finally</code>中使用<code>return</code>、抛出异常等。</li><li>为了给调用者提供尽可能多的信息，从而可以更好地避免/处理异常。对异常进行Javadoc文档说明，并且描述抛出异常的场景。</li><li>不要捕获<code>Throwable</code>。<code>Throwable</code>是所有异常和错误的父类。如果<code>catch</code>了<code>throwable</code>，那么不仅仅会捕获所有<code>Exception</code>，还会捕获<code>Error</code>。而<code>Error</code>是表明无法恢复的JVM错误。因此除非绝对肯定能够处理或者被要求处理<code>Error</code>，不要捕获<code>Throwable</code>。</li><li>包装异常时要包含原始的异常。包装异常时，一定要把原始的异常设置为<code>cause</code>(<code>Exception</code>有构造方法可以传入<code>cause</code>)。否则，丢失了原始的异常信息会让错误的分析变得困难。</li></ul><h2 id="常见异常及解释"><a href="#常见异常及解释" class="headerlink" title="常见异常及解释"></a>常见异常及解释</h2><p>以下是常见<a href="http://rymden.nu/exceptions.html" target="_blank" rel="noopener">Java异常</a>的<strong>非技术角度</strong>的理解。阅读有风险，理解需谨慎。</p><h3 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h3><ul><li><code>ArithmeticException</code>：你正在试图使用电脑解决一个自己解决不了的数学问题，请重新阅读你的算术表达式并再次尝试。</li><li><code>ArrayIndexOutOfBoundsException</code>：请查看<a href="http://rymden.nu/exceptions.html#IndexOutOfBoundsException" target="_blank" rel="noopener">IndexOutOfBoundsException</a>。不同之处在于这个异常越界的元素不止一个。</li><li><code>ArrayStoreException</code>：你已用光了所有数组，需要从数组商店中购买更多的数组。</li><li><code>ClassCastException</code>：你需要呆在自己出生的种姓或阶级。Java 不会允许达利特人表现得像刹帝利或者高贵种族的人假装成为工人阶级。为了保持向前兼容，Java 1.0中把Caste误写为Cast保留到了现在。</li><li><code>ClassNotFoundException</code>：你似乎创造了自己的类。这也是目前 Java 还未实现的种姓制度，但是 Java 明显使用了巴厘岛的种姓制度。也就是说，如果你是一个武士，也就相当于印度种姓制度中的第三层——吠舍。</li><li><code>CloneNotSupportedException</code>：你是一名克隆人。找到你的原型，告诉他你想做什么，然后自杀。</li><li><code>IllegalAccessException</code>：你是一个正在运行 Java 程序入室盗窃的小偷，请结束对电脑的盗窃行为，离开房子，然后再试一次。</li><li><code>IllegalArgumentException</code>：你试图反对之前的异常。</li><li><code>IllegalMonitorStateException</code>：请打开你的电脑屏幕背面。</li><li><code>IllegalStateException</code>：你来自一个尚未被联合国承认的国家，也许是库尔德斯坦或者巴勒斯坦。拿到真正的国籍后重新编译你的 Java 代码，然后再试一次。</li><li><code>IllegalThreadStateException</code>：你电脑的一颗螺丝上到了错误的螺纹孔里，请联系你的硬盘供应商。</li><li><code>IndexOutOfBoundsException</code>：你把食指放在了无法接收的地方，重新放置，再试一次。</li><li><code>InstantiationException</code>：不是每件事都会立即发生，请更耐心一点。</li><li><code>InterruptedException</code>：告诉你的同事、室友等，当你工作的时候，请勿打扰。</li><li><code>NegativeArraySizeException</code>：你创建了一个负数长度的数组。这会丢失信息，长期发展将会毁灭宇宙。不过放宽心，Java 发现了你正在做的事，不要再这么干了。</li><li><code>NoSuchFieldException</code>：你正试图去一个不存在的区域游览。如果你试图去参观一个事实上不存在，其实已经是最高机密的飞机场时，也会得到这个异常。我可以给你示例，然后不得不杀了你。</li><li><code>NoSuchMethodException</code>：不要使用那个方法！拜托了，就像我们一直做的那样去解决事情吧。</li><li><code>NullPointerException</code>：你没有狗。请你先找一只狗，比如一只布烈塔尼獵犬，然后再试一次。</li><li><code>NumberFormatException</code>：你正在使用过时的测量单位，比如英寸或者品脱。请转换成国际基本单位。有一个已知的 bug 会导致 Java 抛出这个异常，那就是你太矮了或者太高了。</li><li><code>RuntimeException</code>：你不能跑得足够快，可能因为你太胖了。关掉你的电脑，出门锻炼吧。</li><li><code>SecurityException</code>：你已被认为是国家安全的一个威胁。请你呆在原地别动，然后等着警察来并带你走。</li><li><code>StringIndexOutOfBoundsException</code>：你的内裤和这个地方格格不入。换掉它们，再试一次。另外如果你根本不穿任何内裤，也会得到这个异常。</li><li><code>UnsupportedOperationException</code>：因为一些原因，你正试图做一个在道德上不被 Java 支持的手术。包括不必要的截肢，例如割包皮。请停止滥用你的身体，不要移除你的孩子，该死的！</li></ul><h3 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h3><ul><li><code>ConcurrentModificationException</code>：有人修改了你的 Java 代码。你应该更改密码。</li><li><code>EmptyStackException</code>：为了让 Java 工作，你必须在桌子上放一叠 Java 书籍。当然，如果书很厚的话，一本就够了。</li><li><code>MissingResourceException</code>：你太穷了，不配使用 Java。换一个更便宜的语言吧（比如 Whitespace、Shakesperre、Cow、Spaghetti 或者 C#）。</li><li><code>NoSuchElementException</code>：这里只存在四种元素（地球、水、空气、火）。《第五元素》只是部电影而已。</li><li><code>TooManyListenersException</code>：你被太多秘密机构窃听了，SecurityException 马上就到。</li></ul><h3 id="java-awt"><a href="#java-awt" class="headerlink" title="java.awt"></a>java.awt</h3><ul><li><code>AWTException</code>：你正在使用AWT，也就是说你的图形界面会很丑。这个异常只是一个警告可以被忽略。</li><li><code>FontFormatException</code>：你的布局很丑陋，或者你选择了一个糟糕的字体，或者太多的字体。请咨询一名专业的设计师。</li><li><code>HeadlessException</code>：Java 认为身为一名程序员，你实在是太蠢了。</li><li><code>IllegalComponentStateException</code>：你的一个硬件（例如硬盘、CPU、内存）坏掉了。请联系你的硬件供应商。</li></ul><h3 id="java-awt-color"><a href="#java-awt-color" class="headerlink" title="java.awt.color"></a>java.awt.color</h3><ul><li><code>CMMException</code>：你的 CMM 坏掉了，真是见鬼了。我经常烧毁自己的房子，然后去一个新的城市重新开始。</li><li><code>ProfileDataException</code>：你的个人档案包含可疑信息。如果你不是一名共产主义者、恐怖分子或者无神论者，请联系 CIA 修正错误。</li></ul><h3 id="java-awt-datatransfer"><a href="#java-awt-datatransfer" class="headerlink" title="java.awt.datatransfer"></a>java.awt.datatransfer</h3><ul><li><code>MimeTypeParseException</code>：你的哑剧（Mime）糟透了，没人能够理解你到底想表达什么。尝试一些更简单的事情吧，比如迎风散步，或者被困在一个看不见的盒子里。</li><li><code>UnsupportedFlavorException</code>：你正试图使用一种 Java 不知道的香料。大部分人似乎只知道使用香草和樱桃。</li></ul><h3 id="java-beans"><a href="#java-beans" class="headerlink" title="java.beans"></a>java.beans</h3><ul><li><code>IntrospectionException</code>：你太内向了，你应该变得外向一些。 别再当一个呆子，出门去见见人吧！</li><li><code>PropertyVetoException</code>：你的一部分财产被冻结了。这条信息应该已经告诉你谁干的和原因。如果没看见，你可能也不该询问。</li></ul><h3 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h3><ul><li><code>CharConversionException</code>：你一直试图焚烧一些不燃物。也可能是因为你试着把自己变成一条鱼，但这不可能发生。</li><li><code>EOFException</code>：你得到这条异常是因为你不知道EOF是什么意思。但是，我并不打算告诉你，因为你是一个不学无术的人。</li><li><code>FileNotFoundException</code>：一名木匠应该总是知道他的工具放在哪里。</li><li><code>InterruptedIOException</code>：你不顾之前的 IOException，一直在使用 IO，然后你的活动就被中断了。</li><li><code>InvalidClassException</code>：查看 ClassNotFoundException。</li><li><code>InvalidObjectException</code>：反对无效，就像他们在法庭上说的一样。</li><li><code>IOException</code>：IO 代表输入、输出，并且不得不做收发数据的事。IO 是一个安全问题，不应使用。</li><li><code>NotActiveException</code>：这个异常意味着两件事。要么是未激活，需要激活；要么是已激活，需要停止。到开始工作为止，激活与未激活都是随机的。</li><li><code>NotSerializableException</code>：你正试图把一部电影改成电视剧。</li><li><code>ObjectStreamException</code>：你提出了一连串的反对（Object）意见。提出新的意见前，请限制自己一下，等待法官作出判决。查看 InvalidObjectException。</li><li><code>OptionalDataException</code>：你似乎认为一些可选数据是必须的。不要让事情变得复杂。</li><li><code>StreamCorruptedException</code>：你的数据流被损坏了，这意味着它已经被截包，并在黑市上贩卖。</li><li><code>SyncFailedException</code>：你试图与其他人同步你的失败，然后被证明比他人更加失败。去找一些跟你同等水平的人吧。</li><li><code>UnsupportedEncodingException</code>：如果你想在网上发送自己的代码，必须与美国国家安全局核对你的加密密匙。如果不这么做，将把你视为恐怖分子，并以适当方式处理。如果你得到这个异常，能跑多快跑多快。</li><li><code>UTFDataFormatException</code>：UTF 代表通用传输格式，是一种无论你使用哪种格式都会用到的数据传输方式。你试图通过 UTF 传输错误格式的数据。</li><li><code>WriteAbortedException</code>：你需要在程序中的某处写上“aborted”。这通常没什么意义，但你就得这样做。</li></ul><h3 id="java-net"><a href="#java-net" class="headerlink" title="java.net"></a>java.net</h3><ul><li><code>BindException</code>：Java编程和束缚不能混为一谈。</li><li><code>ConnectException</code>：你正试图与一个不能连接的事物建立连接。试着连接其他事物吧。也许可以通过一个特殊的连接对象实现你想要的连接。</li><li><code>MalformedURLException</code>：你正在制作一个形状错误的壶（例如一个“L”状），或者你有拼写错误的单词“urn”（例如“url”）。</li><li><code>NoRouteToHostException</code>：没有通往主机的“道路”，请联系公路管理员。</li><li><code>PortUnreachableException</code>：港口必须正确地放置在水边。如果在内陆，它们将会无法接触。</li><li><code>ProtocolException</code>：这是一个严重违反规定的结果（例如在你主机上的“puk韓g”）。解决方法很简单：不要那样做！</li><li><code>SocketException</code>：你把电脑连接到了错误的电源插座。大部分情况下你不得不寻找其它插座，但一些电脑背部有一个开关，可以设置电源插座类型。</li><li><code>SocketTimeoutException</code>：你的电脑连接了一个带计时器的电源插座，并且时间已经走完。只有烙铁和相似的东西才会使用这种插座。</li><li><code>UnknownHostException</code>：你的父母没有教过你不要和陌生人说话么？</li><li><code>UnknownServiceException</code>：你正试图进入接近一个未知服务。众所周知，未知服务或许是特工组织。</li><li><code>URISyntaxException</code>：“You are I”是一个语法错误的句子。将其改为“You are me”，别管那到底啥意思。</li></ul><h3 id="java-rmi"><a href="#java-rmi" class="headerlink" title="java.rmi"></a>java.rmi</h3><ul><li><code>AccessException</code>：你正在使用“Microsoft Access”。请不要这样做。</li><li><code>AlreadyBoundException</code>：不管在 java.net.BindException 的描述中是什么状况，RMI 都提供捆绑服务。然而，你不能绑一个已经被捆绑的人。</li><li><code>ConnectException</code>：你正试图与一个不能连接的事物建立连接。试着连接其他事物吧。也许可以通过一个特殊的连接对象实现你想要的连接。</li><li><code>ConnectIOException</code>：你正试图通过 IO 与另一个不能被连接的事物建立连接。尝试连接其他事物吧。或许你可以通过一个特殊的连接对象实现想要的连接。</li><li><code>MarshalException</code>：你的“marshal”出问题了。你应做的事取决于我们正在讨论的是哪种“marshal”。他可以是陆军元帅、警察、消防队员或者只不过是一名普通的司仪。注意这个异常与马绍尔群岛共和国没有任何关系，也称为 RMI。</li><li><code>NoSuchObjectException</code>：你正试图使用一个不存在的对象。以爱因斯坦之名，创造它或者不要使用它！</li><li><code>NotBoundException</code>：如果你正在使用奴隶，请确认至少有一个人被绑住了。</li><li><code>RemoteException</code>：这是一条远程抛出的特殊异常。如果其他人的应用变得不稳定，以致于不能产生一条异常，相反地，你可能会得到这条异常。请找到源头并提醒那位程序员这个错误。</li><li><code>RMISecurityException</code>：马绍尔群岛共和国变得不稳定了。如果你住在这儿，你最好离开，直到安全得到保障为止都别回来。如果你住在其他地方，可以无视这个异常。</li><li><code>ServerException</code>：第二发球（或者双发失误同样适用）。</li><li><code>ServerRuntimeException</code>：只要是网球比赛都很长。当你花太长时间发球时，就会得到这条异常。</li><li><code>StubNotFoundException</code>：当你去看电影的时候，你应该一直保留自己的票根。如果不这么做，并且离开了电影院，你就不能重新进去，不得不去买张新票。所以保留你的票根！</li><li><code>UnexpectedException</code>：这个异常对你来说应该会成为一个大惊喜。如果发生了，所有事都变成它应该的样子。</li><li><code>UnknownHostException</code>：你父母没有教过你不要和陌生人说话吗？</li><li><code>UnmarshalException</code>：.你没有完成一名法律工作人员的职责（例如你曾经的法官工作）。注意这个正确的术语是“曾经”（used to）。你已经被解雇（fire）了（如果你是一名消防队员（firefighter），这可真是讽刺啊）。</li></ul><h3 id="java-security"><a href="#java-security" class="headerlink" title="java.security"></a>java.security</h3><ul><li><code>AccessControlException</code>：你失去了对 Microsoft Access 的控制。如果你无法重获控制或者通过其他方式停止程序，你应该尽快切断电脑电源。</li><li><code>DigestException</code>：你应该注意自己的食物，消化不良也能变成严重的问题。</li><li><code>GeneralSecurityException</code>：在某些地方做一些事情并不安全。如果你有足够的权力，你应该随机入侵一个国家（最好在中东地区）。如果你没有那种权力，至少应该有一把枪。</li><li><code>InvalidAlgorithmParameterException</code>：你向一位残疾人用他不能理解的方式解释你的算法。简单一点！</li><li><code>InvalidKeyException</code>：这个异常有两种不同的原因：1、你正在使用错误的钥匙。我的建议是在你的钥匙上画不同颜色的小点来帮助你记住哪一把对应哪一个锁。2、 你不能锁住残疾人却不给他们钥匙，如果他们足够聪明发现如何使用钥匙，他们就有自由移动的权- 利。</li><li><code>InvalidParameterException</code>：你使用了蔑视的术语去描述一名残疾人。</li><li><code>KeyException</code>：不要尝试不用钥匙就能开锁。</li><li><code>KeyManagementException</code>：你遗失了自己的钥匙。很可能忘在办公室（如果你正试图进入你家）或者忘在家里（如果你正试图进入办公室）。</li><li><code>KeyStoreException</code>：延续之前 KeyManagementException 的解释就是你的钱包有个洞。</li><li><code>NoSuchAlgorithmException</code>：你试图用以前未知的方法解决问题。停止创新吧，用老算法重写一遍。你也可以为自己的想法申请专利，然后等待未来 Java 发布新版本的时候纳入其中。</li><li><code>NoSuchProviderException</code>：如果你是一名单亲妈妈，你没法成为家庭主妇。首先，你得为家庭找到一名供养者。</li><li><code>PrivilegedActionException</code>：你试图采取一个行动，但是没有得到权限。比如，只有名人才可以做到地从谋杀中逃脱，只有天主教神父和耶和华的高级见证人才能做地猥亵儿童，只有在私人企业担任管理职位的人才能被允许地偷钱。</li><li><code>ProviderException</code>：你是一名妇女并试图供养一个家庭。显而易见，你的丈夫不能成为一名“家庭主妇”，所以你得让他供养个家庭。想象一下，Java固执且不肯改变，事情就是这样工作的，解决它。</li><li><code>SignatureException</code>：要么你是伪造的其他人的签名，要么是无法接受你的签名。一个签名不能太丑陋、太易读或太大。</li><li><code>UnrecoverableKeyException</code>：该死。你把你的钥匙扔进了下水沟。我唯一能安慰你的就是其他人也无法恢复钥匙，所以倒不是必须换掉你的锁。</li></ul><h3 id="java-text"><a href="#java-text" class="headerlink" title="java.text"></a>java.text</h3><ul><li><code>ParseException</code>：你做的没有任何意义，冷静下来，再试一次。</li></ul><hr><p>参考文档：</p><ul><li><a href="http://www.importnew.com/20629.html" target="_blank" rel="noopener">java提高篇之异常（上）</a></li><li><a href="http://www.importnew.com/20645.html" target="_blank" rel="noopener">java提高篇之异常（下）</a></li><li><a href="http://www.importnew.com/14688.html" target="_blank" rel="noopener">深入理解java异常处理机制</a></li><li><a href="http://www.importnew.com/26775.html" target="_blank" rel="noopener">Java 中 9 个处理 Exception 的最佳实践</a></li><li><a href="http://www.importnew.com/16725.html" target="_blank" rel="noopener">Java常见异常及解释</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你需要知道的Java枚举知识</title>
      <link href="/2018/10/27/hou-duan/java/ni-xu-yao-zhi-dao-de-java-mei-ju-zhi-shi/"/>
      <url>/2018/10/27/hou-duan/java/ni-xu-yao-zhi-dao-de-java-mei-ju-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>枚举</strong>（<code>enum</code>全称为<code>enumeration</code>）类型是<code>Java 5</code>新增的类型，存放在<code>java.lang</code>包中，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。</p><h3 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h3><p> 创建枚举类型要使用<code>enum</code>关键字，隐含了所创建的类型都是<code>java.lang.Enum</code>类的子类（<code>java.lang.Enum</code>是一个抽象类）。枚举类型符合通用模式<code>Class Enum&lt;E extends Enum&lt;E&gt;&gt;</code>，而<code>E</code>表示枚举类型的名称。枚举类型的每一个值都将映射到<code>protected Enum(String name, int ordinal)</code>构造函数中。在这里每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。</p><p>枚举类的定义格式如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> 类名 <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//枚举值</span><span class="token punctuation">}</span></code></pre><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>需要的数据不能是任意的，而必须是一定范围内的值</li><li>枚举类也是一个特殊的类，构造方法默认的修饰符是<code>private</code>的</li><li>枚举值默认的修饰符是<code>public static final</code>，必须要位于枚举类的第一个语句</li><li>枚举类可以定义自己的成员变量、成员函数和带参构造方法，自定义带参构造方法时，枚举值需要传参</li><li>枚举类可以存在抽象的方法，但是枚举值必须要实现抽象的方法</li><li>可以使用<code>==</code>来比较枚举实例</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>枚举中的一些常用方法如下：</p><ul><li><code>int ordinal()</code>：返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）。</li><li><code>String name()</code>：返回此枚举常量的名称。</li><li><code>String toString()</code>：返回覆盖枚举常量的<code>toString()</code>方法的值。</li><li><code>int compareTo(E o)</code>：比较此枚举与指定对象的顺序。</li><li><code>Class&lt;E&gt; getDeclaringClass()</code>：返回与此枚举常量的枚举类型相对应的 Class 对象。</li><li><code>static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)</code>：返回指定名称的枚举常量指定的enumtype的方法。如：<code>ColorEnum color = ColorEnum.valueOf(&quot;RED&quot;);</code>。</li></ul><h2 id="主要应用"><a href="#主要应用" class="headerlink" title="主要应用"></a>主要应用</h2><h3 id="表达常量"><a href="#表达常量" class="headerlink" title="表达常量"></a>表达常量</h3><p>在<code>Java 5</code>之前，定义常量的最佳方式是在<code>final</code>修饰的常量类中定义：<code>public static fianl...</code>修饰的属性，且须将构造方法设为<code>private</code>。代码示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ColorConst</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RED <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> GREEN <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> BLUE <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">ColorConst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但，<strong>不建议在接口中定义常量</strong>。在<code>《Effective Java》</code>一书中提到过：</p><blockquote><p><strong>The constant interface pattern is a poor use of interfaces</strong>. That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the class’s exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface.There are several constant interfaces in the java platform libraries, such as java.io.ObjectStreamConstants. These interfaces should be regarded as anomalies and should not be emulated.</p></blockquote><p>大意是：<strong>如果某个实现了常量接口的类被修改不再需要常量了，也会因为序列化兼容原因不得不保持该实现，而且非<code>final</code>类实现常量接口会导致所有子类被污染</strong>。</p><p>现在好了，有了枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> ColorEnum <span class="token punctuation">{</span>    RED<span class="token punctuation">,</span> GREEN<span class="token punctuation">,</span> BLUE<span class="token punctuation">}</span></code></pre><blockquote><p><strong>注意</strong>：枚举类的名称一般以<code>Enum</code>结尾，比如<code>ColorEnum</code>等。如果你写个枚举类，取名为<code>Color</code>，那么没人能快速知道它是一个枚举类。</p></blockquote><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>Java 中使用<code>values()</code>方法将枚举所有元素item转换成一个数组。这样就可以通过<code>foreach</code>语法来遍历枚举中的所有元素了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>ColorEnum color<span class="token operator">:</span> ColorEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"ordinal:{}, name:{}"</span><span class="token punctuation">,</span> color<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出结果；</p><pre class=" language-bash"><code class="language-bash">ordinal:0, name:REDordinal:1, name:GREENordinal:2, name:BLUE</code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>在<code>JDK7</code>之前，String字符串是不支持通过<code>switch</code>语法来筛选数据，但是 Java 为枚举提供了<code>switch</code>语法的支持。使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 客户端传来的枚举item</span>ColorEnum color <span class="token operator">=</span> ColorEnum<span class="token punctuation">.</span>GREEN<span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>color<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> RED<span class="token operator">:</span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"进入了 RED 的分支"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> GREEN<span class="token operator">:</span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"进入了 GREEN 的分支"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> BLUE<span class="token operator">:</span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"进入了 BLUE 的分支"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"进入了 default 的分支"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-bash"><code class="language-bash">进入了 GREEN 的分支</code></pre><blockquote><p><strong>注意</strong>：<code>switch</code>后已经指定了枚举的类型，<code>case</code>后无须再使用全名<code>ColorEnum</code>。</p></blockquote><h3 id="自定义属性和方法"><a href="#自定义属性和方法" class="headerlink" title="自定义属性和方法"></a>自定义属性和方法</h3><p>Java枚举中允许定义属性和方法，但必须在枚举实例序列的最后一个分号后再添加。Java 要求必须先定义枚举实例在前面，使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 关于颜色的枚举. * @author blinkfox on 2017/9/17. */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> ColorEnum <span class="token punctuation">{</span>    <span class="token function">RED</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"红色"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GREEN</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"绿色"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">BLUE</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"蓝色"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 颜色的code. */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> code<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 颜色的名称. */</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 枚举的构造方法默认且只能是private的.     * @param code 代码值     * @param name 名称     */</span>    <span class="token function">ColorEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> code<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 根据颜色的code值获取到对应的名称.     * @param code 颜色code     * @return 颜色名称     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getNameByCode</span><span class="token punctuation">(</span><span class="token keyword">int</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>ColorEnum color<span class="token operator">:</span> ColorEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>color<span class="token punctuation">.</span>code <span class="token operator">==</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> color<span class="token punctuation">.</span>name<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 覆盖的toString方法.     * @return 字符串     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* getter方法. */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注意</strong>：枚举的构造方法默认且只能是<code>private</code>的。</p></blockquote><h3 id="使用枚举来表达多态"><a href="#使用枚举来表达多态" class="headerlink" title="使用枚举来表达多态"></a>使用枚举来表达多态</h3><p>所有的枚举都继承自<code>java.lang.Enum</code>类。由于 Java 不支持多继承，所以枚举不能再继承其他类。但枚举类中可以定义抽象方法，也可以实现一个或者多个接口。由于每一个枚举值会呈现出不同的行为方式，则须要让每个枚举值分别实现方法。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 关于颜色的枚举. * @author blinkfox on 2017/9/17. */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> ColorEnum <span class="token punctuation">{</span>    <span class="token function">RED</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"红色"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"使用了'红色'颜料来喷漆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">GREEN</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"绿色"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"使用了'绿色'颜料来喷漆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">BLUE</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"蓝色"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"使用了'蓝色'颜料来喷漆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>ColorEnum<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 颜色的code. */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> code<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 颜色的名称. */</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 枚举的构造方法默认且只能是private的.     * @param code 代码值     * @param name 名称     */</span>    <span class="token function">ColorEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> code<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 使用不同的颜色来喷漆的抽象方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 根据颜色的code值获取到对应的名称.     * @param code 颜色code     * @return 颜色名称     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getNameByCode</span><span class="token punctuation">(</span><span class="token keyword">int</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>ColorEnum color<span class="token operator">:</span> ColorEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>color<span class="token punctuation">.</span>code <span class="token operator">==</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> color<span class="token punctuation">.</span>name<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* getter方法. */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 覆盖的toString方法.     * @return 字符串     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="枚举集合的使用"><a href="#枚举集合的使用" class="headerlink" title="枚举集合的使用"></a>枚举集合的使用</h3><p>Java 中提供了两个方便操作<code>enum</code>的集合类：<code>java.util.EnumSet</code>和<code>java.util.EnumMap</code>。<code>EnumSet</code>保证集合中的元素不重复；<code>EnumMap</code>中的<code>key</code>是<code>enum</code>类型且不能为<code>null</code>，而<code>value</code>则可以是任意类型。<code>EnumSet</code>和<code>EnumMap</code>内部以数组来实现，性能更好。</p><p>以下是<code>EnumMap</code>的使用示例：</p><pre class=" language-java"><code class="language-java">EnumMap<span class="token operator">&lt;</span>ColorEnum<span class="token punctuation">,</span> String<span class="token operator">></span> colorEnumMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token operator">&lt;</span>ColorEnum<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span>ColorEnum<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>colorEnumMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ColorEnum<span class="token punctuation">.</span>RED<span class="token punctuation">,</span> <span class="token string">"这是EnumMap中的'RED'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>colorEnumMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ColorEnum<span class="token punctuation">.</span>GREEN<span class="token punctuation">,</span> <span class="token string">"这是EnumMap中的'GREEN'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>colorEnumMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ColorEnum<span class="token punctuation">.</span>BLUE<span class="token punctuation">,</span> <span class="token string">"这是EnumMap中的'BLUE'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> colorEnumMap<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出结果：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span>1:红色<span class="token operator">=</span>这是EnumMap中的<span class="token string">'RED'</span>, 2:绿色<span class="token operator">=</span>这是EnumMap中的<span class="token string">'GREEN'</span>, 3:蓝色<span class="token operator">=</span>这是EnumMap中的<span class="token string">'BLUE'</span><span class="token punctuation">}</span></code></pre><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><p>在<code>《Effective Java》</code>一书中强烈推荐<strong>使用枚举来实现单例模式</strong>，同时枚举单例代码也最为简单：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> ColorEnumSingleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do something</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用枚举单例有以下好处：</p><ul><li>自由序列化</li><li>保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）</li><li>线程安全</li></ul><blockquote><p><strong>注意</strong>：枚举单例是<strong>饿汉</strong>式的。</p></blockquote><h3 id="枚举策略"><a href="#枚举策略" class="headerlink" title="枚举策略"></a>枚举策略</h3><p>在使用 Java 的枚举时往往会结合<code>Switch</code>来进行判断以实现不同值的处理，但是我们知道多用<code>switch</code>不是一种很好的代码风格，不利用维护和适应变化，因为这不符合<strong>开闭原则</strong>。为此一种方法是用<strong>策略模式</strong>来重构原有的枚举实现。在<code>《Effective Java》</code>一书中提出了一种<strong>枚举策略模式</strong>很好的解决了这个问题。</p><p>具体使用方法和前面所讲的<strong>使用枚举来表达多态</strong>一节中的示例一样，这里就不再举例说明了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>枚举类也是一个特殊的类，构造方法默认的修饰符是<code>private</code>（不管写不写）的，它们都可以定义一些属性和方法，但是不能使用<code>extends</code>关键字继承其他类，因为<code>enum</code>已经继承了<code>java.lang.Enum</code>（java是单一继承）。</li><li>枚举类中可以定义抽象方法，也可以实现一个或者多个接口。</li><li>使用枚举大大加强了程序的可读性、易用性和可维护性，并且可在此基础之上进行了扩展，使之可以像类一样去使用，更是为 Java 对离散量的表示上升了一个台阶。</li><li>枚举最大的缺点是：<strong>相对于普通的常量会占用更多的内存</strong>。所以，我还是不建议大面积的使用枚举来替代整形常量。但是如果这些常量还有关联属性或者行为等，那么强烈推荐使用枚举类型。<strong>使用枚举类型的性能几乎是使用静态类的16倍</strong>。</li><li>枚举类型对象之间的值比较，可以使用<code>==</code>直接来比较值是否相等的，不是必须使用<code>equals</code>方法。</li><li>推荐使用<strong>枚举单例</strong>来实现单例模式，可以使用<strong>枚举策略</strong>来简化策略模式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合框架知识整理</title>
      <link href="/2018/10/24/hou-duan/java/java-ji-he-kuang-jia-zhi-shi-zheng-li/"/>
      <url>/2018/10/24/hou-duan/java/java-ji-he-kuang-jia-zhi-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<p>Java集合框架主要由<code>Collection</code>和<code>Map</code>两个根接口及其子接口、实现类组成。</p><h2 id="集合类关系梳理"><a href="#集合类关系梳理" class="headerlink" title="集合类关系梳理"></a>集合类关系梳理</h2><ul><li><code>Collection</code>接口继承了<code>Iterable</code>接口，依赖了<code>Predicate</code>、<code>Spliterator</code>、<code>Stream</code>接口（这些均为<code>Java8</code>新增），<code>Iterable</code>接口依赖了<code>Iterator</code>接口。<ul><li><code>List</code>接口继承自<code>Collection</code>接口,依赖了<code>UnaryOperator</code>接口（<code>Java8</code>新增）、<code>ListIterator</code>、<code>Comparator</code>接口</li><li><code>Queue</code>接口继承了<code>Collection</code>接口<ul><li><code>Deque</code>接口继承了<code>Queue</code>接口</li><li><code>BlockingQueue</code>接口继承了<code>Queue</code>接口<ul><li><code>BlockingDeque</code>接口继承了<code>BlockingQueue</code>、<code>Deque</code>接口</li><li><code>TransferQueue</code>接口继承了<code>BlockingQueue</code>接口</li></ul></li></ul></li><li><code>AbstractCollection</code>抽象类实现了<code>Collection</code>接口，<ul><li><code>AbstractList</code>抽象类继承了<code>AbstractCollection</code>抽象类，实现了<code>List</code>接口，依赖了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口<ul><li><code>ArrayList</code>类继承了<code>AbstractList</code>抽象类，实现了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li><li><code>AbstractSequentialList</code>抽象类继承了<code>AbstractList</code>抽象类<ul><li><code>LinkedList</code>类继承了<code>AbstractSequentialList</code>抽象类，实现了<code>List</code>、<code>Deque</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li></ul></li><li><code>CopyOnWriteArrayList</code>实现了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li><li><code>Vector</code>类继承了<code>AbstractList</code>抽象类，实现了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口<ul><li><code>Stack</code>类继承了<code>Vector</code>类</li></ul></li></ul></li><li><code>AbstractQueue</code>抽象类继承了<code>AbstractCollection</code>接口，实现了<code>Queue</code>接口<ul><li><code>SynchronousQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingQueue</code>、<code>Serializable</code>接口，依赖了<code>Collection</code>、<code>Spliterator</code>接口</li><li><code>ArrayBlockingQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingQueue</code>、<code>Serializable</code>接口</li><li><code>LinkedBlockingQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingQueue</code>、<code>Serializable</code>接口</li><li><code>PriorityBlockingQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingQueue</code>、<code>Serializable</code>接口，聚合了<code>Comparator</code>接口，依赖了<code>Collection</code>、<code>Comparator</code>、<code>Comparable</code>接口</li><li><code>DelayQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingQueue</code>接口</li><li><code>LinkedBlockingDeque</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingDeque</code>、<code>Serializable</code>接口</li><li><code>PriorityQueue</code>类继承了<code>AbstractQueue</code>接口</li><li><code>LinkedTransferQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>TransferQueue</code>、<code>Serializable</code>接口（Java7新增）</li></ul></li><li><code>ConcurrentLinkedDeque</code>类继承了<code>AbstractCollection</code>抽象类，实现了<code>Deque</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li><li><code>ArrayDeque</code>类继承了<code>AbstractCollection</code>抽象类，实现了<code>Deque</code>、<code>Serializable</code>接口</li></ul></li><li><code>Set</code>接口继承自<code>Collection</code>接口<ul><li><code>AbstractSet</code>抽象类继承了<code>AbstractCollection</code>抽象类，实现了<code>Set</code>接口<ul><li><code>HashSet</code>类继承了<code>AbstractSet</code>抽象类，实现了<code>Set</code>、<code>Cloneable</code>、<code>Serializable</code>接口，聚合了<code>HashMap</code><ul><li><code>LinkedHashSet</code>类继承了<code>HashSet</code>类，实现了<code>Set</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li></ul></li><li><code>TreeSet</code>类继承了<code>AbstractSet</code>抽象类，实现了<code>NavigableSet</code>、<code>Cloneable</code>、<code>Serializable</code>接口，聚合了<code>NavigableMap</code>，依赖了<code>Comparator</code>、<code>SortedSet</code>接口</li><li><code>EnumSet</code>抽象类继承了<code>AbstractSet</code>抽象类，实现了<code>Cloneable</code>、<code>Serializable</code>接口，依赖了<code>Comparator</code>、<code>SortedSet</code>接口<ul><li><code>RegularEnumSet</code>类继承了<code>EnumSet</code>抽象类</li><li><code>JumboEnumSet</code>类继承了<code>EnumSet</code>抽象类</li></ul></li><li><code>ConcurrentSkipListSet</code>类继承了<code>AbstractSet</code>抽象类，实现了<code>NavigableSet</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li><li><code>CopyOnWriteArraySet</code>类继承了<code>AbstractSet</code>抽象类，实现了<code>Serializable</code>接口，聚合了<code>CopyOnWriteArrayList</code>类，依赖了<code>Predicate</code>、<code>Consumer</code>接口</li></ul></li><li><code>SortedSet</code>接口继承自<code>Set</code>接口，依赖了<code>Comparator</code>接口<ul><li><code>NavigableSet</code>接口继承自<code>SortedSet</code>接口(Java6新增)</li></ul></li></ul></li></ul></li><li><code>Map</code>接口依赖了<code>Set</code>、<code>Collection</code>、<code>BiConsumer</code>、<code>Function</code>、<code>BiFunction</code>接口，<code>Map.Entry</code>是Map中的内部接口<ul><li><code>AbstractMap</code>抽象类实现了<code>Map</code>接口，聚合了<code>Collection</code>、<code>Set</code>接口<ul><li><code>HashMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>接口，依赖了<code>Collection</code>、<code>Set</code>接口<ul><li><code>LinkedHashMap</code>继承了<code>HashMap</code>类，实现了<code>Map</code>接口，依赖了<code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>接口</li></ul></li><li><code>TreeMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>NavigableMap</code>、<code>Cloneable</code>、<code>Serializable</code>接口，依赖了<code>Comparator</code>、<code>SortedMap</code>、<code>Collection</code>、<code>Set</code>、<code>BiConsumer</code>、<code>BiFunction</code>接口</li><li><code>EnumMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>Cloneable</code>、<code>Serializable</code>接口，依赖了<code>AbstractSet</code>类，<code>Collection</code>、<code>Set</code>接口</li><li><code>WeakHashMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>Map</code>接口，依赖了<code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>BiFunction</code>接口</li><li><code>IdentityHashMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>Map</code>、<code>Serializable</code>、<code>Cloneable</code>接口，依赖了<code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>BiFunction</code>接口</li><li><code>ConcurrentHashMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>ConcurrentMap</code>、<code>Serializable</code>接口，依赖了<code>Comparable</code>、<code>ParameterizedType</code>、<code>Collection</code>、<code>Set</code>、<code>Spliterator</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>Function</code>、<code>BiFunction</code>、<code>ToDoubleFunction</code>、<code>DoubleBinaryOperator</code>等接口</li><li><code>ConcurrentSkipListMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>ConcurrentNavigableMap</code>、<code>Cloneable</code>、<code>Serializable</code>接口，聚合了<code>Comparator</code>接口，依赖了<code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>BiFunction</code>、<code>NavigableSet</code>接口</li></ul></li><li><code>SortedMap</code>接口继承自<code>Map</code>接口，依赖了<code>Set</code>、<code>Collection</code>、<code>Comparator</code>接口<ul><li><code>NavigableMap</code>接口继承了<code>SortedMap</code>接口，依赖了<code>NavigableSet</code>接口</li><li><code>ConcurrentNavigableMap</code>接口继承了<code>ConcurrentMap</code>、<code>NavigableMap</code>接口，聚合了<code>NavigableSet</code>接口</li></ul></li><li><code>ConcurrentMap</code>接口继承了<code>Map</code>接口，依赖了<code>BiConsumer</code>、<code>BiFunction</code>接口</li><li><code>Hashtable</code>类继承了<code>Dictionary</code>抽象类，实现了<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>接口，聚合了<code>Collection</code>、<code>Set</code>接口，依赖了<code>Enumeration</code>、<code>BiConsumer</code>、<code>BiFunction</code>接口<ul><li><code>Properties</code>类继承了<code>Hashtable</code>类</li></ul></li></ul></li><li><code>Collections</code>是<code>Collection</code>的辅助工具类，依赖了上述大多数接口和类</li><li><code>Arrays</code>是数组的辅助工具类，依赖了上述一些接口和类</li></ul><h2 id="集合UML关系图"><a href="#集合UML关系图" class="headerlink" title="集合UML关系图"></a>集合UML关系图</h2><p>Java Collection UML类关系图如下：</p><p><img src="http://static.blinkfox.com/Java_Collection_UML.png" alt="Java Collection UML类关系图"></p><p>Java Map UML类关系图如下：</p><p><img src="http://static.blinkfox.com/Java_Map_UML.png" alt="Java Map UML类关系图"></p><h2 id="各集合接口、类的介绍"><a href="#各集合接口、类的介绍" class="headerlink" title="各集合接口、类的介绍"></a>各集合接口、类的介绍</h2><ul><li><code>Collection</code>：<code>Collection</code>是最基本集合接口，它定义了一组允许重复的对象。<code>Collection</code>接口派生了三个子接口<code>List</code>、<code>Set</code>和<code>Queue</code>。<code>Collection</code>所有实现类的遍历都可以使用<code>Iterator</code>接口或者是<code>foreach</code>来循环。<ul><li><code>List</code>：<code>List</code>代表有序、可重复的集合。<ul><li><code>ArrayList</code>：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程不安全，效率高。<code>ArrayList</code>创建时的大小为<code>0</code>；当加入第一个元素时，进行第一次扩容时，默认容量大小为<code>10</code>，每次扩容都以当前数组大小的1.5倍去扩容。</li><li><code>Vector</code>：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程安全，效率低。<code>Vector</code>创建时的默认大小为<code>10</code>；<code>Vector</code>每次扩容都以当前数组大小的<code>2</code>倍去扩容。当指定了<code>capacityIncrement</code>之后，每次扩容仅在原先基础上增加<code>capacityIncrement</code>个单位空间。<code>ArrayList</code>和<code>Vector</code>的<code>add</code>、<code>get</code>、<code>size</code>方法的复杂度都为<code>O(1)</code>，<code>remove</code>方法的复杂度为<code>O(n)</code>。<ul><li><code>Stack</code>：<code>Vector</code>的一个子类，是标准的<strong>先进后出</strong>(FILO, First In Last Out)的栈。底层通过数组实现的，线程安全。</li></ul></li><li><code>LinkedList</code>：底层使用双向循环链表的数据结构来实现，排列有序可重复，查询速度慢、增删数据快，线程不安全。</li><li><code>CopyOnWriteArrayList</code>：底层使用<code>Copy-On-Write</code>的优化策略实现，适用于<strong>读多写少</strong>的场景，同<code>ArrayList</code>功能相似，线程安全。<code>CopyOnWriteArrayList</code>在某些情况下比<code>Collections.synchronizedList(List list)</code>有更好的性能。缺点是：内存占用大和数据一致性问题，只能保证最终一致性。</li></ul></li><li><code>Set</code>：<code>Set</code>代表无序、不可重复的集合。<ul><li><code>HastSet</code>：底层使用<code>Hash</code>表来实现，内部使用了<code>HashMap</code>，排列无序不可重复，存取速度快，线程不安全。<ul><li><code>LinkedHashSet</code>：底层采用<code>Hash</code>表存储，并用双向链表记录插入顺序，排列有序不可重复，存取速度较<code>HashSet</code>略慢，比<code>TreeSet</code>快，线程不安全。</li></ul></li><li><code>TreeSet</code>：底层使用红黑树来实现，内部使用了<code>NavigableMap</code>，按自然顺序或者自定义顺序存放、不可重复，线程不安全。</li><li><code>CopyOnWriteArraySet</code>：底层使用<code>Copy-On-Write</code>的优化策略实现，适用于<strong>读多写少</strong>的场景，内部使用了<code>CopyOnWriteArrayList</code>，同<code>HastSet</code>功能相似，线程安全。</li><li><code>ConcurrentSkipListSet</code>：底层使用<strong>跳跃列表</strong>来实现，适用于<strong>高并发</strong>的场景，内部使用了<code>ConcurrentNavigableMap</code>，同<code>TreeSet</code>功能相似，线程安全。</li><li><code>EnumSet</code>：是抽象类，只能用来存储Enum常量或其子类，不能存储其它类型，<code>EnumSet</code>有两种实现方式，<code>RegularEnumSet</code>和<code>JumboEnumSet</code>，但是这两种实现方式是包<strong>私有</strong>的，不能在包外访问，因此必须使用工厂方法来创建并返回<code>EnumSet</code>实例，不能通过构造函数来创建。<code>EnumSet</code>中提供了多种创建<code>EnumSet</code>实例的静态工厂方法，例如<code>of</code>方法（进行了函数重载），<code>copyOf</code>方法，<code>noneOf</code>方法等。存储效率快，线程不安全。存储枚举常量时使用<code>EnumSet</code>而不要用<code>HashSet</code>。</li></ul></li><li><code>Queue</code>：<code>Queue</code>是Java 5之后增加的集合体系，表示<strong>队列</strong>集合的相关实现，大多遵循<strong>先进先出</strong>(FIFO, First-In-First-Out)的模式。<ul><li><code>PriorityQueue</code>：即优先队列，底层基于<strong>优先堆的一个无界队列</strong>来实现，无界但可选容量界限。这个优先队列中的元素可以默认自然排序或者通过提供的<code>Comparator</code>（比较器）在队列实例化的时排序，而不是先进先出。不允许空值、不支持<code>non-comparable</code>（不可比较）的对象，每次从队列中取出的是具有最高优先权的元素，线程不安全。</li><li><code>ArrayBlockingQueue</code>：底层基于<strong>定长数组</strong>的阻塞队列实现，即是线程安全的有界阻塞队列。<code>ArrayBlockingQueue</code>内部通过<strong>互斥锁</strong>保护竞争资源，实现了多线程对竞争资源的互斥访问。队列中的锁是没有分离的，所以在添加的同时就不能读取，读取的同时就不能添加，所以锁方面性能不如<code>LinkedBlockingQueue</code>。</li><li><code>LinkedBlockingQueue</code>：即链接队列，底层基于<strong>单向链表</strong>的阻塞队列实现，无界但可选容量界限，线程安全。队列中的锁是分离的，即添加用的是<code>putLock</code>，获取是<code>takeLock</code>，所以在添加获取方面理论上性能会高于<code>ArrayBlockingQueue</code>。所以<code>LinkedBlockingQueue</code>更适合实现生产者-消费者队列。</li><li><code>PriorityBlockingQueue</code>：即优先阻塞队列，底层基于<strong>优先堆的一个无界队列</strong>来实现，无界但可选容量界限的阻塞队列，线程安全，功能同<code>PriorityQueue</code>、<code>LinkedBlockQueue</code>相似。其所含对象的排序不是先进先出，而是依据对象的自然排序顺序或者是构造函数的<code>Comparator</code>决定的顺序。</li><li><code>SynchronousQueue</code>：即同步队列，是一种线程安全无缓冲的无界阻塞队列。其操作必须是放和取交替完成的，即每个<code>put</code>必须等待一个<code>take</code>，反之亦然。</li><li><code>DelayQueue</code>：即延迟队列，是一种有序无界阻塞队列，只有在延迟期满时才能从中提取元素，线程安全。</li><li><code>ArrayDeque</code>：底层采用了循环数组的方式来完成双端队列的实现，无限扩展且可选容量。Java已不推荐使用<code>Stack</code>，而是推荐使用更高效的<code>ArrayDeque</code>来实现栈的功能，非线程安全。</li><li><code>LinkedBlockingDeque</code>：底层采用了<strong>双向链表</strong>实现的<strong>双端阻塞并发</strong>队列，无限扩展且可选容量。该阻塞队列同时支持<code>FIFO</code>和<code>FILO</code>两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。</li><li><code>ConcurrentLinkedDeque</code>：底层采用了<strong>双向链表</strong>实现的<strong>双端非阻塞并发</strong>队列，无限扩展且可选容量。该队列同时支持<code>FIFO</code>和<code>FILO</code>两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。</li><li><code>LinkedTransferQueue</code>：底层采用了<strong>单向链表</strong>实现的<strong>无界传输阻塞</strong>队列，先进先出，无限扩展且可选容量线程安全。</li></ul></li></ul></li><li><code>Map</code>：<code>Map</code>代表具有映射关系的集合。<ul><li><code>HashMap</code>：底层是用<strong>链表数组</strong>，<code>Java8</code>后又加了<strong>红黑树</strong>来实现，键无序不可重复可为null、值可重复可为null，存取速度快，线程不安全。<ul><li><code>LinkedHashMap</code>：底层是用<strong>链表数组</strong>存储，并用双向链表记录插入顺序，键有序不可重复可为null、值可重复可为null，存取速度快较<code>HashMap</code>略慢，比<code>TreeMap</code>快，线程不安全。</li></ul></li><li><code>HashTable</code>：底层是用<strong>链表数组</strong>，键无序不可重复可为null、值可重复可为null，存取速度较<code>HashMap</code>慢，线程安全。<ul><li><code>Properties</code>：是<code>HashTable</code>的子类，是&lt;String,String&gt;的映射，比<code>HashTable</code>多了<code>load</code>、<code>store</code>两个方法，线程安全。</li></ul></li><li><code>TreeMap</code>：底层使用红黑树来实现，内部使用了<code>Comparator</code>，按自然顺序或自定义顺序存放键，键不可重复不可为null、值可重复可为null，存取速度较<code>HashMap</code>慢，线程不安全。</li><li><code>EnumMap</code>：底层使用数组来实现，是专门为枚举类型量身定做的Map，性能更好。只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以<code>EnumMap</code>使用数组来存放与枚举类型对应的值，线程不安全。</li><li><code>WeakHashMap</code>：同<code>HashMap</code>基本相似。区别在于，<code>HashMap</code>的<code>key</code>保留对象的强引用，这意味着只要该<code>HashMap</code>对象不被销毁，该<code>HashMap</code>对象所有key所引用的对象不会被垃圾回收，<code>HashMap</code>也不会自动删除这些<code>key</code>所对应的<code>key-value</code>对象；但<code>WeakHashMap</code>的<code>key</code>只保留对实际对象的弱引用，这意味着当垃圾回收了该<code>key</code>所对应的实际对象后，<code>WeakHashMap</code>会自动删除该<code>key</code>对应的<code>key-value</code>对象。</li><li><code>IdentityHashMap</code>：同<code>HashMap</code>基本相似。区别在于，在处理两个<code>key</code>相等时，对于普通<code>HashMap</code>而言，只要<code>key1</code>和<code>key2</code>通过<code>equals</code>比较返回<code>true</code>时就认为key相同；在<code>IdentityHashMap</code>中，当且仅当两个<code>key</code>严格相等时(<code>key1 = key2</code>)时才认为两个<code>key</code>相同。</li><li><code>ConcurrentHashMap</code>：底层使用<strong>锁分段</strong>技术来实现线程安全，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。<code>ConcurrentHashMap</code>是由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成。<code>Segment</code>是一种可重入锁<code>ReentrantLock</code>，在<code>ConcurrentHashMap</code>里扮演锁的角色，<code>HashEntry</code>则用于存储键值对数据。一个<code>ConcurrentHashMap</code>里包含一个<code>Segment</code>数组，<code>Segment</code>的结构和<code>HashMap</code>类似，是一种数组和链表结构， 一个<code>Segment</code>里包含一个<code>HashEntry</code>数组，每个<code>HashEntry</code>是一个链表结构的元素， 每个<code>Segment</code>守护者一个<code>HashEntry</code>数组里的元素,当对<code>HashEntry</code>数组的数据进行修改时，必须首先获得它对应的<code>Segment</code>锁。</li><li><code>ConcurrentSkipListMap</code>：底层使用<strong>跳跃列表</strong>来实现，适用于<strong>高并发</strong>的场景，内部使用了<code>ConcurrentNavigableMap</code>，同<code>TreeMap</code>功能相似，是一个并发的、可排序的Map，线程安全。因此它可以在多线程环境中弥补<code>ConcurrentHashMap</code>不支持排序的问题。</li></ul></li></ul><p>Java集合框架功能介绍思维导图如下：</p><p><img src="http://static.blinkfox.com/Java_collections_mind.png" alt="Java集合框架功能介绍思维导图"></p><h3 id="一些概念解释"><a href="#一些概念解释" class="headerlink" title="一些概念解释"></a>一些概念解释</h3><ul><li><strong>跳表</strong>：是一种采用了用空间换时间思想的数据结构。它会随机地将一些节点提升到更高的层次，以创建一种逐层的数据结构，以提高操作的速度。</li><li><strong>阻塞队列和非阻塞的区别</strong>：如果队列里面已经放满了，如果是阻塞队列那么线程会一直阻塞，而非阻塞对垒则会抛出异常。</li></ul><h3 id="一些数据结构的优缺点"><a href="#一些数据结构的优缺点" class="headerlink" title="一些数据结构的优缺点"></a>一些数据结构的优缺点</h3><ul><li><strong>Hash表</strong>：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。</li><li><strong>红黑树</strong>：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。</li><li><strong>SkipList</strong>：插入、查找为O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。</li></ul><h2 id="一些接口的主要方法梳理"><a href="#一些接口的主要方法梳理" class="headerlink" title="一些接口的主要方法梳理"></a>一些接口的主要方法梳理</h2><h3 id="Collection接口中的抽象方法"><a href="#Collection接口中的抽象方法" class="headerlink" title="Collection接口中的抽象方法"></a>Collection接口中的抽象方法</h3><ul><li><code>int size()</code>，返回集合的大小</li><li><code>boolean isEmpty()</code>，返回集合是否为空的布尔值</li><li><code>boolean contains(Object o)</code>，返回集合是否包含元素<code>o</code>的布尔值</li><li><code>Iterator&lt;E&gt; iterator()</code>，返回该集合中元素的迭代器，继承自<code>Iterable</code>接口</li><li><code>Object[] toArray()</code>，返回一个包含此集合中所有元素的数组</li><li><code>&lt;T&gt; T[] toArray(T[] a)</code>，<code>toArray()</code>方法的泛型版本，返回一个包含此集合中所有元素的数组，返回类型由传入数组参数的类型决定</li><li><code>boolean add(E e)</code>，返回向集合中插入元素<code>e</code>是否成功的布尔值</li><li><code>boolean remove(Object o)</code>，返回从集合中删除元素<code>o</code>是否成功的布尔值</li><li><code>boolean containsAll(Collection&lt;?&gt; c)</code>，返回本集合中是否完全包含集合<code>c</code>的布尔值，即判断集合<code>c</code>是否是本集合子集</li><li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>，将集合<code>c</code>中的所有元素添加到本集合中并返回</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>，移除本集合中所有包含集合<code>c</code>的所有元素</li><li><code>default boolean removeIf(Predicate&lt;? super E&gt; filter)</code>，Java8新增的接口默认方法。将会批量删除符合filter条件的所有元素，该方法需要一个Predicate对象作为作为参数，Predicate也是函数式接口，因此可使用Lambda表达式作为参数。</li><li><code>boolean retainAll(Collection&lt;?&gt; c)</code>，返回本集合和集合<code>c</code>中相同的元素并存到本集合中,集合<code>c</code>保持不变，返回值表示的是本集合是否发生过改变。即该方法是用来求两个集合的交集，交集的结果存到本集合中，如果本集合没发生变化则返回<code>true</code></li><li><code>void clear()</code>，清空本集合中的所有元素</li><li><code>boolean equals(Object o)</code>，返回本集合是否和对象<code>o</code>相等的布尔值</li><li><code>int hashCode()</code>，返回此集合的<code>Hash</code>码值</li><li><code>default Spliterator&lt;E&gt; spliterator()</code>，在集合中创建<code>Spliterator</code>对象<ul><li><code>Spliterator</code>是Java 8引入的新接口，顾名思义，<code>Spliterator</code>可以理解<code>Iterator</code>的<code>Split</code>版本（但用途要丰富很多）。使用<code>Iterator</code>的时候，我们可以顺序地遍历容器中的元素，使用<code>Spliterator</code>的时候，我们可以将元素分割成多份，分别交于不于的线程去遍历，以提高效率。使用<code>Spliterator</code>每次可以处理某个元素集合中的一个元素 — 不是从<code>Spliterator</code>中获取元素，而是使用<code>tryAdvance()</code>或<code>forEachRemaining()</code>方法对元素应用操作。但<code>Spliterator</code>还可以用于估计其中保存的元素数量，而且还可以像细胞分裂一样变为一分为二。这些新增加的能力让流并行处理代码可以很方便地将工作分布到多个可用线程上完成。</li></ul></li><li><code>default Stream&lt;E&gt; stream()</code>，返回一个顺序的<code>Stream</code>对象。Java8引入了Stream以实现对集合更方便地进行函数式编程。</li><li><code>default Stream&lt;E&gt; parallelStream()</code>，返回一个可能并行的<code>Stream</code>对象。Java8新增的方法。流可以是顺序的也可以是并行的。顺序流的操作是在单线程上执行的，而并行流的操作是在多线程上并发执行的。</li></ul><h3 id="List接口中的额外抽象方法"><a href="#List接口中的额外抽象方法" class="headerlink" title="List接口中的额外抽象方法"></a>List接口中的额外抽象方法</h3><ul><li><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code>，将指定集合<code>c</code>中的所有元素插入到指定索引位置处</li><li><code>default void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，Java8新增的使用<code>Lambda</code>的方式，通过应用<code>UnaryOperator</code>获得的结果来替换列表中的每个元素</li><li><code>default void sort(Comparator&lt;? super E&gt; c)</code>，在比较器的基础上将本列表排序</li><li><code>E get(int index)</code>，获取本集合中指定索引位置处的元素</li><li><code>E set(int index, E element)</code>，设置或替换本集合中指定索引位置处的元素</li><li><code>void add(int index, E element)</code>，在本集合中的指定索引位置处插入指定的元素</li><li><code>E remove(int index)</code>，移除本集合中指定索引位置处的元素</li><li><code>int indexOf(Object o)</code>，返回指定元素第一次出现的索引位置</li><li><code>int lastIndexOf(Object o)</code>，返回指定元素最后出现的索引位置</li><li><code>ListIterator&lt;E&gt; listIterator()</code>，返回本集合中的<code>ListIterator</code>迭代器</li><li><code>ListIterator&lt;E&gt; listIterator(int index)</code>，返回本集合中从指定索引位置开始的<code>ListIterator</code>迭代器</li><li><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code>，返回指定开始和结束索引位置的子集合</li></ul><h3 id="Set接口中的额外抽象方法"><a href="#Set接口中的额外抽象方法" class="headerlink" title="Set接口中的额外抽象方法"></a>Set接口中的额外抽象方法</h3><p>无</p><h3 id="Map接口中的抽象方法"><a href="#Map接口中的抽象方法" class="headerlink" title="Map接口中的抽象方法"></a>Map接口中的抽象方法</h3><ul><li><code>boolean containsKey</code>，判断本Map集合中是否包含指定的key键</li><li><code>boolean containsValue</code>，判断本Map集合中是否包含指定的value值</li><li><code>V get(Object key)</code>，根据key获取本Map集合中的value值</li><li><code>V get(Object key)</code>，向本Map集合中存放key键和value值,返回value值</li><li><code>V remove(Object key)</code>，根据key删除本Map集合中的key和value值，并返回删除的value值</li><li><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code>，将指定的Map集合添加到本的Map集合当中</li><li><code>Set&lt;K&gt; keySet()</code>，获取本Map集合中的所有key值，并以Set接口的结果作为返回</li><li><code>Collection&lt;V&gt; values()</code>，获取本Map集合中的所有value值，并以Collection接口的结果作为返回</li><li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>，获取本Map集合中的所有key和value值，并以<code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code>的结果作为返回</li><li><code>default V getOrDefault(Object key, V defaultValue)</code>，根据key获取本Map集合中的value值，如果没找到对应的值或者value值是null,则返回<code>defaultValue</code>的值</li><li><code>default void forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code>，Java8新增的使用<code>Lambda</code>的方式遍历操作Map中的元素的默认接口方法</li><li><code>default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</code>，Java8新增的使用<code>Lambda</code>的方式遍历替换Map中的元素的默认接口方法</li><li><code>default V putIfAbsent(K key, V value)</code>，Java8新增的不用写是否为null值的检测语句向Map中保存key和value的元素的默认接口方法，即如果通过key获取到的value是空的，则在调用<code>put(key, value)</code>方法并返回value值</li><li><code>default boolean remove(Object key, Object value)</code>，Java8新增的默认接口方法，删除给定key所对应的元素，如果value不存在、为null或者与参数中的value不等，则不能删除。即删除操作需要满足给定的值需要和map中的值相等的条件</li><li><code>default boolean replace(K key, V oldValue, V newValue)</code>，Java8新增的默认接口方法，替换给定key所对应的元素，如果value不存在、为null或者与参数中的oldValue不等，则不能替换。即替换操作需要满足给定的值需要和map中的值相等的条件</li><li><code>default V replace(K key, V value)</code>，Java8新增的默认接口方法，替换给定key所对应的元素，如果value不为null，则value值与参数中的value值做替换。</li><li><code>default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</code>，Java8新增的默认接口方法，根据key获取到的value如果不为null，则直接返回value值，否则将<code>Lambda</code>表达式中的结果值存放到Map中</li><li><code>default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>，Java8新增的默认接口方法，根据key获取到的value和新计算的值如果不为null，则直接新计算的值，否则移除该key，且返回null</li><li><code>default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>，Java8新增的默认接口方法，将<code>Lambda</code>表达式中的结果值存放到Map中，如果计算的新值为null则返回null，且移除以前有的key和value值</li><li><code>default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</code>，Java8新增的默认接口方法，将新计算的值覆盖Map中原key对应的value值</li></ul><h3 id="SortedSet接口中的额外抽象方法"><a href="#SortedSet接口中的额外抽象方法" class="headerlink" title="SortedSet接口中的额外抽象方法"></a>SortedSet接口中的额外抽象方法</h3><ul><li><code>Comparator&lt;? super E&gt; comparator()</code>，返回本SortedSet集合中的<code>Comparator</code>比较器</li><li><code>SortedSet&lt;E&gt; subSet(E fromElement, E toElement)</code>，获取开始元素和结束元素之间的子SortedSet集合</li><li><code>SortedSet&lt;E&gt; headSet(E toElement)</code>，获取开始元素和<code>toElement</code>元素之间的子SortedSet集合</li><li><code>SortedSet&lt;E&gt; tailSet(E fromElement)</code>，获取<code>fromElement</code>元素和结束元素之间的子SortedSet集合</li><li><code>E first()</code>，获取本SortedSet集合中的第一个元素</li><li><code>E last()</code>，获取本SortedSet集合中的最后一个元素</li></ul><h3 id="SortedMap接口中的额外抽象方法"><a href="#SortedMap接口中的额外抽象方法" class="headerlink" title="SortedMap接口中的额外抽象方法"></a>SortedMap接口中的额外抽象方法</h3><ul><li><code>Comparator&lt;? super K&gt; comparator()</code>，返回本SortedMap集合中的<code>Comparator</code>比较器</li><li><code>SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)</code>，获取开始key和结束key之间的子SortedMap集合</li><li><code>SortedMap&lt;K,V&gt; headMap(K toKey)</code>，获取开始key和<code>toKey</code>元素之间的子SortedMap集合</li><li><code>SortedMap&lt;K,V&gt; tailMap(K fromKey)</code>，获取<code>fromKey</code>元素和结束key之间的子SortedMap集合</li><li><code>K firstKey()</code>，获取本SortedMap集合中的第一个key</li><li><code>K lastKey()</code>，获取本SortedMap集合中的最后一个key</li><li><code>Set&lt;K&gt; keySet()</code>，获取本SortedMap集合中所有key的Set集合</li><li><code>Collection&lt;V&gt; values()</code>，获取本SortedMap集合中所有value的Collection集合</li><li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>，获取本SortedMap集合中所有key和value的Map集合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UML各类关系介绍</title>
      <link href="/2018/10/22/ruan-jian-she-ji/uml-ge-lei-guan-xi-jie-shao/"/>
      <url>/2018/10/22/ruan-jian-she-ji/uml-ge-lei-guan-xi-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="继承关系（generalization）"><a href="#继承关系（generalization）" class="headerlink" title="继承关系（generalization）"></a>继承关系（generalization）</h2><p><strong>继承</strong>关系用一条带<strong>空心箭头的直线</strong>表示。如下图所示（A继承自B）：</p><p><img src="http://static.blinkfox.com/uml_demo_1.png" alt="A继承自B"></p><p><strong>继承</strong>指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。<strong>继承关系为<code>is-a</code>的关系</strong>，是类与类或者接口与接口之间最常见的关系之一，在Java中此类关系通过关键字<code>extends</code>来表示。</p><blockquote><p><strong>注意</strong>：表现在代码中，继承关系表现为<strong>一个类继承另一个类或者一个接口继承另一个接口</strong>。</p></blockquote><h2 id="实现关系（realization）"><a href="#实现关系（realization）" class="headerlink" title="实现关系（realization）"></a>实现关系（realization）</h2><p><strong>实现</strong>关系是用一条带<strong>空心箭头的虚线</strong>表示。如下图所示（A实现B）：：</p><p><img src="http://static.blinkfox.com/uml_demo_2.png" alt="A实现B"></p><p><strong>实现</strong>指的是一个<code>class</code>类实现<code>interface</code>接口（可以是多个）的功能。实现是类与接口之间最常见的关系之一，在Java中此类关系通过关键字<code>implements</code>来表示。</p><blockquote><p><strong>注意</strong>：表现在代码中，实现关系表现为<strong>普通类实现某个接口</strong>。</p></blockquote><h2 id="关联关系（association）"><a href="#关联关系（association）" class="headerlink" title="关联关系（association）"></a>关联关系（association）</h2><p><strong>关联</strong>关系是用一条<strong>可能会有方向的直线</strong>表示的。关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如上图，表示A关联B，但B不关联A；如下图所示：</p><p><img src="http://static.blinkfox.com/uml_demo_3.png" alt="A关联B"></p><p><strong>关联</strong>关系体现的是两个类、或者类与接口之间语义级别的一种强依赖的结构关系，是一种长期的静态稳定的关系，通常与运行状态无关，一般由常识等因素决定的。</p><p>例如：乘车人和车票之间就是一种关联关系。</p><blockquote><p><strong>注意</strong>：表现在代码中，<strong>被关联类以类属性的形式出现在关联类中，也可能是关联类引用了一个类型为被关联类的全局变量</strong>。</p></blockquote><h2 id="聚合关系（aggregation）"><a href="#聚合关系（aggregation）" class="headerlink" title="聚合关系（aggregation）"></a>聚合关系（aggregation）</h2><p><strong>聚合</strong>关系用一条带<strong>空心菱形箭头的直线</strong>表示，如下图所示A聚合到B，或者说B由A组成。</p><p><img src="http://static.blinkfox.com/uml_demo_4.png" alt="A聚合到B"></p><p><strong>聚合</strong>关系用于表示实体对象之间的关系，表示整体由部分构成的意思。<strong>聚合是关联关系的一种特例，它体现的是整体与部分、拥有的关系，即<code>has-a</code>的关系</strong>，此时整体与部分之间是<strong>可分离</strong>的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。例如一个部门由多个员工组成。</p><blockquote><p><strong>注意</strong>：表现在代码中，和关联关系是一致的，只能从语义级别来区分。聚合与组合不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在。</p></blockquote><h2 id="组合关系（composition）"><a href="#组合关系（composition）" class="headerlink" title="组合关系（composition）"></a>组合关系（composition）</h2><p><strong>组合</strong>关系用一条带<strong>实心菱形箭头的直线</strong>表示，如下图表示A组成B，或者B由A组成。</p><p><img src="http://static.blinkfox.com/uml_demo_5.png" alt="A组合到B"></p><p><strong>组合</strong>关系同样表示整体由部分组成的意思。与聚合关系一样，<strong>组合也是关联关系的一种特例，它体现的是一种整体与部分不可分割的关系，即<code>contains-a</code>的关系，这种关系比聚合更强，也称为强聚合</strong>。例如公司由多个部门组成组合，但此时整体与部分是<strong>不可分离</strong>的，整体的生命周期结束也就意味着部分的生命周期结束。</p><blockquote><p><strong>注意</strong>：表现在代码中，和关联关系是一致的，只能从语义级别来区分。组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也就不存在了。例如，公司不存在了，部门也将不存在了。</p></blockquote><h2 id="依赖关系（dependency）"><a href="#依赖关系（dependency）" class="headerlink" title="依赖关系（dependency）"></a>依赖关系（dependency）</h2><p><strong>依赖</strong>关系是用一套<strong>带箭头的虚线</strong>表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系。</p><p><img src="http://static.blinkfox.com/uml_demo_6.png" alt="A依赖于B"></p><p><strong>依赖</strong>关系是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A，与关联关系不同的是，它是一种<strong>临时性</strong>的关系，通常在运行期间产生，并且随着运行时的变化依赖关系也可能发生变化。</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。</p><blockquote><p><strong>注意</strong>：表现在代码中，依赖关系体现为<strong>类的构造方法及类方法的传入参数</strong>。</p></blockquote><h2 id="UML类关系图示例"><a href="#UML类关系图示例" class="headerlink" title="UML类关系图示例"></a>UML类关系图示例</h2><p>请看以下这个UML类关系图：</p><p><img src="http://static.blinkfox.com/uml_demo_0.png" alt="UML示例"></p><ul><li>开车的类图结构表示的是一个接口</li><li>有一个自行车的抽象类，实现了开车的接口，它们之间的关系为实现关系，使用带空心三角箭头的虚线表示</li><li>自行车与摩拜单车之间是继承关系，使用带空心三角箭头的实线表示</li><li>学生上学需要用到摩拜单车，与摩拜单车是一种依赖关系，使用带箭头的虚线表示</li><li>学生与身份证之间为关联关系，使用一根实线表示，如果两个类之间互相通过属性引用，则是双向关联关系</li><li>学生与班级、学生与学校之间是聚合关系，使用带空心菱形箭头的实线表示</li><li>学校与班级是组合关系，使用带实心菱形箭头的实线表示</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象编程的理解</title>
      <link href="/2018/10/21/bian-cheng-zhi-dao/mian-xiang-dui-xiang-bian-cheng-de-li-jie/"/>
      <url>/2018/10/21/bian-cheng-zhi-dao/mian-xiang-dui-xiang-bian-cheng-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h2><h3 id="面向过程思想概述"><a href="#面向过程思想概述" class="headerlink" title="面向过程思想概述"></a>面向过程思想概述</h3><p>面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。</p><h3 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h3><p>当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。面向对象是基于面向过程的编程思想。</p><h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><ul><li>抽象</li><li>封装</li><li>继承</li><li>多态</li></ul><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面：</p><ul><li>数据抽象：表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性)</li><li>过程抽象：表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法)</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。隐藏之后，外部程序就不能接触和改变那些细节，所以不用担心自己的类会受到非法修改，可确保它们不会对其他程序造成影响。</p><h4 id="封装的原则"><a href="#封装的原则" class="headerlink" title="封装的原则"></a>封装的原则</h4><ul><li>将不需要对外提供的内容都隐藏起来</li><li>把属性都隐藏，提供公共方法对其访问</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一种联结类的层次模型，并且允许和鼓励类的重用，提供一种明确表达共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，原始类称为新类的基类(父类)。派生类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。因此可以说，继承为了重用父类代码，同时为实现多态性作准备。</p><h4 id="继承概念的实现方式"><a href="#继承概念的实现方式" class="headerlink" title="继承概念的实现方式"></a>继承概念的实现方式</h4><ul><li>类继承：类继承是指直接使用基类的属性和方法而无需额外编码。</li><li>接口继承：接口继承是指仅使用属性和方法的名称、但是子类必须提供实现。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><h4 id="实现多态的方式"><a href="#实现多态的方式" class="headerlink" title="实现多态的方式"></a>实现多态的方式</h4><ul><li>重载</li><li>重写</li><li>实现接口</li></ul><h2 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h2><p>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了<strong>代码重用</strong>。而多态则是为了实现另一个目的：<strong>接口重用</strong>！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</p><h3 id="面向对象开发"><a href="#面向对象开发" class="headerlink" title="面向对象开发"></a>面向对象开发</h3><p>就是不断的创建对象，使用对象，指挥对象做事情。</p><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>更好的管理和维护对象之间的关系。</p><h3 id="面向对象优点"><a href="#面向对象优点" class="headerlink" title="面向对象优点"></a>面向对象优点</h3><ul><li>更符合我们思想习惯的思想</li><li>将复杂的事情简单化</li><li>将我们从执行者变成了指挥者</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之建造者模式</title>
      <link href="/2018/10/20/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-jian-zao-zhe-mo-shi/"/>
      <url>/2018/10/20/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>造者模式(<code>Builder Pattern</code>)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于<strong>对象创建型模式</strong>。建造者模式又可以称为<strong>生成器模式</strong>。</p></blockquote><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>建造者模式包含如下角色：</p><ul><li><code>Builder</code>：抽象建造者</li><li><code>ConcreteBuilder</code>：具体建造者</li><li><code>Director</code>：导演者</li><li><code>Product</code>：产品角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Builder.jpg" alt="建造者模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是产品类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 产品类. * * Created by blinkfox on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String part1<span class="token punctuation">;</span>    <span class="token keyword">private</span> String part2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* getter 和 setter方法. */</span>    <span class="token keyword">public</span> String <span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> part1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPart1</span><span class="token punctuation">(</span>String part1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>part1 <span class="token operator">=</span> part1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> part2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPart2</span><span class="token punctuation">(</span>String part2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>part2 <span class="token operator">=</span> part2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实，是抽象的建造者<code>Builder</code>接口和具体的建造者<code>ConcreteBuilder</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的建造者. * * Created by blinkfox on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分1.     */</span>    <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分2.     */</span>    <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 得到建造的产品.     *     * @return 产品     */</span>    Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的建造者实现类. * * Created by blinkfox on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 产品. */</span>    <span class="token keyword">private</span> Product product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPart1</span><span class="token punctuation">(</span><span class="token string">"编号：95757"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPart2</span><span class="token punctuation">(</span><span class="token string">"名称：小机器人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 得到建造的产品.     *     * @return 产品     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，导演者<code>Director</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 导演者类. * * Created by blinkfox on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 当前需要的建造者对象. */</span>    <span class="token keyword">private</span> Builder builder<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param builder     */</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品构造方法，负责调用各个零件建造方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是建造者模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 建造者模式的客户端场景类. * * Created by blinkfox on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuilderClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Director director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>抽象建造者类中定义了产品的创建方法和返回方法;</p><p>建造者模式的结构中还引入了一个导演者类<code>Director</code>，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象</p><p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>建造者模式的优点：</p><ul><li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>建造者模式的缺点：</p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用建造者模式：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul><h3 id="4-建造者模式与抽象工厂模式的比较"><a href="#4-建造者模式与抽象工厂模式的比较" class="headerlink" title="4. 建造者模式与抽象工厂模式的比较"></a>4. 建造者模式与抽象工厂模式的比较</h3><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。</li><li>建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造</li><li>在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</li><li>建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li><li>建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之外观模式</title>
      <link href="/2018/10/18/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-wai-guan-mo-shi/"/>
      <url>/2018/10/18/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-wai-guan-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><blockquote><p><strong>外观模式</strong>(<code>Facade Pattern</code>)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为<strong>门面模式</strong>，它是一种对象结构型模式。</p></blockquote><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>外观模式包含如下角色：</p><ul><li><code>Facade</code>: 外观角色</li><li><code>SubSystem</code>: 子系统角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Facade.jpg" alt="命令模式结构图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是各个子系统角色类，分别如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类A. * * Created by blinkfox on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法A..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类B. * * Created by blinkfox on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassB</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法B..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类C. * * Created by blinkfox on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassC</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法C..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是外观模式的外观类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 外观门面类. * * Created by blinkfox on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Facade</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ClassA a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ClassB b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ClassC c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以下是提供给外部访问的方法.</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">doSomethingA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">doSomethingB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">doSomethingC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“<strong>迪米特法则</strong>”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p><ul><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式的目的在于降低系统的复杂程度。</li><li>外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>外观模式的优点k：</p><ul><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>外观模式的缺点：</p><ul><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“<strong>开闭原则</strong>”。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用外观模式：</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h2 id="五、模式总结"><a href="#五、模式总结" class="headerlink" title="五、模式总结"></a>五、模式总结</h2><ul><li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li><li>外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li><li>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之中介者模式</title>
      <link href="/2018/10/17/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhong-jie-zhe-mo-shi/"/>
      <url>/2018/10/17/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhong-jie-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：</p><ul><li>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li><li>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li><li>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li><li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。</li><li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。</li></ul><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>中介者模式(<code>Mediator Pattern</code>)</strong>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为<strong>调停者模式</strong>，它是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>中介者模式包含如下角色：</p><ul><li><code>Mediator</code>: 抽象中介者</li><li><code>ConcreteMediator</code>: 具体中介者</li><li><code>Colleague</code>: 抽象同事类</li><li><code>ConcreteColleague</code>: 具体同事类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Mediator.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Mediator</code>类和具体的<code>ConcreteMediator</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通用抽象中介者类. * * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义同事类1. */</span>    <span class="token keyword">protected</span> ConcreteColleague1 colleague1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 定义同事类2. */</span>    <span class="token keyword">protected</span> ConcreteColleague2 colleague2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* getter 和 setter 方法 */</span>    <span class="token keyword">public</span> ConcreteColleague1 <span class="token function">getColleague1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colleague1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColleague1</span><span class="token punctuation">(</span>ConcreteColleague1 colleague1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>colleague1 <span class="token operator">=</span> colleague1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ConcreteColleague2 <span class="token function">getColleague2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colleague2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColleague2</span><span class="token punctuation">(</span>ConcreteColleague2 colleague2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>colleague2 <span class="token operator">=</span> colleague2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的抽象业务逻辑1.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的抽象业务逻辑2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的通用中介者类. * * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteMediator</span> <span class="token keyword">extends</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的具体业务逻辑1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague1<span class="token punctuation">.</span><span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague2<span class="token punctuation">.</span><span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的具体业务逻辑2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague1<span class="token punctuation">.</span><span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague2<span class="token punctuation">.</span><span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实，是抽象的<code>Colleague</code>类和具体的<code>ConcreteColleague</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的同事类. * * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 中介者. */</span>    <span class="token keyword">protected</span> Mediator mediator<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Colleague</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mediator <span class="token operator">=</span> mediator<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的同事类1. * * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteColleague1</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleague1</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague1-处理自己的业务逻辑1--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 依赖方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague1-委托给中介者的业务逻辑1--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>mediator<span class="token punctuation">.</span><span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的同事类2. * * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteColleague2</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleague2</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague2-处理自己的业务逻辑2--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 依赖方法2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague2-委托给中介者的业务逻辑2--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>mediator<span class="token punctuation">.</span><span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是中介者模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 中介者模式的场景类 * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediatorClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Mediator mediator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteMediator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleague1 colleague1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleague1</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleague2 colleague2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleague2</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">setColleague1</span><span class="token punctuation">(</span>colleague1<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">setColleague2</span><span class="token punctuation">(</span>colleague2<span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague1<span class="token punctuation">.</span><span class="token function">depMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague2<span class="token punctuation">.</span><span class="token function">depMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>中介者模式可以使对象之间的关系数量急剧减少。</p><p>中介者承担两方面的职责：</p><ul><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>中介者模式的优点：</p><ul><li>简化了对象之间的交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>中介者模式的缺点：</p><ul><li>在具体中介者类中包含了同事之间的交互细节，<strong>可能会导致具体中介者类非常复杂，使得系统难以维护</strong>。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用中介者模式：</p><ul><li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。</li><li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</li><li>中介者模式包含四个角色：抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</li><li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</li><li>中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li><li>中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之命令模式</title>
      <link href="/2018/10/16/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ming-ling-mo-shi/"/>
      <url>/2018/10/16/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ming-ling-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>命令模式(<code>Command Pattern</code>)</strong>：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(<code>Action</code>)模式或事务(<code>Transaction</code>)模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>命令模式包含如下角色：</p><ul><li><code>Command</code>: 抽象命令类</li><li><code>ConcreteCommand</code>: 具体命令类</li><li><code>Invoker</code>: 调用者</li><li><code>Receiver</code>: 接收者</li><li><code>Client</code>: 客户类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Command.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Receiver</code>类和具体的<code>Receiver</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通用的抽象 Receiver 接收者. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义每个接收者都必须完成的业务.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Receiver 类1. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver1</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver1 处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Receiver 类2. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver2</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver2 处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实，是抽象的<code>Command</code>类和具体的<code>Command</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的 Command 类. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 命令的抽象执行命令的方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Command 命令类1. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand1</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 对哪个receiver类进行处理. */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand1</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 必须实现的一个命令.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Command 命令类2. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand2</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 对哪个receiver类进行处理. */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand2</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 必须实现的命令.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，调用者<code>Invoker</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 调用者 Invoker 类. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Invoker</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Command command<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCommand</span><span class="token punctuation">(</span>Command command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 执行命令.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是命令模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 命令模式的场景类. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Invoker invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Receiver receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteReceiver1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Command command <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCommand1</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把命令交给调用者执行</span>        invoker<span class="token punctuation">.</span><span class="token function">setCommand</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p><strong>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开</strong>。</p><ul><li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>命令模式的优点：</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的<code>Undo</code>和<code>Redo</code>。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>命令模式的缺点：</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用命令模式：</p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。</li><li>命令模式包含四个角色：抽象命令类中声明了用于执行请求的<code>execute()</code>等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li><li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。</li><li>命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>代码整洁之道内容概要</title>
      <link href="/2018/10/15/bian-cheng-zhi-dao/dai-ma-zheng-ji-zhi-dao-nei-rong-gai-yao/"/>
      <url>/2018/10/15/bian-cheng-zhi-dao/dai-ma-zheng-ji-zhi-dao-nei-rong-gai-yao/</url>
      
        <content type="html"><![CDATA[<p>读了代码整洁之道，觉得这本书写的很好，所以就将里面自己觉得很经典的内容记录下来，作为自己以后写代码的标准和准则。同时也为那些曾经困惑过的人一点参考吧！</p><h2 id="一、在正式开始之前，我们先思考几个几个问题："><a href="#一、在正式开始之前，我们先思考几个几个问题：" class="headerlink" title="一、在正式开始之前，我们先思考几个几个问题："></a>一、在正式开始之前，我们先思考几个几个问题：</h2><h3 id="1-需求与代码哪个重要？"><a href="#1-需求与代码哪个重要？" class="headerlink" title="1.需求与代码哪个重要？"></a>1.需求与代码哪个重要？</h3><p>答：并不是所有的产品都能提出合理的需求，当你面对一个提出不合理需求的产品的时候，你需要坚持自己的原则，不能妥协。</p><h3 id="2-易读和易懂是一回事吗？"><a href="#2-易读和易懂是一回事吗？" class="headerlink" title="2.易读和易懂是一回事吗？"></a>2.易读和易懂是一回事吗？</h3><p>答：易读的代码和易懂的代码是有区别的，不是易读的代码就是易懂的代码。</p><h3 id="3-什么是测试驱动代码？"><a href="#3-什么是测试驱动代码？" class="headerlink" title="3.什么是测试驱动代码？"></a>3.什么是测试驱动代码？</h3><p>答：测试驱动代码，你写的代码要可以执行单元测试。如果你发现你的代码很难写单元测试，那么你就要思考你的代码是不是已经不整洁了，或者说已经乱成一团了。</p><h3 id="4-什么是简单的代码？"><a href="#4-什么是简单的代码？" class="headerlink" title="4.什么是简单的代码？"></a>4.什么是简单的代码？</h3><p>答：<br>1.能通过所有测试<br>2.没有重复代码<br>3.体现系统中全部设计理念<br>4.包含尽量少的实体，包括，类，函数，方法等</p><p>如果某段代码在程序设计中反复出现，就证明想法在代码中没有很好的体现出来。总之，不要重复代码，只做一件事，表达力，小规模抽象。</p><h2 id="二、第二章-有意义的命名"><a href="#二、第二章-有意义的命名" class="headerlink" title="二、第二章 有意义的命名"></a>二、第二章 有意义的命名</h2><h3 id="1-名副其实"><a href="#1-名副其实" class="headerlink" title="1.名副其实"></a>1.名副其实</h3><p>变量，函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事情，应该怎么用。如果名称需要注释来补充，那么就不算名副其实。</p><h3 id="2-避免误导"><a href="#2-避免误导" class="headerlink" title="2.避免误导"></a>2.避免误导</h3><p>必须避免留下掩藏代码本意的错误线索。</p><h3 id="3-做有意义的区分"><a href="#3-做有意义的区分" class="headerlink" title="3.做有意义的区分"></a>3.做有意义的区分</h3><p>只要体现出有意义的区分，使用a和the这样的前缀就没有错。废话就是冗余。</p><h3 id="4-使用读得出来的名称"><a href="#4-使用读得出来的名称" class="headerlink" title="4.使用读得出来的名称"></a>4.使用读得出来的名称</h3><p>不要用傻乎乎的自造词，而不是恰当的英语词。</p><h3 id="5-使用可搜索的名称"><a href="#5-使用可搜索的名称" class="headerlink" title="5.使用可搜索的名称"></a>5.使用可搜索的名称</h3><p>使用便于搜索的名字。</p><h3 id="6-避免使用编码"><a href="#6-避免使用编码" class="headerlink" title="6.避免使用编码"></a>6.避免使用编码</h3><p>把类型或者作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的代码之外，还要再搞懂另一种编码”语言”。</p><h3 id="7-避免思维映射"><a href="#7-避免思维映射" class="headerlink" title="7.避免思维映射"></a>7.避免思维映射</h3><p>不应当让读者在脑中把你的名称翻译为他们熟知的名称，尤其是在经常出现在选择是使用问题领域术语还是解决方案领域术语的时候。</p><h3 id="8-类名或对象名最好使用名词或者名词短语"><a href="#8-类名或对象名最好使用名词或者名词短语" class="headerlink" title="8.类名或对象名最好使用名词或者名词短语"></a>8.类名或对象名最好使用名词或者名词短语</h3><h3 id="9-方法名最好使用动词或者动词短语"><a href="#9-方法名最好使用动词或者动词短语" class="headerlink" title="9.方法名最好使用动词或者动词短语"></a>9.方法名最好使用动词或者动词短语</h3><h3 id="10-别扮可爱"><a href="#10-别扮可爱" class="headerlink" title="10.别扮可爱"></a>10.别扮可爱</h3><p>命名一定要通俗易懂。</p><h3 id="11-每一个概念对应一个词"><a href="#11-每一个概念对应一个词" class="headerlink" title="11.每一个概念对应一个词"></a>11.每一个概念对应一个词</h3><p>给每个抽象概念选择一个词，并一以贯之</p><h3 id="12-别用双关语词"><a href="#12-别用双关语词" class="headerlink" title="12.别用双关语词"></a>12.别用双关语词</h3><p>避免将同一个词用于不同目的，遵循一词一义的原则</p><h3 id="13-使用解决方案领域名"><a href="#13-使用解决方案领域名" class="headerlink" title="13.使用解决方案领域名"></a>13.使用解决方案领域名</h3><h3 id="14-使用源自所涉领域名"><a href="#14-使用源自所涉领域名" class="headerlink" title="14.使用源自所涉领域名"></a>14.使用源自所涉领域名</h3><h3 id="15-添加有意义的语境"><a href="#15-添加有意义的语境" class="headerlink" title="15.添加有意义的语境"></a>15.添加有意义的语境</h3><p>在一个bean中定义变量名的时候，变量名一定是基于实际使用场景。</p><h3 id="16-不要添加没用的语境"><a href="#16-不要添加没用的语境" class="headerlink" title="16.不要添加没用的语境"></a>16.不要添加没用的语境</h3><h2 id="三、第三章-函数"><a href="#三、第三章-函数" class="headerlink" title="三、第三章 函数"></a>三、第三章 函数</h2><h3 id="1-短小"><a href="#1-短小" class="headerlink" title="1.短小"></a>1.短小</h3><p>函数第一规则是要短小。第二条规则是还要更短小。</p><h3 id="2-只做一件事"><a href="#2-只做一件事" class="headerlink" title="2.只做一件事"></a>2.只做一件事</h3><ul><li>函数应该做一件事。做好这件事。只做一件事。如果可以从你的函数中还能拆分出一个函数，该函数不仅只是单纯地重新诠释其实现，那么你设计的函数就不是一个好的函数。</li><li>函数中的区段，如果函数被切分了多个区段，这就证明该函数做的事情太多了。</li></ul><h3 id="3-每个函数一个抽象层级"><a href="#3-每个函数一个抽象层级" class="headerlink" title="3.每个函数一个抽象层级"></a>3.每个函数一个抽象层级</h3><h3 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4.switch语句"></a>4.switch语句</h3><p>确保每个switch都埋藏在较低的抽象层级，而且永远不重复。</p><h3 id="5-使用描述性的名称"><a href="#5-使用描述性的名称" class="headerlink" title="5.使用描述性的名称"></a>5.使用描述性的名称</h3><p>命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。例如：includeSetupPages。</p><h3 id="6-函数参数"><a href="#6-函数参数" class="headerlink" title="6.函数参数"></a>6.函数参数</h3><ul><li>最理想的函数参数的数量是零个，其次是一，再次是二，应尽量避免三。有足够的理由才能用上三个以上的参数。</li><li>如果函数看来需要两个，三个或者三个以上参数，就说明其中一些参数应该封装为类了。</li><li>函数和函数的参数命名一般是动名词比较好。</li></ul><h3 id="7-无副作用"><a href="#7-无副作用" class="headerlink" title="7.无副作用"></a>7.无副作用</h3><h3 id="8-分割指令与查询"><a href="#8-分割指令与查询" class="headerlink" title="8.分割指令与查询"></a>8.分割指令与查询</h3><p>函数要么做什么事，要么回答什么事，但二者不可兼得</p><h3 id="9-使用异常替代返回错误码"><a href="#9-使用异常替代返回错误码" class="headerlink" title="9.使用异常替代返回错误码"></a>9.使用异常替代返回错误码</h3><ul><li>返回错误码的时候，就是在要求调用者立刻处理错误。</li><li>如果使用异常替代返回错误码，错误处理代码就能从住路径代码中分离出来，得到简化。</li><li>抽离try/catch代码块</li></ul><h3 id="10-别重复自己"><a href="#10-别重复自己" class="headerlink" title="10.别重复自己"></a>10.别重复自己</h3><h3 id="11-结构化编程"><a href="#11-结构化编程" class="headerlink" title="11.结构化编程"></a>11.结构化编程</h3><h2 id="四、第四章-注释"><a href="#四、第四章-注释" class="headerlink" title="四、第四章 注释"></a>四、第四章 注释</h2><h3 id="1-如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。"><a href="#1-如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。" class="headerlink" title="1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。"></a>1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。</h3><h3 id="2-真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？"><a href="#2-真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？" class="headerlink" title="2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？"></a>2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？</h3><ul><li>法律信息</li><li>提供信息的注释</li><li>提供意图的解释</li><li>阐释</li><li>警告</li><li>TODO注释</li><li>TODO是一种程序要认为应该要做的，但是由于某种原因没有做的</li><li>放大,放大某些看似不合理的地方</li></ul><h2 id="五、第六章-对象和数据结构"><a href="#五、第六章-对象和数据结构" class="headerlink" title="五、第六章 对象和数据结构"></a>五、第六章 对象和数据结构</h2><h3 id="1-得墨忒定律"><a href="#1-得墨忒定律" class="headerlink" title="1.得墨忒定律"></a>1.得墨忒定律</h3><p>模块不应该了解他所操作对象的内部情形。对象隐藏数据曝露操作，这就意味着对象不应该通过存取器曝露其内部结构。</p><h2 id="六、第七章-错误处理"><a href="#六、第七章-错误处理" class="headerlink" title="六、第七章 错误处理"></a>六、第七章 错误处理</h2><h3 id="1-将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。"><a href="#1-将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。" class="headerlink" title="1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。"></a>1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。</h3><h3 id="2-异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。"><a href="#2-异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。" class="headerlink" title="2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。"></a>2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。</h3><h2 id="七、第八章-边界"><a href="#七、第八章-边界" class="headerlink" title="七、第八章 边界"></a>七、第八章 边界</h2><h3 id="1-整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。"><a href="#1-整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。" class="headerlink" title="1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。"></a>1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。</h3><h2 id="八、第九章-单元测试"><a href="#八、第九章-单元测试" class="headerlink" title="八、第九章 单元测试"></a>八、第九章 单元测试</h2><h3 id="1-TDD三定律"><a href="#1-TDD三定律" class="headerlink" title="1.TDD三定律"></a>1.TDD三定律</h3><ul><li>在编写不能通过的单元测试前，不可编写生产代码。</li><li>只可编写刚好无法通过的单元测试，不能编译也算不通过</li><li>只可编写刚好足以通过当前失败测试的生产代码</li></ul><h3 id="2-整洁测试三要素"><a href="#2-整洁测试三要素" class="headerlink" title="2.整洁测试三要素"></a>2.整洁测试三要素</h3><ul><li>可读性</li><li>可读性</li><li>可读性</li></ul><h3 id="3-整洁测试的五条原则："><a href="#3-整洁测试的五条原则：" class="headerlink" title="3.整洁测试的五条原则："></a>3.整洁测试的五条原则：</h3><ul><li>快速，测试应该够快</li><li>独立，测试应该相互独立</li><li>可重复，测试应当可在任何环境中重复通过。</li><li>自足验证，测试应该有布尔值输出，无论测试是成功还是失败，不应该人工通过log来确认测试是否成功或者失败。</li><li>及时，测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li></ul><h2 id="九、第十章-类"><a href="#九、第十章-类" class="headerlink" title="九、第十章 类"></a>九、第十章 类</h2><h3 id="1-单一权责原则，类或者模块应有且只有一条加以修改的理由。"><a href="#1-单一权责原则，类或者模块应有且只有一条加以修改的理由。" class="headerlink" title="1.单一权责原则，类或者模块应有且只有一条加以修改的理由。"></a>1.单一权责原则，类或者模块应有且只有一条加以修改的理由。</h3><h3 id="2-内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。"><a href="#2-内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。" class="headerlink" title="2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。"></a>2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。</h3><h2 id="十、第十一章-系统"><a href="#十、第十一章-系统" class="headerlink" title="十、第十一章 系统"></a>十、第十一章 系统</h2><h3 id="1-将系统的构造与使用分开"><a href="#1-将系统的构造与使用分开" class="headerlink" title="1.将系统的构造与使用分开"></a>1.将系统的构造与使用分开</h3><p>软件系统应将起始过程和启始过程之后的运行时逻辑分离开，在起始过程中构建应用对象，也会存在相互缠结的依赖关系。（延迟初始化可以加快程序运行速度）</p><h4 id="1-1分解main"><a href="#1-1分解main" class="headerlink" title="1.1分解main"></a>1.1分解main</h4><p>将程序的构造放到main，并使其与运行时逻辑分开，main只管构造并将构造后的数据对象发送给各个应用，或者被各个应用使用。但是，不参与运行时的任何逻辑控制。</p><h4 id="1-2工厂模式"><a href="#1-2工厂模式" class="headerlink" title="1.2工厂模式"></a>1.2工厂模式</h4><p>使用该模式可以将系统构造和系统运行时逻辑分开。</p><h4 id="1-3依赖注入（需要强化理解）"><a href="#1-3依赖注入（需要强化理解）" class="headerlink" title="1.3依赖注入（需要强化理解）"></a>1.3依赖注入（需要强化理解）</h4><h4 id="1-4扩容"><a href="#1-4扩容" class="headerlink" title="1.4扩容"></a>1.4扩容</h4><p>“一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统，实现新用户的故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发，重构以及他们打造出的整洁的代码。</p><h4 id="1-5测试驱动系统架构"><a href="#1-5测试驱动系统架构" class="headerlink" title="1.5测试驱动系统架构"></a>1.5测试驱动系统架构</h4><p>最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯编程语言对象实现。不同的领域之间用最不具有侵害性的方面或类方面工具结合起来。这种架构就能测试驱动，就像代码一样。(需要关注面向切片编程(POJO))</p><h4 id="1-6优化决策"><a href="#1-6优化决策" class="headerlink" title="1.6优化决策"></a>1.6优化决策</h4><p>模块化和关注面切分成就了分散化管理和决策。在巨大的系统中，不管是一座城市或是一个软件项目，无人能做所有的决策。最好是授权给最有资格的人。拥有模块化关注面的POJO系统提供的敏捷能力，允许我们基于最新的知识做出优化的，时机刚好的决策。决策的复杂性降低了。</p><h2 id="十一、第十二章-迭进"><a href="#十一、第十二章-迭进" class="headerlink" title="十一、第十二章 迭进"></a>十一、第十二章 迭进</h2><h3 id="1-通过迭进设计达到代码整洁的目的："><a href="#1-通过迭进设计达到代码整洁的目的：" class="headerlink" title="1. 通过迭进设计达到代码整洁的目的："></a>1. 通过迭进设计达到代码整洁的目的：</h3><p>通过这几个原则可以让你的设计变简单（DIP，SRP）</p><ul><li>运行所有测试</li><li>不可重复，</li><li>表达了程序员的意图</li><li>尽可能减少类和方法的数量</li><li>以上规则按其重要程度排序</li></ul><h3 id="2-简单设计规则1-运行所有测试"><a href="#2-简单设计规则1-运行所有测试" class="headerlink" title="2. 简单设计规则1:运行所有测试"></a>2. 简单设计规则1:运行所有测试</h3><p>编写的测试越多就越能持续走向编写较易测试的代码，紧耦合的代码很难编写测试。遵循有关编写测试并持续运行测试的简单，明确的规则，系统就会更贴近OO低耦合度，高内聚度的目标。编写测试引致更好的设计。</p><h3 id="3-简单设计规则2-4：重构"><a href="#3-简单设计规则2-4：重构" class="headerlink" title="3. 简单设计规则2-4：重构"></a>3. 简单设计规则2-4：重构</h3><p>在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等。这也是简单设计原则后三条规则的地方:消除重复，保证表达力，尽可能减少类和方法的数量。</p><h3 id="4-不可重复"><a href="#4-不可重复" class="headerlink" title="4. 不可重复"></a>4. 不可重复</h3><h3 id="5-表达力"><a href="#5-表达力" class="headerlink" title="5. 表达力"></a>5. 表达力</h3><h3 id="6-尽可能少的类和方法"><a href="#6-尽可能少的类和方法" class="headerlink" title="6. 尽可能少的类和方法"></a>6. 尽可能少的类和方法</h3><h2 id="十二、第十三章-并发编程"><a href="#十二、第十三章-并发编程" class="headerlink" title="十二、第十三章 并发编程"></a>十二、第十三章 并发编程</h2><h3 id="1-为什么要并发"><a href="#1-为什么要并发" class="headerlink" title="1. 为什么要并发"></a>1. 为什么要并发</h3><p>并发是一种解耦策略。它帮我们把做什么和何时做分解开。</p><h3 id="2-并发的防御原则"><a href="#2-并发的防御原则" class="headerlink" title="2. 并发的防御原则"></a>2. 并发的防御原则</h3><h3 id="13-1-单一权责原则（SRP）"><a href="#13-1-单一权责原则（SRP）" class="headerlink" title="13.1 单一权责原则（SRP）"></a>13.1 单一权责原则（SRP）</h3><p>并发代码应该从其他代码中分离出来，因为，并发代码相比于其他的代码是很复杂的存在。但是，并发实现细节常常直接嵌入到其他生产代码中。那么下面几个问题需要考虑，</p><ul><li>并发相关代码由自己的开发，修改和调优生命周期</li><li>开发相关代码由自己要对付的挑战，和非并发相关代码不同，而且往往更为困难</li><li>即便没有周边应用程序增加负担，写得不好的并发代码可能的出错方式数量已经足具挑战性。</li></ul><blockquote><p>建议：分离并发相关代码与其他代码。</p></blockquote><h3 id="13-2-限制数据作用域"><a href="#13-2-限制数据作用域" class="headerlink" title="13.2 限制数据作用域"></a>13.2 限制数据作用域</h3><p>两个线程修改共享对象的同一字段时，可能相互干扰，导致未预期的行为。解决方案之一是采用<code>synchronized</code>关键字在代码中保护一块使用共享对象的临界区。限制临界区的数量很重要。更新共享数据的地方越多，就越可能出错。</p><blockquote><p>建议：谨记数据封装，严格限制对可能被共享的数据的访问。</p></blockquote><h3 id="13-3-使用数据副本"><a href="#13-3-使用数据副本" class="headerlink" title="13.3 使用数据副本"></a>13.3 使用数据副本</h3><p>避免共享数据的好方法之一就是一开始就避免共享数据。在某些情况下，有可能复制对象并以只读方式对待。在另外一种情况下，有可能复制对象，从多个线程收集所有副本的结果，并在单个线程中合并这些结果。</p><h3 id="13-4-线程尽可能地独立"><a href="#13-4-线程尽可能地独立" class="headerlink" title="13.4　线程尽可能地独立"></a>13.4　线程尽可能地独立</h3><p>让每个线程在自己的世界中存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳所有请求数据，存储为本地变量。</p><p>建议：尝试将数据分解到可被独立线程操作的独立子集。</p><h3 id="13-5-了解执行模型"><a href="#13-5-了解执行模型" class="headerlink" title="13.5 了解执行模型"></a>13.5 了解执行模型</h3><h4 id="13-5-1-生产者－－－消费者模型"><a href="#13-5-1-生产者－－－消费者模型" class="headerlink" title="13.5.1 生产者－－－消费者模型"></a>13.5.1 生产者－－－消费者模型</h4><p>一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。</p><h4 id="13-5-2-读者－－－作者模型"><a href="#13-5-2-读者－－－作者模型" class="headerlink" title="13.5.2 读者－－－作者模型"></a>13.5.2 读者－－－作者模型</h4><p>当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的消息，这是一种辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。</p><p>挑战之处在于平衡读者线程和作者线程的需求，实现正确的操作，提供合理的吞吐量，避免线程饥饿。</p><h4 id="13-5-3哲学家问题（故事内容不在这里描述）"><a href="#13-5-3哲学家问题（故事内容不在这里描述）" class="headerlink" title="13.5.3哲学家问题（故事内容不在这里描述）"></a>13.5.3哲学家问题（故事内容不在这里描述）</h4><p>从哲学家问题可以反映出编写并发经常遇到的问题，死锁，活锁，吞吐量和效率降低等问题。那么学习这些基础问题的解决算法可以帮助你解决大多数的并发问题，因为大多的并发问题都是上述问题的变种。</p><h3 id="13-6-警惕同步方法之间的依赖"><a href="#13-6-警惕同步方法之间的依赖" class="headerlink" title="13.6 警惕同步方法之间的依赖"></a>13.6 警惕同步方法之间的依赖</h3><p>同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java语言有synchronized概念，可以用来保护单个方法。然而，如果在同一共享类中由多个同步方法，系统就可能写得不太正确了。</p><blockquote><p>建议：避免使用一个共享对象的多个方法。如果有时必须使用一个共享对象的多个方法。这种情况发生时，有３中写对代码的手段：</p></blockquote><ul><li>基于客户端的锁定－－客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。</li><li>基于服务端的锁定－－在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新的方法。</li><li>适配服务端－－创建执行锁定的中间层。这是一种基于服务端的锁定例子，但不修改原始服务端代码。</li></ul><h3 id="13-7保持同步区域微小"><a href="#13-7保持同步区域微小" class="headerlink" title="13.7保持同步区域微小"></a>13.7保持同步区域微小</h3><p>应该尽可能少地设计临界区，如果有请尽可能减小同步区域。</p><h3 id="13-8-编写线程需要注意的几点："><a href="#13-8-编写线程需要注意的几点：" class="headerlink" title="13.8　编写线程需要注意的几点："></a>13.8　编写线程需要注意的几点：</h3><h4 id="1-将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。"><a href="#1-将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。" class="headerlink" title="(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。"></a>(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。</h4><h4 id="2-先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。"><a href="#2-先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。" class="headerlink" title="(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。"></a>(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。</h4><h4 id="3-编写可插拔的线程代码。编写在数个环境下运行的线程代码"><a href="#3-编写可插拔的线程代码。编写在数个环境下运行的线程代码" class="headerlink" title="(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码"></a>(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码</h4><ul><li>1.单线程与多线程在执行时不同的情况</li><li>2.线程代码与实物或测试替身互动</li><li>3.用运行速度,缓慢和有变动的测试替身执行</li><li>4.将测试配置为能运行一定数量的迭代</li></ul><blockquote><p>建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行。</p></blockquote><h4 id="4-编写可调整的线程代码"><a href="#4-编写可调整的线程代码" class="headerlink" title="(4). 编写可调整的线程代码"></a>(4). 编写可调整的线程代码</h4><p>在系统运行时允许线程发生变动。允许线程依据吞吐量和使用率自我调整。</p><h4 id="5-运行多余处理器数量的线程"><a href="#5-运行多余处理器数量的线程" class="headerlink" title="(5). 运行多余处理器数量的线程"></a>(5). 运行多余处理器数量的线程</h4><p>任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。</p><h4 id="6-在不同平台上运行"><a href="#6-在不同平台上运行" class="headerlink" title="(6). 在不同平台上运行"></a>(6). 在不同平台上运行</h4><h4 id="7-调整代码并强迫错误发生"><a href="#7-调整代码并强迫错误发生" class="headerlink" title="(7). 调整代码并强迫错误发生"></a>(7). 调整代码并强迫错误发生</h4><h2 id="十三、第14章-逐步改进"><a href="#十三、第14章-逐步改进" class="headerlink" title="十三、第14章 逐步改进"></a>十三、第14章 逐步改进</h2><p>代码并不是一次就能写的很干净的，需要我们不断的迭代和优化。</p><h2 id="十四、第17章-味道与启发"><a href="#十四、第17章-味道与启发" class="headerlink" title="十四、第17章 味道与启发"></a>十四、第17章 味道与启发</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h3><h4 id="1-不恰当的注释信息"><a href="#1-不恰当的注释信息" class="headerlink" title="(1). 不恰当的注释信息"></a>(1). 不恰当的注释信息</h4><p>让注释传达本该更好地在源代码控制系统，问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。例如，修改历史记录只会用大量过时而无趣的文本搞乱源代码文件。注释只应该描述有关代码和设计的技术性信息。</p><h4 id="2-废弃的注释"><a href="#2-废弃的注释" class="headerlink" title="(2). 废弃的注释"></a>(2). 废弃的注释</h4><p>过时，无关或不正确的注释就是废弃的注释。</p><h4 id="3-冗余注释"><a href="#3-冗余注释" class="headerlink" title="(3). 冗余注释"></a>(3). 冗余注释</h4><p>如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的。注释应该谈及代码自身没有提到的东西。</p><h4 id="4-注释要写就要写最好的注释，别画蛇添足"><a href="#4-注释要写就要写最好的注释，别画蛇添足" class="headerlink" title="(4). 注释要写就要写最好的注释，别画蛇添足"></a>(4). 注释要写就要写最好的注释，别画蛇添足</h4><h4 id="5-注释掉的代码，看到注释掉的代码就删。"><a href="#5-注释掉的代码，看到注释掉的代码就删。" class="headerlink" title="(5). 注释掉的代码，看到注释掉的代码就删。"></a>(5). 注释掉的代码，看到注释掉的代码就删。</h4><h3 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h3><h4 id="1-需要多步才能实现的构建"><a href="#1-需要多步才能实现的构建" class="headerlink" title="(1). 需要多步才能实现的构建"></a>(1). 需要多步才能实现的构建</h4><p>构建系统应该是单步的小操作。不应该从源代码控制系统中一小点一小点签出代码。不应该需要一系列神秘指令或环境依赖脚本来构建单个元素。不应该四出寻找额外的小jar,xml文件和其他系统所需的杂物。你应该能够用单个命令签出系统，并单个指令构建它。</p><h4 id="2-需要多步才能做到测试"><a href="#2-需要多步才能做到测试" class="headerlink" title="(2). 需要多步才能做到测试"></a>(2). 需要多步才能做到测试</h4><p>你应该能够用单个指令就可以运行全部单元测试。能够运行全部测试是如此基础和重要，应该快速，轻易和直接了当地做到。</p><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h3><ul><li>函数的参数应该少。</li><li>输出参数违反直觉。如果非要修改，那就修改函数所在对象好了。</li><li>标示参数，布尔值参数宣告函数做了不止一件事，应该消灭掉，即函数只做一件事。</li><li>永不被调用的方法应该丢弃。</li></ul><h3 id="4-一般性问题"><a href="#4-一般性问题" class="headerlink" title="4. 一般性问题"></a>4. 一般性问题</h3><p>(1). 如果代码需要有多种语言，那么应该尽力减少源文件中额外语言的数量和范围。</p><p>(2). 明显的行为未被实现，如果明显的行为未被实现，读者和用户就不能再依靠他们对函数名称的直觉。他们不再信任原作者，不得不阅读代码细节。</p><p>(3). 不正确的边界行为，追索每种边界条件，编写测试。</p><p>(4). 忽视安全</p><p>(5). 重复，尽可能找到并消除重复。</p><p>(6). 在错误的抽象层级上的代码，创建分离较高层级一般性概念与较低层级细节概念的抽象模型，这很重要。</p><p>(7). 基类不可多度依赖于派生类，基类应该对派生类一无所知。</p><p>(8). 信息过多，设计良好的模块有着非常小的接口，让你事半功倍。设计良好的接口并不提供许多需要依靠的函数，所以耦合度比较低。</p><p>优秀的软件开发人员学会限制类或模块中暴露的接口数量。类中的方法越少越好。函数知道的变量越少越好。类拥有的实体变量越少越好。隐藏你的数据。隐藏你的工具函数。隐藏你的常量和你的临时变量。不要创建拥有大量方法或大量实体变量的类。不要为子类创建大量受保护变量和函数。尽力保持接口紧凑。通过限制信息来控制耦合度。</p><p>(9). 死代码一定要删除。</p><p>(10). 垂直分隔，变量和函数应该在靠近被使用的地方定义。私有函数应该刚好在其首次被使用的位置下面定义。</p><p>(11). 前后不一致，从一而终即一旦选中，就小心持续遵循。如果在特定函数中用了response的变量来持有HttpServletResponse对象，则在其他用到HttpServletResponse对象的函数中也用同样的变量名。这样会让你的代码更易阅读。</p><p>(12). 混淆视听，没用的变量或者函数直接删掉，以免造成不必要的干扰。</p><p>(13). 人为耦合，不互相依赖的东西不该耦合。一般来说，人为耦合是指两个没有直接目的之间的模块的耦合。其根源是将变量，常量或函数不恰当地放在临时方便的位置。</p><p>(14). 特性依恋，类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数。当方法通过某个其他对象的访问器和修改器来操作该对象内部数据，则它就依恋于该对象所属类的范围。</p><p>(15). 选择算子参数，尽量不要把boolean作为函数参数</p><p>(16). 晦涩意图，代码要尽可能具有表达力。</p><p>(17). 位置错误的权责，我们可以采用最小惊异原则来帮助我们即代码应该放在读者自然而然期待它所在的地方。</p><p>(18). 不恰当的静态方法，对于没有机会打算让它有多态行为的函数可以作为动态函数，否则可选用静态函数。</p><p>(19). 使用解释性变量，命名要有意义。</p><p>(20). 函数名称应该表达其行为</p><p>(21). 理解算法</p><p>(22). 把逻辑依赖改为物理依赖：</p><ul><li>1.逻辑依赖：原始数据和业务逻辑之间的依赖关系。例如：定义的常量和业务逻辑存在着依赖关系或者说被捆绑在了一起，即当业务逻辑发生变化或者存在其他可能性的时候且定义的常量无法满足导致常量需要修改。</li><li>2.物理依赖：函数方法和业务逻辑之间的依赖关系。例如：为了解决逻辑依赖的问题，我们可以通过构造一个方法将数据和业务隔离。</li></ul><p>(23). 用多态替代<code>if/else</code> 或 <code>switch/case</code></p><p>(24). 遵循标准约定</p><p>(25). 用命名常量替代魔术数，魔术数不仅仅指的是数字，也泛指任何不能自我描述的符号。</p><p>(26). 准确，在可以用List的时候，非要把变量声明为ArrayList就过分拘束了。在代码中做决定时，确认自己足够准确。明确自己为何要这么做，如果遇到异常情况如何处理。别懒得理会决定的准确性。代码中的含糊和不准确性要么是意见不同的结果，要么源于懒惰。无论原因是什么，都要消除。</p><p>(27). 结构甚于约定，坚守结构甚于约定的设计决策。</p><p>(28). 封装条件，如果没有if或while语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。</p><p>例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">shouldBeDeleted</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>要好于</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">.</span><span class="token function">hasExpired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timer<span class="token punctuation">.</span><span class="token function">isRecurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>(29). 避免否定性条件，尽可能将条件表示为肯定形式。</p><p>(30). 函数只该做一件事</p><p>(31). 掩蔽时序耦合，排列函数参数，好让它们被调用的次序显而易见。</p><p>(32). 别随意，构建代码需要理由，而且理由应于代码结构相契合。</p><p>(33). 封装边界条件，把处理边界条件的代码集中到一处，不要散落于代码中。</p><p>(34). 函数应该只在一个抽象层级上，函数中的语句应该在同意抽象级上，该层级应该是函数名所示操作的下一层。</p><p>(35). 在较高层级放置可配置数据，如果你有个已知并在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中。把它作为较高层级函数调用较低层级函数时的一个参数。位于较高层级的配置性常量易于修改。它们向下贯穿应用程序。应用程序的较低层级并不拥有这些常量的值。</p><p>(36). 避免传递浏览，编写害羞代码。</p><p>(37). 不要继承常量</p><h3 id="17-5-测试"><a href="#17-5-测试" class="headerlink" title="17.5 测试"></a>17.5 测试</h3><ol><li>使用覆盖率工具，覆盖率工具能汇报你测试策略中的缺口。使用测试覆盖率工具能更容易地找到不足的模块，类和函数。</li><li>别略过小测试</li><li>被忽略的测试就是对不确定事物的疑问。</li><li>测试边界条件</li><li>全面测试相近的缺陷，缺陷趋向于扎堆。</li><li>测试失败的模式有启发性。</li><li>测试覆盖率的模式有启发性，查看被或未被以通过的测试执行的代码，往往能发现失败的测试为何失败的线索。</li><li>测试应该快速。</li></ol><p>来自：<a href="http://www.uml.org.cn/codeNorms/201701162.asp" target="_blank" rel="noopener">代码整洁之道内容概要</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整洁代码 </tag>
            
            <tag> 重构 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之观察者模式</title>
      <link href="/2018/10/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-guan-cha-zhe-mo-shi/"/>
      <url>/2018/10/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>观察者模式(<code>Observer Pattern</code>)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（<code>Publish</code>/<code>Subscribe</code>）模式、模型-视图（<code>Model</code>/<code>View</code>）模式、源-监听器（<code>Source</code>/<code>Listener</code>）模式或从属者（<code>Dependents</code>）模式。</p></blockquote><p>观察者模式是一种<strong>对象行为型模式</strong>。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成："><a href="#1-角色组成：" class="headerlink" title="1. 角色组成："></a>1. 角色组成：</h3><p>观察者模式包含如下角色：</p><ul><li><code>Subject</code>: 目标（抽象的被观察着）</li><li><code>ConcreteSubject</code>: 具体目标（具体的被观察者）</li><li><code>Observer</code>: 观察者</li><li><code>ConcreteObserver</code>: 具体观察者</li></ul><h3 id="2-结构图："><a href="#2-结构图：" class="headerlink" title="2. 结构图："></a>2. 结构图：</h3><p><img src="http://static.blinkfox.com/Obeserver.jpg" alt="观察者模式结构图"></p><h3 id="3-时序图："><a href="#3-时序图：" class="headerlink" title="3. 时序图："></a>3. 时序图：</h3><p><img src="http://static.blinkfox.com/seq_Obeserver.jpg" alt="观察者模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是观察者接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者接口 * Created by blinkfox on 16/7/14. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 更新的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来，是具体的观察者类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的观察者. * * Created by blinkfox on 16/7/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现更新方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到信息,并进行处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是被观察者的抽象类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被观察者的抽象类. * * Created by blinkfox on 16/7/14. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义一个观察者的集合. */</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Observer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 增加一个观察者.     *     * @param o     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除一个观察者.     *     * @param o     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通知所有观察者.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer o<span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            o<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>具体的被观察者：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的被观察者. * * Created by blinkfox on 16/7/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteSubject</span> <span class="token keyword">extends</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体的业务.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是用于测试观察者模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者模式客户端场景类. * * Created by blinkfox on 16/7/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个被观察者和观察者.</span>        ConcreteSubject sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Observer obs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察者观察被观察者.</span>        sub<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>obs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察者开始活动了.</span>        sub<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。</li><li>这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅</strong>(<code>publish-subscribe</code>)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>观察者模式的优点：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>观察者模式的缺点：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用观察者模式：</p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><blockquote><p>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li><li>观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li><li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</li><li>在JDK的<code>java.util</code>包中，提供了<code>Observable</code>类以及<code>Observer</code>接口，它们构成了Java语言对观察者模式的支持。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用Bash命令整理之其他常用命令</title>
      <link href="/2018/10/13/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/"/>
      <url>/2018/10/13/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="1-hostname-查看主机名"><a href="#1-hostname-查看主机名" class="headerlink" title="1. hostname - 查看主机名"></a>1. hostname - 查看主机名</h2><p><code>hostname</code>命令用于查看系统的主机名，或是修改系统的主机名。</p><p><code>hostname</code>的常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示系统的当前主机名</span><span class="token function">hostname</span><span class="token comment" spellcheck="true"># 修改你系统的主机名</span><span class="token function">hostname</span> blinkfox-system<span class="token comment" spellcheck="true"># 使用 -F 选项，从指定的文件中读取主机名</span><span class="token function">hostname</span> -F /root/hostname.txt</code></pre><h2 id="2-uptime-查看系统运行时间"><a href="#2-uptime-查看系统运行时间" class="headerlink" title="2. uptime - 查看系统运行时间"></a>2. uptime - 查看系统运行时间</h2><p><code>uptime</code>命令用于打印系统的运行时间等信息。使用如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">uptime</span></code></pre><h2 id="3-w、who-列出登录的用户"><a href="#3-w、who-列出登录的用户" class="headerlink" title="3. w、who - 列出登录的用户"></a>3. w、who - 列出登录的用户</h2><p><code>w</code>命令用于显示登录用户及他们当前运行的进程。输入的内容格式如下：</p><pre class=" language-bash"><code class="language-bash">w<span class="token comment" spellcheck="true"># 打印如下</span>22:42  up 18 days, 1 hr, 2 users, load averages: 1.23 1.79 1.75USER     TTY      FROM              LOGIN@  IDLE WHATblinkfox console  -                日19   6days -blinkfox s000     -                五23       - w</code></pre><p><code>who</code>命令有与<code>w</code>命令类似的用途，但它的功能比<code>w</code>命令更强大一些。语法格式如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">who</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>FILE <span class="token operator">|</span> ARG1 ARG2<span class="token punctuation">]</span></code></pre><p><code>who</code>常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示当前登录的所有用户信息</span><span class="token function">who</span><span class="token comment" spellcheck="true"># 显示系统的启动时间</span><span class="token function">who</span> -b<span class="token comment" spellcheck="true"># 显示系统登录进程</span><span class="token function">who</span> -l<span class="token comment" spellcheck="true"># 显示与当前标准输入关联的用户信息</span><span class="token function">who</span> -m<span class="token comment" spellcheck="true"># 显示系统的运行级别</span><span class="token function">who</span> -r<span class="token comment" spellcheck="true"># 显示所有登录用户的用户名和登录用户数</span><span class="token function">who</span> -q</code></pre><h2 id="4-uname-查看系统信息"><a href="#4-uname-查看系统信息" class="headerlink" title="4. uname - 查看系统信息"></a>4. uname - 查看系统信息</h2><p><code>uname</code>命令用于打印内核名称和版本、主机名等系统信息。命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">uname</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>.</code></pre><p>常用使用方式如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 只打印内核的名称</span><span class="token function">uname</span><span class="token comment" spellcheck="true"># 使用 -n 选项，只打印系统的主机名</span><span class="token function">uname</span> -n<span class="token comment" spellcheck="true"># 使用 -r 选项，打印内核版本信息</span><span class="token function">uname</span> -r<span class="token comment" spellcheck="true"># 使用 -m 选项，打印系统的硬件名称</span><span class="token function">uname</span> -m<span class="token comment" spellcheck="true"># 使用 -p 选项，打印系统的处理器类型信息</span><span class="token function">uname</span> -p<span class="token comment" spellcheck="true"># 使用 -i 选项，打印系统的硬件平台信息</span><span class="token function">uname</span> -i<span class="token comment" spellcheck="true"># 使用 -a 选项，打印上述所有示例中的信息</span><span class="token function">uname</span> -a</code></pre><h2 id="5-date-显示和设置系统日期和时间"><a href="#5-date-显示和设置系统日期和时间" class="headerlink" title="5. date - 显示和设置系统日期和时间"></a>5. date - 显示和设置系统日期和时间</h2><p><code>date</code>命令用于以多种格式显示日期和时间，或设置系统的日期和时间。<code>date</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">date</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>+FORMAT<span class="token punctuation">]</span><span class="token function">date</span> <span class="token punctuation">[</span>-u<span class="token operator">|</span>--utc<span class="token operator">|</span>--universal<span class="token punctuation">]</span> <span class="token punctuation">[</span>MMDDhhmm<span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span><span class="token punctuation">[</span>.ss<span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p>常用使用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 以默认格式显示系统的当前日期时间</span><span class="token function">date</span><span class="token comment" spellcheck="true"># 格式化当前日期</span><span class="token function">date</span> +<span class="token string">"%Y-%m-%d"</span><span class="token comment" spellcheck="true"># 格式化输出昨天的日期</span><span class="token function">date</span> -d <span class="token string">"1 day ago"</span> +<span class="token string">"%Y-%m-%d"</span><span class="token comment" spellcheck="true"># 2秒后格式化输出</span><span class="token function">date</span> -d <span class="token string">"2 second"</span> +<span class="token string">"%Y-%m-%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># 普通格式化转出</span><span class="token function">date</span> -d <span class="token string">"2009-12-12"</span> +<span class="token string">"%Y/%m/%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># apache格式转换</span><span class="token function">date</span> -d <span class="token string">"Dec 5, 2009 12:00:37 AM"</span> +<span class="token string">"%Y-%m-%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># 日期加减操作</span><span class="token function">date</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前天年月日</span><span class="token function">date</span> -d <span class="token string">"+1 day"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前一天的日期</span><span class="token function">date</span> -d <span class="token string">"-1 day"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示后一天的日期</span><span class="token function">date</span> -d <span class="token string">"-1 month"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示上一月的日期</span><span class="token function">date</span> -d <span class="token string">"+1 month"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示下一月的日期</span><span class="token function">date</span> -d <span class="token string">"-1 year"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前一年的日期</span><span class="token function">date</span> -d <span class="token string">"+1 year"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示下一年的日期</span><span class="token comment" spellcheck="true"># 设定时间</span><span class="token function">date</span> -s <span class="token comment" spellcheck="true"># 设置当前时间，只有root权限才能设置，其他只能查看</span><span class="token function">date</span> -s 20160816 <span class="token comment" spellcheck="true"># 设置成20160816，这样会把具体时间设置成空00:00:00</span><span class="token function">date</span> -s 01:01:01 <span class="token comment" spellcheck="true"># 设置具体时间，不会对日期做更改</span><span class="token function">date</span> -s <span class="token string">"01:01:01 2012-05-23"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间 </span><span class="token function">date</span> -s <span class="token string">"01:01:01 20120523"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span class="token function">date</span> -s <span class="token string">"2012-05-23 01:01:01"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间 </span><span class="token function">date</span> -s <span class="token string">"20120523 01:01:01"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span></code></pre><h2 id="6-id-显示用户属性"><a href="#6-id-显示用户属性" class="headerlink" title="6. id - 显示用户属性"></a>6. id - 显示用户属性</h2><p><code>id</code>命令用于打印输出用户<code>uid</code>、<code>gid</code>、用户名和组名等用户身份信息。<code>id</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">id</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>USERNAME<span class="token punctuation">]</span></code></pre><p>常见使用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 输出当前用户的uid、用户名、gid、组名及用户属于的群组信息</span><span class="token function">id</span><span class="token comment" spellcheck="true"># 使用 -u 选项，输出用户的 uid</span><span class="token function">id</span> -u<span class="token comment" spellcheck="true">#-u 选项和 -n 选项结合使用，输出账户的用户名</span><span class="token function">id</span> -un<span class="token comment" spellcheck="true"># 使用 -g 选项，输出帐号当前起作用的gid</span><span class="token function">id</span> -g<span class="token comment" spellcheck="true"># -g 与 -n 选项结合使用，输出帐号当前起作用的用户组名</span><span class="token function">id</span> -gn<span class="token comment" spellcheck="true"># 使用 -G 选项，输出帐号所属的所有群组id</span><span class="token function">id</span> -G root<span class="token comment" spellcheck="true"># -G 与 -n 选项结合使用，输出账号所属的所有群组的名称</span><span class="token function">id</span> -Gn root</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用Bash命令整理之文本处理</title>
      <link href="/2018/10/11/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/"/>
      <url>/2018/10/11/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/</url>
      
        <content type="html"><![CDATA[<h2 id="1-sort-文本排序"><a href="#1-sort-文本排序" class="headerlink" title="1. sort - 文本排序"></a>1. sort - 文本排序</h2><p><code>sort</code>命令用于将文本文件的行排序。默认情况下，<code>sort</code>命令是按照字符串的字母顺序排序。</p><p>sort 的常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将文本内容按字母顺序排序</span><span class="token function">sort</span> example.txt<span class="token comment" spellcheck="true"># 使用 -u 选项，移除所有重复行后排序</span><span class="token function">sort</span> -u example.txt<span class="token comment" spellcheck="true"># 使用 -n 选项，将令数字按数值的大小排序</span><span class="token function">sort</span> -n example.txt<span class="token comment" spellcheck="true"># 使用 -r 选项，以倒序方式排序</span><span class="token function">sort</span> -n -r example.txt<span class="token comment" spellcheck="true"># 同时将 file1、file2 的内容排序</span><span class="token function">sort</span> file1 file2</code></pre><h2 id="2-uniq-文本去重"><a href="#2-uniq-文本去重" class="headerlink" title="2.uniq - 文本去重"></a>2.uniq - 文本去重</h2><p><code>uniq</code>命令用于移除或发现文件中重复的条目。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 它将移除文件中重复的行并显示单一行</span><span class="token function">uniq</span> example.txt<span class="token comment" spellcheck="true"># 可以统计重复行出现的次数</span><span class="token function">uniq</span> -c example.txt<span class="token comment" spellcheck="true"># 使用 -d 选项，只显示文件中有重复的行并只显示一次</span><span class="token function">uniq</span> -d example.txt<span class="token comment" spellcheck="true"># 使用 -D 选项，显示文件中所有重复的行</span><span class="token function">uniq</span> -D example.txt<span class="token comment" spellcheck="true"># 使用 -u 选项，只显示文件中不重复的行</span><span class="token function">uniq</span> -u example.txt<span class="token comment" spellcheck="true"># 使用 -w 选项，限制 uniq 命令只比较每行的前 3 个字符是否重复</span><span class="token function">uniq</span> -w 3 example.txt<span class="token comment" spellcheck="true"># 使用 -s 选项，避免 uniq 命令比较每行的前 3 个字符，只比较后面的字符是否重复</span><span class="token function">uniq</span> -s 3 example.txt<span class="token comment" spellcheck="true"># 使用 -f 选项，避免 uniq 命令比较第一列的内容，只比较后面的字符是否重复</span><span class="token function">uniq</span> -f 1 example.txt</code></pre><h2 id="3-tr-替换或删除字符"><a href="#3-tr-替换或删除字符" class="headerlink" title="3.tr - 替换或删除字符"></a>3.tr - 替换或删除字符</h2><p><code>tr</code>命令主要用于删除文件中控制字符或进行字符转换。使用<code>tr</code>时要转换两个字符串：字符串 1 用于查询，字符串 2 用于处理各种转换。<code>tr</code>刚执行时，字符串 1 中的字符被映射到字符串 2 中的字符，然后转换操作开始。</p><p><code>tr</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">tr</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. SET1 <span class="token punctuation">[</span>SET2<span class="token punctuation">]</span></code></pre><p>常用命令示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 若要将大括号转换为小括号</span><span class="token function">tr</span> <span class="token string">'{}'</span> <span class="token string">'()'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要将大括号转换成方括号</span><span class="token function">tr</span> <span class="token string">'{}'</span> <span class="token string">'\[]'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要将小写字符转换成大写，请输入：</span><span class="token function">tr</span> <span class="token string">'a-z'</span> <span class="token string">'A-Z'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要创建一个文件中的单词列表</span><span class="token function">tr</span> -cs <span class="token string">'[:lower:][:upper:]'</span> <span class="token string">'[\n*]'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要从某个文件中删除所有空字符</span><span class="token function">tr</span> -d <span class="token string">'\0'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要用单独的换行替换每一序列的一个或多个换行，请输入：</span><span class="token function">tr</span> -s <span class="token string">'\n'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 要以单个“#”字符替换 &lt;space> 字符类中的每个字符序列</span><span class="token function">tr</span> -s <span class="token string">'[:space:]'</span> <span class="token string">'[#*]'</span></code></pre><h2 id="4-grep-查找字符串"><a href="#4-grep-查找字符串" class="headerlink" title="4.grep - 查找字符串"></a>4.grep - 查找字符串</h2><p><code>grep</code>命令用于搜索文本或指定的文件中与指定的字符串或模式相匹配的行。默认情况下，<code>grep</code>命令只显示匹配的行。</p><p><code>grep</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">grep</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. PATTERN <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token function">grep</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>-e PATTERN <span class="token operator">|</span> -f FILE<span class="token punctuation">]</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># `grep`命令查找文件/etc/passwd 中帐号 blinkfox 的信息</span><span class="token function">grep</span> blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -i 选项，强制 grep 命令忽略搜索关键字的大小写</span><span class="token function">grep</span> -i blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -r 选项，可以递归搜索指定目录下的所有文件</span><span class="token function">grep</span> -r blinkfox /etc/<span class="token comment" spellcheck="true"># 使用 -w 选项，只匹配包含指定单词的行</span><span class="token function">grep</span> -w blinkfox /etc/<span class="token comment" spellcheck="true"># 使用 -c 选项，报告文件或文本中模式被匹配的次数</span><span class="token function">grep</span> -c blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -n 选项，显示每一个匹配的行的行号</span><span class="token function">grep</span> -n blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -v 选项，可以输出除匹配指定模式的行以外的其他所有行</span><span class="token function">grep</span> -v blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 --color 选项，在输出中将匹配的字符串以彩色的形式标出</span><span class="token function">grep</span> --color blinkfox /etc/passwd</code></pre><h2 id="5-diff-比较两个文件"><a href="#5-diff-比较两个文件" class="headerlink" title="5.diff - 比较两个文件"></a>5.diff - 比较两个文件</h2><p><code>diff</code>命令用于比较两个文件，并找出它们之间的不同。<code>diff</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">diff</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. from-file to-file</code></pre><p>常用使用方式如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 比较两个文件</span><span class="token function">diff</span> nsswitch.conf nsswitch.conf.org<span class="token comment" spellcheck="true"># 使用 -w 选项，比较时忽略空格</span><span class="token function">diff</span> -w nsswitch.conf nsswitch.conf.org<span class="token comment" spellcheck="true"># 使用 -y 选项，以并排的格式输出两个文件的比较结果</span><span class="token function">diff</span> -y nsswitch.conf nsswitch.conf.org使用 -c 选项，以上下对比的格式输出两个文件的比较结果<span class="token function">diff</span> -c nsswitch.conf nsswitch.conf.org</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用Bash命令整理之操作文件和目录</title>
      <link href="/2018/10/10/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cao-zuo-wen-jian-he-mu-lu/"/>
      <url>/2018/10/10/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cao-zuo-wen-jian-he-mu-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-touch-创建文件"><a href="#1-touch-创建文件" class="headerlink" title="1. touch - 创建文件"></a>1. touch - 创建文件</h2><p><code>touch</code>命令就可用于创建、变更和修改文件的时间戳。它是 Linux 操作系统的标准程序。<code>touch</code>命令又如下选项：</p><pre class=" language-bash"><code class="language-bash">-a: 只改变访问时间 -c: 不创建任何文件-m: 只改变修改时间-r: 使用指定文件的时间替代当前时间-t: 使用 <span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span>MMDDhhmm<span class="token punctuation">[</span>.ss<span class="token punctuation">]</span> 替代当前时间</code></pre><p>touch 命令的常见用法如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建一个名为 effyl 的新空文件</span><span class="token function">touch</span> effyl<span class="token comment" spellcheck="true"># 同时创建名称分别为 effyl myeffyl lueffyl 的三个文件</span><span class="token function">touch</span> effyl myeffyl lueffyl<span class="token comment" spellcheck="true"># 使用 -a 选项，可以改变或更新文件的最新访问时间，如果文件 effyl 不存在，则新创建一个</span><span class="token function">touch</span> -a effyl<span class="token comment" spellcheck="true"># 使用 -c 选项，可以避免创建一个新文件，并用当前时间更新文件的时间戳</span><span class="token function">touch</span> -c effyl<span class="token comment" spellcheck="true"># 使用 -m 选项，可以只改变文件的修改时间，而访问时间不变</span><span class="token function">touch</span> -m effyl<span class="token comment" spellcheck="true"># 使用 -c 和 -t 选项，来明确设置文件的时间</span><span class="token function">touch</span> -c -t YYMMDDHHMM filename<span class="token comment" spellcheck="true"># 如果想使用文件 myeffyl 的时间戳更新文件 effyl 的时间戳，可以使用 -r 选项</span><span class="token function">touch</span> -r myeffyl effyl</code></pre><h2 id="2-mkdir-创建目录"><a href="#2-mkdir-创建目录" class="headerlink" title="2.mkdir - 创建目录"></a>2.mkdir - 创建目录</h2><p><code>mkdir</code>命令用于创建一个新目录。最基本的<code>mkdir</code>命令的使用方法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录下创建一个给定的目录名</span><span class="token function">mkdir</span> <span class="token operator">&lt;</span>dirname<span class="token operator">></span><span class="token comment" spellcheck="true"># 在 backup 中的相对路径创建一个名为 old 的目录</span><span class="token function">mkdir</span> backup/old<span class="token comment" spellcheck="true"># 在 backup 中的绝对路径中创建一个名为 old 的目录</span><span class="token function">mkdir</span> /home/blinkfox/backup/old<span class="token comment" spellcheck="true"># 使用 -p 选项，会自动创建所有还不存在的父目录</span><span class="token function">mkdir</span> -p backup/old<span class="token comment" spellcheck="true"># 使用 -m 选项，可以设置将要创建目录的权限</span><span class="token comment" spellcheck="true"># 如：创建一个任何人都有读写访问权限的目录</span><span class="token function">mkdir</span> -p -m 777 backup/old</code></pre><h2 id="3-cp-复制文件或目录"><a href="#3-cp-复制文件或目录" class="headerlink" title="3.cp - 复制文件或目录"></a>3.cp - 复制文件或目录</h2><p><code>cp</code>命令用于将文件从一个地方复制到另一个地方。原来的文件保持不变，新文件可能保持原名或用一个不同的名字。</p><p>使用 cp 命令复制文件和目录的语法有以下几种：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 复制源文件到目标文件</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> SOURCE DEST<span class="token comment" spellcheck="true"># 复制一个或多个源文件到一个目录</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> SOURCE<span class="token punctuation">..</span>. DIRECTORY<span class="token comment" spellcheck="true"># 同上</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> -t DIRECTORY SOURCE<span class="token punctuation">..</span>. </code></pre><p>常用使用示例如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录下，创建一个文件 file.txt 的副本，取名为 newfile.txt</span><span class="token function">cp</span> file.txt newfile.txt<span class="token comment" spellcheck="true"># 复制当前目录下的 file.txt 文件到 /tmp 目录下</span><span class="token function">cp</span> file.txt /tmp<span class="token comment" spellcheck="true"># 复制当前目录下的所有文件到 /tmp 目录下</span><span class="token function">cp</span> * /tmp<span class="token comment" spellcheck="true"># 使用 -p 选项，可以使复制一个文件到新文件时，保留源文件的所有者、权限等信息</span><span class="token function">cp</span> -p filename /path/to/new/location/myfile<span class="token comment" spellcheck="true"># 使用 -R 或 -r 选项，恶意递归地复制一个目录</span><span class="token comment" spellcheck="true"># 即将一个目录及其下的所有文件和子目录都复制到另一个目录</span><span class="token function">cp</span> -R * /home/blinkfox/backup</code></pre><h2 id="4-ln-链接文件或目录"><a href="#4-ln-链接文件或目录" class="headerlink" title="4.ln - 链接文件或目录"></a>4.ln - 链接文件或目录</h2><p><code>ln</code>命令用于创建软链接或硬链接。使用 -s 选项，可以创建一个软链接：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在目录 lib 下创建一个软链接 library.so，链接到 /home/blinkfox/src/library.so</span><span class="token function">ln</span> -s /home/blinkfox/src/library.so /home/blinkfox/lib<span class="token comment" spellcheck="true"># 创建目录的软链接</span><span class="token function">ln</span> -s /home/blinkfox/src <span class="token function">source</span></code></pre><h2 id="5-mv-移动文件或目录"><a href="#5-mv-移动文件或目录" class="headerlink" title="5. mv - 移动文件或目录"></a>5. mv - 移动文件或目录</h2><p><code>mv</code>命令用于将文件和目录从一个位置移到另外一个位置。除了移动文件，<code>mv</code>命令还可用于修改文件或目录的名字。</p><p>mv 命令的基本语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mv</span> SOURCE<span class="token punctuation">..</span>. DIRECTORY</code></pre><p>常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将当前目录下的文件 source.txt 移到目录 /tmp 下</span><span class="token function">mv</span> source.txt /tmp<span class="token comment" spellcheck="true"># 将目录 dir1、dir2 移到目录 dir_dist 下</span><span class="token function">mv</span> dir1 dir2 dir_dist<span class="token comment" spellcheck="true"># 将当前目录下的 old.txt 文件更名为 new.txt</span><span class="token function">mv</span> old.txt new.txt<span class="token comment" spellcheck="true"># 使用 -i 选项，在重写覆盖目标文件或目录之前给出提示信息</span><span class="token function">mv</span> -i old.txt new.txt<span class="token comment" spellcheck="true"># 将当前目录下的所有文件移动到目录 /tmp 下</span><span class="token function">mv</span> * /tmp/<span class="token comment" spellcheck="true"># 使用 -i 选项，从 dir1 中移动那些在目标目录中不存在的文件到目标目录</span><span class="token function">mv</span> -u dir1/* dir2/</code></pre><h2 id="6-rm-删除文件或目录"><a href="#6-rm-删除文件或目录" class="headerlink" title="6.rm - 删除文件或目录"></a>6.rm - 删除文件或目录</h2><p><code>rm</code>命令用于删除指定的文件和目录。其语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span><span class="token punctuation">..</span>. FILE<span class="token punctuation">..</span>.</code></pre><p><code>rm</code>的常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 删除当前目录下的文件 file1.txt、file2.txt、file3.txt</span><span class="token function">rm</span> file1.txt file2.txt file3.txt<span class="token comment" spellcheck="true"># 删除当前目录下的所有文件</span><span class="token function">rm</span> *<span class="token comment" spellcheck="true"># 删除你当前帐号主目录下的 temp 目录中的所有文件</span><span class="token function">rm</span> ~/temp/*<span class="token comment" spellcheck="true"># 使用 -i 选项，可以在删除每个文件或目录前提示用户确认</span><span class="token function">rm</span> -i *<span class="token comment" spellcheck="true"># 删除当前目录下所有以".doc"结尾的文件</span><span class="token function">rm</span> *.doc<span class="token comment" spellcheck="true"># 删除当前目录下所有文件名中包含"movie"字符串的文件</span><span class="token function">rm</span> *movie*<span class="token comment" spellcheck="true"># 删除当前目录下所有以"a"开头的文件</span><span class="token function">rm</span> a*<span class="token comment" spellcheck="true"># 删除当前目录下整个文件名（包括扩展名）只有 3 个字符的所有文件</span><span class="token function">rm</span> ???<span class="token comment" spellcheck="true"># 删除当前目录下文件扩展名有两个字符的所有文件</span><span class="token function">rm</span> *.??<span class="token comment" spellcheck="true"># 删除当前目录下文件名中含有字母 a 或 b 或 c 的所有文件</span><span class="token function">rm</span> *<span class="token punctuation">[</span>abc<span class="token punctuation">]</span>*<span class="token comment" spellcheck="true"># 删除当前目录下文件名中包含 0~9 的所有文件</span><span class="token function">rm</span> *<span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>*<span class="token comment" spellcheck="true"># 删除当前目录下文件扩展名是字母 c 或 h 的所有文件</span><span class="token function">rm</span> *.<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除 /tmp 目录下的所有文件及其子目录</span><span class="token function">rm</span> -rf /tmp/*</code></pre><blockquote><p>-f 删除前不提示用户确认，并忽略不存在的文件</p></blockquote><blockquote><p>-r 递归地删除目录及其下的内容</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用Bash命令整理之查看文件和目录</title>
      <link href="/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/"/>
      <url>/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ls-列出文件名和目录"><a href="#1-ls-列出文件名和目录" class="headerlink" title="1. ls - 列出文件名和目录"></a>1. ls - 列出文件名和目录</h2><p><code>ls</code>命令是<code>Linux</code>中最常用的命令之一，其作用就是列出文件名和目录。在命令行提示符下，直接输入<code>ls</code>命令，不带任何选项，将列出当前目录下所有文件和目录，但不会显示详细的信息，比如，文件类型、大小、修改日期和时间、权限等。</p><p>以下便是<code>ls</code>命令及其选项的作用说明：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 仅列出当前目录下所有文件和目录</span><span class="token function">ls</span><span class="token comment" spellcheck="true"># 每行显示一条记录，每条记录包括文件类型、大小、修改日期和时间、权限等</span><span class="token function">ls</span> -l<span class="token comment" spellcheck="true"># 将文件大小显示符合人类阅读习惯的格式</span><span class="token function">ls</span> -lh<span class="token comment" spellcheck="true"># 将使用不同的特殊字符归类不同的文件类型</span><span class="token function">ls</span> -F<span class="token comment" spellcheck="true"># 以长列表格式列出某个目录的信息</span><span class="token function">ls</span> -ld /var/log<span class="token comment" spellcheck="true"># 将递归地列出子目录的内容</span><span class="token function">ls</span> -R /etc/sysconfig/<span class="token comment" spellcheck="true"># 以长列表格式按文件或目录的修改时间倒序地列出文件和目录</span><span class="token function">ls</span> -ltr<span class="token comment" spellcheck="true"># 以长列表格式按文件大小顺序列出文件和目录</span><span class="token function">ls</span> -ls<span class="token comment" spellcheck="true"># 列出包括隐藏文件或目录在内的所有文件和目录，包括“.”（当前目录）和“..”（父目录）</span><span class="token function">ls</span> -a<span class="token comment" spellcheck="true"># 列出包括隐藏文件或目录在内的所有文件和目录，不包括“.”（当前目录）和“..”（父目录）</span><span class="token function">ls</span> -A输出的内容类似于-l选项，指示显示uid和gid，替代显示所有者和用户组<span class="token function">ls</span> -n</code></pre><h2 id="2-cat-连接显示文件内容"><a href="#2-cat-连接显示文件内容" class="headerlink" title="2. cat - 连接显示文件内容"></a>2. cat - 连接显示文件内容</h2><p><code>cat</code> 命令也是Linux系统中最常用的命令之一。<code>cat</code>命令让我们可以看看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件。</p><p><code>cat</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.</code></pre><p><code>cat</code>常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 使用 cat 命令查看文件 /etc/group 的内容</span><span class="token function">cat</span> /etc/group<span class="token comment" spellcheck="true"># 显示多个文件的内容</span><span class="token function">cat</span> /etc/redhat-release /etc/issue<span class="token comment" spellcheck="true"># -n 选项，可以显示文件内容的行号</span><span class="token function">cat</span> -n /etc/fstab<span class="token comment" spellcheck="true"># -b 选项和 -n 选项类似，但只标识非空白行的行号</span><span class="token function">cat</span> -b /etc/fstab<span class="token comment" spellcheck="true"># -e 选项，将在每一行的结尾显示“$”字符</span><span class="token function">cat</span> -e /etc/fstab</code></pre><blockquote><p>当你只输入 cat 命令，而没有任何参数时，它只是接收标准输入的内容并在标准输出中显示。所以你在输入一行内容并回车后，会在接下来的一行显示相同的内容。你也可以重定向标准输出到一个新文件。</p></blockquote><h2 id="3-less、more-分屏显示文件"><a href="#3-less、more-分屏显示文件" class="headerlink" title="3.less、more - 分屏显示文件"></a>3.less、more - 分屏显示文件</h2><p><code>more</code>命令在你使用小的xterm窗口时，或是想不使用文本编辑器而只是简单地阅读一个文件时是很有用的。more命令是一个用于一次翻阅一整屏文件的过滤器。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看一个文件，自动清空屏幕并显示文件开头部分</span><span class="token function">more</span> /etc/inittab<span class="token comment" spellcheck="true"># 指定一次显示num行</span><span class="token function">more</span> -num /etc/inittab</code></pre><p>与<code>more</code>命令相比，我个人更喜欢<code>less</code>命令来查看文件。<code>less</code>命令与<code>more</code>命令类似，但<code>less</code>命令向前和向后翻页都支持，而且<code>less</code>命令不需要在查看前加载整个文件，即<code>less</code>命令查看文件更快速。</p><p><code>less</code>常用命令参数如下：</p><pre class=" language-bash"><code class="language-bash">-b  <span class="token operator">&lt;</span>缓冲区大小<span class="token operator">></span> 设置缓冲区的大小-e  当文件显示结束后，自动离开-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g  只标志最后搜索的关键词-i  忽略搜索时的大小写-m  显示类似more命令的百分比-N  显示每行的行号-o  <span class="token operator">&lt;</span>文件名<span class="token operator">></span> 将less 输出的内容在指定文件中保存起来-Q  不使用警告音-s  显示连续空行为一行-S  行过长时间将超出部分舍弃-x  <span class="token operator">&lt;</span>数字<span class="token operator">></span> 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n： 重复前一个搜索（与 / 或 ? 有关）N： 反向重复前一个搜索（与 / 或 ? 有关）b  向后翻一页d  向后翻半页h  显示帮助界面Q  退出less 命令u  向前滚动半页y  向前滚动一行空格键 滚动一行回车键 滚动一页<span class="token punctuation">[</span>pagedown<span class="token punctuation">]</span>： 向下翻动一页<span class="token punctuation">[</span>pageup<span class="token punctuation">]</span>：   向上翻动一页</code></pre><h2 id="4-head-显示文件头部"><a href="#4-head-显示文件头部" class="headerlink" title="4.head - 显示文件头部"></a>4.head - 显示文件头部</h2><p><code>head</code>命令用于打印指定输入的开头部分内容。默认情况下，打印每个指定输入的前10行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的前N行：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定打印文件的前5行</span><span class="token function">head</span> -n 5 /etc/inittab（或）head -5 /etc/inittab<span class="token comment" spellcheck="true"># 打印文件的前N个字节的数据</span><span class="token function">head</span> -c 10 /etc/inittab</code></pre><h2 id="5-tail-显示文件尾部"><a href="#5-tail-显示文件尾部" class="headerlink" title="5.tail - 显示文件尾部"></a>5.tail - 显示文件尾部</h2><p><code>tail</code>命令和<code>head</code>命令相反，它打印指定输入的结尾部分的内容。默认情况下，它打印指定输入的最后10行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的最后N行：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定打印文件的后10行</span><span class="token function">tail</span> -n 10 /etc/inittab<span class="token function">tail</span> -10 /etc/inittab<span class="token comment" spellcheck="true"># 即时打印文件中新写入的行</span><span class="token function">tail</span> -f /var/log/messages<span class="token comment" spellcheck="true"># --retry选项表示持续尝试打开某个文件，当你想打开一个稍后才会创建或即使不可用的文件</span><span class="token function">tail</span> -f /tmp/debug.log --retry</code></pre><h2 id="6-file-查看文件类型"><a href="#6-file-查看文件类型" class="headerlink" title="6.file - 查看文件类型"></a>6.file - 查看文件类型</h2><p><code>file</code>命令用于接收一个文件作为参数并执行某些测试，已确定正确的文件类型。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看文件类型</span><span class="token function">file</span> /etc/inittab<span class="token comment" spellcheck="true"># 可以MIME类型的格式显示文件类型的信息</span><span class="token function">file</span> -i  /etc/inittab<span class="token comment" spellcheck="true"># 使用-N 选项，输出的队列可以以在文件名之后无空白填充的形式显示</span><span class="token function">file</span> -N *</code></pre><h2 id="7-wc-查看文件统计信息"><a href="#7-wc-查看文件统计信息" class="headerlink" title="7.wc - 查看文件统计信息"></a>7.wc - 查看文件统计信息</h2><p><code>wc</code>命令用于查看文件的行数、单词数和字符数等信息。语法类似如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">wc</span> filenameX Y Z /etc/inittab</code></pre><p>其中X表示行数，Y表示单词数，Z表示字节数，filename表示文件名。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># -l选项，可以只统计文件的行数信息</span><span class="token function">wc</span> -l /etc/inittab<span class="token comment" spellcheck="true"># -w选项，可以只统计文件的单词数信息</span><span class="token function">wc</span> -w /etc/inittab<span class="token comment" spellcheck="true"># -c选项，可以只统计文件的字节数信息</span><span class="token function">wc</span> -c /etc/inittab<span class="token comment" spellcheck="true"># -L选项，可以只统计文件中最长的行的长度</span><span class="token function">wc</span> -L /etc/inittab</code></pre><h2 id="8-find-查找文件或目录"><a href="#8-find-查找文件或目录" class="headerlink" title="8.find - 查找文件或目录"></a>8.find - 查找文件或目录</h2><p><code>find</code>命令用于根据你指定的参数搜索和定位文件和目录的列表。<code>find</code>命令可以在多种情况下使用，比如你可以通过权限、用户、用户组、文件类型、日期、大小和其他可能的条件来查找文件。</p><p><code>find</code>命令常用使用和说明如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查找指定目录下的某个文件</span><span class="token function">find</span> /etc/ -name inittab<span class="token comment" spellcheck="true"># 在当前目录下查找名称为 inittab 的文件</span><span class="token function">find</span> <span class="token keyword">.</span> -name inittab<span class="token comment" spellcheck="true"># 在当前目录下，文件不区分大小写是example的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -iname example<span class="token comment" spellcheck="true"># 找出当前目录下所有以 sh 结尾的文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -name <span class="token string">"*.sh"</span><span class="token comment" spellcheck="true"># 找出当前目录下，文件权限是 777 的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -perm 777<span class="token comment" spellcheck="true"># 找出当前目录下，文件权限不是 777 的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f <span class="token operator">!</span> -perm 777<span class="token comment" spellcheck="true"># 找出当前目录下所有只读文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f <span class="token operator">!</span> -perm /a+w<span class="token comment" spellcheck="true"># 找出你帐号主目录下的所有可执行文件</span><span class="token function">find</span> ~ -type f -perm /a+w<span class="token comment" spellcheck="true"># 找出 /tmp 目录下的.log文件并将其删除：</span><span class="token function">find</span> /tmp/ -type f -name <span class="token string">"*.log"</span> -exec <span class="token function">rm</span> -f <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 找出当前目录下的所有空文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -empty<span class="token comment" spellcheck="true"># 找出当前目录下的所有空目录</span><span class="token function">find</span> <span class="token keyword">.</span> -type d -empty<span class="token comment" spellcheck="true"># 找出 /tmp 目录下的所有隐藏文件</span><span class="token function">find</span> /tmp/ -type f -name <span class="token string">".*"</span><span class="token comment" spellcheck="true"># 找出 /tmp 目录下，所有者是 root 的文件和目录</span><span class="token function">find</span> /tmp/ -user root<span class="token comment" spellcheck="true"># 找出 /tmp 目录下，用户组是 developer 的文件和目录</span><span class="token function">find</span> /tmp/ -group root<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天前修改的文件</span><span class="token function">find</span> ~ -type f -mtime 3<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime +30<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天以内修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime -3<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前，60 天以内修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime +30 -mtime -60<span class="token comment" spellcheck="true"># 找出 /etc 目录下，一小时以内变更过的文件</span><span class="token function">find</span> /etc -type f -cmin -60<span class="token comment" spellcheck="true"># 找出 /etc 目录下，一小时以内访问过的文件</span><span class="token function">find</span> /etc -type f -amin -60<span class="token comment" spellcheck="true"># 找出你账号主目录下，大小是50MB的所有文件</span><span class="token function">find</span> ~ -type f -size 50MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于50MB小于100MB的所有文件</span><span class="token function">find</span> ~ -type f -size +50MB -size -100MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于100MB的文件并将其删除</span><span class="token function">find</span> ~ -type f -size +100MB -exec <span class="token function">rm</span> -rf <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>轻量级滚动动画JavaScript库aos.js</title>
      <link href="/2018/10/08/qian-duan/qing-liang-ji-gun-dong-dong-hua-javascript-ku-aos.js/"/>
      <url>/2018/10/08/qian-duan/qing-liang-ji-gun-dong-dong-hua-javascript-ku-aos.js/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><a href="http://michalsnik.github.io/aos/" target="_blank" rel="noopener">aos.js</a>是一款效果超赞的页面滚动的 JavaScript 动画库插件。该动画库可以在页面滚动时提供28种不同的元素动画效果，以及多种<code>easing</code>效果。在页面往回滚动时，元素会恢复到原来的状态。</p><p><img src="http://static.blinkfox.com/aos1.png" alt="AOS"></p><blockquote><p>注：从<code>2.0.0</code>版本之后,只支持使用<code>data-aos</code>属性，不再支持使用<code>aos</code>属性。</p></blockquote><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="1-Bower-安装"><a href="#1-Bower-安装" class="headerlink" title="1. Bower 安装"></a>1. Bower 安装</h3><p>你可以使用 <a href="https://bower.io/" target="_blank" rel="noopener">Bower</a> 包管理工具安装<code>aos</code>：</p><pre class=" language-bash"><code class="language-bash">bower <span class="token function">install</span> aos --save</code></pre><h3 id="2-npm"><a href="#2-npm" class="headerlink" title="2. npm"></a>2. npm</h3><p>你也能在 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> 上找到 <code>aos</code>：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> aos --save</code></pre><h3 id="3-Github-下载"><a href="#3-Github-下载" class="headerlink" title="3. Github 下载"></a>3. Github 下载</h3><p>Github 下载点击<a href="https://github.com/michalsnik/aos/archive/master.zip" target="_blank" rel="noopener">此处</a></p><h2 id="三、使用示例"><a href="#三、使用示例" class="headerlink" title="三、使用示例"></a>三、使用示例</h2><h3 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>引入<code>CSS</code>样式文件：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bower_components/aos/dist/aos.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>添加<code>JavaScript</code>脚本文件：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bower_components/aos/dist/aos.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>初始化载入<code>AOS</code>：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    AOS<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h3 id="2-简单示例"><a href="#2-简单示例" class="headerlink" title="2. 简单示例"></a>2. 简单示例</h3><pre class=" language-css"><code class="language-css"><span class="token selector">body </span><span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> Helvetica,Tahoma<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">*,*<span class="token pseudo-element">:before</span>,*<span class="token pseudo-element">:after</span> </span><span class="token punctuation">{</span>    <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.aos-all</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">1000</span>px<span class="token punctuation">;</span>    <span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">98%</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">10</span>vh auto <span class="token number">0</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.aos-item</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">33.3333%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.aos-item__inner</span> </span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#1da4e2</span><span class="token punctuation">;</span>    <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">260</span>px<span class="token punctuation">;</span>    <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@media</span> screen and <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 800px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>    <span class="token selector"><span class="token class">.aos-item</span> </span><span class="token punctuation">{</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>AOS的简单示例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos/aos.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos_test.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initLoad();<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>transcroller<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-all<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-down<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zoom-out-down<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>flip-down<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>flip-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-down<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-down<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-down<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-down<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>13<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>14<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>16<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-down<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>18<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zoom-out<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>19<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>20<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zoom-out<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>22<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zoom-out-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>23<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zoom-out-down<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>24<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>25<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>26<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>27<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>28<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>29<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>31<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>32<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>34<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>35<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>36<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>37<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>38<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>39<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>40<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>41<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-in<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-item__inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>42<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos/aos.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">function</span> <span class="token function">initLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AOS<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="3-异步示例"><a href="#3-异步示例" class="headerlink" title="3. 异步示例"></a>3. 异步示例</h3><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>AOS 异步使用的示例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos_test.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initLoad();<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos_async<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos-all<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aos.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">function</span> <span class="token function">initLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AOS<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 0.5秒执行一次</span>    <span class="token function">setInterval</span><span class="token punctuation">(</span>addItem<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> itemsCounter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'aos_async'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 动态生成的div元素     */</span>    <span class="token keyword">function</span> addItem <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>itemsCounter <span class="token operator">></span> <span class="token number">42</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> item <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        item<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'aos-item'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        item<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'data-aos'</span><span class="token punctuation">,</span> <span class="token string">'fade-up'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        item<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'&lt;div class="aos-item__inner">&lt;h3>'</span> <span class="token operator">+</span> itemsCounter <span class="token operator">+</span> <span class="token string">'&lt;/h3>&lt;/div>'</span><span class="token punctuation">;</span>        container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        itemsCounter<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="四、动画样式"><a href="#四、动画样式" class="headerlink" title="四、动画样式"></a>四、动画样式</h2><p>以下是<code>AOS</code>已经提供了的多种动画：</p><h3 id="1-Fade-animations"><a href="#1-Fade-animations" class="headerlink" title="1. Fade animations"></a>1. Fade animations</h3><ul><li>fade-up</li><li>fade-down</li><li>fade-left</li><li>fade-right</li><li>fade-up-right</li><li>fade-up-left</li><li>fade-down-right</li><li>fade-down-left</li></ul><h3 id="2-Flip-animations"><a href="#2-Flip-animations" class="headerlink" title="2. Flip animations"></a>2. Flip animations</h3><ul><li>flip-up</li><li>flip-down</li><li>flip-left</li><li>flip-right</li></ul><h3 id="3-Slide-animations"><a href="#3-Slide-animations" class="headerlink" title="3. Slide animations"></a>3. Slide animations</h3><ul><li>slide-up</li><li>slide-down</li><li>slide-left</li><li>slide-right</li></ul><h3 id="4-Zoom-animations"><a href="#4-Zoom-animations" class="headerlink" title="4. Zoom animations"></a>4. Zoom animations</h3><ul><li>zoom-in</li><li>zoom-in-up</li><li>zoom-in-down</li><li>zoom-in-left</li><li>zoom-in-right</li><li>zoom-out</li><li>zoom-out-up</li><li>zoom-out-down</li><li>zoom-out-left</li><li>zoom-out-right</li></ul><h3 id="5-Anchor-placement"><a href="#5-Anchor-placement" class="headerlink" title="5. Anchor placement"></a>5. Anchor placement</h3><ul><li>top-bottom</li><li>top-center</li><li>top-top</li><li>center-bottom</li><li>center-center</li><li>center-top</li><li>bottom-bottom</li><li>bottom-center</li><li>bottom-top</li></ul><h2 id="五、Easing-函数"><a href="#五、Easing-函数" class="headerlink" title="五、Easing 函数"></a>五、Easing 函数</h2><p>你可以选择以下任意一个时间函数来做出很好的做动画元素：</p><ul><li>linear</li><li>ease</li><li>ease-in</li><li>ease-out</li><li>ease-in-out</li><li>ease-in-back</li><li>ease-out-back</li><li>ease-in-out-back</li><li>ease-in-sine</li><li>ease-out-sine</li><li>ease-in-out-sine</li><li>ease-in-quad</li><li>ease-out-quad</li><li>ease-in-out-quad</li><li>ease-in-cubic</li><li>ease-out-cubic</li><li>ease-in-out-cubic</li><li>ease-in-quart</li><li>ease-out-quart</li><li>ease-in-out-quart</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全功能JavaScript灯箱画廊插件lightgallery.js</title>
      <link href="/2018/10/06/qian-duan/quan-gong-neng-javascript-deng-xiang-hua-lang-cha-jian-lightgallery.js/"/>
      <url>/2018/10/06/qian-duan/quan-gong-neng-javascript-deng-xiang-hua-lang-cha-jian-lightgallery.js/</url>
      
        <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><blockquote><p><a href="https://sachinchoolur.github.io/lightgallery.js/" target="_blank" rel="noopener">lightgallery.js</a> 是一个全功能、轻量级、无依赖的灯箱画廊显示库。</p></blockquote><p><img src="http://static.blinkfox.com/lg.png" alt="lightgallery"></p><h3 id="二、主要特性"><a href="#二、主要特性" class="headerlink" title="二、主要特性"></a>二、主要特性</h3><ul><li>全响应式兼容</li><li>模块化的架构和内置插件</li><li>移动设备和触摸支持</li><li>桌面设备拖拽支持</li><li>双击查看图像的实际大小</li><li>动画缩略图</li><li>社交媒体分享</li><li>YouTube，Vimeo，DailyMotion，VK和 HTML5 视频支持</li><li>20+ 硬件加速CSS3过渡</li><li>全屏支持</li><li>支持缩放</li><li>浏览器历史记录</li><li>响应式图像</li><li>HTML iframe 支持</li><li>支持iFrame框架</li><li>单页多实例</li><li>可能过CSS(SCSS)定制样式</li><li>智能图像预加载与代码优化</li><li>桌面键盘导航</li><li>字体图标支持</li><li>还有更多</li></ul><h3 id="三、浏览器支持"><a href="#三、浏览器支持" class="headerlink" title="三、浏览器支持"></a>三、浏览器支持</h3><p>lightgallery 支持所有主要的浏览器包括IE 9及以上。</p><h3 id="四、安装下载"><a href="#四、安装下载" class="headerlink" title="四、安装下载"></a>四、安装下载</h3><h4 id="1-Bower-安装"><a href="#1-Bower-安装" class="headerlink" title="1. Bower 安装"></a>1. Bower 安装</h4><p>你可以使用 <a href="https://bower.io/" target="_blank" rel="noopener">Bower</a> 包管理工具安装<code>lightgallery</code>：</p><pre class=" language-bash"><code class="language-bash">bower <span class="token function">install</span> lightgallery.js --save</code></pre><h4 id="2-npm"><a href="#2-npm" class="headerlink" title="2. npm"></a>2. npm</h4><p>你也能在 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> 上找到 <code>lightgallery</code>：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> lightgallery.js</code></pre><h4 id="3-Github-下载"><a href="#3-Github-下载" class="headerlink" title="3. Github 下载"></a>3. Github 下载</h4><p>你也可以直接从 GitHub 下载<a href="https://github.com/sachinchoolur/lightgallery.js" target="_blank" rel="noopener">lightgallery</a></p><h3 id="五、基础示例"><a href="#五、基础示例" class="headerlink" title="五、基础示例"></a>五、基础示例</h3><h4 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h4><p>首先，在 html 头文件<code>&lt;head&gt;</code>中引入<code>lightgallery.css</code>：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>css/lightgallery.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span></code></pre><p>然后，在<code>&lt;body&gt;</code>标签结尾引入<code>lightgallery.min.js</code>，如果你想引入其他 lightgallery 的功能插件，你可以将这些插件引入到<code>lightgallery.min.js</code>之后，如下：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    ...    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>js/lightgallery.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- lightgallery plugins --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>js/lg-thumbnail.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>js/lg-fullscreen.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><p>以下是页面标记的图片示例：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightgallery<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img/img1.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img/thumb1.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img/img2.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img/thumb2.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>最后，是 JavaScript 调用插件的方式：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token function">lightGallery</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'lightgallery'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><h4 id="2-完整示例"><a href="#2-完整示例" class="headerlink" title="2. 完整示例"></a>2. 完整示例</h4><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>lightgallery.js的使用示例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/lightGallery/css/lightgallery.min.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token selector">ul </span><span class="token punctuation">{</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">list-style-type</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector">ul li </span><span class="token punctuation">{</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>            <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.lgallery</span> </span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">213</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">137</span>px<span class="token punctuation">;</span>            <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initLoad();<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightGallery<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/a.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lgallery<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/a.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/b.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lgallery<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/b.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/c.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lgallery<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/c.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/d.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lgallery<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/d.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/e.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lgallery<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/e.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/f.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lgallery<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/f.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/g.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lgallery<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/images/g.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/lightGallery/js/lightgallery.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/lightGallery/js/plugins/lg-fullscreen.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/lightGallery/js/plugins/lg-thumbnail.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/lightGallery/js/plugins/lg-autoplay.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/lightGallery/js/plugins/lg-hash.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/lightGallery/js/plugins/lg-pager.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/lightGallery/js/plugins/lg-share.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/lightGallery/js/plugins/lg-zoom.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">function</span> <span class="token function">initLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> lg <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'lightGallery'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lightGallery</span><span class="token punctuation">(</span>lg<span class="token punctuation">,</span> <span class="token punctuation">{</span>        mode<span class="token punctuation">:</span> <span class="token string">'lg-slide'</span><span class="token punctuation">,</span>        cssEasing<span class="token punctuation">:</span> <span class="token string">'ease'</span><span class="token punctuation">,</span>        speed<span class="token punctuation">:</span> <span class="token number">500</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="六、学习和参考资源"><a href="#六、学习和参考资源" class="headerlink" title="六、学习和参考资源"></a>六、学习和参考资源</h3><ul><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html" target="_blank" rel="noopener">API Reference</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html#events" target="_blank" rel="noopener">Events</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html#methods" target="_blank" rel="noopener">Methods</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html#attributes" target="_blank" rel="noopener">Data Attributes</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html#dynamic" target="_blank" rel="noopener">Dynamic variables</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html#sass" target="_blank" rel="noopener">Sass variables</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/plugin-api.html" target="_blank" rel="noopener">Module API</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Google Java编程风格指南</title>
      <link href="/2018/10/05/bian-cheng-zhi-dao/google-java-bian-cheng-feng-ge-zhi-nan/"/>
      <url>/2018/10/05/bian-cheng-zhi-dao/google-java-bian-cheng-feng-ge-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>这份文档是<code>Google Java</code>编程风格规范的完整定义。当且仅当一个<code>Java</code>源文件符合此文档中的规则，我们才认为它符合<code>Google</code>的<code>Java</code>编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>本文档中除非特殊说明，否则：</p><ul><li>术语<code>class</code>可表示一个普通类、枚举类、接口或者注解。</li><li>术语<code>comment</code>只用来指代实现的注释(<code>implementation comments</code>)，我们不使用文档注释(<code>documentation comments</code>)一词，而是用<code>Javadoc</code>。</li></ul><p>其他术语说明，将在文档中需要说明的地方单独说明。</p><h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。</p><h2 id="2-源文件基础"><a href="#2-源文件基础" class="headerlink" title="2 源文件基础"></a>2 源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名（其中只有一个）来命名，大小写敏感，文件扩展名为<code>.java</code>。</p><h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式使用<code>UTF-8</code>。</p><h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空格字符"><a href="#2-3-1-空格字符" class="headerlink" title="2.3.1 空格字符"></a>2.3.1 空格字符</h4><p>除了换行符外，<code>ASCII</code>水平空白字符（0x20）是源码文件中唯一支持的空格字符。这意味着：</p><ul><li>所有其他空白字符将被转义。</li><li><code>Tab</code>字符不被用作缩进控制。</li></ul><h4 id="2-3-2-特殊转义字符串"><a href="#2-3-2-特殊转义字符串" class="headerlink" title="2.3.2 特殊转义字符串"></a>2.3.2 特殊转义字符串</h4><p>任何需要转义字符串表示的字符（例如：<code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\f</code>, <code>\r</code>, <code>\&#39;</code>, <code>\\</code>等），采用这种转义字符串的方式表示，而不采用对应字符的八进制数（例如 <code>\012</code>）或<code>Unicode</code>码（例如：<code>\u000a</code>）表示。</p><h4 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h4><p>对于其余非<code>ASCII</code>字符，直接使用<code>Unicode</code>字符（例如 <code>∞</code>），或者使用对应的<code>Unicode</code>码（例如：<code>\u221e</code>）转义，都是允许的。<strong>唯一需要考虑的是，何种方式更能使代码容易阅读和理解</strong>。</p><blockquote><p><strong>注意</strong>：在使用<code>Unicode</code>码转义，或者甚至是有时直接使用<code>Unicode</code>字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。</p></blockquote><p>例子：</p><table><thead><tr><th>示例</th><th>结论</th></tr></thead><tbody><tr><td>String unitAbbrev = “μs”;</td><td>赞：即使没有注释也非常清晰。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // “μs”</td><td>允许，但没有理由要这样做。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td><td>允许，但这样做显得笨拙还容易出错。</td></tr><tr><td>String unitAbbrev = “\u03bcs”;</td><td>很糟：读者根本看不出这是什么。</td></tr><tr><td>return ‘\ufeff’ + content; // byte order mark</td><td>很好：对于非打印字符，使用转义，并在必要时写上注释。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：永远不要由于害怕某些程序可能无法正确处理非<code>ASCII</code>字符而让你的代码可读性变差。当程序无法正确处理非<code>ASCII</code>字符时，它自然无法正确运行，你就会去<code>fix</code>这些问题的了。(言下之意就是大胆去用非<code>ASCII</code>字符，如果真的有需要的话)</p></blockquote><h2 id="3-源文件结构"><a href="#3-源文件结构" class="headerlink" title="3 源文件结构"></a>3 源文件结构</h2><p>源文件按照先后顺序，由以下几部分组成：</p><ul><li>许可证(<code>License</code>)或版权信息(<code>copyright</code>)（如果需要）</li><li><code>package</code>语句</li><li><code>import</code>语句</li><li><code>class</code>类声明（每个源码文件只能有唯一一个顶级<code>class</code>）。</li></ul><blockquote><p><strong>注意</strong>：以上每个部分之间应该只有<strong>一个空行</strong>作为间隔。</p></blockquote><h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p><code>package</code>语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里)</p><h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不使用通配符"><a href="#3-3-1-import不使用通配符" class="headerlink" title="3.3.1 import不使用通配符"></a>3.3.1 import不使用通配符</h4><p><code>import</code>语句中不应该使用通配符，不管是否是静态导入。</p><h4 id="3-3-2-import不换行"><a href="#3-3-2-import不换行" class="headerlink" title="3.3.2 import不换行"></a>3.3.2 import不换行</h4><p><code>import</code>语句不换行，列限制(4.4节)并不适用于<code>import</code>语句。(每个<code>import</code>语句独立成行)</p><h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p><code>import</code>语句可分为以下几组，按照顺序，每组由<strong>一个空行</strong>分隔：</p><ul><li>所有的静态导入(static import)归为一组</li><li><code>com.google</code>包的<code>import</code>归为一组</li><li>使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：<code>android</code>, <code>com</code>, <code>junit</code>, <code>org</code>, <code>sun</code></li><li><code>java</code>包归为一组</li><li><code>javax</code>包归为一组</li></ul><blockquote><p><strong>注意</strong>：同一组内的<code>import</code>语句之间不应用空行隔开，同一组中的<code>import</code>语句按字典序排列。</p></blockquote><h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只声明唯一一个顶级class"><a href="#3-4-1-只声明唯一一个顶级class" class="headerlink" title="3.4.1 只声明唯一一个顶级class"></a>3.4.1 只声明唯一一个顶级class</h4><p>每个源文件中只能有一个顶级class。</p><h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。</p><p>最重要的一点，<strong>每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑</strong>。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。</p><h2 id="4-格式"><a href="#4-格式" class="headerlink" title="4 格式"></a>4 格式</h2><blockquote><p><strong>术语说明</strong>：块状结构(<code>block-­like construct</code>)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p></blockquote><h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号一般用在<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code>等语句，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="4-1-2-非空语句块采用K-amp-R风格"><a href="#4-1-2-非空语句块采用K-amp-R风格" class="headerlink" title="4.1.2 非空语句块采用K&amp;R风格"></a>4.1.2 非空语句块采用<code>K&amp;R</code>风格</h4><p>对于非空语句块，大括号遵循<code>Kernighan</code>和<code>Ritchie</code>风格 (<a href="https://blog.codinghorror.com/new-programming-jargon/" target="_blank" rel="noopener">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号结束是一个<code>语句块</code>或者<code>方法体</code>、<code>构造函数体</code>或者<code>有命名的类体</code>，则需要换行。当右括号后面接<code>else</code>或者<code>逗号</code>时，不应该换行。</li></ul><p>示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ProblemException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">otherCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">somethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">lastThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>一些例外的情况，将在<code>4.8.1</code>节讲<code>枚举类型</code>的时候讲到。</p><h4 id="4-1-3-空语句块：使代码更简洁"><a href="#4-1-3-空语句块：使代码更简洁" class="headerlink" title="4.1.3 空语句块：使代码更简洁"></a>4.1.3 空语句块：使代码更简洁</h4><p>一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行。（例如：<code>if/else</code> 或者<code>try/catch/finally</code>）.</p><p>示例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是可接受的</span><span class="token keyword">void</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这同样是可接受的</span><span class="token keyword">void</span> <span class="token function">doNothingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是不可接受的：多块语句中没有简洁的空语句块</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h3 id="4-2块缩进：2个空格"><a href="#4-2块缩进：2个空格" class="headerlink" title="4.2块缩进：2个空格"></a>4.2块缩进：2个空格</h3><p>每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。</p><blockquote><p><strong>注意</strong>：根据实际的编程经验，<code>2</code>个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码<code>臃肿</code>不够美观。所以，我这里建议使用<code>4</code>个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。</p></blockquote><h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每条语句结束都需要换行。</p><h3 id="4-4-列长度限制：100"><a href="#4-4-列长度限制：100" class="headerlink" title="4.4 列长度限制：100"></a>4.4 列长度限制：100</h3><p>Java代码的列长度限制为<code>100个</code>字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。</p><p>例外：</p><ul><li>不可能满足行长度限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)</li><li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)</li><li>注释中那些可能被剪切并粘贴到shell中的命令行</li></ul><blockquote><p><strong>注意</strong>：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，<code>100</code>个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用<code>120</code>个字符的宽度更为合适。</p></blockquote><h3 id="4-5-换行"><a href="#4-5-换行" class="headerlink" title="4.5 换行"></a>4.5 换行</h3><p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(<code>100</code>个字符)而被分为多行，我们称之为断行(<code>line­-wrapping</code>)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。</p><blockquote><p><strong>注意</strong>: 提取<code>方法</code>或<code>局部变量</code>可以解决问题，而不不需要进行断行。</p></blockquote><h4 id="4-5-1-在何处断行"><a href="#4-5-1-在何处断行" class="headerlink" title="4.5.1 在何处断行"></a>4.5.1 在何处断行</h4><p>断行的主要原则是：<strong>选择在更高级的语法逻辑处断行</strong>。其他一些原则如下：</p><ul><li>当一个非赋值运算的语句断行时，在运算符号之前断行。（这与Google的C++规范和JavaScrip规范等其他规范不同）。</li><li>如果要在非赋值运算符处断行，那么在该符号前断开(比如<code>+</code>操作符，它将位于下一行)。以下的<code>类运算符</code>也可作为参考：<ul><li>点操作符<code>.</code></li><li>类型界限中的<code>&amp;</code>、<code>||</code>等（例如：<code>&lt;T extends Foo &amp; Bar&gt;</code>)</li></ul></li><li>当要在一个赋值运算语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：<code>=</code>，它与前面的内容留在同一行)。<ul><li>这条规则也适用于<code>foreach</code>语句中的冒号。</li></ul></li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(<code>,</code>)与其前面的内容留在同一行。也就是在逗号之后断行。</li><li><code>Lambda</code>表达式在箭头符号(<code>-&gt;</code>)后断行。</li></ul><p>示例：</p><pre class=" language-java"><code class="language-java">MyLambda<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token punctuation">,</span> Object<span class="token operator">></span> lambda <span class="token operator">=</span>    <span class="token punctuation">(</span>String label<span class="token punctuation">,</span> Long value<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> predicate <span class="token operator">=</span> str <span class="token operator">-</span><span class="token operator">></span>    <span class="token function">longExpressionInvolving</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注意</strong>：换行的主要目标是使代码更清晰易读。</p></blockquote><h4 id="4-5-2-断行的缩进：至少-4个空格"><a href="#4-5-2-断行的缩进：至少-4个空格" class="headerlink" title="4.5.2 断行的缩进：至少+4个空格"></a>4.5.2 断行的缩进：至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进<code>4</code>个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只<code>4</code>个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用单行空行：</p><ul><li>类成员之间需要单个空行隔开：例如：<code>字段</code>，<code>构造函数</code>，<code>方法</code>，<code>嵌套类</code>，<code>静态初始化块</code>，<code>实例初始化块</code>。但也有以下两种例外情况：<ul><li>两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。</li><li>枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。</li></ul></li><li>在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。</li><li>类的第一个成员之前或最后一个成员之后，使用空行(可选)。</li><li>本文档所介绍的其他章节的空行要求(比如3.3节：<code>import</code>语句)。</li></ul><h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现：</p><ul><li>所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：<code>if</code>, <code>for</code> <code>catch</code>等)</li><li>所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：<code>else</code>、<code>catch</code>）</li><li>在左大括号之前都需要空格隔开。只有两种例外：<ul><li><code>@SomeAnnotation({a, b})</code></li><li><code>String[][] x = foo;</code></li></ul></li><li>所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：<code>a + b</code>、<code>b = a &lt; 0 ? 0 : a</code>)</li><li>逗号(<code>,</code>)、冒号(<code>:</code>)、分号(<code>;</code>)和右小括号(<code>)</code>)、Lambda箭头符号(<code>-&gt;</code>)之后，需要空格隔开。</li><li><code>//</code>双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。（可选，例如：<code>a = 0; // 赋值为0</code>）</li><li>变量声明时，变量类型和变量名之间需要用空格隔开。（例如：<code>List&lt;String&gt; list</code>）</li><li>初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。（可选，例如：<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>）</li></ul><blockquote><p><strong>注意</strong>：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p></blockquote><h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><blockquote><p><strong>术语说明</strong>：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。</p></blockquote><p>这种对齐是被允许的，但是不会做强制要求。</p><p>以下是没有水平对齐和水平对齐的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 这种挺好</span><span class="token keyword">private</span> Color color<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 同上</span><span class="token keyword">private</span> <span class="token keyword">int</span>   x<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 允许，但是未来会继续编辑</span><span class="token keyword">private</span> Color color<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可能会使它对不齐</span></code></pre><blockquote><p><strong>注意</strong>：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为<strong>爆炸半径</strong>。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码<code>review</code>的速度，引起更多<code>merge</code>代码冲突的情况。</p></blockquote><h3 id="4-7-分组小括号：推荐使用"><a href="#4-7-分组小括号：推荐使用" class="headerlink" title="4.7 分组小括号：推荐使用"></a>4.7 分组小括号：推荐使用</h3><p>除非作者和<code>reviewer</code>都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。</p><h3 id="4-8-特殊结构"><a href="#4-8-特殊结构" class="headerlink" title="4.8 特殊结构"></a>4.8 特殊结构</h3><h4 id="4-8-1-枚举类型"><a href="#4-8-1-枚举类型" class="headerlink" title="4.8.1 枚举类型"></a>4.8.1 枚举类型</h4><p>枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行（通常只有一个）。以下就是一种可能性的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Answer <span class="token punctuation">{</span>    YES <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"yes"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    NO<span class="token punctuation">,</span>    MAYBE<span class="token punctuation">}</span></code></pre><p>没有方法和Javadoc的枚举类可写成数组初始化的格式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Suit <span class="token punctuation">{</span> CLUBS<span class="token punctuation">,</span> HEARTS<span class="token punctuation">,</span> SPADES<span class="token punctuation">,</span> DIAMONDS <span class="token punctuation">}</span></code></pre><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次声明一个变量"><a href="#4-8-2-1-每次声明一个变量" class="headerlink" title="4.8.2.1 每次声明一个变量"></a>4.8.2.1 每次声明一个变量</h5><p>不要使用组合声明。例如：<code>int a, b;</code>是不允许的。</p><h5 id="4-8-2-2-需要时才声明，尽快进行初始化"><a href="#4-8-2-2-需要时才声明，尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，尽快进行初始化"></a>4.8.2.2 需要时才声明，尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，例如以下格式的写法都是允许的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>           <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>            <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span>                       <span class="token number">1</span><span class="token punctuation">,</span>                        <span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>             <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>               <span class="token punctuation">}</span>  <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>                     <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                          <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre><h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p><h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p><strong>术语说明</strong>：<code>switch</code>块的大括号内是一个或多个语句组。每个语句组包含一个或多个<code>switch</code>标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p><h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>和其他语句块一样，<code>switch</code>大括号之后缩进两个字符。每个<code>switch</code>标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。</p><h5 id="4-8-4-2-继续向下执行的注释"><a href="#4-8-4-2-继续向下执行的注释" class="headerlink" title="4.8.4.2 继续向下执行的注释"></a>4.8.4.2 继续向下执行的注释</h5><p>在一个<code>switch</code>块内，每个语句组要么通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>抛出异常</code>来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">switch</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token function">prepareOneOrTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// fall through</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>        <span class="token function">handleOneTwoOrThree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token function">handleLargeNumber</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注意</strong>：在<code>case 1</code>之后不需要该注释，仅在语句组的末尾。</p></blockquote><h5 id="4-8-4-3-default标签需要显式声明"><a href="#4-8-4-3-default标签需要显式声明" class="headerlink" title="4.8.4.3 default标签需要显式声明"></a>4.8.4.3 default标签需要显式声明</h5><p>每个<code>switch</code>语句中，都需要显式声明<code>default</code>标签。即使没有任何代码也需要显示声明。</p><blockquote><p><strong>注意</strong>：枚举类型的<code>switch</code>语句可以省略<code>default</code>语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。</p></blockquote><h4 id="4-8-5-注解"><a href="#4-8-5-注解" class="headerlink" title="4.8.5 注解"></a>4.8.5 注解</h4><p>注解应用到类、方法或者构造方法时，应紧接<code>Javadoc</code>之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> String <span class="token function">getNameIfPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p><strong>例外</strong>：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>注解应用到成员变量时，也是紧接<code>Javadoc</code>之后。不同的是，多个注解可以放在同一行。例如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Partial</span> <span class="token annotation punctuation">@Mock</span> DataLoader loader<span class="token punctuation">;</span></code></pre><p>对于参数或者局部变量使用注解的情况，没有特定的规范。</p><h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>注释的缩进与它所注释的代码缩进相同。可以采用<code>/* */</code>进行注释，也可以用<code>//</code>进行注释。当使用<code>/* */</code>进行多行注释时，每一行都应该以<code>*</code>开始，并且<code>*</code>应该上下对齐。</p><p>例如：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* * This is * okay. */</span><span class="token comment" spellcheck="true">// And so</span><span class="token comment" spellcheck="true">// is this.</span><span class="token comment" spellcheck="true">/* Or you can * even do this. */</span></code></pre><blockquote><p><strong>注意</strong>：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用<code>/* */</code>，<code>//</code>一般不会自动对齐。</p></blockquote><h4 id="4-8-7-修饰符"><a href="#4-8-7-修饰符" class="headerlink" title="4.8.7 修饰符"></a>4.8.7 修饰符</h4><p>类和成员变量的修饰符，按<code>Java Lauguage Specification</code>中介绍的先后顺序排序。具体是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">protected</span> <span class="token keyword">private</span> <span class="token keyword">abstract</span> <span class="token keyword">default</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">synchronized</span> <span class="token keyword">native</span> <span class="token keyword">strictfp</span></code></pre><h4 id="4-8-8-数字字面量"><a href="#4-8-8-数字字面量" class="headerlink" title="4.8.8 数字字面量"></a>4.8.8 数字字面量</h4><p>长整型的数字字面量使用大写的<code>L</code>作为后缀，不得使用小写（以免与数字1混淆）。例如：使用<code>3000000000L</code>，而不是<code>3000000000l</code>。</p><h2 id="5-命名约定"><a href="#5-命名约定" class="headerlink" title="5 命名约定"></a>5 命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用<code>ASCII</code>字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p><h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用<code>com.example.deepspace</code>，而不是<code>com.example.deepSpace</code>或者<code>com.example.deep_space</code>。</p><h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以<code>UpperCamelCase</code>风格编写。</p><p>类名通常是名词或名词短语。例如：<code>Character</code>或者<code>ImmutableList</code>。接口名称也可以是名词或名词短语（例如：<code>List</code>），但有时可能是形容词或形容词短语（例如：<code>Readable</code>）。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如：<code>HashTest</code>或<code>HashIntegrationTest</code>。</p><h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以<code>lowerCamelCase</code>风格编写。</p><p>方法名通常是动词或动词短语。例如：<code>sendMessage</code>或者<code>stop</code>。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如：<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p><h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？</p><p>每个常量都是一个静态<code>final</code>字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 常量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUMBER <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableList<span class="token operator">&lt;</span>String<span class="token operator">></span> NAMES <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> AGES <span class="token operator">=</span> ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Joiner COMMA_JOINER <span class="token operator">=</span> Joiner<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因为Joiner是不可变的</span><span class="token keyword">static</span> <span class="token keyword">final</span> SomeMutableType<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">enum</span> SomeEnum <span class="token punctuation">{</span> ENUM_CONSTANT <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 非常量</span><span class="token keyword">static</span> String nonFinal <span class="token operator">=</span> <span class="token string">"non-final"</span><span class="token punctuation">;</span><span class="token keyword">final</span> String nonStatic <span class="token operator">=</span> <span class="token string">"non-static"</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> mutableCollection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableSet<span class="token operator">&lt;</span>SomeMutableType<span class="token operator">></span> mutableElements <span class="token operator">=</span> ImmutableSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>mutable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> SomeMutableType<span class="token operator">></span> mutableValues <span class="token operator">=</span>    ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> mutableInstance<span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">,</span> mutableInstance2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> Logger<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> nonEmptyArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"these"</span><span class="token punctuation">,</span> <span class="token string">"can"</span><span class="token punctuation">,</span> <span class="token string">"change"</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这些常量的名字通常是名词或名词短语。</p><h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p><p>这些名字通常是名词或名词短语。例如：<code>computedValues</code>或者<code>index</code>。</p><h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以<code>lowerCamelCase</code>风格编写。</p><p>参数应该避免用单个字符命名。</p><h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以<code>lowerCamelCase</code>风格编写。</p><p>即使局部变量是<code>final</code>和<code>不可改变</code>的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。</p><h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以视具体情况跟一个数字(如：<code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：<code>RequestT</code>, <code>FooBarT</code>)。</li></ul><h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p><strong>驼峰式命名法</strong>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：<code>IPv6</code>或<code>iOS</code>)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ul><li>把短语转换为纯<code>ASCII</code>码，并且移除任何单引号。例如：<code>Müller’s algorithm</code>将变成<code>Muellers algorithm</code>。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul><li><strong>推荐</strong>：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如<code>AdWords</code>将分割成<code>ad words</code>)。 </li><li>需要注意的是iOS并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li><li>最后将所有的单词连接起来得到一个标识符。</li></ul><p>示例：</p><table><thead><tr><th>散文形式</th><th>正确</th><th>不正确</th></tr></thead><tbody><tr><td>“XML HTTP request”</td><td>XmlHttpRequest</td><td>XMLHTTPRequest</td></tr><tr><td>“new customer ID”</td><td>newCustomerId</td><td>newCustomerID</td></tr><tr><td>“inner stopwatch”</td><td>innerStopwatch</td><td>innerStopWatch</td></tr><tr><td>“supports IPv6 on iOS?”</td><td>supportsIpv6OnIos</td><td>supportsIPv6OnIOS</td></tr><tr><td>“YouTube importer”</td><td>YouTubeImporter YoutubeImporter^</td><td>无</td></tr></tbody></table><p>加<code>^</code>号处表示可以，但不推荐。</p><blockquote><p><strong>注意</strong>：在英语中，某些带有连字符的单词形式不唯一。例如：<code>nonempty</code>和<code>non-empty</code>都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p></blockquote><h2 id="6-编程实践"><a href="#6-编程实践" class="headerlink" title="6 编程实践"></a>6 编程实践</h2><h3 id="6-1-Override：总是使用"><a href="#6-1-Override：总是使用" class="headerlink" title="6.1 @Override：总是使用"></a>6.1 <code>@Override</code>：总是使用</h3><p>只要是合法的方法，就把<code>@Override</code>注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。</p><p><strong>例外</strong>：当父方法为<code>@Deprecated</code>时，可以省略<code>@Override</code>。</p><h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p><p>如果它确实是不需要在<code>catch</code>块中做任何响应，需要做注释加以说明(如下面的例子)。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">handleNumericResponse</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NumberFormatException</span> ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 它不是一个数字，不过没关系，继续</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token function">handleTextResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    emptyStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchElementException</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>6.3 静态成员：使用类来调用</p><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><pre class=" language-java"><code class="language-java">Foo aFoo <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>Foo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 好</span>aFoo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 糟</span><span class="token function">somethingThatYieldsAFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 很糟</span></code></pre><p>6.4 <code>Finalizers</code>: 禁用</p><p>极少会去重载<code>Object.finalize</code>。</p><blockquote><p><strong>注意</strong>：不要使用<code>finalize</code>。如果你非要使用它，请先仔细阅读和理解<code>Effective Java第7条款</code>：“Avoid Finalizers”，然后不要使用它。</p></blockquote><h2 id="7-Javadoc"><a href="#7-Javadoc" class="headerlink" title="7 Javadoc"></a>7 Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p><code>Javadoc</code>块的基本格式如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Multiple lines of Javadoc text are written here, * wrapped normally... */</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span>String p1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>或者是以下单行形式：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** An especially short bit of Javadoc. */</span></code></pre><p>基本格式总是可以接受的。当整个<code>Javadoc</code>块能容纳于一行时(且没有标记<code>@XXX</code>)，就可以使用单行形式。</p><h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(只包含最左侧星号的行)会出现在段落之间和<code>Javadoc</code>标记(<code>@XXX</code>)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p><h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的<code>Javadoc</code>标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进<code>4</code>个空格(<strong>注</strong>：如果你的缩进统一采用采用<code>4</code>个空格，那么这里就应该是<code>8</code>个空格)。</p><h4 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h4><p>每个类或成员的<code>Javadoc</code>以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或者<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record.</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><blockquote><p><strong>注意</strong>：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p></blockquote><h3 id="7-3-在哪里使用Javadoc"><a href="#7-3-在哪里使用Javadoc" class="headerlink" title="7.3 在哪里使用Javadoc"></a>7.3 在哪里使用Javadoc</h3><p>至少在每个<code>public</code>类及它的每个<code>public</code>和<code>protected</code>成员处使用<code>Javadoc</code>，以下是一些例外：</p><h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如<code>getFoo</code>，<code>Javadoc</code>是可选的(可以不写)。这种情况下除了写<code>Returns the foo</code>，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><blockquote><p><strong>注意</strong>：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>，就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p></blockquote><h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么<code>Javadoc</code>并非必需的。</p><h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用<code>Javadoc</code>的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成<code>Javadoc</code>，这样更统一更友好。</p><p>原文地址: <a href="http://checkstyle.sourceforge.net/reports/google-java-style-20170228.html" target="_blank" rel="noopener">Google Java Style Guide</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Java调用PhantomJS动态导出ECharts图片到Word文件中</title>
      <link href="/2018/10/01/hou-duan/java/shi-yong-java-diao-yong-phantomjs-dong-tai-dao-chu-echarts-tu-pian-dao-word-wen-jian-zhong/"/>
      <url>/2018/10/01/hou-duan/java/shi-yong-java-diao-yong-phantomjs-dong-tai-dao-chu-echarts-tu-pian-dao-word-wen-jian-zhong/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在一个项目中遇到导出为Word文件的问题，导出Word的功能很简单，但是导出Word文件中包含数据库动态查询的统计数据而生成的Echarts图片，且导出Word的时机又是在凌晨的服务器定时执行，所以不能通过客户端访问统计页面时再去生成。</p><p>服务端语言使用Java语言，最开始考虑使用<a href="http://www.jfree.org/jfreechart/index.html" target="_blank" rel="noopener">JFreeChart</a>来生成统计图片，但是JFreeChart生成的图片很丑，且和ECharts的统计图效果截然不同。所以最终抛弃了使用<code>JFreeChart</code>，而采用了在服务端使用Java调用<a href="http://phantomjs.org/" target="_blank" rel="noopener">PhantomJS</a>的指令来导出Ehcarts图片。所以主要的技术方案选型如下：</p><ul><li><code>poi-tl</code>，一个简单的基于<code>Word</code>模版生成<code>Word</code>的工具。</li><li><code>PhantomJS</code>，一个基于<code>webkit</code>内核的无头浏览器，可在服务端程序实现加载、操作页面等功能</li></ul><h2 id="使用poi-tl导出Word"><a href="#使用poi-tl导出Word" class="headerlink" title="使用poi-tl导出Word"></a>使用poi-tl导出Word</h2><h3 id="poi-tl介绍"><a href="#poi-tl介绍" class="headerlink" title="poi-tl介绍"></a>poi-tl介绍</h3><p>使用Java导出Word通常采用的是<a href="https://poi.apache.org/" target="_blank" rel="noopener">Apache POI</a>的库，但是使用POI来导出Word，会书写大量的段落、样式等细节代码，代码量巨大，而且不易于维护。通过<a href="https://github.com/Sayi/poi-tl" target="_blank" rel="noopener">poi-tl</a>只需要制作导出的模版，服务端一行代码调用，传入模版路径和<code>Map</code>或者<code>Bean</code>即可生成Word模版，代码量大大降低，以后导出样式不满意的时候，只需要修改Word模版文件即可。</p><blockquote><p><strong>注意</strong>：<code>poi-tl</code>只能生成<code>docx</code>文件，对word2007之前的<code>doc</code>文档则不支持。</p></blockquote><h3 id="Maven引入"><a href="#Maven引入" class="headerlink" title="Maven引入"></a>Maven引入</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.deepoove<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>poi-tl<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><blockquote><p><strong>注</strong>：该包带入了<code>POI3.16</code>，如果系统中本身有低于<code>3.15</code>版本的<code>POI</code>，需要排除掉，否则生成Word时会报错。</p></blockquote><h3 id="demo示例"><a href="#demo示例" class="headerlink" title="demo示例"></a>demo示例</h3><p>首先，制作一个用于测试的word模版，使用<code>poi-tl</code>的标记语法做如下标记，如下图所示：</p><p><img src="http://static.blinkfox.com/test_word_template.jpg" alt="测试word模版"></p><p>然后，构造一个需要渲染的model JavaBean类，如果有多个Bean，貌似只能通过继承来复用属性，采用组合的方式是渲染不了的，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * BaseProp * @author blinkfox on 2017-06-28. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BaseProp</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> String baseProp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     * @param baseProp 基础属性     */</span>    <span class="token keyword">public</span> <span class="token function">BaseProp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getBaseProp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> baseProp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBaseProp</span><span class="token punctuation">(</span>String baseProp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>baseProp <span class="token operator">=</span> baseProp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试旅游信息的bean. * @author blinkfox on 2017-06-28. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Travel</span> <span class="token keyword">extends</span> <span class="token class-name">BaseProp</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>    <span class="token keyword">private</span> String smallTitle<span class="token punctuation">;</span>    <span class="token keyword">private</span> String startDate<span class="token punctuation">;</span>    <span class="token keyword">private</span> String endDate<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> money<span class="token punctuation">;</span>    <span class="token keyword">private</span> String place1<span class="token punctuation">;</span>    <span class="token keyword">private</span> String place2<span class="token punctuation">;</span>    <span class="token keyword">private</span> PictureRenderData pic<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     */</span>    <span class="token keyword">public</span> <span class="token function">Travel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*getter和setter方法.*/</span>    <span class="token keyword">public</span> String <span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> title<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTitle</span><span class="token punctuation">(</span>String title<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getSmallTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> smallTitle<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSmallTitle</span><span class="token punctuation">(</span>String smallTitle<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>smallTitle <span class="token operator">=</span> smallTitle<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getStartDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> startDate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStartDate</span><span class="token punctuation">(</span>String startDate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>startDate <span class="token operator">=</span> startDate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getEndDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> endDate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setEndDate</span><span class="token punctuation">(</span>String endDate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>endDate <span class="token operator">=</span> endDate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> money<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMoney</span><span class="token punctuation">(</span><span class="token keyword">double</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>money <span class="token operator">=</span> money<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getPlace1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> place1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPlace1</span><span class="token punctuation">(</span>String place1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>place1 <span class="token operator">=</span> place1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getPlace2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> place2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPlace2</span><span class="token punctuation">(</span>String place2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>place2 <span class="token operator">=</span> place2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> PictureRenderData <span class="token function">getPic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> pic<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPic</span><span class="token punctuation">(</span>PictureRenderData pic<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pic <span class="token operator">=</span> pic<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是模拟调用示例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * poi-tl库的使用示例. * Created by blinkfox on 2017/6/27. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PoitlTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>PoitlTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 项目资源路径. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PATH <span class="token operator">=</span> <span class="token string">"F:/poitl-test/web"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** word模板路径. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DOC_PATH <span class="token operator">=</span> PATH <span class="token operator">+</span> <span class="token string">"/template/test/test.docx"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 图片路径. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PIC_PATH <span class="token operator">=</span> PATH <span class="token operator">+</span> <span class="token string">"/template/test/pic.png"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 输出文件及路径. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String OUTPUT_PATH <span class="token operator">=</span> <span class="token string">"G:/test/poitl_out_word.docx"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造Bean型的data数据.     * @return map     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Travel <span class="token function">buildBeanData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Travel travel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Travel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        travel<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"我的旅游日记"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        travel<span class="token punctuation">.</span><span class="token function">setSmallTitle</span><span class="token punctuation">(</span><span class="token string">"再写日记"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        travel<span class="token punctuation">.</span><span class="token function">setStartDate</span><span class="token punctuation">(</span><span class="token string">"2017-01-01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        travel<span class="token punctuation">.</span><span class="token function">setEndDate</span><span class="token punctuation">(</span><span class="token string">"2017-06-28"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        travel<span class="token punctuation">.</span><span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        travel<span class="token punctuation">.</span><span class="token function">setPlace1</span><span class="token punctuation">(</span><span class="token string">"九寨沟"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        travel<span class="token punctuation">.</span><span class="token function">setPlace2</span><span class="token punctuation">(</span><span class="token string">"天涯海角"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        travel<span class="token punctuation">.</span><span class="token function">setMoney</span><span class="token punctuation">(</span><span class="token number">1872.52</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        travel<span class="token punctuation">.</span><span class="token function">setPic</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PictureRenderData</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> PIC_PATH<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        travel<span class="token punctuation">.</span><span class="token function">setBaseProp</span><span class="token punctuation">(</span><span class="token string">"这是"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> travel<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * main方法.     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        XWPFTemplate template <span class="token operator">=</span> XWPFTemplate<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>DOC_PATH<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token function">buildBeanData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>OUTPUT_PATH<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"通过'poi-tl'导出word成功!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，在导出的文件夹中可查看生成的word文件，如下所示：</p><p><img src="http://static.blinkfox.com/test_out_result.jpg" alt="生成的Word文件结果"></p><h2 id="Java调用PhantomJS导出Ehcarts图片"><a href="#Java调用PhantomJS导出Ehcarts图片" class="headerlink" title="Java调用PhantomJS导出Ehcarts图片"></a>Java调用PhantomJS导出Ehcarts图片</h2><h3 id="PhantomJS介绍"><a href="#PhantomJS介绍" class="headerlink" title="PhantomJS介绍"></a>PhantomJS介绍</h3><p><code>PhantomJS</code>是一个基于<code>webkit</code>内核的无头浏览器，即没有UI界面的一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。<code>PhantomJS</code>提供JavaScript API接口，即通过编写js程序可以直接与<code>webkit</code>内核交互，在此之上可以结合Java语言等，通过java调用js等相关操作，从而解决了以前<code>c/c++</code>才能比较好的基于<code>webkit</code>开发优质采集器的限制。</p><h3 id="PhantomJS的安装配置"><a href="#PhantomJS的安装配置" class="headerlink" title="PhantomJS的安装配置"></a>PhantomJS的安装配置</h3><h4 id="windows环境"><a href="#windows环境" class="headerlink" title="windows环境"></a>windows环境</h4><p>如果是在windows环境下，则在官网下载解压到某个目录后，将其bin目录加入到<code>path</code>变量中即可。</p><h4 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h4><p>如果是在<code>Linux</code>环境下，在官网下载解压后，同样需要将<code>PhantomJS</code>的<code>bin</code>目录加入到<code>path</code>环境变量中，参考的命令和配置如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 编辑配置文件.</span><span class="token function">vi</span> ~/.bashrc<span class="token comment" spellcheck="true"># 将PhantomJS的bin目录加入到PATH环境变量中.</span><span class="token function">export</span> PHANTOMJS_HOME<span class="token operator">=</span>/home/blinkfox/Documents/phantomjs-2.1.1-linux-x86_64<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">${PHANTOMJS_HOME}</span>/bin:<span class="token variable">$PATH</span><span class="token comment" spellcheck="true"># 退出vi编辑器，使用source命令让刚才的配置即时生效.</span><span class="token function">source</span> ~/.bashrc<span class="token comment" spellcheck="true"># 测试PhantomJS是否安装成功，如果打出了版本信息，即安装成功.</span>phantomjs -v</code></pre><h3 id="demo示例-1"><a href="#demo示例-1" class="headerlink" title="demo示例"></a>demo示例</h3><p>这个demo的需求是这样的，我们使用Java调用<code>PhantomJS</code>的指令来在服务端加载含<code>ECharts</code>统计的图<code>html</code>文件，然后调用<code>ECharts</code>的生成图片方法，将图片传输到Java后台最终实现保存图片到指定路径中。</p><p>首先，制作<code>ECharts</code>的html页面，示例页面如下代码如下：</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>测试的ECharts数据统计图<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span><span class="token number">560</span>px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">270</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/js/lib/jquery/jquery-1.9.1.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/js/lib/echarts/v3/echarts.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token comment" spellcheck="true">// 基于准备好的dom，初始化echarts实例</span><span class="token keyword">var</span> myChart <span class="token operator">=</span> echarts<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'main'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指定图表的配置项和数据</span><span class="token keyword">var</span> option <span class="token operator">=</span> <span class="token punctuation">{</span>    title<span class="token punctuation">:</span> <span class="token punctuation">{</span>        text<span class="token punctuation">:</span> <span class="token string">'ECharts 入门示例'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    animation<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 关闭动画效果</span>    tooltip<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    legend<span class="token punctuation">:</span> <span class="token punctuation">{</span>        data<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'销量'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    xAxis<span class="token punctuation">:</span> <span class="token punctuation">{</span>        data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"衬衫"</span><span class="token punctuation">,</span><span class="token string">"羊毛衫"</span><span class="token punctuation">,</span><span class="token string">"雪纺衫"</span><span class="token punctuation">,</span><span class="token string">"裤子"</span><span class="token punctuation">,</span><span class="token string">"高跟鞋"</span><span class="token punctuation">,</span><span class="token string">"袜子"</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    yAxis<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    series<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>        name<span class="token punctuation">:</span> <span class="token string">'销量'</span><span class="token punctuation">,</span>        type<span class="token punctuation">:</span> <span class="token string">'bar'</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用刚指定的配置项和数据显示图表。</span>myChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * ajax传输图片信息. */</span><span class="token keyword">function</span> <span class="token function">postImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 向后台发起请求保存图片到指定目录.</span>    $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>        url<span class="token punctuation">:</span> <span class="token string">'/test/saveImage'</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span> <span class="token punctuation">{</span>picInfo<span class="token punctuation">:</span> myChart<span class="token punctuation">.</span><span class="token function">getDataURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        success<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'通过post请求传输数据成功!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>然后，使用<code>Servlet</code>来写一个服务端代码，用来获取<code>Base64</code>的图片信息并在后端解析保存图片，<code>Servlet</code>代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 保存Echarts统计图片的Servlet. * @author blinkfox on 2017-06-28. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaveImageServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>SaveImageServlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 执行获取echarts图片的post请求.     * @param request req     * @param response resp     * @throws ServletException Servlet异常.     * @throws IOException IO异常.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取图片信息.</span>        String picInfo <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"picInfo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>picInfo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"picInfo为空,未从前台获取到base64图片信息!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAndsaveImage</span><span class="token punctuation">(</span>picInfo<span class="token punctuation">,</span> <span class="token string">"G:/test/image1.png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取并保存图片到本地.     * @param picInfo 图片信息     * @param imagePath 图片保存的路径     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">getAndsaveImage</span><span class="token punctuation">(</span>String picInfo<span class="token punctuation">,</span> String imagePath<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 传递过程中  "+" 变为了 " ".</span>        String newPicInfo <span class="token operator">=</span> picInfo<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String picPath <span class="token operator">=</span> <span class="token function">decodeBase64</span><span class="token punctuation">(</span>newPicInfo<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>imagePath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"从echarts中生成图片的的路径为:{}"</span><span class="token punctuation">,</span> picPath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 解析Base64位信息并输出到某个目录下面.     * @param base64Info base64串     * @param picPath 生成的文件路径     * @return 文件地址     */</span>    <span class="token keyword">private</span> String <span class="token function">decodeBase64</span><span class="token punctuation">(</span>String base64Info<span class="token punctuation">,</span> File picPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>base64Info<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 数据中：data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABI4AAAEsCAYAAAClh/jbAAA ...  在"base64,"之后的才是图片信息</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> base64Info<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"base64,"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将图片输出到系统某目录.</span>        OutputStream out <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 使用了Apache commons codec的包来解析Base64</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">decodeBase64</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>picPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"解析Base64图片信息并保存到某目录下出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            IOUtils<span class="token punctuation">.</span><span class="token function">closeQuietly</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> picPath<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是书写PhantomJS脚本<code>echarts_load.js</code>来加载和调用图片下载的代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> system <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> page <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpage'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果是windows,设置编码为gbk，防止中文乱码,Linux本身是UTF-8</span><span class="token keyword">var</span> osName <span class="token operator">=</span> system<span class="token punctuation">.</span>os<span class="token punctuation">.</span>name<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'os name:'</span> <span class="token operator">+</span> osName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'windows'</span> <span class="token operator">===</span> osName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    phantom<span class="token punctuation">.</span>outputEncoding<span class="token operator">=</span><span class="token string">"gbk"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取第二个参数(即请求地址url).</span><span class="token keyword">var</span> url <span class="token operator">=</span> system<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'url:'</span> <span class="token operator">+</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 显示控制台日志.</span>page<span class="token punctuation">.</span>onConsoleMessage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> lineNum<span class="token punctuation">,</span> sourceId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'CONSOLE: '</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">' (from line #'</span> <span class="token operator">+</span> lineNum <span class="token operator">+</span> <span class="token string">' in "'</span> <span class="token operator">+</span> sourceId <span class="token operator">+</span> <span class="token string">'")'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打开给定url的页面.</span><span class="token keyword">var</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>page<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> <span class="token string">'success'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'echarts页面加载完成,加载耗时:'</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">' ms'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 由于echarts动画效果，延迟500毫秒确保图片渲染完毕再调用下载图片方法.</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            page<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">postImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了echarts的下载图片功能."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"页面加载失败 Page failed to load!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3秒后再关闭浏览器.</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        phantom<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后，是使用<code>Java</code>来调用<code>PhantomJS</code>的指令，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * HttpTest. * @author blinkfox on 2017-06-28. * @version 1.0 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>HttpTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PHANTOM_PATH <span class="token operator">=</span> <span class="token string">"phantomjs"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这里我的test.js是保存在G盘下面的phantomjs目录</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String TEST_JS <span class="token operator">=</span> <span class="token string">"G:/test/phantom/test.js "</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> String <span class="token function">downloadImage</span><span class="token punctuation">(</span>String url<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String cmdStr <span class="token operator">=</span> PHANTOM_PATH <span class="token operator">+</span> TEST_JS <span class="token operator">+</span> url<span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"命令行字符串:{}"</span><span class="token punctuation">,</span> cmdStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        Runtime rt <span class="token operator">=</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            rt<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>cmdStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"执行phantomjs的指令失败！请检查是否安装有PhantomJs的环境或配置path路径！PhantomJs详情参考这里:http://phantomjs.org"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * main.     * @param args args     * @throws IOException IO异常     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token function">downloadImage</span><span class="token punctuation">(</span><span class="token string">"http://127.0.0.1:8080/test/echart_test/test_echarts.html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过调用测试代码即可在指定目录生成<code>Echarts</code>的图片啦！</p><p>联系上面生成<code>Word</code>的功能，两个功能一结合即可动态导出<code>ECharts</code>图片到<code>Word</code>文件中。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apache Commons Lang之日期时间工具类</title>
      <link href="/2018/09/29/hou-duan/java/commons/apache-commons-lang-zhi-ri-qi-shi-jian-gong-ju-lei/"/>
      <url>/2018/09/29/hou-duan/java/commons/apache-commons-lang-zhi-ri-qi-shi-jian-gong-ju-lei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>码农不识Apache，码尽一生也枉然。</p></blockquote><h2 id="FastDateFormat"><a href="#FastDateFormat" class="headerlink" title="FastDateFormat"></a>FastDateFormat</h2><p><code>FastDateFormat</code>是一个快速且线程安全的时间操作类，它完全可以替代<code>SimpleDateFromat</code>。因为是线程安全的，所以你可以把它作为一个类的静态字段使用。构造方法为protected，不允许直接构造它的对象，可以通过工厂方法获取。FastDateFormat之所以是线程安全的，是因为这个类是无状态的：内部的成员在构造时就完成了初始化，并在对象存活期，不提供任何API供外界修改他们。</p><h3 id="getInstance-String-pattern"><a href="#getInstance-String-pattern" class="headerlink" title="getInstance(String pattern)"></a>getInstance(String pattern)</h3><p>获取指定日期时间格式的<code>FastDateFormat</code>实例。</p><h3 id="format-Date-date"><a href="#format-Date-date" class="headerlink" title="format(Date date)"></a>format(Date date)</h3><p>将日期时间格式化为字符串。</p><pre class=" language-java"><code class="language-java">FastDateFormat<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-03 23:32:31</span></code></pre><h3 id="format-long-millis"><a href="#format-long-millis" class="headerlink" title="format(long millis)"></a>format(long millis)</h3><p>同<code>format(Date date)</code>相似。</p><h3 id="format-Calendar-calendar"><a href="#format-Calendar-calendar" class="headerlink" title="format(Calendar calendar)"></a>format(Calendar calendar)</h3><p>同<code>format(Date date)</code>相似。</p><h2 id="DateFormatUtils"><a href="#DateFormatUtils" class="headerlink" title="DateFormatUtils"></a>DateFormatUtils</h2><p>将时间转化为字符串的工具类。不可实例化对象且线程安全，依赖于<code>FastDateFormat</code>。</p><h3 id="预定义的日期格式"><a href="#预定义的日期格式" class="headerlink" title="预定义的日期格式"></a>预定义的日期格式</h3><p><code>DateFormatUtils</code>预定义的日期格式有如下几种：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FastDateFormat ISO_8601_EXTENDED_DATETIME_FORMAT <span class="token operator">=</span> FastDateFormat<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd'T'HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FastDateFormat ISO_8601_EXTENDED_DATETIME_TIME_ZONE_FORMAT <span class="token operator">=</span> FastDateFormat<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd'T'HH:mm:ssZZ"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FastDateFormat ISO_8601_EXTENDED_DATE_FORMAT <span class="token operator">=</span> FastDateFormat<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FastDateFormat ISO_8601_EXTENDED_TIME_FORMAT <span class="token operator">=</span> FastDateFormat<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FastDateFormat ISO_8601_EXTENDED_TIME_TIME_ZONE_FORMAT <span class="token operator">=</span> FastDateFormat<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ssZZ"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> FastDateFormat SMTP_DATETIME_FORMAT <span class="token operator">=</span> FastDateFormat<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"EEE, dd MMM yyyy HH:mm:ss Z"</span><span class="token punctuation">,</span> Locale<span class="token punctuation">.</span>US<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="format-Date-date-String-pattern"><a href="#format-Date-date-String-pattern" class="headerlink" title="format(Date date, String pattern)"></a>format(Date date, String pattern)</h3><p>将日期格式化为字符串。</p><pre class=" language-java"><code class="language-java">DateFormatUtils<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-03 23:03:53</span>DateFormatUtils<span class="token punctuation">.</span>ISO_8601_EXTENDED_DATETIME_FORMAT<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-03T23:09:52</span>DateFormatUtils<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-03 23:16:59</span></code></pre><h3 id="format-long-millis-String-pattern"><a href="#format-long-millis-String-pattern" class="headerlink" title="format(long millis, String pattern)"></a>format(long millis, String pattern)</h3><p>同<code>format(Date date, String pattern)</code>相似。</p><h3 id="format-Calendar-calendar-String-pattern"><a href="#format-Calendar-calendar-String-pattern" class="headerlink" title="format(Calendar calendar, String pattern)"></a>format(Calendar calendar, String pattern)</h3><p>同<code>format(Date date, String pattern)</code>相似。</p><h2 id="DateUtils"><a href="#DateUtils" class="headerlink" title="DateUtils"></a>DateUtils</h2><p><code>DateUtils</code>提供了很多很方便的功能，减轻了使用Date的复杂性。把原来需用<code>Calendar</code>才能完成的功能统一集中了起来，也就是说没有对应的<code>CalendarUtils</code>类。在JDK中，Date与Calendar概念本身就有些混淆，只是为了保持兼容性才引入的Calendar。相对于Calendar提供的方法，DateUtils提供了更加合理的方法，对时间的单个字段操作变得更加的容易。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> MILLIS_PER_SECOND <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1秒钟的毫秒数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> MILLIS_PER_MINUTE <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> MILLIS_PER_SECOND<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1分钟的毫秒数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> MILLIS_PER_HOUR <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> MILLIS_PER_MINUTE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1小时的毫秒数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> MILLIS_PER_DAY <span class="token operator">=</span> <span class="token number">24</span> <span class="token operator">*</span> MILLIS_PER_HOUR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1天的毫秒数</span></code></pre><h3 id="boolean-isSameDay-Date-date1-Date-date2"><a href="#boolean-isSameDay-Date-date1-Date-date2" class="headerlink" title="boolean isSameDay(Date date1, Date date2)"></a>boolean isSameDay(Date date1, Date date2)</h3><p>判断两个日期是否是同一天。</p><pre class=" language-java"><code class="language-java">DateUtils<span class="token punctuation">.</span><span class="token function">isSameDay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><h3 id="boolean-isSameDay-Calendar-cal1-Calendar-cal2"><a href="#boolean-isSameDay-Calendar-cal1-Calendar-cal2" class="headerlink" title="boolean isSameDay(Calendar cal1, Calendar cal2)"></a>boolean isSameDay(Calendar cal1, Calendar cal2)</h3><p>同<code>isSameDay(Date date1, Date date2)</code>相似。</p><h3 id="Date-parseDate-String-str-String…-parsePatterns"><a href="#Date-parseDate-String-str-String…-parsePatterns" class="headerlink" title="Date parseDate(String str, String… parsePatterns)"></a>Date parseDate(String str, String… parsePatterns)</h3><p>解析日期时间字符串日期时间Date对象，通过尝试各种不同的解析器来解析表示日期的字符串。</p><pre class=" language-java"><code class="language-java">DateUtils<span class="token punctuation">.</span><span class="token function">parseDate</span><span class="token punctuation">(</span><span class="token string">"2017-06-03 23:51:44"</span><span class="token punctuation">,</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-03 23:51:44</span>DateUtils<span class="token punctuation">.</span><span class="token function">parseDate</span><span class="token punctuation">(</span><span class="token string">"2017年06月03日 23时51分44秒"</span><span class="token punctuation">,</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">,</span> <span class="token string">"yyyy年MM月dd日 HH时mm分ss秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="Date-addYears-Date-date-int-amount"><a href="#Date-addYears-Date-date-int-amount" class="headerlink" title="Date addYears(Date date, int amount)"></a>Date addYears(Date date, int amount)</h3><p>得到<code>date</code>日期时间后（前）<code>amount</code>年后的日期时间。</p><pre class=" language-java"><code class="language-java">Date d3 <span class="token operator">=</span> DateUtils<span class="token punctuation">.</span><span class="token function">addYears</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2020-06-04 00:06:21</span>Date d3 <span class="token operator">=</span> DateUtils<span class="token punctuation">.</span><span class="token function">addYears</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2015-06-04 00:06:21</span></code></pre><h3 id="Date-addMonths-Date-date-int-amount"><a href="#Date-addMonths-Date-date-int-amount" class="headerlink" title="Date addMonths(Date date, int amount)"></a>Date addMonths(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对月份数进行加减。</p><h3 id="Date-addWeeks-Date-date-int-amount"><a href="#Date-addWeeks-Date-date-int-amount" class="headerlink" title="Date addWeeks(Date date, int amount)"></a>Date addWeeks(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对周数进行加减。</p><h3 id="Date-addDays-Date-date-int-amount"><a href="#Date-addDays-Date-date-int-amount" class="headerlink" title="Date addDays(Date date, int amount)"></a>Date addDays(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对天数进行加减。</p><h3 id="Date-addHours-Date-date-int-amount"><a href="#Date-addHours-Date-date-int-amount" class="headerlink" title="Date addHours(Date date, int amount)"></a>Date addHours(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对小时数进行加减。</p><h3 id="Date-addMinutes-Date-date-int-amount"><a href="#Date-addMinutes-Date-date-int-amount" class="headerlink" title="Date addMinutes(Date date, int amount)"></a>Date addMinutes(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对分钟数进行加减。</p><h3 id="Date-addSeconds-Date-date-int-amount"><a href="#Date-addSeconds-Date-date-int-amount" class="headerlink" title="Date addSeconds(Date date, int amount)"></a>Date addSeconds(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对秒数进行加减。</p><h3 id="Date-addMilliseconds-Date-date-int-amount"><a href="#Date-addMilliseconds-Date-date-int-amount" class="headerlink" title="Date addMilliseconds(Date date, int amount)"></a>Date addMilliseconds(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对毫秒数进行加减。</p><h3 id="Date-setYears-Date-date-int-amount"><a href="#Date-setYears-Date-date-int-amount" class="headerlink" title="Date setYears(Date date, int amount)"></a>Date setYears(Date date, int amount)</h3><p>对给定的日期时间设置年份。</p><pre class=" language-java"><code class="language-java">Date d4 <span class="token operator">=</span> DateUtils<span class="token punctuation">.</span><span class="token function">setYears</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2028</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2028-06-04 00:16:48</span></code></pre><h3 id="Date-setMonths-Date-date-int-amount"><a href="#Date-setMonths-Date-date-int-amount" class="headerlink" title="Date setMonths(Date date, int amount)"></a>Date setMonths(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对月数进行设置。</p><h3 id="Date-setDays-Date-date-int-amount"><a href="#Date-setDays-Date-date-int-amount" class="headerlink" title="Date setDays(Date date, int amount)"></a>Date setDays(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对天数进行设置。</p><h3 id="Date-setHours-Date-date-int-amount"><a href="#Date-setHours-Date-date-int-amount" class="headerlink" title="Date setHours(Date date, int amount)"></a>Date setHours(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对小时数进行设置。</p><h3 id="Date-setMinutes-Date-date-int-amount"><a href="#Date-setMinutes-Date-date-int-amount" class="headerlink" title="Date setMinutes(Date date, int amount)"></a>Date setMinutes(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对分钟数进行设置。</p><h3 id="Date-setSeconds-Date-date-int-amount"><a href="#Date-setSeconds-Date-date-int-amount" class="headerlink" title="Date setSeconds(Date date, int amount)"></a>Date setSeconds(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对秒钟数进行设置。</p><h3 id="Date-setMilliseconds-Date-date-int-amount"><a href="#Date-setMilliseconds-Date-date-int-amount" class="headerlink" title="Date setMilliseconds(Date date, int amount)"></a>Date setMilliseconds(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对毫秒数进行设置。</p><h3 id="toCalendar-Date-date"><a href="#toCalendar-Date-date" class="headerlink" title="toCalendar(Date date)"></a>toCalendar(Date date)</h3><p>将日期转为<code>Calendar</code>实例。</p><h3 id="Date-round-Date-date-int-field"><a href="#Date-round-Date-date-int-field" class="headerlink" title="Date round(Date date, int field)"></a>Date round(Date date, int field)</h3><p>对日期时间进行四舍五入。filed指定取整的字段，可以取的值为</p><ul><li>Calendar.SECOND</li><li>Calendar.MINUTE</li><li>Calendar.HOUR_OF_DAY</li><li>Calendar.DAY_OF_MONTH</li><li>Calendar.MONTH</li><li>Calendar.YEAR<br>… </li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 当前时间为'2017-06-04 00:44:41'，则执行以下代码</span>DateUtils<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>YEAR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-01-01 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-01 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>HOUR_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 01:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>DAY_OF_MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>HOUR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 01:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MINUTE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 00:45:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>SECOND<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 00:44:43</span></code></pre><h3 id="Date-truncate-Date-date-int-field"><a href="#Date-truncate-Date-date-int-field" class="headerlink" title="Date truncate(Date date, int field)"></a>Date truncate(Date date, int field)</h3><p>从给定字段开始格式化截取日期。对一个时间对象的某个字段进行截断。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 当前时间为'2017-06-04 00:56:05'，则执行以下代码</span>DateUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>YEAR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-01-01 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-01 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>HOUR_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>DAY_OF_MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>HOUR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MINUTE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 00:56:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>SECOND<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 00:56:05</span></code></pre><h3 id="Date-ceiling-Date-date-int-field"><a href="#Date-ceiling-Date-date-int-field" class="headerlink" title="Date ceiling(Date date, int field)"></a>Date ceiling(Date date, int field)</h3><p>从给定字段开始“向上”格式化日期。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 当前时间为'2017-06-04 01:02:31'，则执行以下代码</span>DateUtils<span class="token punctuation">.</span><span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>YEAR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2018-01-01 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-07-01 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>HOUR_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 02:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>DAY_OF_MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-05 00:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>HOUR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 02:00:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MINUTE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 01:03:00</span>DateUtils<span class="token punctuation">.</span><span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>SECOND<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2017-06-04 01:02:32</span></code></pre><h3 id="long-getFragmentInDays-Date-date-int-fragment"><a href="#long-getFragmentInDays-Date-date-int-fragment" class="headerlink" title="long getFragmentInDays(Date date, int fragment)"></a>long getFragmentInDays(Date date, int fragment)</h3><p>返回一个指定时间的天数。关键的是参数<code>fragment</code>，它的作用非常重要。它的值必须是Calendar的时间常量字段。</p><p><strong>注意</strong>：小时必须用24小时制的，即<code>Calendar.HOUR_OF_DAY</code>，而不能用<code>Calendar.HOUR</code>字段。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 当前时间为'2017-06-04 01:12:31'，则执行以下代码</span>DateUtils<span class="token punctuation">.</span><span class="token function">getFragmentInDays</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>YEAR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 155</span>DateUtils<span class="token punctuation">.</span><span class="token function">getFragmentInDays</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span></code></pre><h3 id="long-getFragmentInMilliseconds-Date-date-int-fragment"><a href="#long-getFragmentInMilliseconds-Date-date-int-fragment" class="headerlink" title="long getFragmentInMilliseconds(Date date, int fragment)"></a>long getFragmentInMilliseconds(Date date, int fragment)</h3><p>同<code>getFragmentInDays(Date date, int fragment)</code>相似。</p><h3 id="long-getFragmentInSeconds-Date-date-int-fragment"><a href="#long-getFragmentInSeconds-Date-date-int-fragment" class="headerlink" title="long getFragmentInSeconds(Date date, int fragment)"></a>long getFragmentInSeconds(Date date, int fragment)</h3><p>同<code>getFragmentInDays(Date date, int fragment)</code>相似。</p><h3 id="long-getFragmentInMinutes-Date-date-int-fragment"><a href="#long-getFragmentInMinutes-Date-date-int-fragment" class="headerlink" title="long getFragmentInMinutes(Date date, int fragment)"></a>long getFragmentInMinutes(Date date, int fragment)</h3><p>同<code>getFragmentInDays(Date date, int fragment)</code>相似。</p><h3 id="long-getFragmentInHours-Date-date-int-fragment"><a href="#long-getFragmentInHours-Date-date-int-fragment" class="headerlink" title="long getFragmentInHours(Date date, int fragment)"></a>long getFragmentInHours(Date date, int fragment)</h3><p>同<code>getFragmentInDays(Date date, int fragment)</code>相似。</p><h3 id="boolean-truncatedEquals-Date-date1-Date-date2-int-field"><a href="#boolean-truncatedEquals-Date-date1-Date-date2-int-field" class="headerlink" title="boolean truncatedEquals(Date date1, Date date2, int field)"></a>boolean truncatedEquals(Date date1, Date date2, int field)</h3><p>比较日历对应字段是否相等。</p><h2 id="StopWatch"><a href="#StopWatch" class="headerlink" title="StopWatch"></a>StopWatch</h2><p><code>StopWatch</code>是一个方便的计时器。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre class=" language-java"><code class="language-java">StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stopWatch<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="主要方法："><a href="#主要方法：" class="headerlink" title="主要方法："></a>主要方法：</h3><ul><li><code>start()</code>: 开始计时</li><li><code>stop()</code>: 停止计时</li><li><code>reset()</code>: 重置计时</li><li><code>suspend()</code>: 暂停计时</li><li><code>resume()</code>: 继续计时</li><li><code>getTime()</code>: 获取消耗的毫秒数</li><li><code>getNanoTime()</code>: 获取消耗的纳秒数</li><li><code>getStartTime()</code>: 获取开始的毫秒数</li><li><code>isStarted()</code>: 是否开始</li><li><code>isSuspended()</code>: 是否暂停</li><li><code>isStopped()</code>: 是否停止</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apache Commons Lang之ArrayUtils</title>
      <link href="/2018/09/28/hou-duan/java/commons/apache-commons-lang-zhi-arrayutils/"/>
      <url>/2018/09/28/hou-duan/java/commons/apache-commons-lang-zhi-arrayutils/</url>
      
        <content type="html"><![CDATA[<blockquote><p>码农不识Apache，码尽一生也枉然。</p></blockquote><h2 id="常量数组"><a href="#常量数组" class="headerlink" title="常量数组"></a>常量数组</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_OBJECT_ARRAY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_CLASS_ARRAY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_STRING_ARRAY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_LONG_ARRAY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">long</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Long<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_LONG_OBJECT_ARRAY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_INT_ARRAY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_INTEGER_OBJECT_ARRAY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h2 id="转换为Map"><a href="#转换为Map" class="headerlink" title="转换为Map"></a>转换为Map</h2><h3 id="toMap-Object-array"><a href="#toMap-Object-array" class="headerlink" title="toMap(Object[] array)"></a>toMap(Object[] array)</h3><p>将二维数组转换为Map。</p><pre class=" language-java"><code class="language-java">Map colorMap <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token string">"RED"</span><span class="token punctuation">,</span> <span class="token string">"#FF0000"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"GREEN"</span><span class="token punctuation">,</span> <span class="token string">"#00FF00"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"BLUE"</span><span class="token punctuation">,</span> <span class="token string">"#0000FF"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="生成数组"><a href="#生成数组" class="headerlink" title="生成数组"></a>生成数组</h2><h3 id="T-toArray-final-T…-items"><a href="#T-toArray-final-T…-items" class="headerlink" title="T[] toArray(final T… items)"></a>T[] toArray(final T… items)</h3><p>将不定参数转换为数组。</p><pre class=" language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> emptyArray <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span>&lt;String<span class="token operator">></span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="null转空数组"><a href="#null转空数组" class="headerlink" title="null转空数组"></a>null转空数组</h2><h3 id="Object-nullToEmpty-Object-array"><a href="#Object-nullToEmpty-Object-array" class="headerlink" title="Object[] nullToEmpty(Object[] array)"></a>Object[] nullToEmpty(Object[] array)</h3><p>将null数组转为对应类型的空数组，如果array不是null，则返回array。</p><pre class=" language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span><span class="token function">nullToEmpty</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="T-subarray-T-array-int-startIndexInclusive-int-endIndexExclusive"><a href="#T-subarray-T-array-int-startIndexInclusive-int-endIndexExclusive" class="headerlink" title=" T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive)"></a><t> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive)</t></h3><p>截取数组开始索引位置和结束索引位置的数组为子数组</p><pre class=" language-java"><code class="language-java">Object<span class="token punctuation">[</span><span class="token punctuation">]</span>s1<span class="token operator">=</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">subarray</span><span class="token punctuation">(</span>newObject<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"aa"</span><span class="token punctuation">,</span><span class="token string">"bb"</span><span class="token punctuation">,</span><span class="token string">"cc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ["aa"]</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span>s2<span class="token operator">=</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">subarray</span><span class="token punctuation">(</span>newObject<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"aa"</span><span class="token punctuation">,</span><span class="token string">"bb"</span><span class="token punctuation">,</span><span class="token string">"cc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ["aa", "bb"]</span></code></pre><h3 id="reverse-long-array"><a href="#reverse-long-array" class="headerlink" title="reverse(long[] array)"></a>reverse(long[] array)</h3><p>反转数组。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"aa"</span><span class="token punctuation">,</span><span class="token string">"bb"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果是：{"bb"，"aa"}</span></code></pre><h3 id="swap-Object-array-int-offset1-int-offset2"><a href="#swap-Object-array-int-offset1-int-offset2" class="headerlink" title="swap(Object[] array, int offset1, int offset2)"></a>swap(Object[] array, int offset1, int offset2)</h3><p>交换数组中的元素。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span></code></pre><h2 id="数组元素查找"><a href="#数组元素查找" class="headerlink" title="数组元素查找"></a>数组元素查找</h2><h3 id="int-indexOf-Object-array-Object-objectToFind"><a href="#int-indexOf-Object-array-Object-objectToFind" class="headerlink" title="int indexOf(Object[] array, Object objectToFind)"></a>int indexOf(Object[] array, Object objectToFind)</h3><p>数组元素所在的索引位置,如果没有则返回-1,可指定起始搜索位置。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"aa"</span><span class="token punctuation">,</span><span class="token string">"bb"</span><span class="token punctuation">,</span><span class="token string">"cc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"aa"</span><span class="token punctuation">,</span><span class="token string">"bb"</span><span class="token punctuation">,</span><span class="token string">"bb"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"bb"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>newObject<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"aa"</span><span class="token punctuation">,</span><span class="token string">"bb"</span><span class="token punctuation">,</span><span class="token string">"cc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"cc"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -1</span></code></pre><h3 id="int-lastIndexOf-Object-array-Object-objectToFind-int-startIndex"><a href="#int-lastIndexOf-Object-array-Object-objectToFind-int-startIndex" class="headerlink" title="int lastIndexOf(Object[] array, Object objectToFind, int startIndex)"></a>int lastIndexOf(Object[] array, Object objectToFind, int startIndex)</h3><p>同<code>indexOf(Object[] array, Object objectToFind)</code>相反。反向查询某个object在数组中的位置，可以指定起始搜索位置。</p><h3 id="contains-Object-array-Object-objectToFind"><a href="#contains-Object-array-Object-objectToFind" class="headerlink" title="contains(Object[] array, Object objectToFind)"></a>contains(Object[] array, Object objectToFind)</h3><p>判断数组中是否包含某个元素。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><h2 id="数组判空"><a href="#数组判空" class="headerlink" title="数组判空"></a>数组判空</h2><h3 id="boolean-isEmpty-Object-array"><a href="#boolean-isEmpty-Object-array" class="headerlink" title="boolean isEmpty(Object[] array)"></a>boolean isEmpty(Object[] array)</h3><p>判断数组是否为空。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"21"</span><span class="token punctuation">,</span><span class="token string">"是"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>null<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><h3 id="boolean-isNotEmpty-T-array"><a href="#boolean-isNotEmpty-T-array" class="headerlink" title=" boolean isNotEmpty(T[] array)"></a><t> boolean isNotEmpty(T[] array)</t></h3><p>同<code></code>相反。判断数组是否不为空。</p><h2 id="合并数组元素"><a href="#合并数组元素" class="headerlink" title="合并数组元素"></a>合并数组元素</h2><h3 id="T-addAll-T-array1-T…-array2"><a href="#T-addAll-T-array1-T…-array2" class="headerlink" title=" T[] addAll(T[] array1, T… array2)"></a><t> T[] addAll(T[] array1, T… array2)</t></h3><p>合并多个数组到某一个数组中。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">)</span>     <span class="token operator">=</span> nullArrayUtils<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>array1<span class="token punctuation">,</span> null<span class="token punctuation">)</span>   <span class="token operator">=</span> cloned copy of array1ArrayUtils<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> array2<span class="token punctuation">)</span>   <span class="token operator">=</span> cloned copy of array2ArrayUtils<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span>null<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>null<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span>null<span class="token punctuation">,</span> null<span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span></code></pre><h3 id="T-add-T-array-T-element"><a href="#T-add-T-array-T-element" class="headerlink" title=" T[] add(T[] array, T element)"></a><t> T[] add(T[] array, T element)</t></h3><p>将单个元素合并到数组中。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">)</span>      <span class="token operator">=</span> IllegalArgumentExceptionArrayUtils<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> null<span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span></code></pre><h3 id="T-add-T-array-int-index-T-element"><a href="#T-add-T-array-int-index-T-element" class="headerlink" title=" T[] add(T[] array, int index, T element)"></a><t> T[] add(T[] array, int index, T element)</t></h3><p>将单个元素合并到指定索引位置的数组中。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>      <span class="token operator">=</span> IllegalArgumentExceptionArrayUtils<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> null<span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span></code></pre><h2 id="移除数组元素"><a href="#移除数组元素" class="headerlink" title="移除数组元素"></a>移除数组元素</h2><h3 id="T-remove-T-array-int-index"><a href="#T-remove-T-array-int-index" class="headerlink" title=" T[] remove(T[] array, int index)"></a><t> T[] remove(T[] array, int index)</t></h3><p>移除数组中指定索引位置的元素。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>           <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span></code></pre><h3 id="T-removeAll-T-array-int…-indices"><a href="#T-removeAll-T-array-int…-indices" class="headerlink" title=" T[] removeAll(T[] array, int… indices)"></a><t> T[] removeAll(T[] array, int… indices)</t></h3><p>同<code>&lt;T&gt; T[] remove(T[] array, int index)</code>相似，移除数组中所有指定索引位置的元素。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span></code></pre><h3 id="T-removeElement-T-array-Object-element"><a href="#T-removeElement-T-array-Object-element" class="headerlink" title=" T[] removeElement(T[] array, Object element)"></a><t> T[] removeElement(T[] array, Object element)</t></h3><p>移除数组中的第一个element元素。</p><pre class=" language-java"><code class="language-java">ArrayUtils<span class="token punctuation">.</span><span class="token function">removeElement</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>            <span class="token operator">=</span> nullArrayUtils<span class="token punctuation">.</span><span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>              <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span>           <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo博客主题之hexo-theme-matery的介绍</title>
      <link href="/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/"/>
      <url>/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一个采用<code>Material Design</code>和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a>设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>每天动态切换<code>Banner</code>图片</li><li>瀑布流式的博客文章列表(文章无特色图片时会有<code>24</code>张漂亮的图片代替)</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>TOC目录</li><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>和<a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a>评论模块（推荐使用Gitalk）</li></ul><h2 id="后续开发计划"><a href="#后续开发计划" class="headerlink" title="后续开发计划"></a>后续开发计划</h2><ul><li style="list-style: none"><input type="checkbox" checked> 重构标签页为<strong>可分页</strong></li><li style="list-style: none"><input type="checkbox" checked> 重构归档页为<strong>可分页</strong></li><li style="list-style: none"><input type="checkbox" checked> 增加分类页</li><li style="list-style: none"><input type="checkbox" checked> 增加关于我页面</li><li style="list-style: none"><input type="checkbox" checked> 集成<a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a></li><li style="list-style: none"><input type="checkbox" checked> 右上角实现<code>fork me on github</code></li><li style="list-style: none"><input type="checkbox" checked> 添加<code>RSS</code></li><li style="list-style: none"><input type="checkbox" checked> 添加文章<code>TOC</code></li><li><del>网站底部加上访问量等统计功能</del>（主题使用者可以基于谷歌分析、百度统计、LeanCloud等来实现）</li><li style="list-style: none"><input type="checkbox" checked> 首页设计和添加置顶文章</li><li style="list-style: none"><input type="checkbox" checked> 文章结束后增加<strong>打赏</strong>功能</li><li><del>为博客添加萌萌的<strong>宠物</strong>或者<strong>成长树</strong>等</del>（可以使用<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a>插件来实现）</li></ul><blockquote><p>欢迎贡献!</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当你看到这里的时候，应该已经有一个自己的<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>博客了，如果还没有的话，不妨使用 Hexo 和<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown</a>来写博客和文章。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载<code>master</code>分支的最新稳定版的代码，解压缩后，将<code>hexo-theme-matery</code>的文件夹复制到你 Hexo 的<code>themes</code>文件夹中即可。当然你也可以在你的<code>themes</code>文件夹下使用<code>Git clone</code>命令来下载:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的<code>_config.yml</code>的<code>theme</code>的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml文件的其它修改建议"><a href="#config-yml文件的其它修改建议" class="headerlink" title="_config.yml文件的其它修改建议:"></a><code>_config.yml</code>文件的其它修改建议:</h4><ul><li>请修改<code>_config.yml</code>的<code>url</code>的值为你的网站主<code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个<code>per_page</code>的分页条数值为<code>6</code>的倍数，如：<code>12</code>、<code>18</code>等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改<code>language</code>的值为<code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code>页是用来展示所有分类的页面，如果在你的博客<code>source</code>目录下还没有<code>categories/index.md</code>文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span></code></pre><p>编辑你刚刚新建的页面文件<code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code>页是用来展示所有标签的页面，如果在你的博客<code>source</code>目录下还没有<code>tags/index.md</code>文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span></code></pre><p>编辑你刚刚新建的页面文件<code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code>页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客<code>source</code>目录下还没有<code>about/index.md</code>文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"about"</span></code></pre><p>编辑你刚刚新建的页面文件<code>/source/about/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了<a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a>的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下<code>_config.yml</code>文件中<code>highlight.enable</code>的值为<code>false</code>，并新增<code>prism</code>插件相关的配置，主要配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># default false</span>  <span class="token key atrule">custom_css</span><span class="token punctuation">:</span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了<a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a>的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post</code></pre><h3 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于<code>SEO</code>，且<code>gitment</code>评论对中文链接也不支持。我们可以用<a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment" spellcheck="true"># default: '-'</span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a>插件也可以生成非中文的链接。</p></blockquote><h3 id="添加RSS订阅支持（可选的）"><a href="#添加RSS订阅支持（可选的）" class="headerlink" title="添加RSS订阅支持（可选的）"></a>添加RSS订阅支持（可选的）</h3><p>本主题中还使用到了<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a>的 Hexo 插件来做<code>RSS</code>，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code>重新生成博客文件，然后在<code>public</code>文件夹中即可看到<code>atom.xml</code>文件，说明你已经安装成功了。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题文件的<code>/layout/_partial/social-link.ejs</code>文件中，你可以修改或添加你需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在<a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a>中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的<code>Font Awesome</code>版本为<code>4.5.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的<code>source/medias/reward</code>文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h2 id="文章Front-matter示例"><a href="#文章Front-matter示例" class="headerlink" title="文章Front-matter示例"></a>文章Front-matter示例</h2><p>以下为文章<code>Front-matter</code>的示例，所有内容均为<strong>非必填</strong>的。但是，仍然建议至少填写<code>title</code>的值，当然最好都填写上这些文章信息。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg <span class="token comment" spellcheck="true"># 或者:http://xxx.com/xxx.jpg</span><span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 如果top值为true，则会是首页推荐文章</span><span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span></code></pre><blockquote><p><strong>注意</strong>:</p><ol><li>如果<code>img</code>属性不填写的话，文章特色图会根据文章标题的<code>hashcode</code>的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code>的值尽量保证每篇文章是唯一的，因为本主题中<code>Gitment</code>识别<code>id</code>是通过<code>date</code>的值来作为唯一标识的。</li></ol></blockquote><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p><img src="http://static.blinkfox.com/hexo-matery-index1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/hexo-matery-index2.png" alt="首页文章列表"></p><h3 id="文章页"><a href="#文章页" class="headerlink" title="文章页"></a>文章页</h3><p><img src="http://static.blinkfox.com/hexo-matery-post1.png" alt="文章"></p><p><img src="http://static.blinkfox.com/hexo-matery-post2.png" alt="文章后续内容"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的<code>_config.yml</code>中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>首页的励志名言</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC目录</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>和<code>disqus</code>评论配置</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的<code>hashcode</code>值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的<code>_config.yml</code>中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的<code>/source/css/matery.css</code>文件中，搜索<code>.bg-color</code>来修改背景颜色：</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector"><span class="token class">.bg-color</span> </span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token hexcode">#4cbf30</span> <span class="token number">0%</span>, <span class="token hexcode">#0f9d58</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 和背景颜色相同的文字颜色，目前仅在首页一个地方使用到，你也可以将此样式应用到其他地方. */</span><span class="token selector"><span class="token class">.text-color</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#0f9d58</span> <span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span></code></pre><h3 id="修改banner图和文章特色图"><a href="#修改banner图和文章特色图" class="headerlink" title="修改banner图和文章特色图"></a>修改banner图和文章特色图</h3><p>你可以直接在<code>/source/medias/banner</code>文件夹中更换你喜欢的<code>banner</code>图片，主题代码中是每天动态切换一张，只需<code>7</code>张即可。如果你会<code>JavaScript</code>代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code>切换的代码位置在<code>/layout/_partial/bg-cover.ejs</code>文件的<code>&lt;script&gt;&lt;/script&gt;</code>代码中：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在<code>/source/medias/featureimages</code>文件夹中默认有24张特色图片，你可以再增加或者减少，并需要在<code>_config.yml</code>做同步修改。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apache Commons Lang之StringUtils</title>
      <link href="/2018/09/27/hou-duan/java/commons/apache-commons-lang-zhi-stringutils/"/>
      <url>/2018/09/27/hou-duan/java/commons/apache-commons-lang-zhi-stringutils/</url>
      
        <content type="html"><![CDATA[<blockquote><p>码农不识Apache，码尽一生也枉然。</p></blockquote><h2 id="判断空字符串"><a href="#判断空字符串" class="headerlink" title="判断空字符串"></a>判断空字符串</h2><h3 id="isEmpty-CharSequence-cs"><a href="#isEmpty-CharSequence-cs" class="headerlink" title="isEmpty(CharSequence cs)"></a>isEmpty(CharSequence cs)</h3><p>判断是否是空字符串，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token string">"bob"</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token string">"  bob  "</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="isNotEmpty-CharSequence-cs"><a href="#isNotEmpty-CharSequence-cs" class="headerlink" title="isNotEmpty(CharSequence cs)"></a>isNotEmpty(CharSequence cs)</h3><p>判断是否不是空字符串，与<code>isEmpty(CharSequence cs)</code>相反。</p><h3 id="isAnyEmpty-CharSequence…-css"><a href="#isAnyEmpty-CharSequence…-css" class="headerlink" title="isAnyEmpty(CharSequence… css)"></a>isAnyEmpty(CharSequence… css)</h3><p>判断是否含有空字符串，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">isAnyEmpty</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>             <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAnyEmpty</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAnyEmpty</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAnyEmpty</span><span class="token punctuation">(</span><span class="token string">"bob"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAnyEmpty</span><span class="token punctuation">(</span><span class="token string">"  bob  "</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAnyEmpty</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAnyEmpty</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="isNoneEmpty-CharSequence…-css"><a href="#isNoneEmpty-CharSequence…-css" class="headerlink" title="isNoneEmpty(CharSequence… css)"></a>isNoneEmpty(CharSequence… css)</h3><p>判断是否都不是空字符串，与<code>isAnyEmpty(CharSequence... css)</code>相反。</p><h3 id="isAllEmpty-CharSequence…-css"><a href="#isAllEmpty-CharSequence…-css" class="headerlink" title="isAllEmpty(CharSequence… css)"></a>isAllEmpty(CharSequence… css)</h3><p>判断是否都是空字符串，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">isAllEmpty</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>             <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllEmpty</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>         <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllEmpty</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllEmpty</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllEmpty</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllEmpty</span><span class="token punctuation">(</span><span class="token string">"bob"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllEmpty</span><span class="token punctuation">(</span><span class="token string">"  bob  "</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllEmpty</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllEmpty</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="isBlank-CharSequence-cs"><a href="#isBlank-CharSequence-cs" class="headerlink" title="isBlank(CharSequence cs)"></a>isBlank(CharSequence cs)</h3><p>判断是否是“大空字符串”，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span><span class="token string">"bob"</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span><span class="token string">"  bob  "</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="isNotBlank-CharSequence-cs"><a href="#isNotBlank-CharSequence-cs" class="headerlink" title="isNotBlank(CharSequence cs)"></a>isNotBlank(CharSequence cs)</h3><p>判断是否不是“大空字符串”，与<code>isBlank(CharSequence cs)</code>相反，与<code>isNotEmpty(CharSequence cs)</code>相似。</p><h3 id="isAnyBlank-CharSequence…-css"><a href="#isAnyBlank-CharSequence…-css" class="headerlink" title="isAnyBlank(CharSequence… css)"></a>isAnyBlank(CharSequence… css)</h3><p>判断是否有“大空字符串”，与<code>isAnyEmpty(CharSequence... css)</code>相似。</p><h3 id="isNoneBlank-CharSequence…-css"><a href="#isNoneBlank-CharSequence…-css" class="headerlink" title="isNoneBlank(CharSequence… css)"></a>isNoneBlank(CharSequence… css)</h3><p>判断是否都不是“大空字符串”，与<code>isAnyBlank(CharSequence... css)</code>相反，与<code>isNoneEmpty(CharSequence... css)</code>相似。</p><h3 id="isAllBlank-CharSequence…-css"><a href="#isAllBlank-CharSequence…-css" class="headerlink" title="isAllBlank(CharSequence… css)"></a>isAllBlank(CharSequence… css)</h3><p>判断是否都是“大空字符串”，与<code>isAllEmpty(CharSequence... css)</code>相似。</p><h2 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h2><h3 id="trim-String-str"><a href="#trim-String-str" class="headerlink" title="trim(String str)"></a>trim(String str)</h3><p>去除字符串前后的控制符，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>          <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>            <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token string">"     "</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span>         <span class="token operator">=</span> <span class="token string">"abc"</span>StringUtils<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token string">"    abc    "</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abc"</span></code></pre><h3 id="trimToNull-String-str"><a href="#trimToNull-String-str" class="headerlink" title="trimToNull(String str)"></a>trimToNull(String str)</h3><p>去除字符串前后的控制符，如何是空字符串则转为<code>null</code>，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">trimToNull</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>          <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">trimToNull</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>            <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">trimToNull</span><span class="token punctuation">(</span><span class="token string">"     "</span><span class="token punctuation">)</span>       <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">trimToNull</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span>         <span class="token operator">=</span> <span class="token string">"abc"</span>StringUtils<span class="token punctuation">.</span><span class="token function">trimToNull</span><span class="token punctuation">(</span><span class="token string">"    abc    "</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abc"</span></code></pre><h3 id="trimToEmpty-String-str"><a href="#trimToEmpty-String-str" class="headerlink" title="trimToEmpty(String str)"></a>trimToEmpty(String str)</h3><p>去除字符串前后的控制符，如何是<code>null</code>则转为空字符串，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">trimToEmpty</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>          <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">trimToEmpty</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>            <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">trimToEmpty</span><span class="token punctuation">(</span><span class="token string">"     "</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">trimToEmpty</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span>         <span class="token operator">=</span> <span class="token string">"abc"</span>StringUtils<span class="token punctuation">.</span><span class="token function">trimToEmpty</span><span class="token punctuation">(</span><span class="token string">"    abc    "</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abc"</span></code></pre><h3 id="truncate-String-str-int-maxWidth"><a href="#truncate-String-str-int-maxWidth" class="headerlink" title="truncate(String str, int maxWidth)"></a>truncate(String str, int maxWidth)</h3><p>截断字符串，具有以下特点：</p><ul><li>如果str字符串的长度小于maxWidth，则直接返回str。</li><li>不满足第一条时，则为<code>substring(str, 0, maxWidth)</code>。</li><li>如果maxWidth小于0，则抛出IllegalArgumentException。</li><li>在任何情况下都不会返回长度大于maxWidth的字符串。</li></ul><p>代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>       <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>       <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>         <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"abcd"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"abcdef"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"abcdefg"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"abcdefg"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">throws</span> an IllegalArgumentException</code></pre><h3 id="truncate-String-str-int-offset-int-maxWidth"><a href="#truncate-String-str-int-offset-int-maxWidth" class="headerlink" title="truncate(String str, int offset, int maxWidth)"></a>truncate(String str, int offset, int maxWidth)</h3><p>截断字符串，具有以下特点：</p><ul><li>如果str字符串的长度小于maxWidth，则直接返回str。</li><li>不满足第一条时，则为<code>substring(str, offset, maxWidth)</code>。</li><li>如果maxWidth或者offset小于0，则抛出IllegalArgumentException。</li><li>在任何情况下都不会返回长度大于maxWidth的字符串。</li></ul><p>代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghij"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abc"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghij"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"fghij"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"raspberry peach"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"peach"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abcdefghij"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">throws</span> an IllegalArgumentExceptionStringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abcdefghij"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abcdefghijklmno"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abcdefghijklmno"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"bcdefghijk"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"cdefghijkl"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"defghijklm"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"efghijklmn"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"fghijklmno"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"fghij"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"fgh"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"klm"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"klmno"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"n"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"no"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"o"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"o"</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghijklmno"</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghij"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">throws</span> an IllegalArgumentExceptionStringUtils<span class="token punctuation">.</span><span class="token function">truncate</span><span class="token punctuation">(</span><span class="token string">"abcdefghij"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">throws</span> an IllegalArgumentException</code></pre><h3 id="left-String-str-int-len"><a href="#left-String-str-int-len" class="headerlink" title="left(String str, int len)"></a>left(String str, int len)</h3><p>得到一个字符串最左边的len个字符</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">left</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">left</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"ab"</span>StringUtils<span class="token punctuation">.</span><span class="token function">left</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"abc"</span></code></pre><h3 id="right-String-str-int-len"><a href="#right-String-str-int-len" class="headerlink" title="right(String str, int len)"></a>right(String str, int len)</h3><p>同<code>left(String str, int len)</code>相反，从右边截取len个字符。</p><h3 id="mid-String-str-int-pos-int-len"><a href="#mid-String-str-int-pos-int-len" class="headerlink" title="mid(String str, int pos, int len)"></a>mid(String str, int pos, int len)</h3><p>得到一个字符串中间的len个字符。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">mid</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"ab"</span>StringUtils<span class="token punctuation">.</span><span class="token function">mid</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"abc"</span>StringUtils<span class="token punctuation">.</span><span class="token function">mid</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"c"</span>StringUtils<span class="token punctuation">.</span><span class="token function">mid</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">mid</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"ab"</span></code></pre><h3 id="substringBefore-String-str-String-separator"><a href="#substringBefore-String-str-String-separator" class="headerlink" title="substringBefore(String str, String separator)"></a>substringBefore(String str, String separator)</h3><p>得到一个字符串第一个分隔符字符串之前的字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">substringBefore</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">substringBefore</span><span class="token punctuation">(</span><span class="token string">"abcba"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"a"</span>StringUtils<span class="token punctuation">.</span><span class="token function">substringBefore</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"ab"</span>StringUtils<span class="token punctuation">.</span><span class="token function">substringBefore</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"abc"</span>StringUtils<span class="token punctuation">.</span><span class="token function">substringBefore</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">substringBefore</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"abc"</span></code></pre><h3 id="substringAfter-String-str-String-separator"><a href="#substringAfter-String-str-String-separator" class="headerlink" title="substringAfter(String str, String separator)"></a>substringAfter(String str, String separator)</h3><p>同<code>substringBefore(String str, String separator)</code>相反。得到一个字符串第一个分隔符字符串之后的字符串。</p><h3 id="substringBetween-String-str-String-open-String-close"><a href="#substringBetween-String-str-String-open-String-close" class="headerlink" title="substringBetween(String str, String open, String close)"></a>substringBetween(String str, String open, String close)</h3><p>得到一个字符串两个字符串之间字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">substringBetween</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>          <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">substringBetween</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"]"</span><span class="token punctuation">)</span>         <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">substringBetween</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"["</span><span class="token punctuation">,</span> <span class="token string">"]"</span><span class="token punctuation">)</span>        <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">substringBetween</span><span class="token punctuation">(</span><span class="token string">"yabcz"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">substringBetween</span><span class="token punctuation">(</span><span class="token string">"yabcz"</span><span class="token punctuation">,</span> <span class="token string">"y"</span><span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"abc"</span>StringUtils<span class="token punctuation">.</span><span class="token function">substringBetween</span><span class="token punctuation">(</span><span class="token string">"yabczyabcz"</span><span class="token punctuation">,</span> <span class="token string">"y"</span><span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"abc"</span></code></pre><h3 id="substringBetween-String-str-String-tag"><a href="#substringBetween-String-str-String-tag" class="headerlink" title="substringBetween(String str, String tag)"></a>substringBetween(String str, String tag)</h3><p>是<code>substringBetween(String str, String open, String close)</code>的特殊情形。得到一个字符串中同一个字符串之间的字符串。</p><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><h3 id="equals-CharSequence-cs1-CharSequence-cs2"><a href="#equals-CharSequence-cs1-CharSequence-cs2" class="headerlink" title="equals(CharSequence cs1, CharSequence cs2)"></a>equals(CharSequence cs1, CharSequence cs2)</h3><p>判断两字符串相等，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"ABC"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="equalsIgnoreCase-CharSequence-str1-CharSequence-str2"><a href="#equalsIgnoreCase-CharSequence-str1-CharSequence-str2" class="headerlink" title="equalsIgnoreCase(CharSequence str1, CharSequence str2)"></a>equalsIgnoreCase(CharSequence str1, CharSequence str2)</h3><p>判断两字符串相等，忽略大小写，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"ABC"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span></code></pre><h3 id="equalsAny-CharSequence-string-CharSequence…-searchStrings"><a href="#equalsAny-CharSequence-string-CharSequence…-searchStrings" class="headerlink" title="equalsAny(CharSequence string, CharSequence… searchStrings)"></a>equalsAny(CharSequence string, CharSequence… searchStrings)</h3><p>比较一个字符串是否与其后的某个字符串相等，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">equalsAny</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token punctuation">(</span>CharSequence<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> null<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsAny</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsAny</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsAny</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsAny</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsAny</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"ABC"</span><span class="token punctuation">,</span> <span class="token string">"DEF"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="equalsAnyIgnoreCase-CharSequence-string-CharSequence…searchStrings"><a href="#equalsAnyIgnoreCase-CharSequence-string-CharSequence…searchStrings" class="headerlink" title="equalsAnyIgnoreCase(CharSequence string, CharSequence…searchStrings)"></a>equalsAnyIgnoreCase(CharSequence string, CharSequence…searchStrings)</h3><p>比较一个字符串是否与其后的某个字符串相等，忽略大小写，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">equalsAnyIgnoreCase</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token punctuation">(</span>CharSequence<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> null<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsAnyIgnoreCase</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsAnyIgnoreCase</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsAnyIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsAnyIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">equalsAnyIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"ABC"</span><span class="token punctuation">,</span> <span class="token string">"DEF"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span></code></pre><h3 id="compare-String-str1-String-str2"><a href="#compare-String-str1-String-str2" class="headerlink" title="compare(String str1, String str2)"></a>compare(String str1, String str2)</h3><p>比较两字符串的大小，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>null <span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>   <span class="token operator">&lt;</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>    <span class="token operator">></span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span>     <span class="token operator">&lt;</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>     <span class="token operator">></span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span>     <span class="token operator">></span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span>  <span class="token operator">&lt;</span> <span class="token number">0</span></code></pre><h3 id="compareIgnoreCase-String-str1-String-str2"><a href="#compareIgnoreCase-String-str1-String-str2" class="headerlink" title="compareIgnoreCase(String str1, String str2)"></a>compareIgnoreCase(String str1, String str2)</h3><p>比较两字符串的大小，忽略大小写，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">compareIgnoreCase</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compareIgnoreCase</span><span class="token punctuation">(</span>null <span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>   <span class="token operator">&lt;</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compareIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>    <span class="token operator">></span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compareIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compareIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"ABC"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compareIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span>     <span class="token operator">&lt;</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compareIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>     <span class="token operator">></span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compareIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span>     <span class="token operator">&lt;</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compareIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span>     <span class="token operator">&lt;</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">compareIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"ABC"</span><span class="token punctuation">)</span>  <span class="token operator">&lt;</span> <span class="token number">0</span></code></pre><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><h3 id="indexOf-CharSequence-seq-int-searchChar"><a href="#indexOf-CharSequence-seq-int-searchChar" class="headerlink" title="indexOf(CharSequence seq, int searchChar)"></a>indexOf(CharSequence seq, int searchChar)</h3><p>查找某个字符在字符串中第一次出现时的索引位置，代码示例：</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span></code></pre><h3 id="indexOf-CharSequence-seq-CharSequence-searchSeq"><a href="#indexOf-CharSequence-seq-CharSequence-searchSeq" class="headerlink" title="indexOf(CharSequence seq, CharSequence searchSeq)"></a>indexOf(CharSequence seq, CharSequence searchSeq)</h3><p>同<code>indexOf(CharSequence seq, int searchChar)</code>相似。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token number">2</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">"ab"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token number">0</span></code></pre><h3 id="indexOf-final-CharSequence-seq-final-CharSequence-searchSeq-final-int-startPos"><a href="#indexOf-final-CharSequence-seq-final-CharSequence-searchSeq-final-int-startPos" class="headerlink" title="indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos)"></a>indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos)</h3><p>同<code>indexOf(CharSequence seq, int searchChar)</code>相似。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token number">2</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token number">5</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"aabaabaa"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token number">2</span>StringUtils<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token number">3</span></code></pre><h3 id="indexOfIgnoreCase-CharSequence-str-CharSequence-searchStr"><a href="#indexOfIgnoreCase-CharSequence-str-CharSequence-searchStr" class="headerlink" title="indexOfIgnoreCase(CharSequence str, CharSequence searchStr)"></a>indexOfIgnoreCase(CharSequence str, CharSequence searchStr)</h3><p>同<code>indexOf(CharSequence seq, int searchChar)</code>相似,忽略大小写。</p><h3 id="lastIndexOf-CharSequence-seq-int-searchChar"><a href="#lastIndexOf-CharSequence-seq-int-searchChar" class="headerlink" title="lastIndexOf(CharSequence seq, int searchChar)"></a>lastIndexOf(CharSequence seq, int searchChar)</h3><p>同<code>indexOf(CharSequence seq, int searchChar)</code>相似，从后面开始查找。</p><h3 id="contains-CharSequence-seq-CharSequence-searchSeq"><a href="#contains-CharSequence-seq-CharSequence-searchSeq" class="headerlink" title="contains(CharSequence seq, CharSequence searchSeq)"></a>contains(CharSequence seq, CharSequence searchSeq)</h3><p>判断某字符串是否包含某子字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="containsIgnoreCase-CharSequence-str-CharSequence-searchStr"><a href="#containsIgnoreCase-CharSequence-str-CharSequence-searchStr" class="headerlink" title="containsIgnoreCase(CharSequence str, CharSequence searchStr)"></a>containsIgnoreCase(CharSequence str, CharSequence searchStr)</h3><p>同<code>contains(CharSequence seq, CharSequence searchSeq)</code>相似，忽略大小写。</p><h3 id="containsWhitespace-final-CharSequence-seq"><a href="#containsWhitespace-final-CharSequence-seq" class="headerlink" title="containsWhitespace(final CharSequence seq)"></a>containsWhitespace(final CharSequence seq)</h3><p>是<code>contains(CharSequence seq, CharSequence searchSeq)</code>的特殊情形，判断是否包含空白字符。</p><h3 id="containsAny-CharSequence-cs-CharSequence…-searchCharSequences"><a href="#containsAny-CharSequence-cs-CharSequence…-searchCharSequences" class="headerlink" title="containsAny(CharSequence cs, CharSequence… searchCharSequences)"></a>containsAny(CharSequence cs, CharSequence… searchCharSequences)</h3><p>判断某字符串是否包含其后的任意一个字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">containsAny</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">"ab"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">containsAny</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"cd"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">containsAny</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span></code></pre><h3 id="containsNone-CharSequence-cs-String-invalidChars"><a href="#containsNone-CharSequence-cs-String-invalidChars" class="headerlink" title="containsNone(CharSequence cs, String invalidChars)"></a>containsNone(CharSequence cs, String invalidChars)</h3><p>判断某字符串是否不含其后字符串的任意一个字符。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">containsNone</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">containsNone</span><span class="token punctuation">(</span><span class="token string">"abab"</span><span class="token punctuation">,</span> <span class="token string">"xyz"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">containsNone</span><span class="token punctuation">(</span><span class="token string">"ab1"</span><span class="token punctuation">,</span> <span class="token string">"xyz"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">containsNone</span><span class="token punctuation">(</span><span class="token string">"abz"</span><span class="token punctuation">,</span> <span class="token string">"xyz"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h2 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h2><h3 id="split-String-str-String-separatorChars"><a href="#split-String-str-String-separatorChars" class="headerlink" title="split(String str, String separatorChars)"></a>split(String str, String separatorChars)</h3><p>将某字符串按字符分割成数组，默认按空格分组。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"abc def"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"abc def"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"abc  def"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"ab:cd:ef"</span><span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"cd"</span><span class="token punctuation">,</span> <span class="token string">"ef"</span><span class="token punctuation">]</span></code></pre><h3 id="split-String-str-String-separatorChars-int-max"><a href="#split-String-str-String-separatorChars-int-max" class="headerlink" title="split(String str, String separatorChars, int max)"></a>split(String str, String separatorChars, int max)</h3><p>将某字符串按字符分割成最大max长度的数组，默认按空格分组。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"ab cd ef"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"cd"</span><span class="token punctuation">,</span> <span class="token string">"ef"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"ab   cd ef"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"cd"</span><span class="token punctuation">,</span> <span class="token string">"ef"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"ab:cd:ef"</span><span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"cd"</span><span class="token punctuation">,</span> <span class="token string">"ef"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"ab:cd:ef"</span><span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"cd:ef"</span><span class="token punctuation">]</span></code></pre><h3 id="splitByCharacterType-final-String-str"><a href="#splitByCharacterType-final-String-str" class="headerlink" title="splitByCharacterType(final String str)"></a>splitByCharacterType(final String str)</h3><p>按字符串类型划分字符串为数组。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">splitByCharacterType</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>         <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">splitByCharacterType</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>           <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">splitByCharacterType</span><span class="token punctuation">(</span><span class="token string">"ab de fg"</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">"de"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">"fg"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">splitByCharacterType</span><span class="token punctuation">(</span><span class="token string">"ab   de fg"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"   "</span><span class="token punctuation">,</span> <span class="token string">"de"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">"fg"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">splitByCharacterType</span><span class="token punctuation">(</span><span class="token string">"ab:cd:ef"</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> <span class="token string">"cd"</span><span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> <span class="token string">"ef"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">splitByCharacterType</span><span class="token punctuation">(</span><span class="token string">"number5"</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"number"</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">splitByCharacterType</span><span class="token punctuation">(</span><span class="token string">"fooBar"</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"ar"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">splitByCharacterType</span><span class="token punctuation">(</span><span class="token string">"foo200Bar"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"200"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"ar"</span><span class="token punctuation">]</span>StringUtils<span class="token punctuation">.</span><span class="token function">splitByCharacterType</span><span class="token punctuation">(</span><span class="token string">"ASFRules"</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"ASFR"</span><span class="token punctuation">,</span> <span class="token string">"ules"</span><span class="token punctuation">]</span></code></pre><h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h2><h3 id="join-T…-elements"><a href="#join-T…-elements" class="headerlink" title="join(T… elements)"></a>join(T… elements)</h3><p>无连接符连接字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>            <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>              <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span>null<span class="token punctuation">]</span><span class="token punctuation">)</span>          <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abc"</span>StringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span>null<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"a"</span></code></pre><h3 id="join-Object-array-String-separator"><a href="#join-Object-array-String-separator" class="headerlink" title="join(Object[] array, String separator)"></a>join(Object[] array, String separator)</h3><p>将提供的数组按连接符连成字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span>               <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span>                 <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span>null<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span>             <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">';'</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"a;b;c"</span>StringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abc"</span>StringUtils<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span>null<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">';'</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">";;a"</span></code></pre><h2 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a>删除字符串</h2><h3 id="deleteWhitespace-String-str"><a href="#deleteWhitespace-String-str" class="headerlink" title="deleteWhitespace(String str)"></a>deleteWhitespace(String str)</h3><p>删除空白字符。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">deleteWhitespace</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>         <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">deleteWhitespace</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>           <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">deleteWhitespace</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token string">"abc"</span>StringUtils<span class="token punctuation">.</span><span class="token function">deleteWhitespace</span><span class="token punctuation">(</span><span class="token string">"   ab  c  "</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abc"</span></code></pre><h3 id="removeStart-String-str-String-remove"><a href="#removeStart-String-str-String-remove" class="headerlink" title="removeStart(String str, String remove)"></a>removeStart(String str, String remove)</h3><p>删除指定字符串前缀的字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">removeStart</span><span class="token punctuation">(</span><span class="token string">"www.domain.com"</span><span class="token punctuation">,</span> <span class="token string">"www."</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"domain.com"</span>StringUtils<span class="token punctuation">.</span><span class="token function">removeStart</span><span class="token punctuation">(</span><span class="token string">"domain.com"</span><span class="token punctuation">,</span> <span class="token string">"www."</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token string">"domain.com"</span>StringUtils<span class="token punctuation">.</span><span class="token function">removeStart</span><span class="token punctuation">(</span><span class="token string">"www.domain.com"</span><span class="token punctuation">,</span> <span class="token string">"domain"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"www.domain.com"</span>StringUtils<span class="token punctuation">.</span><span class="token function">removeStart</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token string">"abc"</span></code></pre><h3 id="removeStartIgnoreCase-String-str-String-remove"><a href="#removeStartIgnoreCase-String-str-String-remove" class="headerlink" title="removeStartIgnoreCase(String str, String remove)"></a>removeStartIgnoreCase(String str, String remove)</h3><p>同<code>removeStart(String str, String remove)</code>相似，忽略大小写。</p><h3 id="removeEnd-String-str-String-remove"><a href="#removeEnd-String-str-String-remove" class="headerlink" title="removeEnd(String str, String remove)"></a>removeEnd(String str, String remove)</h3><p>同<code>removeStart(String str, String remove)</code>相反。</p><h3 id="removeEndIgnoreCase-String-str-String-remove"><a href="#removeEndIgnoreCase-String-str-String-remove" class="headerlink" title="removeEndIgnoreCase(String str, String remove)"></a>removeEndIgnoreCase(String str, String remove)</h3><p>同<code>removeEnd(String str, String remove)</code>相似，忽略大小写。</p><h3 id="remove-String-str-String-remove"><a href="#remove-String-str-String-remove" class="headerlink" title="remove(String str, String remove)"></a>remove(String str, String remove)</h3><p>移除字符串中指定的字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"queued"</span><span class="token punctuation">,</span> <span class="token string">"ue"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"qd"</span>StringUtils<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"queued"</span><span class="token punctuation">,</span> <span class="token string">"zz"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"queued"</span></code></pre><h3 id="removeIgnoreCase-String-str-String-remove"><a href="#removeIgnoreCase-String-str-String-remove" class="headerlink" title="removeIgnoreCase(String str, String remove)"></a>removeIgnoreCase(String str, String remove)</h3><p>同<code>remove(String str, String remove)</code>相似，忽略大小写。</p><h2 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h2><h3 id="replace-String-text-String-searchString-String-replacement"><a href="#replace-String-text-String-searchString-String-replacement" class="headerlink" title="replace(String text, String searchString, String replacement)"></a>replace(String text, String searchString, String replacement)</h3><p>替换某字符串为另一个字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"aba"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token string">"b"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"zbz"</span></code></pre><h3 id="replaceIgnoreCase-String-text-String-searchString-String-replacement"><a href="#replaceIgnoreCase-String-text-String-searchString-String-replacement" class="headerlink" title="replaceIgnoreCase(String text, String searchString, String replacement)"></a>replaceIgnoreCase(String text, String searchString, String replacement)</h3><p>同<code>replace(String text, String searchString, String replacement)</code>相似，忽略大小写。</p><h3 id="replace-String-text-String-searchString-String-replacement-int-max"><a href="#replace-String-text-String-searchString-String-replacement-int-max" class="headerlink" title="replace(String text, String searchString, String replacement, int max)"></a>replace(String text, String searchString, String replacement, int max)</h3><p>替换某字符串为另一个字符串,从左到右替换最大max次。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"abaa"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abaa"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"abaa"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"b"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"abaa"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"abaa"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"abaa"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"zbaa"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"abaa"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"zbza"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"abaa"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"zbzz"</span></code></pre><h3 id="replaceEach-String-text-String-searchList-String-replacementList"><a href="#replaceEach-String-text-String-searchList-String-replacementList" class="headerlink" title="replaceEach(String text, String[] searchList, String[] replacementList)"></a>replaceEach(String text, String[] searchList, String[] replacementList)</h3><p>替换某些字符串为另一些字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">replaceEach</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"aba"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replaceEach</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"aba"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replaceEach</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"aba"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replaceEach</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"aba"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replaceEach</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"b"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replaceEach</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>null<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"aba"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replaceEach</span><span class="token punctuation">(</span><span class="token string">"abcde"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token string">"t"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"wcte"</span>StringUtils<span class="token punctuation">.</span><span class="token function">replaceEach</span><span class="token punctuation">(</span><span class="token string">"abcde"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"t"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"dcte"</span></code></pre><h2 id="填充字符串"><a href="#填充字符串" class="headerlink" title="填充字符串"></a>填充字符串</h2><h3 id="repeat-final-String-str-final-int-repeat"><a href="#repeat-final-String-str-final-int-repeat" class="headerlink" title="repeat(final String str, final int repeat)"></a>repeat(final String str, final int repeat)</h3><p>生成重复的字符串，repeat代表生成次数。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"aaa"</span>StringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abab"</span>StringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">""</span></code></pre><h3 id="repeat-String-str-String-separator-int-repeat"><a href="#repeat-String-str-String-separator-int-repeat" class="headerlink" title="repeat(String str, String separator, int repeat)"></a>repeat(String str, String separator, int repeat)</h3><p>生成重复的字符串，repeat代表生成次数。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token string">"xxx"</span>StringUtils<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">"?"</span><span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"?, ?, ?"</span></code></pre><h2 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a>字符串计数</h2><h3 id="countMatches-CharSequence-str-CharSequence-sub"><a href="#countMatches-CharSequence-str-CharSequence-sub" class="headerlink" title="countMatches(CharSequence str, CharSequence sub)"></a>countMatches(CharSequence str, CharSequence sub)</h3><p>计算某字符串在字符串中的出现次数。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">countMatches</span><span class="token punctuation">(</span><span class="token string">"abba"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">countMatches</span><span class="token punctuation">(</span><span class="token string">"abba"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token number">0</span>StringUtils<span class="token punctuation">.</span><span class="token function">countMatches</span><span class="token punctuation">(</span><span class="token string">"abba"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token number">2</span>StringUtils<span class="token punctuation">.</span><span class="token function">countMatches</span><span class="token punctuation">(</span><span class="token string">"abba"</span><span class="token punctuation">,</span> <span class="token string">"ab"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token number">1</span>StringUtils<span class="token punctuation">.</span><span class="token function">countMatches</span><span class="token punctuation">(</span><span class="token string">"abba"</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span></code></pre><h2 id="字符测试"><a href="#字符测试" class="headerlink" title="字符测试"></a>字符测试</h2><h3 id="isAlpha-CharSequence-cs"><a href="#isAlpha-CharSequence-cs" class="headerlink" title="isAlpha(CharSequence cs)"></a>isAlpha(CharSequence cs)</h3><p>判断字符串是否是Unicode字母。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">isAlpha</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlpha</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlpha</span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlpha</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlpha</span><span class="token punctuation">(</span><span class="token string">"ab2c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlpha</span><span class="token punctuation">(</span><span class="token string">"ab-c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="isAlphaSpace-CharSequence-cs"><a href="#isAlphaSpace-CharSequence-cs" class="headerlink" title="isAlphaSpace(CharSequence cs)"></a>isAlphaSpace(CharSequence cs)</h3><p>同<code>isAlpha(CharSequence cs)</code>相似。判断字符串是否是Unicode字母或空格。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">isAlphaSpace</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlphaSpace</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlphaSpace</span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlphaSpace</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlphaSpace</span><span class="token punctuation">(</span><span class="token string">"ab c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlphaSpace</span><span class="token punctuation">(</span><span class="token string">"ab2c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAlphaSpace</span><span class="token punctuation">(</span><span class="token string">"ab-c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="isAlphanumeric-CharSequence-cs"><a href="#isAlphanumeric-CharSequence-cs" class="headerlink" title="isAlphanumeric(CharSequence cs)"></a>isAlphanumeric(CharSequence cs)</h3><p>同<code>isAlpha(CharSequence cs)</code>相似。判断字符串是否是Unicode字母或数字。</p><h3 id="isAlphanumericSpace-CharSequence-cs"><a href="#isAlphanumericSpace-CharSequence-cs" class="headerlink" title="isAlphanumericSpace(CharSequence cs)"></a>isAlphanumericSpace(CharSequence cs)</h3><p>同<code>isAlpha(CharSequence cs)</code>相似。判断字符串是否是Unicode字母、空格或数字。</p><h3 id="isNumeric-CharSequence-cs"><a href="#isNumeric-CharSequence-cs" class="headerlink" title="isNumeric(CharSequence cs)"></a>isNumeric(CharSequence cs)</h3><p>判断字符串是否是数字。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">isNumeric</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNumeric</span><span class="token punctuation">(</span><span class="token string">"12 3"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNumeric</span><span class="token punctuation">(</span><span class="token string">"ab2c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNumeric</span><span class="token punctuation">(</span><span class="token string">"12-3"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNumeric</span><span class="token punctuation">(</span><span class="token string">"12.3"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNumeric</span><span class="token punctuation">(</span><span class="token string">"-123"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNumeric</span><span class="token punctuation">(</span><span class="token string">"+123"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="isNumericSpace-CharSequence-cs"><a href="#isNumericSpace-CharSequence-cs" class="headerlink" title="isNumericSpace(CharSequence cs)"></a>isNumericSpace(CharSequence cs)</h3><p>同<code>isNumeric(CharSequence cs)</code>相似。判断字符串是否是空格或数字。</p><h3 id="getDigits-String-str"><a href="#getDigits-String-str" class="headerlink" title="getDigits(String str)"></a>getDigits(String str)</h3><p>从字符串中提取出数字为字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">getDigits</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>  <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">getDigits</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">getDigits</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">getDigits</span><span class="token punctuation">(</span><span class="token string">"1000$"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"1000"</span>StringUtils<span class="token punctuation">.</span><span class="token function">getDigits</span><span class="token punctuation">(</span><span class="token string">"1123~45"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"12345"</span>StringUtils<span class="token punctuation">.</span><span class="token function">getDigits</span><span class="token punctuation">(</span><span class="token string">"(541) 754-3010"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"5417543010"</span></code></pre><h3 id="isWhitespace-CharSequence-cs"><a href="#isWhitespace-CharSequence-cs" class="headerlink" title="isWhitespace(CharSequence cs)"></a>isWhitespace(CharSequence cs)</h3><p>判断是否是空格。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">isWhitespace</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isWhitespace</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isWhitespace</span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isWhitespace</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isWhitespace</span><span class="token punctuation">(</span><span class="token string">"ab2c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isWhitespace</span><span class="token punctuation">(</span><span class="token string">"ab-c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="isAllLowerCase-CharSequence-cs"><a href="#isAllLowerCase-CharSequence-cs" class="headerlink" title="isAllLowerCase(CharSequence cs)"></a>isAllLowerCase(CharSequence cs)</h3><p>判断字符串是否都是小写。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">isAllLowerCase</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllLowerCase</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllLowerCase</span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllLowerCase</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllLowerCase</span><span class="token punctuation">(</span><span class="token string">"abC"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllLowerCase</span><span class="token punctuation">(</span><span class="token string">"ab c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllLowerCase</span><span class="token punctuation">(</span><span class="token string">"ab1c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">isAllLowerCase</span><span class="token punctuation">(</span><span class="token string">"ab/c"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="isAllUpperCase-CharSequence-cs"><a href="#isAllUpperCase-CharSequence-cs" class="headerlink" title="isAllUpperCase(CharSequence cs)"></a>isAllUpperCase(CharSequence cs)</h3><p>同<code>isAllLowerCase</code>相反。判断字符串是否都是大写。</p><h3 id="isMixedCase-CharSequence-cs"><a href="#isMixedCase-CharSequence-cs" class="headerlink" title="isMixedCase(CharSequence cs)"></a>isMixedCase(CharSequence cs)</h3><p>同<code>isAllLowerCase</code>相似。判断字符串是否大小写都有。</p><h2 id="默认字符串"><a href="#默认字符串" class="headerlink" title="默认字符串"></a>默认字符串</h2><h3 id="defaultString-String-str"><a href="#defaultString-String-str" class="headerlink" title="defaultString(String str)"></a>defaultString(String str)</h3><p>得到默认字符串，默认空字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">defaultString</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">defaultString</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">defaultString</span><span class="token punctuation">(</span><span class="token string">"bat"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"bat"</span></code></pre><h3 id="defaultString-String-str-String-defaultStr"><a href="#defaultString-String-str-String-defaultStr" class="headerlink" title="defaultString(String str, String defaultStr)"></a>defaultString(String str, String defaultStr)</h3><p>如果是null，则得到默认字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">defaultString</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"NULL"</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"NULL"</span>StringUtils<span class="token punctuation">.</span><span class="token function">defaultString</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"NULL"</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">defaultString</span><span class="token punctuation">(</span><span class="token string">"bat"</span><span class="token punctuation">,</span> <span class="token string">"NULL"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"bat"</span></code></pre><h3 id="defaultIfEmpty-T-str-T-defaultStr"><a href="#defaultIfEmpty-T-str-T-defaultStr" class="headerlink" title="defaultIfEmpty(T str, T defaultStr)"></a>defaultIfEmpty(T str, T defaultStr)</h3><p>同<code>defaultString(String str, String defaultStr)</code>相似。如果是空字符串，则得到默认字符串。</p><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><h3 id="reverse-final-String-str"><a href="#reverse-final-String-str" class="headerlink" title="reverse(final String str)"></a>reverse(final String str)</h3><p>反转字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span>  <span class="token operator">=</span> nullStringUtils<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">"bat"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"tab"</span></code></pre><h2 id="缩写字符串"><a href="#缩写字符串" class="headerlink" title="缩写字符串"></a>缩写字符串</h2><h3 id="abbreviate-String-str-int-maxWidth"><a href="#abbreviate-String-str-int-maxWidth" class="headerlink" title="abbreviate(String str, int maxWidth)"></a>abbreviate(String str, int maxWidth)</h3><p>缩写字符串为最大maxWidth长度的字符串，使用<code>...</code>作为缩写的后缀，maxWidth不能小于等于3。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abc..."</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abcdefg"</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"abcdefg"</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"a..."</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> IllegalArgumentException</code></pre><h3 id="abbreviate-String-str-String-abbrevMarker-int-maxWidth"><a href="#abbreviate-String-str-String-abbrevMarker-int-maxWidth" class="headerlink" title="abbreviate(String str, String abbrevMarker, int maxWidth)"></a>abbreviate(String str, String abbrevMarker, int maxWidth)</h3><p>缩写字符串为最大maxWidth长度的字符串，使用<code>abbrevMarker</code>作为缩写的后缀，maxWidth不能小于等于<code>abbrevMarker</code>的长度。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"..."</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token operator">=</span> <span class="token string">""</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"abcd."</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"abcdefg"</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token string">"abcdefg"</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"ab.."</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">"a.."</span>StringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token operator">=</span> IllegalArgumentExceptionStringUtils<span class="token punctuation">.</span><span class="token function">abbreviate</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token string">"..."</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> IllegalArgumentException</code></pre><h2 id="字符串钱后缀"><a href="#字符串钱后缀" class="headerlink" title="字符串钱后缀"></a>字符串钱后缀</h2><h3 id="startsWith-CharSequence-str-CharSequence-prefix"><a href="#startsWith-CharSequence-str-CharSequence-prefix" class="headerlink" title="startsWith(CharSequence str, CharSequence prefix)"></a>startsWith(CharSequence str, CharSequence prefix)</h3><p>判断某字符串是否包含有指定前缀的字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"abcdef"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"abcdef"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"ABCDEF"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="startsWithIgnoreCase-CharSequence-str-CharSequence-prefix"><a href="#startsWithIgnoreCase-CharSequence-str-CharSequence-prefix" class="headerlink" title="startsWithIgnoreCase(CharSequence str, CharSequence prefix)"></a>startsWithIgnoreCase(CharSequence str, CharSequence prefix)</h3><p>同<code>startsWith(CharSequence str, CharSequence prefix)</code>相似。忽略大小写。</p><h3 id="startsWithAny-CharSequence-sequence-CharSequence…-searchStrings"><a href="#startsWithAny-CharSequence-sequence-CharSequence…-searchStrings" class="headerlink" title="startsWithAny(CharSequence sequence, CharSequence… searchStrings)"></a>startsWithAny(CharSequence sequence, CharSequence… searchStrings)</h3><p>判断某字符串是否包含有其后任意一个指定前缀的字符串。</p><pre class=" language-java"><code class="language-java">StringUtils<span class="token punctuation">.</span><span class="token function">startsWithAny</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWithAny</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"abc"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWithAny</span><span class="token punctuation">(</span><span class="token string">"abcxyz"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>     <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWithAny</span><span class="token punctuation">(</span><span class="token string">"abcxyz"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWithAny</span><span class="token punctuation">(</span><span class="token string">"abcxyz"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"abc"</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWithAny</span><span class="token punctuation">(</span><span class="token string">"abcxyz"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>null<span class="token punctuation">,</span> <span class="token string">"xyz"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWithAny</span><span class="token punctuation">(</span><span class="token string">"abcxyz"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token string">"xyz"</span><span class="token punctuation">,</span> <span class="token string">"ABCX"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWithAny</span><span class="token punctuation">(</span><span class="token string">"ABCXYZ"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token string">"xyz"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><h3 id="endsWith-CharSequence-str-CharSequence-suffix"><a href="#endsWith-CharSequence-str-CharSequence-suffix" class="headerlink" title="endsWith(CharSequence str, CharSequence suffix)"></a>endsWith(CharSequence str, CharSequence suffix)</h3><p>同<code>startsWith(CharSequence str, CharSequence prefix)</code>相反。</p><h3 id="endsWithIgnoreCase-CharSequence-str-CharSequence-suffix"><a href="#endsWithIgnoreCase-CharSequence-str-CharSequence-suffix" class="headerlink" title="endsWithIgnoreCase(CharSequence str, CharSequence suffix)"></a>endsWithIgnoreCase(CharSequence str, CharSequence suffix)</h3><p>同<code>startsWithIgnoreCase(CharSequence str, CharSequence prefix)</code>相反。</p><h3 id="endsWithAny-CharSequence-sequence-CharSequence…-searchStrings"><a href="#endsWithAny-CharSequence-sequence-CharSequence…-searchStrings" class="headerlink" title="endsWithAny(CharSequence sequence, CharSequence… searchStrings)"></a>endsWithAny(CharSequence sequence, CharSequence… searchStrings)</h3><p>同<code>startsWithAny(CharSequence sequence, CharSequence... searchStrings)</code>相反。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL基础知识整理</title>
      <link href="/2018/09/25/shu-ju-ku/postgresql-ji-chu-zhi-shi-zheng-li/"/>
      <url>/2018/09/25/shu-ju-ku/postgresql-ji-chu-zhi-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库操作DML"><a href="#数据库操作DML" class="headerlink" title="数据库操作DML"></a>数据库操作DML</h2><h3 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h3><p><code>CREATE TABLE</code>语句用于创建数据库中的表。语法是：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名称 <span class="token punctuation">(</span>列名<span class="token number">1</span> 数据类型<span class="token punctuation">,</span>列名<span class="token number">2</span> 数据类型<span class="token punctuation">,</span>列名<span class="token number">3</span> 数据类型<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id <span class="token keyword">integer</span><span class="token punctuation">,</span>user_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>email <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>age <span class="token keyword">integer</span><span class="token punctuation">,</span>address <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>注意</strong>：字段类型<code>char</code>和<code>varchar</code>区别：</p><ul><li>容纳固定长度的字符串。</li><li>容纳可变长度的字符串。</li></ul><h3 id="CONSTRAINT"><a href="#CONSTRAINT" class="headerlink" title="CONSTRAINT"></a>CONSTRAINT</h3><p>约束、限制，常见的约束如下：</p><ul><li><code>CHECK</code>(检查约束)</li><li><code>NOT NULL</code>(非空约束)</li><li><code>UNIQUE</code>(唯一约束)</li><li><code>Primary Key</code>(主键)</li><li><code>Foreign Key</code>(外键)</li></ul><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 各种约束的使用示例</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>    id <span class="token keyword">integer</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    corp_id <span class="token keyword">integer</span> <span class="token keyword">REFERENCES</span> corp <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>    user_name <span class="token keyword">text</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>    age <span class="token keyword">numeric</span> <span class="token keyword">CHECK</span> <span class="token punctuation">(</span>age <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h3><p><code>ALTER TABLE</code>用来添加，删除或修改现有表中的列，也可以用来添加和删除现有表上的各种制约因素。语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 现有表中添加一个新的列</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span> <span class="token keyword">ADD</span> <span class="token keyword">column</span> datatype<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 现有表中删除一个新的列</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span> <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> <span class="token keyword">column</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 现有表中更改数据类型的列</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span> <span class="token keyword">MODIFY</span> <span class="token keyword">COLUMN</span> <span class="token keyword">column</span> datatype<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 现有表中一列添加NOT NULL约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span> <span class="token keyword">MODIFY</span> <span class="token keyword">column</span> datatype <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 现有表中添加唯一约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span> <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> MyUniqueConstraint <span class="token keyword">UNIQUE</span><span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 现有表中添加CHECK约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span> <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> MyUniqueConstraint <span class="token keyword">CHECK</span> <span class="token punctuation">(</span>CONDITION<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 现有表中添加PRIMARY KEY约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span> <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> MyPrimaryKey <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 现有表中删除约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span> <span class="token keyword">DROP</span> <span class="token keyword">CONSTRAINT</span> MyUniqueConstraint<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 现有表中删除主键</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span> <span class="token keyword">DROP</span> <span class="token keyword">CONSTRAINT</span> MyPrimaryKey<span class="token punctuation">;</span></code></pre><h3 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a>DROP TABLE</h3><p><code>DROP TABLE</code>语句是用来删除表定义及其所有相关的数据表的索引，规则，触发器和约束。语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><h3 id="TRUNCATE-TABLE"><a href="#TRUNCATE-TABLE" class="headerlink" title="TRUNCATE TABLE"></a>TRUNCATE TABLE</h3><p><code>TRUNCATE TABLE</code>命令用于从现有的表删除完整的数据。在每个表上的DELETE（删除）具有相同的效果，但是，因为它没有实际扫描的表，它的速度快。语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span>  <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><h3 id="DELETE-FROM"><a href="#DELETE-FROM" class="headerlink" title="DELETE FROM"></a>DELETE FROM</h3><p><code>DELETE FROM</code>用来从一个表中删除现有的记录。可以使用WHERE子句DELETE查询删除所选行，否则所有的记录会被删除。语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> <span class="token punctuation">[</span>condition<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h3><p><code>INSERT INTO</code>语句允许一个到一个表中插入新行。一个可以作为一个查询的结果，在一个时间或几行插入一行。基本语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">table</span> <span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> column3<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>columnN<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">,</span> value3<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>valueN<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注</strong>：<br>1.这里 column1, column2,…columnN是要插入数据的表中的列名。</p><ol start="2"><li>可以以任何顺序列出目标列名。 VALUES子句或查询的值都与显式或隐式的列列表从左到右。</li></ol></blockquote><p>如果要添加表中的所有列的值，可能不需要在SQL查询中指定列（次）名称。但要确保表中是在相同的顺序的列值的顺序。INSERT INTO语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">table</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span>value2<span class="token punctuation">,</span>value3<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>valueN<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p><code>UPDATE</code>被用来修改现有的表中的记录。可以使用<code>UPDATE</code>查询的<code>WHERE</code>子句更新选定行，否则会被更新的所有行。基本语法如下：</p><pre><code>UPDATE table SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition];</code></pre><h2 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>找出表内的不同值的情况。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> id<span class="token punctuation">,</span> email <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span></code></pre><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> <span class="token punctuation">[</span>condition<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="AND-OR"><a href="#AND-OR" class="headerlink" title="AND / OR"></a>AND / OR</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> <span class="token punctuation">[</span>condition1<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">AND</span><span class="token operator">|</span><span class="token operator">OR</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>condition2<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="IN-NOT-IN"><a href="#IN-NOT-IN" class="headerlink" title="IN / NOT IN"></a>IN / NOT IN</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> <span class="token keyword">column</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'value1'</span><span class="token punctuation">,</span> <span class="token string">'value2'</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> user_name <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'张三'</span><span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="BETWEEN-…-AND-…"><a href="#BETWEEN-…-AND-…" class="headerlink" title="BETWEEN … AND …"></a>BETWEEN … AND …</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> <span class="token keyword">column</span> <span class="token operator">BETWEEN</span> <span class="token string">'value1'</span> <span class="token operator">AND</span> <span class="token string">'value2'</span><span class="token punctuation">;</span></code></pre><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> age <span class="token operator">BETWEEN</span> <span class="token number">18</span> <span class="token operator">AND</span> <span class="token number">25</span><span class="token punctuation">;</span></code></pre><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> <span class="token keyword">column</span> <span class="token operator">LIKE</span> {模式}<span class="token punctuation">;</span></code></pre><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> user_name <span class="token operator">LIKE</span> <span class="token string">'%张%'</span><span class="token punctuation">;</span></code></pre><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">[</span><span class="token keyword">WHERE</span> condition<span class="token punctuation">]</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">column</span> <span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token punctuation">,</span> <span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注</strong>：ASC（默认）代表结果会以由小往大的顺序列出，而DESC代表结果会以由大往小的顺序列出。</p></blockquote><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> user_name<span class="token punctuation">,</span> email<span class="token punctuation">,</span> age <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> age <span class="token keyword">DESC</span><span class="token punctuation">;</span></code></pre><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>column2<span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> column1<span class="token punctuation">;</span></code></pre><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> user_name<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> user_name<span class="token punctuation">;</span></code></pre><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><p>对函数产生的值来设定条件。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>column2<span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> column1 <span class="token keyword">HAVING</span> <span class="token punctuation">[</span>condition<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> user_name<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>ages<span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> user_name <span class="token keyword">HAVING</span> <span class="token function">SUM</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1500</span><span class="token punctuation">;</span></code></pre><h3 id="ALIAS"><a href="#ALIAS" class="headerlink" title="ALIAS"></a>ALIAS</h3><blockquote><p>SELECT ‘表别名’.’列名’ AS ‘列别名’ FROM table AS ‘表别名’;</p></blockquote><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> u<span class="token punctuation">.</span>user_name <span class="token keyword">AS</span> name<span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> ages <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">AS</span> u <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> u<span class="token punctuation">.</span>store_name<span class="token punctuation">;</span></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><code>AVG</code> (平均)</li><li><code>COUNT</code> (计数)</li><li><code>MAX</code> (最大值)</li><li><code>MIN</code> (最小值)</li><li><code>SUM</code> (总合)</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> fun_name<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">count</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token keyword">AS</span> user_count <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">AS</span> u<span class="token punctuation">;</span></code></pre><h3 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h3><p>INNER JOIN: 如果表中有至少一个匹配，则返回行；<br>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行；<br>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行；<br>FULL JOIN: 只要其中一个表中存在匹配，就返回行。</p><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> u<span class="token punctuation">.</span>uesr_name<span class="token punctuation">,</span> <span class="token number">c</span><span class="token punctuation">.</span>corp_name <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">AS</span> u <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> corp <span class="token keyword">AS</span> <span class="token number">c</span> <span class="token keyword">ON</span> <span class="token number">c</span><span class="token punctuation">.</span>id <span class="token operator">=</span> u<span class="token punctuation">.</span>corp_id<span class="token punctuation">;</span></code></pre><h2 id="SQL进阶"><a href="#SQL进阶" class="headerlink" title="SQL进阶"></a>SQL进阶</h2><h3 id="UNION-UNION-ALL"><a href="#UNION-UNION-ALL" class="headerlink" title="UNION / UNION ALL"></a>UNION / UNION ALL</h3><p><code>UNION</code>用于合并两个或多个SELECT语句的结果，不返回任何重复的行。<code>UNION ALL</code>运算符语句，则包括重复行的结果。使用UNION，每个SELECT选择的列数必须具有相同的，相同数目的列表达式相同的数据类型，并让它们在相同的顺序，但它们不必是相同的长度。语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1 <span class="token punctuation">[</span><span class="token punctuation">,</span> column2 <span class="token punctuation">]</span><span class="token keyword">FROM</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> condition<span class="token punctuation">]</span><span class="token keyword">UNION</span> <span class="token punctuation">[</span><span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token punctuation">]</span><span class="token keyword">SELECT</span> column1 <span class="token punctuation">[</span><span class="token punctuation">,</span> column2 <span class="token punctuation">]</span><span class="token keyword">FROM</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> condition<span class="token punctuation">]</span></code></pre><h3 id="INTERSECT-INTERSECT-ALL"><a href="#INTERSECT-INTERSECT-ALL" class="headerlink" title="INTERSECT / INTERSECT ALL"></a>INTERSECT / INTERSECT ALL</h3><p>和<code>UNION</code>指令类似，<code>INTERSECT</code>也是对两个SQL语句所产生的结果做处理的。不同的地方是，<code>UNION</code>基本上是一个<code>OR</code>(如果这个值存在于第一句或是第二句，它就会被选出)，而<code>INTERSECT</code>则比较像<code>AND</code>(这个值要存在于第一句和第二句才会被选出)。<code>UNION</code>是并集，而<code>INTERSECT</code>是交集。<code>INTERSECT ALL</code>则包含交集后的重复数据。语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1 <span class="token punctuation">[</span><span class="token punctuation">,</span> column2 <span class="token punctuation">]</span><span class="token keyword">FROM</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> condition<span class="token punctuation">]</span><span class="token keyword">INTERSECT</span> <span class="token punctuation">[</span><span class="token keyword">INTERSECT</span> <span class="token keyword">ALL</span><span class="token punctuation">]</span><span class="token keyword">SELECT</span> column1 <span class="token punctuation">[</span><span class="token punctuation">,</span> column2 <span class="token punctuation">]</span><span class="token keyword">FROM</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> condition<span class="token punctuation">]</span></code></pre><h3 id="EXCEPT-EXCEPT-ALL"><a href="#EXCEPT-EXCEPT-ALL" class="headerlink" title="EXCEPT / EXCEPT ALL"></a>EXCEPT / EXCEPT ALL</h3><p><code>EXCEPT</code>用于求差集，其将查询在前一个结果集中但是不再后面一个结果集中的记录。<code>EXCEPT ALL</code>则包含交集后的重复数据。语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1 <span class="token punctuation">[</span><span class="token punctuation">,</span> column2 <span class="token punctuation">]</span><span class="token keyword">FROM</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> condition<span class="token punctuation">]</span><span class="token keyword">EXCEPT</span> <span class="token punctuation">[</span><span class="token keyword">EXCEPT</span> <span class="token keyword">ALL</span><span class="token punctuation">]</span><span class="token keyword">SELECT</span> column1 <span class="token punctuation">[</span><span class="token punctuation">,</span> column2 <span class="token punctuation">]</span><span class="token keyword">FROM</span> table1 <span class="token punctuation">[</span><span class="token punctuation">,</span> table2 <span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> condition<span class="token punctuation">]</span></code></pre><blockquote><p><strong>注</strong>：在其他数据库求差集的关键字是：<code>MINUS</code>。</p></blockquote><h3 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h3><p><code>SUBQUERY</code>即子查询，子查询也是一个普通查询，目的是将用子查询返回的数据将被用来在主查询中作为条件，以进一步限制要检索的数据。可以使用子查询的有SELECT，INSERT，UPDATE和DELETE语句，与运算符如=，&lt;，&gt;，&gt;=，&lt;=，IN等一起使用。有几个子查询必须遵循的规则：</p><ul><li>必须用括号括起来的子查询。</li><li>子查询只能有一个在SELECT子句中的列，除非多列在主查询的查询来比较其选定的列。</li><li>ORDER BY不能使用在子查询中，虽然主查询就可以使用ORDER BY。GROUP BY可以用来执行相同的功能在子查询中的ORDER BY。</li><li>子查询返回多于一行只能用于使用多值的运算符，如为IN，EXISTS，IN，ANY / SOME，ALL运算符。</li></ul><p>使用示例如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- SELECT语句中的子查询</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> COMPANY <span class="token keyword">WHERE</span> ID <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> COMPANY <span class="token keyword">WHERE</span> SALARY <span class="token operator">></span> <span class="token number">45000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- INSERT语句的子查询</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> COMPANY_BKP <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> COMPANY <span class="token keyword">WHERE</span> ID <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> COMPANY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- UPDATE语句的子查询</span><span class="token keyword">UPDATE</span> COMPANY <span class="token keyword">SET</span> SALARY <span class="token operator">=</span> SALARY <span class="token operator">*</span> <span class="token number">0.50</span> <span class="token keyword">WHERE</span> AGE <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> AGE <span class="token keyword">FROM</span> COMPANY_BKP <span class="token keyword">WHERE</span> AGE <span class="token operator">>=</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- UPDATE语句的子查询</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> COMPANY <span class="token keyword">WHERE</span> AGE <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> AGE <span class="token keyword">FROM</span> COMPANY_BKP <span class="token keyword">WHERE</span> AGE <span class="token operator">></span> <span class="token number">27</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="EXISTS-NOT-EXISTS"><a href="#EXISTS-NOT-EXISTS" class="headerlink" title="EXISTS / NOT EXISTS"></a>EXISTS / NOT EXISTS</h3><p><code>EXISTS</code>用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False。EXISTS指定一个子查询，检测行的存在。<code>NOT EXISTS</code>的作用与<code>EXISTS</code>正好相反。如果子查询没有返回行，则满足了<code>NOT EXISTS</code>中的<code>WHERE</code>子句。语法如下： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXISTS</span> subquery</code></pre><p>EXISTS 和 IN 的比较：</p><ul><li>EXISTS(包括 NOT EXISTS )子句的返回值是一个BOOLEAN值。EXISTS内部有一个子查询语句(SELECT … FROM…)，我将其称为EXIST的内查询语句。其内查询语句返回一个结果集。EXISTS子句根据其内查询语句的结果集空或者非空，返回一个布尔值。而IN引导的子查询只能返回一个字段</li><li>EXISTS : 强调的是是否返回结果集，不要求知道返回什么，IN则需要知道返回的字段值。</li><li>EXISTS与IN的使用效率的问题，通常情况下采用exists要比in效率高，因为IN不走索引，但要看实际情况具体使用：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</li></ul><h3 id="CONCATENATE"><a href="#CONCATENATE" class="headerlink" title="CONCATENATE"></a>CONCATENATE</h3><p>连接字符串。有的时候，我们有需要将由不同列获得的资料串连在一起。每一种数据库都有提供方法来达到这个目的。</p><ul><li>Oracle: CONCAT(), || </li><li>SQL Server: + </li><li>MySQL: CONCAT() </li><li>PostgreSQL: CONCAT(), || </li></ul><p>PostgreSQL的<code>CONCAT()</code>的语法如下：</p><blockquote><p>concat(str “any” [, str “any” [, …] ])</p></blockquote><p>PostgreSQL的<code>||</code>的语法如下：</p><blockquote><p>string || string<br>string || non-string 或 non-string || string</p></blockquote><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> u<span class="token punctuation">.</span>user_name <span class="token operator">||</span> <span class="token string">' '</span> <span class="token operator">||</span> u<span class="token punctuation">.</span>age <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">AS</span> u<span class="token punctuation">;</span></code></pre><h3 id="SUBSTRING"><a href="#SUBSTRING" class="headerlink" title="SUBSTRING"></a>SUBSTRING</h3><p>截取字符串。</p><ul><li>Oracle: SUBSTR()</li><li>SQL Server: SUBSTRING()</li><li>MySQL: SUBSTR(), SUBSTRING()</li><li>PostgreSQL: SUBSTRING()</li></ul><p>PostgreSQL的SUBSTRING()语法如下：</p><ul><li>substring(string [from int] [for int]) 截取子字符串。</li><li>substring(string from pattern) 截取匹配POSIX正则表达式的子字符串。</li><li>substring(string from pattern for escape) 截取匹配SQL正则表达式的子字符串。</li></ul><p>例：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 得到hom</span>substring<span class="token punctuation">(</span><span class="token string">'Thomas'</span> <span class="token keyword">from</span> <span class="token number">2</span> <span class="token keyword">for</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 得到mas</span>substring<span class="token punctuation">(</span><span class="token string">'Thomas'</span> <span class="token keyword">from</span> <span class="token string">'...$'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 得到oma</span>substring<span class="token punctuation">(</span><span class="token string">'Thomas'</span> <span class="token keyword">from</span> '<span class="token operator">%</span><span class="token comment" spellcheck="true">#"o_a#"_' for '#')</span></code></pre><h3 id="TRIM"><a href="#TRIM" class="headerlink" title="TRIM"></a>TRIM</h3><p>SQL中的<code>TRIM</code>函数是用来移除掉一个字符串中的字头或字尾。最常见的用途是移除字首或字尾的空白。这个函数在不同的数据库中有不同的名称： </p><ul><li>Oracle: LTRIM(), RTRIM()</li><li>SQL Server: LTRIM(), RTRIM()</li><li>MySQL: TRIM(), LTRIM(), RTRIM()</li><li>PostgreSQL: TRIM(), BTRIM(), LTRIM(), RTRIM()</li></ul><p>PostgreSQL的TRIM()语法如下：</p><ul><li>trim([leading | trailing | both] [characters] from string) 从字符串string的开头/结尾/两边删除只包含characters中字符(缺省是空白)的最长的字符串。</li><li>btrim(string text [, characters text]) 从string开头和结尾删除只包含 characters中字符(缺省是空白)的最长字符串。</li><li>ltrim(string text [, characters text]) 从字符串string的开头删除只包含characters 中字符(缺省是一个空白)的最长的字符串。</li><li>rtrim(string text [, characters text]) 从字符串string的结尾删除只包含characters中字符(缺省是个空白)的最长的字符串。</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 得到Tom</span>trim<span class="token punctuation">(</span>both <span class="token string">'x'</span> <span class="token keyword">from</span> <span class="token string">'xTomxx'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 得到trim</span>btrim<span class="token punctuation">(</span><span class="token string">'xyxtrimyyx'</span><span class="token punctuation">,</span> <span class="token string">'xy'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 得到trim</span>ltrim<span class="token punctuation">(</span><span class="token string">'zzzytrim'</span><span class="token punctuation">,</span> <span class="token string">'xyz'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 得到trim</span>rtrim<span class="token punctuation">(</span><span class="token string">'trimxxxx'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span></code></pre><h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><p><code>CASE</code>表达式是一种通用的条件表达式，类似于其它编程语言中的<code>if/else</code>语句。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> <span class="token punctuation">[</span>condition<span class="token punctuation">]</span> <span class="token keyword">THEN</span> result     <span class="token punctuation">[</span><span class="token keyword">WHEN</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>     <span class="token punctuation">[</span><span class="token keyword">ELSE</span> result<span class="token punctuation">]</span><span class="token keyword">END</span></code></pre><p>示例如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> sex<span class="token punctuation">,</span>     <span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> sex <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">THEN</span> <span class="token string">'女'</span>          <span class="token keyword">WHEN</span> sex <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">THEN</span> <span class="token string">'男'</span>          <span class="token keyword">ELSE</span> <span class="token string">'未知'</span>     <span class="token keyword">END</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span></code></pre><h3 id="COALESCE"><a href="#COALESCE" class="headerlink" title="COALESCE"></a>COALESCE</h3><p><code>COALESCE</code>返回它的第一个非<code>NULL</code>的参数值。如果所有参数都是NULL那么返回NULL。它常用于在显示数据时用缺省值替换NULL。语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">COALESCE</span><span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>使用示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">COALESCE</span><span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> GETDATE<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="NULLIF"><a href="#NULLIF" class="headerlink" title="NULLIF"></a>NULLIF</h3><p>当且仅当value1等于value2时，<code>NULLIF</code>才返回null。否则它返回value1。这些可以用于执行上面给出的<code>COALESCE</code>例子的反例。语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">NULLIF</span><span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">)</span></code></pre><h3 id="GREATEST-LEAST"><a href="#GREATEST-LEAST" class="headerlink" title="GREATEST / LEAST"></a>GREATEST / LEAST</h3><p>GREATEST和LEAST函数从一个任意数字表达式的列表里选取最大或者最小的数值。 这些表达式必须都可以转换成一个普通的数据类型，它将会是结果类型。列表中的NULL值将被忽略。只有所有表达式的结果都是 NULL 的时候，结果才会是 NULL。语法如下：</p><pre class=" language-sql"><code class="language-sql">GREATEST<span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span>LEAST<span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><blockquote><p><strong>注意</strong>：GREATEST和LEAST都不是 SQL 标准，但却是很常见的扩展。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git知识点整理</title>
      <link href="/2018/09/24/ruan-jian-gong-ju/git/git-zhi-shi-dian-zheng-li/"/>
      <url>/2018/09/24/ruan-jian-gong-ju/git/git-zhi-shi-dian-zheng-li/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git基本概念。"><a href="#1-Git基本概念。" class="headerlink" title="1. Git基本概念。"></a>1. Git基本概念。</h2><ul><li><code>repository</code></li><li><code>config</code></li><li><code>init</code></li><li><code>clone</code></li><li><code>fetch</code></li><li><code>pull</code></li><li><code>commit</code></li><li><code>push</code></li><li><code>branch</code></li><li><code>head</code></li><li><code>tag</code></li><li><code>merge</code></li><li><code>conflict</code></li><li><code>diff</code></li><li><code>log</code></li><li><code>show</code></li><li><code>status</code></li></ul><h2 id="2-Git工作空间和文件状态"><a href="#2-Git工作空间和文件状态" class="headerlink" title="2. Git工作空间和文件状态"></a>2. Git工作空间和文件状态</h2><h3 id="1-工作空间"><a href="#1-工作空间" class="headerlink" title="(1).工作空间"></a>(1).工作空间</h3><p><img src="http://blog.chinaunix.net/attachment/201402/19/10415985_139279770639pM.jpg" alt="Git工作空间"></p><p>左侧为工作区，右侧为版本库。</p><ul><li>工作区（<code>Working Directory</code>） 就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区。</li><li>版本库（<code>Repository</code>）工作区有一个隐藏目录<code>.git</code>，是Git的版本库。</li></ul><p>在版本库中标记为<code>index</code>的区域为暂存区，标记为<code>master</code>的是Git为我们自动创建的第一个分支，代表的是目录树。此时<code>HEAD</code>实际是指向<code>master</code>分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用<code>master</code>来替换。图中的objects标识的区域为git的对象库，实际位于<code>.git/objects</code>目录下。</p><ul><li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树会被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库（对象库）中，master分支会做相应的更新，即master最新指向的目录树就是提交时原暂存区的目录树。</li><li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，会被master分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行<code>git rm --cached</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行<code>git checkout .</code>或<code>git checkout --</code> 命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清楚工作区中未添加到暂存区的改动。</li><li>当执行<code>git checkout HEAD .</code>或<code>git checkout HEAD</code>命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极度危险的。因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。</li></ul><h3 id="1-文件状态"><a href="#1-文件状态" class="headerlink" title="(1).文件状态"></a>(1).文件状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交(<code>committed</code>)</strong>、<strong>已修改(<code>modified</code>)</strong>和<strong>已暂存(<code>staged</code>)</strong>。</p><h2 id="3-Git配置系统级、全局、当前仓库用户名、邮箱的命令"><a href="#3-Git配置系统级、全局、当前仓库用户名、邮箱的命令" class="headerlink" title="3. Git配置系统级、全局、当前仓库用户名、邮箱的命令"></a>3. Git配置系统级、全局、当前仓库用户名、邮箱的命令</h2><p>系统级、全局、当前仓库选项分别是:仓库-system、-global、-local(或默认不填)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"Jerry Mouse"</span><span class="token function">git</span> config --global user.email <span class="token string">"jerry@yiibai.com"</span></code></pre><p>列出Git设置</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --list<span class="token function">git</span> config -l</code></pre><h2 id="4-Git-fetch和pull的区别"><a href="#4-Git-fetch和pull的区别" class="headerlink" title="4. Git fetch和pull的区别"></a>4. Git fetch和pull的区别</h2><ul><li><code>git fetch</code>：相当于是从远程获取最新版本到本地，不会自动merge.</li><li><code>git pull</code>：相当于是从远程获取最新版本并merge到本地.</li></ul><h3 id="1-git-fetch示例："><a href="#1-git-fetch示例：" class="headerlink" title="(1). git fetch示例："></a>(1). git fetch示例：</h3><pre class=" language-bash"><code class="language-bash">Git fetch origin master<span class="token function">git</span> log -p master<span class="token punctuation">..</span>origin/master<span class="token function">git</span> merge origin/master</code></pre><p>以上命令的含义：</p><ul><li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li><li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li><li>最后进行合并</li><li>上述过程其实可以用以下更清晰的方式来进行：</li></ul><h3 id="1-git-pull示例："><a href="#1-git-pull示例：" class="headerlink" title="(1). git pull示例："></a>(1). git pull示例：</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master</code></pre><p>上述命令其实相当于<code>git fetch</code>和<code>git merge</code>。在实际使用中，<code>git fetch</code>更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。</p><h2 id="5-Git-reset和revert的却别"><a href="#5-Git-reset和revert的却别" class="headerlink" title="5. Git reset和revert的却别"></a>5. Git reset和revert的却别</h2><ul><li><code>git revert</code>是用一次新的commit来回滚之前的commit，<code>git reset</code>是直接删除指定的commit。 </li><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是<code>git reset</code>是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</li><li><code>git reset</code>是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li><li>git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交。</li></ul><p>另外，说一下<code>git revert</code>， <code>git reset –hard</code>和 <code>–soft</code>的区别</p><ul><li><code>git reset –mixed id</code>: 是将git的HEAD变了（也就是提交记录变了），但文件并没有改变，（也就是working tree并没有改变）。</li><li><code>git reset –soft id</code>: 实际上，是<code>git reset –mixed id</code>后，又做了一次<code>git add</code>。</li><li><code>git reset –herd id</code>: 是将git的HEAD变了，文件也变了。</li></ul><h2 id="6-Git-merge和reabse的相同点和不同点"><a href="#6-Git-merge和reabse的相同点和不同点" class="headerlink" title="6. Git merge和reabse的相同点和不同点"></a>6. Git merge和reabse的相同点和不同点</h2><p><code>merge</code>是合并的意思，<code>rebase</code>是复位基底的意思，相同点都是用来合并分支的。</p><p><img src="http://images2015.cnblogs.com/blog/759200/201608/759200-20160806092734215-279978821.png" alt="merge和rebase"></p><p>不同点:</p><ul><li><code>merge</code>操作会生成一个新的节点，之前的提交分开显示。而<code>rebase</code>操作不会生成新的节点，是将两个分支融合成一个线性的提交。</li><li>解决冲突时。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit就可以了。而<code>rebase</code>操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行<code>git rebase –continue</code>继续操作，或者<code>git rebase –skip</code>忽略冲突。</li><li><code>git pull</code>和<code>git pull --rebase</code>区别：<code>git pull</code>做了两个操作分别是”获取”和”合并”。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。</li></ul><p><strong>总结</strong>：选择 merge 还是 rebase？</p><ul><li>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容</li><li>merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面</li><li>rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面</li><li>rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面</li><li>merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定</li><li>merge 和 rebase 还有很多强大的选项，可以使用 git help <command> 查看</li></ul><h2 id="7-Git-stash是什么？它的相关使用方式命令"><a href="#7-Git-stash是什么？它的相关使用方式命令" class="headerlink" title="7. Git stash是什么？它的相关使用方式命令"></a>7. Git stash是什么？它的相关使用方式命令</h2><ul><li>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</li><li>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</li><li>git stash pop –index stash@{0}: 恢复编号为0的进度的工作区和暂存区。</li><li>git stash apply stash@{1} 以将你指定版本号为stash@{1}的工作取出来</li><li>git stash drop[<stash>] 删除某一个进度，默认删除最新进度</stash></li><li>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</li><li>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复工作进度</span><span class="token function">git</span> stash pop <span class="token punctuation">[</span>--index<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>stash<span class="token operator">></span><span class="token punctuation">]</span>--index 参数：不仅恢复工作区，还恢复暂存区<span class="token operator">&lt;</span>stash<span class="token operator">></span> 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度<span class="token comment" spellcheck="true"># 这是git stash保存进度的完整命令形式</span><span class="token function">git</span> stash <span class="token punctuation">[</span>save message<span class="token punctuation">]</span> <span class="token punctuation">[</span>-k<span class="token operator">|</span>--no-keep-index<span class="token punctuation">]</span> <span class="token punctuation">[</span>--patch<span class="token punctuation">]</span>-k和--no-keep-index指定保存进度后，是否重置暂存区--patch 会显示工作区和HEAD的差异,通过编辑差异文件，排除不需要保存的内容。和git add -p命令类似使用save可以对进度添加备注<span class="token comment" spellcheck="true"># git stash save "这是保存的进度"</span></code></pre><h2 id="8-Git只从暂存区删除，从工作空间删除的命令分别是什么"><a href="#8-Git只从暂存区删除，从工作空间删除的命令分别是什么" class="headerlink" title="8. Git只从暂存区删除，从工作空间删除的命令分别是什么?"></a>8. Git只从暂存区删除，从工作空间删除的命令分别是什么?</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> --cached<span class="token function">git</span> <span class="token function">rm</span><span class="token function">git</span> commit</code></pre><h2 id="9-Git标签的使用"><a href="#9-Git标签的使用" class="headerlink" title="9. Git标签的使用"></a>9. Git标签的使用</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出现有的标签</span><span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 打标签</span><span class="token function">git</span> tag -a v1.01 -m <span class="token string">"Relase version 1.01"</span><span class="token comment" spellcheck="true"># 查看相应标签的版本信息</span><span class="token function">git</span> show v1.4</code></pre><ul><li>-a 选项,创建一个含附注类型的标签</li><li>-m 选项,指定了对应的标签说明</li></ul><h2 id="9-Git分支的使用"><a href="#9-Git分支的使用" class="headerlink" title="9. Git分支的使用"></a>9. Git分支的使用</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看本地分支</span><span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 查看远程分支</span><span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 创建本地分支(注意新分支创建后不会自动切换为当前分支)</span><span class="token function">git</span> branch <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换分支</span><span class="token function">git</span> checkout <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 创建新分支并立即切换到新分支</span><span class="token function">git</span> checkout -b <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强制删除一个分支</span><span class="token function">git</span> branch -D <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并分支(将名称为[name]的分支与当前分支合并)</span><span class="token function">git</span> merge <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看各个分支最后提交信息</span><span class="token function">git</span> br -v<span class="token comment" spellcheck="true"># 查看已经被合并到当前分支的分支</span><span class="token function">git</span> br --merged<span class="token comment" spellcheck="true"># 查看尚未被合并到当前分支的分支</span><span class="token function">git</span> br --no-merged</code></pre><h2 id="10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"><a href="#10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。" class="headerlink" title="10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"></a>10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。</h2><p>merge和rebase对于ours和theirs的定义是完全相反的。在merge时，ours指代的是当前分支，theirs代表需要被合并的分支。而在rebase过程中，ours指向了修改参考分支，theirs却是当前分支。因为rebase 隐含了一个<code>git checkout upstream</code>的过程，将<code>HEAD</code>从local分支变成了upstream分支。git会在rebase结束后撤销这个改变，但它已经不可避免地影响了冲突的状态，使rebase中ours和theirs的定义与merge 截然相反。因此，在使用ours与theirs时请格外小心。</p><h2 id="11-Git远程操作相关"><a href="#11-Git远程操作相关" class="headerlink" title="11. Git远程操作相关"></a>11. Git远程操作相关</h2><h3 id="1-clone"><a href="#1-clone" class="headerlink" title="(1). clone"></a>(1). clone</h3><blockquote><p>git clone &lt;版本库的网址&gt;<br>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 克隆jQuery的版本库</span> <span class="token function">git</span> clone https://github.com/jquery/jquery.git <span class="token function">git</span> clone -o jQuery https://github.com/jquery/jquery.git</code></pre><h3 id="2-remote"><a href="#2-remote" class="headerlink" title="(2). remote"></a>(2). remote</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有远程主机</span><span class="token function">git</span> remote<span class="token comment" spellcheck="true"># 使用-v选项，可以参看远程主机的网址</span><span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 可以查看该主机的详细信息</span><span class="token function">git</span> remote show <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 添加远程主机</span><span class="token function">git</span> remote add <span class="token operator">&lt;</span>主机名<span class="token operator">></span> <span class="token operator">&lt;</span>网址<span class="token operator">></span><span class="token comment" spellcheck="true"># 删除远程主机</span><span class="token function">git</span> remote <span class="token function">rm</span> <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 修改远程主机名称</span><span class="token function">git</span> remote <span class="token function">rename</span> <span class="token operator">&lt;</span>原主机名<span class="token operator">></span> <span class="token operator">&lt;</span>新主机名<span class="token operator">></span></code></pre><h3 id="3-fetch"><a href="#3-fetch" class="headerlink" title="(3). fetch"></a>(3). fetch</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回所有分支(branch)的更新到本地</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回某的特定分支的更新</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>分支名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回origin主机的master分支的更新</span><span class="token function">git</span> fetch origin master<span class="token comment" spellcheck="true"># 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支</span><span class="token function">git</span> merge origin/master<span class="token function">git</span> rebase origin/master</code></pre><h3 id="4-pull"><a href="#4-pull" class="headerlink" title="(4). pull"></a>(4). pull</h3><blockquote><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回origin主机的next分支，与本地的master分支合并</span><span class="token function">git</span> pull origin next:master<span class="token comment" spellcheck="true"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span><span class="token function">git</span> pull origin next<span class="token comment" spellcheck="true"># 上面的命令实质上等同于先做git fetch，再做git merge。</span><span class="token function">git</span> fetch origin<span class="token function">git</span> merge origin/next<span class="token comment" spellcheck="true"># 合并需要采用rebase模式</span><span class="token function">git</span> pull --rebase <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">></span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">></span></code></pre><h3 id="5-push"><a href="#5-push" class="headerlink" title="(5). push"></a>(5). push</h3><blockquote><p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p></blockquote><p><strong>注意</strong>:分支推送顺序的写法是”&lt;来源地&gt;:&lt;目的地&gt;”，所以git pull是”&lt;远程分支&gt;:&lt;本地分支&gt;”，而git push是”&lt;本地分支&gt;:&lt;远程分支&gt;”。</p><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。</li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建</span><span class="token function">git</span> push origin master<span class="token comment" spellcheck="true"># 省略了本地分支，以下等同，删除origin主机的master分支</span><span class="token function">git</span> push origin :master<span class="token function">git</span> push origin --delete master<span class="token comment" spellcheck="true"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略</span><span class="token function">git</span> push origin<span class="token comment" spellcheck="true"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><span class="token function">git</span> push<span class="token comment" spellcheck="true"># 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push</span><span class="token function">git</span> push -u origin master<span class="token comment" spellcheck="true"># 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机</span><span class="token function">git</span> push --all origin<span class="token comment" spellcheck="true"># 强制推送</span><span class="token function">git</span> push --force origin<span class="token comment" spellcheck="true"># git push不会推送标签(tag)，除非使用–tags选项</span><span class="token function">git</span> push origin --tags</code></pre><h2 id="12-Git-Flow使用简介"><a href="#12-Git-Flow使用简介" class="headerlink" title="12. Git Flow使用简介"></a>12. Git Flow使用简介</h2><p>就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。三种广泛使用的工作流程：</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow</li></ul><p>三种工作流程，有一个共同点：都采用”功能驱动式开发”（Feature-driven development，简称FDD）。它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。最早诞生、并得到广泛采用的一种工作流程，就是<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">Git flow</a>。</p><p>它最主要的特点有两个。首先，项目存在两个长期分支，分别是：主分支master、开发分支develop。其次，项目存在三种短期分支，分别是：功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch），一旦完成开发，它们就会被合并进develop或master，然后被删除。</p><h3 id="1-Git-Flow流程图"><a href="#1-Git-Flow流程图" class="headerlink" title="(1). Git Flow流程图"></a>(1). Git Flow流程图</h3><p><img src="http://static.blinkfox.com/ghost/imagegit_flow.png" alt="Git Flow流程图"></p><h3 id="2-Git-Flow常用的分支"><a href="#2-Git-Flow常用的分支" class="headerlink" title="(2). Git Flow常用的分支"></a>(2). Git Flow常用的分支</h3><ul><li><code>Production</code>分支。也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改。</li><li><code>Develop</code>分支。这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。</li><li><code>Feature</code>分支。这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。</li><li><code>Release</code>分支。当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。</li><li><code>Hotfix</code>分支。当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。</li></ul><h3 id="3-Git-Flow代码示例"><a href="#3-Git-Flow代码示例" class="headerlink" title="(3). Git Flow代码示例"></a>(3). Git Flow代码示例</h3><h4 id="a-创建develop分支"><a href="#a-创建develop分支" class="headerlink" title="a. 创建develop分支"></a>a. 创建develop分支</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch develop<span class="token function">git</span> push -u origin develop</code></pre><h4 id="b-开始新Feature开发"><a href="#b-开始新Feature开发" class="headerlink" title="b. 开始新Feature开发"></a>b. 开始新Feature开发</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b some-feature develop<span class="token comment" spellcheck="true"># Optionally, push branch to origin:</span><span class="token function">git</span> push -u origin some-feature<span class="token comment" spellcheck="true"># 做一些改动</span><span class="token function">git</span> status<span class="token function">git</span> add some-file<span class="token function">git</span> commit</code></pre><h4 id="c-完成Feature"><a href="#c-完成Feature" class="headerlink" title="c. 完成Feature"></a>c. 完成Feature</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin develop<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff some-feature<span class="token function">git</span> push origin develop<span class="token function">git</span> branch -d some-feature<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete some-feature</code></pre><h4 id="d-开始Relase"><a href="#d-开始Relase" class="headerlink" title="d. 开始Relase"></a>d. 开始Relase</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b release-0.1.0 develop<span class="token comment" spellcheck="true"># Optional: Bump version number, commit</span><span class="token comment" spellcheck="true"># Prepare release, commit</span></code></pre><h4 id="e-完成Release"><a href="#e-完成Release" class="headerlink" title="e. 完成Release"></a>e. 完成Release</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> branch -d release-0.1.0<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete release-0.1.0   <span class="token function">git</span> tag -a v0.1.0 master<span class="token function">git</span> push --tags</code></pre><h4 id="f-开始Hotfix"><a href="#f-开始Hotfix" class="headerlink" title="f. 开始Hotfix"></a>f. 开始Hotfix</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b hotfix-0.1.1 master</code></pre><h4 id="g-完成Hotfix"><a href="#g-完成Hotfix" class="headerlink" title="g. 完成Hotfix"></a>g. 完成Hotfix</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> branch -d hotfix-0.1.1<span class="token function">git</span> tag -a v0.1.1 master<span class="token function">git</span> push --tags</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之状态模式</title>
      <link href="/2018/09/21/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhuang-tai-mo-shi/"/>
      <url>/2018/09/21/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhuang-tai-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(<code>stateful</code>)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>状态模式(<code>State Pattern</code>)</strong>：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(<code>Objects for States</code>)，状态模式是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成："><a href="#1-角色组成：" class="headerlink" title="1. 角色组成："></a>1. 角色组成：</h3><p>状态模式包含如下角色：</p><ul><li><code>Context</code>: 环境类</li><li><code>State</code>: 抽象状态角色</li><li><code>ConcreteState</code>: 具体状态角色类</li></ul><h3 id="2-结构图："><a href="#2-结构图：" class="headerlink" title="2. 结构图："></a>2. 结构图：</h3><p><img src="http://static.blinkfox.com/State.jpg" alt="状态模式结构图"></p><h3 id="3-时序图："><a href="#3-时序图：" class="headerlink" title="3. 时序图："></a>3. 时序图：</h3><p><img src="http://static.blinkfox.com/seq_State.jpg" alt="状态模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的状态角色接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象状态角色 * Created by blinkfox on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法1     */</span>    <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法2     */</span>    <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来，是多个具体的状态角色类，分别如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类1 * Created by blinkfox on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteState1</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类1中的方法1     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类1中的方法1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类1中的方法2     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类1中的方法2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类2 * Created by blinkfox on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteState2</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类2中的方法1     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类2中的方法1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类2中的方法2     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类2中的方法2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是环境类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 环境角色类 * Created by blinkfox on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当前状态</span>    <span class="token keyword">private</span> IState state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法     * @param state     */</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>IState state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法1     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法2     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是用于测试状态模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 状态模式的客户端场景累 * Created by blinkfox on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StateClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteState1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的关键是引入了一个抽象接口来专门表示对象的状态，这个类我们叫做抽象状态接口，而对象的每一种具体状态类都实现了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</li></ul><p>在状态模式结构中需要理解环境类与抽象状态类的作用：</p><ul><li>环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。</li><li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>状态模式的优点：</p><ul><li>封装了转换规则。</li><li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>状态模式的缺点：</p><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用状态模式：</p><ul><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li></ul><blockquote><p>状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。</li><li>状态模式包含三个角色：环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</li><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。</li><li>状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之代理模式</title>
      <link href="/2018/09/20/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-dai-li-mo-shi/"/>
      <url>/2018/09/20/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-dai-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p><p>通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>代理模式(<code>Proxy Pattern</code>)</strong>：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做<code>Proxy</code>或<code>Surrogate</code>，它是一种对象结构型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>代理模式包含如下角色：</p><ul><li><code>Subject</code>: 抽象主题角色</li><li><code>RealSubject</code>: 真实主题角色</li><li><code>Proxy</code>: 代理主题角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg" alt="代理模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的主题接口和真实主题类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 抽象主题类 * Created by blinkfox on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义一个方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 真实主题类 * Created by blinkfox on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">implements</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"真实主题类请求方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是代理类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 代理类 * Created by blinkfox on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ISubject subject<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Proxy</span><span class="token punctuation">(</span>ISubject subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject <span class="token operator">=</span> subject<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 预处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行前(before)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 善后处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行后(after)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景测试类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 代理模式客户端场景类 * Created by blinkfox on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ISubject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Proxy proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>代理模式的优点：</p><ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li><li>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对真实对象的使用权限。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>代理模式的缺点：</p><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li><strong>远程(Remote)代理</strong>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li><li><strong>虚拟(Virtual)代理</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li><strong>Copy-on-Write代理</strong>：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li><li><strong>保护(Protect or Access)代理</strong>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong>缓冲(Cache)代理</strong>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li><strong>防火墙(Firewall)代理</strong>：保护目标不让恶意用户接近。</li><li><strong>同步化(Synchronization)代理</strong>：使几个用户能够同时使用一个对象而没有冲突。</li><li><strong>智能引用(Smart Reference)代理</strong>：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</li><li>代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li><li>代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVEL2.x模板指南</title>
      <link href="/2018/09/19/hou-duan/java/mvel2.x-mo-ban-zhi-nan/"/>
      <url>/2018/09/19/hou-duan/java/mvel2.x-mo-ban-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://github.com/mvel/mvel" target="_blank" rel="noopener">MVEL</a>最初作为Mike Brock创建的 Valhalla项目的表达式计算器（<code>expression evaluator</code>）。Valhalla本身是一个早期的类似 Seam 的“开箱即用”的Web 应用框架，而 Valhalla 项目现在处于休眠状态， MVEL则成为一个继续积极发展的项目。相比最初的<code>OGNL</code>、<code>JEXL</code>和<code>JUEL</code>等项目，而它具有远超它们的性能、功能和易用性 - 特别是集成方面。它不会尝试另一种JVM语言，而是着重解决嵌入式脚本的问题。关于MVEL的语法请参考<a href="http://blinkfox.com/mvel-2-xyu-fa-zhi-nan/" target="_blank" rel="noopener">MVEL 2.x语法指南</a></p></blockquote><p>MVEL 2.0提供了一个新的，更强大的，统一的模板引擎，汇集了1.2中引入的许多模板概念。 不幸的是，1.2中的模板引擎的架构不足以用于常规维护，并且决定从头开始完全重写模板引擎。</p><h2 id="一、MVEL-2-0基本模板"><a href="#一、MVEL-2-0基本模板" class="headerlink" title="一、MVEL 2.0基本模板"></a>一、MVEL 2.0基本模板</h2><p>MVEL模板由纯文本文档中的<code>orb-tags</code>组成。 Orb标记表示引擎将在运行时计算模板的动态元素。</p><p>如果你熟悉FreeMarker，这种类型的语法将不会完全陌生。</p><h3 id="1-一个简单的模板"><a href="#1-一个简单的模板" class="headerlink" title="1. 一个简单的模板"></a>1. 一个简单的模板</h3><pre class=" language-java"><code class="language-java">Hello<span class="token punctuation">,</span> @<span class="token punctuation">{</span>person<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'F'</span> <span class="token operator">?</span> <span class="token string">'Ms.'</span> <span class="token operator">:</span> <span class="token string">'Mr.'</span><span class="token punctuation">}</span> @<span class="token punctuation">{</span>person<span class="token punctuation">.</span>name<span class="token punctuation">}</span>This e<span class="token operator">-</span>mail is to thank you <span class="token keyword">for</span> your interest in MVEL Templates <span class="token number">2.0</span><span class="token punctuation">.</span></code></pre><p>此模板展示了可以在简单文本中嵌入表达式。当计算结果时，输出可能如下所示：</p><pre class=" language-java"><code class="language-java">Hello<span class="token punctuation">,</span> Ms<span class="token punctuation">.</span> Sarah PetersonThis e<span class="token operator">-</span>mail is to thank you <span class="token keyword">for</span> your interest in MVEL Templates <span class="token number">2.0</span><span class="token punctuation">.</span></code></pre><h3 id="2-转义-符号"><a href="#2-转义-符号" class="headerlink" title="2. 转义@符号"></a>2. 转义@符号</h3><p>当然，由于@符号用于表示<code>orb-tag</code>的开头，因此您可能需要对其进行转义，以防止其被编译器处理。幸运的是，只有一种情况，即当你实际上需要输出‘@{‘字符串在您的模板上时。</p><p>由于编译器需要@和{组合触发orb识别，你可以自由使用@符号而不转义它们。例如：</p><pre class=" language-java"><code class="language-java">Email any questions to<span class="token operator">:</span> foo<span class="token annotation punctuation">@bar</span><span class="token punctuation">.</span>com@<span class="token punctuation">{</span>date<span class="token punctuation">}</span><span class="token annotation punctuation">@include</span><span class="token punctuation">{</span><span class="token string">'disclaimer.html'</span><span class="token punctuation">}</span></code></pre><p>但是在你需要一个@符号挨着一个orb-tag的情况下，你需要通过重复它两次来避免它：</p><pre class=" language-java"><code class="language-java">@<span class="token punctuation">{</span>username<span class="token punctuation">}</span>@@@<span class="token punctuation">{</span>domain<span class="token punctuation">}</span></code></pre><p>这是两个@转义一个符号，第三个@是标签的开始。如果你感觉这看起来太乱，你可以使用替代方法，即使用表达式标签，如下所示：</p><pre class=" language-java"><code class="language-java">@<span class="token punctuation">{</span>username<span class="token punctuation">}</span>@<span class="token punctuation">{</span><span class="token string">'@'</span><span class="token punctuation">}</span>@<span class="token punctuation">{</span>domain<span class="token punctuation">}</span></code></pre><h2 id="二、MVEL-2-0-Orb标签"><a href="#二、MVEL-2-0-Orb标签" class="headerlink" title="二、MVEL 2.0 Orb标签"></a>二、MVEL 2.0 Orb标签</h2><p>本文包含了MVEL 2.0模板引擎中所有开箱即用的orb标签。</p><h3 id="1-Orb表达式"><a href="#1-Orb表达式" class="headerlink" title="1. @{} Orb表达式"></a>1. @{} Orb表达式</h3><p>@{}表达式是orb-tag的最基本形式。它包含一个对字符串求值的值表达式，并附加到输出模板中。例如：</p><pre class=" language-java"><code class="language-java">Hello<span class="token punctuation">,</span> my name is @<span class="token punctuation">{</span>person<span class="token punctuation">.</span>name<span class="token punctuation">}</span></code></pre><h3 id="2-code-静默代码标签"><a href="#2-code-静默代码标签" class="headerlink" title="2. @code{} 静默代码标签"></a>2. @code{} 静默代码标签</h3><p>静默代码标记允许您在模板中执行MVEL表达式代码。它不返回值，并且不以任何方式影响模板的格式。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@code</span><span class="token punctuation">{</span>age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span> name <span class="token operator">=</span> <span class="token string">'John Doe'</span><span class="token punctuation">}</span>@<span class="token punctuation">{</span>name<span class="token punctuation">}</span> is @<span class="token punctuation">{</span>age<span class="token punctuation">}</span> years old</code></pre><p>该模板将计算出：John Doe is 23 years old。</p><h3 id="3-if-else-控制流标签"><a href="#3-if-else-控制流标签" class="headerlink" title="3. @if{}@else{} 控制流标签"></a>3. @if{}@else{} 控制流标签</h3><p>@if{}和@else{}标签在MVEL模板中提供了完全的if-then-else功能。 例如：</p><pre class=" language-java"><code class="language-java">@<span class="token keyword">if</span><span class="token punctuation">{</span>foo <span class="token operator">!=</span> bar<span class="token punctuation">}</span>   Foo not a bar<span class="token operator">!</span>@<span class="token keyword">else</span><span class="token punctuation">{</span>bar <span class="token operator">!=</span> cat<span class="token punctuation">}</span>   Bar is not a cat<span class="token operator">!</span>@<span class="token keyword">else</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   Foo may be a Bar or a Cat<span class="token operator">!</span><span class="token annotation punctuation">@end</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>MVEL模板中的所有块必须用<code>@end{}</code>标签来终止，除非是<code>if-then-else</code>结构，其中<code>@else{}</code>标记表示前一个控制语句的终止。</p><h3 id="4-foreach-Foreach迭代"><a href="#4-foreach-Foreach迭代" class="headerlink" title="4. @foreach{} Foreach迭代"></a>4. @foreach{} Foreach迭代</h3><p>foreach标签允许您在模板中迭代集合或数组。 注意：foreach的语法已经在MVEL模板2.0中改变，以使用foreach符号来标记MVEL语言本身的符号。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@foreach</span><span class="token punctuation">{</span>item <span class="token operator">:</span> products<span class="token punctuation">}</span>  <span class="token operator">-</span> @<span class="token punctuation">{</span>item<span class="token punctuation">.</span>serialNumber<span class="token punctuation">}</span><span class="token annotation punctuation">@end</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>MVEL 2.0要求您指定一个迭代变量。虽然MVEL 1.2假设您没有指定别名，但由于对该默认操作有一些抱怨，因此已被删除。</p><h3 id="5-多重迭代"><a href="#5-多重迭代" class="headerlink" title="5. 多重迭代"></a>5. 多重迭代</h3><p>您可以通过逗号分隔迭代在一个foreach循环中一次性迭代多个集合：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@foreach</span><span class="token punctuation">{</span>var1 <span class="token operator">:</span> set1<span class="token punctuation">,</span> var2 <span class="token operator">:</span> set2<span class="token punctuation">}</span>  @<span class="token punctuation">{</span>var1<span class="token punctuation">}</span><span class="token operator">-</span>@<span class="token punctuation">{</span>var2<span class="token punctuation">}</span><span class="token annotation punctuation">@end</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h3 id="6-分隔"><a href="#6-分隔" class="headerlink" title="6. 分隔"></a>6. 分隔</h3><p>你可以通过在<code>@end{}</code>标签中指定迭代器的文本分隔符。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@foreach</span><span class="token punctuation">{</span>item <span class="token operator">:</span> people<span class="token punctuation">}</span>@<span class="token punctuation">{</span>item<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token annotation punctuation">@end</span><span class="token punctuation">{</span><span class="token string">', '</span><span class="token punctuation">}</span></code></pre><p>将返回类似这样的结果：John, Mary, Joseph。</p><h3 id="7-include-包含模板文件"><a href="#7-include-包含模板文件" class="headerlink" title="7. @include{} 包含模板文件"></a>7. @include{} 包含模板文件</h3><p>您可以使用此标签将模板文件包含到MVEL模板中。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@include</span><span class="token punctuation">{</span><span class="token string">'header.mv'</span><span class="token punctuation">}</span>This is a test template<span class="token punctuation">.</span></code></pre><p>您还可以通过在模板名称后面添加分号在include标签内执行MVEL表达式：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@include</span> <span class="token punctuation">{</span><span class="token string">'header.mv'</span><span class="token punctuation">;</span> title <span class="token operator">=</span><span class="token string">'Foo Title'</span><span class="token punctuation">}</span></code></pre><h3 id="8-includeNamed-包括一个命名模板"><a href="#8-includeNamed-包括一个命名模板" class="headerlink" title="8. @includeNamed{} 包括一个命名模板"></a>8. @includeNamed{} 包括一个命名模板</h3><p>命名模板是已经通过TemplateRegistry预先编译并传递到运行时的模板，或者已在模板本身中声明的模板。 您只需添加：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@includeNamed</span> <span class="token punctuation">{</span><span class="token string">'fooTemplate'</span><span class="token punctuation">}</span><span class="token annotation punctuation">@includeNamed</span> <span class="token punctuation">{</span><span class="token string">'footerTemplate'</span>，showSomething <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p>你也可以在<code>@includeNamed{}</code>标签中执行MVEL代码，就像<code>@include{}</code>标签一样。</p><h3 id="9-declare-声明一个模板"><a href="#9-declare-声明一个模板" class="headerlink" title="9. @declare{} 声明一个模板"></a>9. @declare{} 声明一个模板</h3><p>除了包括外部文件的外部模板，并以编程方式传递它们之外，您还可以从模板中声明模板。 它允许你做这样的事情：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@declare</span><span class="token punctuation">{</span><span class="token string">'personTemplate'</span><span class="token punctuation">}</span> Name<span class="token operator">:</span> @<span class="token punctuation">{</span>name<span class="token punctuation">}</span> Age<span class="token operator">:</span>  @<span class="token punctuation">{</span>age<span class="token punctuation">}</span><span class="token annotation punctuation">@end</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@includeNamed</span><span class="token punctuation">{</span><span class="token string">'personTemplate'</span><span class="token punctuation">;</span> name<span class="token operator">=</span><span class="token string">'John Doe'</span><span class="token punctuation">;</span> age<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">}</span></code></pre><h3 id="10-comment-注释标签"><a href="#10-comment-注释标签" class="headerlink" title="10. @comment{} 注释标签"></a>10. @comment{} 注释标签</h3><p>注释标签允许您向模板添加不可见的注释。 例如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@comment</span><span class="token punctuation">{</span>  This is a comment<span class="token punctuation">}</span>Hello<span class="token operator">:</span> @<span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">!</span></code></pre><h2 id="三、MVEL-2-0模板集成"><a href="#三、MVEL-2-0模板集成" class="headerlink" title="三、MVEL 2.0模板集成"></a>三、MVEL 2.0模板集成</h2><p>使用MVEL模板是直接和容易的。 与常规MVEL表达式一样，它们可以解释性地执行，或者预编译并重新用于更快的评估。</p><h3 id="1-org-mvel-templates-TemplateRuntime-类"><a href="#1-org-mvel-templates-TemplateRuntime-类" class="headerlink" title="1. org.mvel.templates.TemplateRuntime 类"></a>1. org.mvel.templates.TemplateRuntime 类</h3><p><code>TemplateRuntime</code>类是模板引擎的中心。您可以通过<code>eval()</code>方法将要计算的模板传递给模板引擎。</p><p>一般来说，模板引擎遵循上下文和变量绑定的所有相同规则，使用一组重载的<code>eval()</code>方法。</p><p>下面是一个解析模板的简单例子：</p><pre class=" language-java"><code class="language-java">String template <span class="token operator">=</span> <span class="token string">"Hello, my name is @{name.toUpperCase()}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Map vars <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vars<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Michael"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String output <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> TemplateRuntime<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>template<span class="token punctuation">,</span> vars<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在执行结束时，“output”变量将包含字符串：</p><pre class=" language-java"><code class="language-java">Hello<span class="token punctuation">,</span> my name is MICHAEL</code></pre><h3 id="2-org-mvel-templates-TemplateCompiler类"><a href="#2-org-mvel-templates-TemplateCompiler类" class="headerlink" title="2. org.mvel.templates.TemplateCompiler类"></a>2. org.mvel.templates.TemplateCompiler类</h3><p><code>TemplateCompiler</code>类允许预先编译模板。</p><p>当编译模板时，将生成一个紧凑，可重用的评估树，可以快速用于计算模板。它直接使用：</p><pre class=" language-java"><code class="language-java">String template <span class="token operator">=</span> <span class="token string">"1 + 1 = @{1+1}"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 编译模板</span>CompiledTemplate compiled <span class="token operator">=</span> TemplateCompiler<span class="token punctuation">.</span><span class="token function">compileTemplate</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 执行模板</span>String output <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> TemplateRuntime<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>compiled<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在执行结束时，“output”变量将包含字符串：</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MVEL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVEL 2.x语法指南</title>
      <link href="/2018/09/18/hou-duan/java/mvel2.x-yu-fa-zhi-nan/"/>
      <url>/2018/09/18/hou-duan/java/mvel2.x-yu-fa-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="MVEL-2-x语法指南"><a href="#MVEL-2-x语法指南" class="headerlink" title="MVEL 2.x语法指南"></a>MVEL 2.x语法指南</h1><p><a href="https://github.com/mvel/mvel" target="_blank" rel="noopener">MVEL</a>全称为：MVFLEX Expression Language，是用来计算Java语法所编写的表达式值的表达式语言。MVEL的语法很大程度上受到Java语法的启发，但为了使表达式语法更高效,还是有一些基本差异，例如可以像正则表达式一样直接支持集合、数组和字符串匹配的运算。</p><p>除了表达式语言之外，MVEL还用作配置和字符串构造的模板语言。这里还有一个关于<a href="https：//en.wikipedia.org/wiki/MVEL">MVEL</a>介绍信息的wiki页面是：https：//en.wikipedia.org/wiki/MVEL。</p><p>MVEL 2.x表达式主要包括以下特性：</p><ul><li>属性表达式</li><li>布尔表达式</li><li>方法调用</li><li>变量赋值</li><li>函数定义</li></ul><h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><p>MVEL是基于Java语法的表达式语言，具有特定于MVEL的一些明显差异。与Java不同，MVEL是动态类型化（可选类型化），意味着在源代码中不需要类型限定。</p><p>MVEL可以方便的集成到产品中使用。Maven的集成方式如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mvel<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mvel2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.8.Final<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>一个MVEL表达式，简单的可以是单个标识符，复杂的则可能是一个充满了方法调用和内部集合创建的庞大的布尔表达式。使用MVEL提供的API。可以动态得到表达式的执行结果。</p><h3 id="1-简单属性表达式"><a href="#1-简单属性表达式" class="headerlink" title="1. 简单属性表达式"></a>1. 简单属性表达式</h3><pre class=" language-java"><code class="language-java">user<span class="token punctuation">.</span>name</code></pre><p>在这个表达式中，我们只有一个标识符（user.name），在MVEL中我们称它为属性表达式，因为表达式的唯一目的就是从上下文中提取出变量或者对象的属性。属性表达式是最常见的用途之一，通过它，MVEL可以用来作为一个高性能，易使用的反射优化器。</p><p>MVEL甚至可以用来计算布尔表达式：</p><pre class=" language-java"><code class="language-java">user<span class="token punctuation">.</span>name <span class="token operator">==</span><span class="token string">'John Doe'</span></code></pre><p>与Java一样，MVEL支持所有优先级规则，包括通过括号来控制执行顺序。</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">'John Doe'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">20</span></code></pre><h3 id="2-复合语句"><a href="#2-复合语句" class="headerlink" title="2. 复合语句"></a>2. 复合语句</h3><p>您可以使用分号来表示语句的终止，使用任意数量的语句编写脚本。分号在所有情况下都是必需的，除非在脚本中只有一个语句或最后一个语句。</p><pre class=" language-java"><code class="language-java">statement1<span class="token punctuation">;</span> statement2<span class="token punctuation">;</span> statement3</code></pre><blockquote><p><strong>注意</strong>：statement3语句后可以缺少分号。</p></blockquote><p>另外，换行不能替代分号来作为一个语句的结束标识。</p><h3 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h3><p>MVEL是被设计为一个集成语言作为核心，允许开发人员提供简单的脚本设置绑定和逻辑。因此，MVEL表达式使用“last value out”原则（输出最后值原则）。这意味着，尽管MVEL支持return关键字，但却没必要使用它。例如：</p><pre class=" language-java"><code class="language-java">a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>a<span class="token punctuation">;</span></code></pre><p>在该示例中，表达式返回a的值，因为<code>a;</code>是表达式的最后一个值。它在功能上与下面的脚本等价：</p><pre class=" language-java"><code class="language-java">a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span></code></pre><h2 id="二、值判断"><a href="#二、值判断" class="headerlink" title="二、值判断"></a>二、值判断</h2><p>在MVEL中所有的判断是否相等，都是对值的判断，而没有对引用的判断，因此表达式<code>foo == &#39;bar&#39;</code>等价于Java中的<code>foo.equals(&quot;bar&quot;)</code>。</p><h3 id="1-判断空值"><a href="#1-判断空值" class="headerlink" title="1. 判断空值"></a>1. 判断空值</h3><p>MVEL提供了一个特殊的字符来表示值为空的情况，叫作<code>empty</code>，例如：</p><pre class=" language-java"><code class="language-java">foo <span class="token operator">==</span> empty</code></pre><p>若foo满足空的任何条件，这个表达式值都为true。</p><h3 id="2-判断Null值"><a href="#2-判断Null值" class="headerlink" title="2. 判断Null值"></a>2. 判断Null值</h3><p>MVEL中，<code>null</code>和<code>nil</code>都可以用来表示一个Null值，如：</p><pre class=" language-java"><code class="language-java">foo <span class="token operator">==</span> null<span class="token punctuation">;</span>foo <span class="token operator">==</span> nil<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 和null一样</span></code></pre><h3 id="3-强制转换"><a href="#3-强制转换" class="headerlink" title="3. 强制转换"></a>3. 强制转换</h3><p>当两个不同类型且没有可比性的值进行比较时，MVEL会应用类型强制转换系统，即将左边的值强制转换成右边的值的类型，反之亦然。如：</p><pre class=" language-java"><code class="language-java"><span class="token string">"123"</span> <span class="token operator">==</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><p>这个表达式的值为true,因为为了执行比较，强制类型转换系统会隐式的将数字<code>123</code>转换成字符串。</p><h2 id="三、内联Lists、Maps和数组Arrays"><a href="#三、内联Lists、Maps和数组Arrays" class="headerlink" title="三、内联Lists、Maps和数组Arrays"></a>三、内联Lists、Maps和数组Arrays</h2><p>MVEL允许你使用简单优雅的语法来表示Lists，Mpas和数组Arrays。 且看下面的示例：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token string">"Bob"</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Michael"</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><p>这个表达式的功能等价于：</p><pre class=" language-java"><code class="language-java">Map map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>用这种结构描述MVEL内部数据结构，功能非常强大，你可以在任何地方使用它，甚至可以作为方法的参数使用，如：</p><pre class=" language-java"><code class="language-java">something<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"foo"</span> <span class="token operator">:</span> <span class="token string">"bar"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="1-Lists"><a href="#1-Lists" class="headerlink" title="1. Lists"></a>1. Lists</h3><p>Lists用以下格式来表示：”[item1, item2, …]”，如：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token string">"Jim"</span><span class="token punctuation">,</span> <span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Smith"</span><span class="token punctuation">]</span></code></pre><h3 id="2-Maps"><a href="#2-Maps" class="headerlink" title="2. Maps"></a>2. Maps</h3><p>Maps用以下格式来表示：”[key1 : value1, key2: value2, …]”，如：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token string">"Foo"</span> <span class="token operator">:</span> <span class="token string">"Bar"</span><span class="token punctuation">,</span> <span class="token string">"Bar"</span> <span class="token operator">:</span> <span class="token string">"Foo"</span><span class="token punctuation">]</span></code></pre><h3 id="3-数组Arrays"><a href="#3-数组Arrays" class="headerlink" title="3. 数组Arrays"></a>3. 数组Arrays</h3><p>数组Arrays用以下格式来表示：”{item1, item2, …}”，如：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"Jim"</span><span class="token punctuation">,</span> <span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Smith"</span><span class="token punctuation">}</span></code></pre><h3 id="4-数组强制转换"><a href="#4-数组强制转换" class="headerlink" title="4. 数组强制转换"></a>4. 数组强制转换</h3><p>关于内联数组，需要知道的一个非常重要的方面是，它可以被强制转换成其它类型的数组，当你声明一个数组时，是不直接指定其类型的，但你可以通过将其传递给一个接收int[]类型参数的方法来指定。如：</p><pre class=" language-java"><code class="language-java">foo<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这种情况下，当MVEL发现目标方法接收的是一个int[]，会自动的将{1,2,3,4}转换成int[]类型。</p><h2 id="四、属性导航"><a href="#四、属性导航" class="headerlink" title="四、属性导航"></a>四、属性导航</h2><p>MVEL属性导航遵循在其他语言（如Groovy，OGNL，EL等）中bean属性表达式中公认惯例的使用方式。和其它语言必须通过底层的方法来控制权限不同的是，MVEL提供了一种单一的，统一的语法来访问属性，静态字段和maps等。</p><h3 id="1-Bean属性"><a href="#1-Bean属性" class="headerlink" title="1. Bean属性"></a>1. Bean属性</h3><p>大多数java开发者都熟悉getter/setter模式，并在java对象中用它来封装属性的访问权限。例如，你可能会通过下面的方式访问一个对象的属性：</p><pre class=" language-java"><code class="language-java">user<span class="token punctuation">.</span><span class="token function">getManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>为了简化此操作，您可以使用以下表达式访问相同的属性：</p><pre class=" language-java"><code class="language-java">user<span class="token punctuation">.</span>manager<span class="token punctuation">.</span>name</code></pre><blockquote><p><strong>注意：</strong>当一个对象中的字段的作用域是public时，MVEL仍然倾向于通过get方法来访问其属性。</p></blockquote><h3 id="2-Bean的安全属性导航"><a href="#2-Bean的安全属性导航" class="headerlink" title="2. Bean的安全属性导航"></a>2. Bean的安全属性导航</h3><p>有时，当你的表达式中会含有null元素时，这时就需要你进行一个为空判断，否则就会发生错误。当你使用null-safe操作符时你可以简化这个操作：</p><pre class=" language-java"><code class="language-java">user<span class="token punctuation">.</span>?manager<span class="token punctuation">.</span>name</code></pre><p>它的功能相当于：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span>manager <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> user<span class="token punctuation">.</span>manager<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="3-集合"><a href="#3-集合" class="headerlink" title="3. 集合"></a>3. 集合</h3><p>集合的遍历也可以通过简单的语法来实现：</p><h4 id="1-List的访问"><a href="#1-List的访问" class="headerlink" title="(1). List的访问"></a>(1). List的访问</h4><p>List可以像访问数组一样访问，如：</p><pre class=" language-java"><code class="language-java">user<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span></code></pre><p>这等价与java中的代码：</p><pre class=" language-java"><code class="language-java">user<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="2-Map的访问"><a href="#2-Map的访问" class="headerlink" title="(2). Map的访问"></a>(2). Map的访问</h4><p>Map的访问和访问数组也非常相似，不同的是，在访问Map时索引值可以是任意对象，如：</p><pre class=" language-java"><code class="language-java">user<span class="token punctuation">[</span><span class="token string">"foobar"</span><span class="token punctuation">]</span></code></pre><p>这等价与java中的代码：</p><pre class=" language-java"><code class="language-java">user<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"foobar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当Map的key是String类型时，还可以使用特殊的方式来访问，如：</p><pre class=" language-java"><code class="language-java">user<span class="token punctuation">.</span>foobar</code></pre><h3 id="4-字符串作数组"><a href="#4-字符串作数组" class="headerlink" title="4. 字符串作数组"></a>4. 字符串作数组</h3><p>为了能使用属性的索引（迭代也是如此），所有的字符串都可以看成是一个数组，在MVEL中你可以用下面的方式来获取一个字符串变量的第一个字符：</p><pre class=" language-java"><code class="language-java">foo <span class="token operator">=</span> <span class="token string">"My String"</span><span class="token punctuation">;</span>foo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 'M'</span></code></pre><h2 id="五、文字常量"><a href="#五、文字常量" class="headerlink" title="五、文字常量"></a>五、文字常量</h2><p>在脚本语言中，一段文字（常量）用来代表一个固定的值。</p><h3 id="1-字符串常量"><a href="#1-字符串常量" class="headerlink" title="1. 字符串常量"></a>1. 字符串常量</h3><p>字符串常量可以用一对单引号或一对双引号来界定。如：</p><pre class=" language-java"><code class="language-java"><span class="token string">"This is a string literal"</span><span class="token string">'This is also string literal'</span></code></pre><h4 id="字符串转义字符"><a href="#字符串转义字符" class="headerlink" title="字符串转义字符"></a>字符串转义字符</h4><ul><li>\ - 代表一个反斜杠。</li><li>\n - 换行符</li><li>\r - 回车符</li><li>\u#### - Unicode字符 (如: /uAE00)</li><li>### - 八进制字符 (如: /73)</li></ul><h3 id="2-数字常量"><a href="#2-数字常量" class="headerlink" title="2. 数字常量"></a>2. 数字常量</h3><p>整数可以表示为十进制（基数为10），8进制（基数为8），或十六进制（基数为16）。</p><p>一个十进制数字，不从零开始（相对于8进制、16进制而言），可以表示任意数，如：</p><pre class=" language-java"><code class="language-java"><span class="token number">125</span> <span class="token comment" spellcheck="true">// 十进制</span></code></pre><p>一个八进制数，以0为前缀，后面跟着0到7内的数字。</p><pre class=" language-java"><code class="language-java"><span class="token number">0353</span> <span class="token comment" spellcheck="true">// 八进制</span></code></pre><p>一个十六进制，以0X为前缀，后面可以跟着0-9，A-F范围内的数字。</p><pre class=" language-java"><code class="language-java"><span class="token number">0xAFF0</span> <span class="token comment" spellcheck="true">// 十六进制</span></code></pre><h3 id="3-浮点型常量"><a href="#3-浮点型常量" class="headerlink" title="3. 浮点型常量"></a>3. 浮点型常量</h3><p>浮点数由整数和由点/周期字符表示的小数部分组成，带有可选的类型后缀。</p><pre class=" language-java"><code class="language-java"><span class="token number">10.503</span> <span class="token comment" spellcheck="true">// double型</span><span class="token number">94.92d</span> <span class="token comment" spellcheck="true">// double型</span><span class="token number">14.5f</span> <span class="token comment" spellcheck="true">// float型</span></code></pre><h3 id="4-大数字常量"><a href="#4-大数字常量" class="headerlink" title="4. 大数字常量"></a>4. 大数字常量</h3><p>您可以使用后缀B和I（必须大写）来表示BigDecimal和BigInteger文字，如：</p><pre class=" language-java"><code class="language-java"><span class="token number">104</span><span class="token punctuation">.</span>39484B <span class="token comment" spellcheck="true">// BigDecimal</span><span class="token number">8</span><span class="token punctuation">.</span>4I <span class="token comment" spellcheck="true">// BigInteger</span></code></pre><h3 id="5-布尔常量"><a href="#5-布尔常量" class="headerlink" title="5. 布尔常量"></a>5. 布尔常量</h3><p>布尔型常量用保留关键字true和false来表示。</p><h3 id="6-空常量"><a href="#6-空常量" class="headerlink" title="6. 空常量"></a>6. 空常量</h3><p>用null或nil来表示。</p><h2 id="六、类型常量"><a href="#六、类型常量" class="headerlink" title="六、类型常量"></a>六、类型常量</h2><p>类型常量的处理方式与Java中的相同，格式为：”<packagename>.<classname>“。</classname></packagename></p><p>所以一个类可以这样限定：</p><pre class=" language-java"><code class="language-java">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap</code></pre><p>或者如果类已经通过或者通过外部配置被导入，则它被简单地通过其非限定名称来引用：</p><pre class=" language-java"><code class="language-java">HashMap</code></pre><h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>嵌套类不能通过MVEL 2.0中的标准点表示法（如Java中）来访问。 相反，你必须用$符号限定这些类。</p><pre class=" language-java"><code class="language-java">org<span class="token punctuation">.</span>proctor<span class="token punctuation">.</span>Person$BodyPart</code></pre><h2 id="七、流程控制"><a href="#七、流程控制" class="headerlink" title="七、流程控制"></a>七、流程控制</h2><p>MVEL的强大已经超出了简单的表达式。事实上，MVEL提供了一系列的程序流程控制操作符来方便你进行高级的脚本操作。</p><h3 id="1-If-Then-Else"><a href="#1-If-Then-Else" class="headerlink" title="1. If-Then-Else"></a>1. If-Then-Else</h3><p>MVEL提供了完整的C/Java式的if-then-else块，如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>var <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Greater than zero!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Minus one!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Something else!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="2-三目运算符"><a href="#2-三目运算符" class="headerlink" title="2. 三目运算符"></a>2. 三目运算符</h3><p>其实就是Java中的条件表达式，如：</p><pre class=" language-java"><code class="language-java">var <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"Yes"</span> <span class="token operator">:</span> <span class="token string">"No"</span><span class="token punctuation">;</span></code></pre><p>可以嵌套三目运算符</p><pre class=" language-java"><code class="language-java">var <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"Yes"</span> <span class="token operator">:</span> <span class="token punctuation">(</span>var <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token string">"Minus One!"</span> <span class="token operator">:</span> <span class="token string">"No"</span><span class="token punctuation">)</span></code></pre><h3 id="3-Foreach"><a href="#3-Foreach" class="headerlink" title="3. Foreach"></a>3. Foreach</h3><p>MVEL的强大特性之一就是其Foreach操作符，在功能和语法上，他都类似于java1.5中的for each操作符，它接收用冒号隔开的两个参数，第一个是当前元素的一个域变量，而第二个是要迭代的集合或数组。如下所示：</p><pre class=" language-java"><code class="language-java">count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">foreach</span> <span class="token punctuation">(</span>name <span class="token operator">:</span> people<span class="token punctuation">)</span> <span class="token punctuation">{</span>   count<span class="token operator">++</span><span class="token punctuation">;</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Person #"</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total people: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>因为MVEL将字符串视作一个可以迭代的对象，所以你可以用foreach语句来迭代一个字符串（一个字符接一个字符的）：</p><pre class=" language-java"><code class="language-java">str <span class="token operator">=</span> <span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="token punctuation">;</span><span class="token function">foreach</span> <span class="token punctuation">(</span>el <span class="token operator">:</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"["</span><span class="token operator">+</span> el <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>上面的示例将会输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">[</span>C<span class="token punctuation">]</span><span class="token punctuation">[</span>D<span class="token punctuation">]</span><span class="token punctuation">[</span>E<span class="token punctuation">]</span><span class="token punctuation">[</span>F<span class="token punctuation">]</span><span class="token punctuation">[</span>G<span class="token punctuation">]</span><span class="token punctuation">[</span>H<span class="token punctuation">]</span><span class="token punctuation">[</span>I<span class="token punctuation">]</span><span class="token punctuation">[</span>J<span class="token punctuation">]</span><span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>O<span class="token punctuation">]</span><span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">[</span>Q<span class="token punctuation">]</span><span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">[</span>S<span class="token punctuation">]</span><span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">[</span>U<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>W<span class="token punctuation">]</span><span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">[</span>Y<span class="token punctuation">]</span><span class="token punctuation">[</span>Z<span class="token punctuation">]</span></code></pre><p>你也可以利用MVEL进行计数（从1开始）：</p><pre class=" language-java"><code class="language-java"><span class="token function">foreach</span> <span class="token punctuation">(</span>x <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这会输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">123456789</span></code></pre><p><strong>注意：</strong>像java5.0一样，在MVEL2.0中，可以将foreach简化成关键字for来使用，如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token operator">:</span> collection<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><h3 id="4-for循环"><a href="#4-for循环" class="headerlink" title="4. for循环"></a>4. for循环</h3><p>MVEL实现了标准的C语言的for循环：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5-Do-While-Do-Until"><a href="#5-Do-While-Do-Until" class="headerlink" title="5. Do While, Do Until"></a>5. Do While, Do Until</h3><p>和java中的意义一样，MVEL也实现了Do While,Do Until，While和Until意义正好相反。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">do</span> <span class="token punctuation">{</span>    x <span class="token operator">=</span> <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在语义上相当于：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">do</span> <span class="token punctuation">{</span>   x <span class="token operator">=</span> <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">until</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="6-While-Until"><a href="#6-While-Until" class="headerlink" title="6. While, Until"></a>6. While, Until</h3><p>MVEL中实现了标准的While，并添加了一个与之相反的Until。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>或者写成</p><pre class=" language-java"><code class="language-java"><span class="token function">until</span> <span class="token punctuation">(</span><span class="token function">isFalse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="八、投影和交集"><a href="#八、投影和交集" class="headerlink" title="八、投影和交集"></a>八、投影和交集</h2><p>简单地说，投影是一种描述集合的方式。 通过非常简单的语法，您可以检索集合中非常复杂的对象模型。</p><p>假设，你有一个User对象的集合。 每个对象都有一个Parent。 现在你想获得集合users中的所有parent的name的列表（假设Parent中有字段name），你可以这样来写：</p><pre class=" language-java"><code class="language-java">parentNames <span class="token operator">=</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>name in users<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>您甚至可以执行嵌套操作，假设，User对象有个集合成员叫做familyMembers，现在我们想获得一个所有家庭成员姓名的集合：</p><pre class=" language-java"><code class="language-java">familyMembers <span class="token operator">=</span> <span class="token punctuation">(</span>name <span class="token function">in</span> <span class="token punctuation">(</span>familyMembers in users<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="九、赋值"><a href="#九、赋值" class="headerlink" title="九、赋值"></a>九、赋值</h2><p>MMVEL允许你对表达式中的变量进行赋值，以便在运行时获取，或在表达式内部使用。因为MVEL是动态类型语言，所以你不必为了声明一个变量而指定其类型。当然，你也可以选择指定。</p><pre class=" language-java"><code class="language-java">str <span class="token operator">=</span>“My String”<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// valid</span>String str <span class="token operator">=</span>“My String”<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// valid</span></code></pre><p>与java语言不同的是，当给一个指定类型的变量赋值时，MVEL会提供自动的类型转换（可行的话），如：</p><pre class=" language-java"><code class="language-java">String num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">assert</span> num <span class="token keyword">instanceof</span> <span class="token class-name">String</span>＆amp<span class="token punctuation">;</span>＆amp<span class="token punctuation">;</span> num <span class="token operator">==</span>“<span class="token number">1</span>”<span class="token punctuation">;</span></code></pre><p>对于动态类型变量而言，你要想对其进行类型转换，你只需要将值转换成相应的类型既可：</p><pre class=" language-java"><code class="language-java">num <span class="token operator">=</span>（String）<span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">assert</span> num <span class="token keyword">instanceof</span> <span class="token class-name">String</span>＆amp<span class="token punctuation">;</span>＆amp<span class="token punctuation">;</span> num <span class="token operator">==</span>“<span class="token number">1</span>”<span class="token punctuation">;</span></code></pre><h2 id="十、函数定义"><a href="#十、函数定义" class="headerlink" title="十、函数定义"></a>十、函数定义</h2><p>MVEL可以使用def或function关键字来定义本地函数。</p><p>函数必须是先声明后引用，唯一例外的是递归调用的时候。</p><h3 id="1-一个简单示例"><a href="#1-一个简单示例" class="headerlink" title="1. 一个简单示例"></a>1. 一个简单示例</h3><p>定义一个简单函数：</p><pre class=" language-java"><code class="language-java">def <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>定义了一个没有参数的函数<code>hello</code>.当调用该函数时会在控制台打印”Hello!” 一个MVEL定义的函数就像任何常规的方法调用。</p><pre class=" language-java"><code class="language-java"><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用函数</span></code></pre><h3 id="2-传参和返回值"><a href="#2-传参和返回值" class="headerlink" title="2. 传参和返回值"></a>2. 传参和返回值</h3><p>函数可以接收参数和返回一个值，看下面的示例：</p><pre class=" language-java"><code class="language-java">def <span class="token function">addTwo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个函数会接收两个参数(a和b)，然后将这两个变量相加。因为MVEL遵循last-value-out原则，所以结果将会被返回。因此，你可以这样来使用这个函数：</p><pre class=" language-java"><code class="language-java">val <span class="token operator">=</span> <span class="token function">addTwo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assert</span> val <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>当然，也可以使用return关键字来强制从程序内部返回一个函数值。</p><h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3. 闭包"></a>3. 闭包</h3><p>MVEL支持闭包,然而其功能与本地java函数没有任何关联。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 定义一个接收一个参数的函数</span>def <span class="token function">someFunction</span><span class="token punctuation">(</span>f_ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">f_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 定义变量a</span>var a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 传递函数闭包</span><span class="token function">someFunction</span><span class="token punctuation">(</span>def <span class="token punctuation">{</span> a <span class="token operator">*</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="十一、Lambda表达式"><a href="#十一、Lambda表达式" class="headerlink" title="十一、Lambda表达式"></a>十一、Lambda表达式</h2><p>MVEL允许定义Lambda方法，如下所示：</p><pre class=" language-java"><code class="language-java">threshold <span class="token operator">=</span> <span class="token function">def</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">>=</span> <span class="token number">10</span> <span class="token operator">?</span> x <span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>result <span class="token operator">=</span> cost <span class="token operator">+</span> <span class="token function">threshold</span><span class="token punctuation">(</span>lowerBound<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面的例子定义了一个Lambda，并将其赋值给变量”threshold”.Lambda实质上就是一个用来给变量赋值的函数，也是闭包。</p><p>翻译原文：<a href="http://mvel.documentnode.com/" target="_blank" rel="noopener">http://mvel.documentnode.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MVEL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring基础介绍</title>
      <link href="/2018/09/17/hou-duan/java/spring-ji-chu-jie-shao/"/>
      <url>/2018/09/17/hou-duan/java/spring-ji-chu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Spring-概述"><a href="#一、Spring-概述" class="headerlink" title="一、Spring 概述"></a>一、Spring 概述</h2><h3 id="（一）Spring-的简史"><a href="#（一）Spring-的简史" class="headerlink" title="（一）Spring 的简史"></a>（一）Spring 的简史</h3><p><a href="https://spring.io/" target="_blank" rel="noopener">Spring</a> 的历史网上有很多的介绍，下面是 Spring 发展历程的一个简介。</p><h4 id="1-第一阶段：xml-配置"><a href="#1-第一阶段：xml-配置" class="headerlink" title="1. 第一阶段：xml 配置"></a>1. 第一阶段：xml 配置</h4><p>在 Spring 1.x 时代，使用 Spring 开发满眼都是 xml 配置的 Bean，随着项目的扩大，我们需要把 xml 配置文件放到不同的配置文件里，那时候需要频繁地在开发的类和配置文件之间切换。</p><h4 id="2-第二阶段：注解配置"><a href="#2-第二阶段：注解配置" class="headerlink" title="2. 第二阶段：注解配置"></a>2. 第二阶段：注解配置</h4><p>在 Spring 2.x 时代，随着 JDK 1.5 带来的注解支持，Spring 提供了声明 Bean 的注解（如：@Component、@Service），大大减少了配置量。这时 Spring 圈子里存在着一种争论：注解配置和 xml 配置究竟哪个更好？我们最终的选择是应用的基本配置（如：数据库配置）用 xml，业务配置用注解。</p><h4 id="3-第三阶段：Java-配置"><a href="#3-第三阶段：Java-配置" class="headerlink" title="3. 第三阶段：Java 配置"></a>3. 第三阶段：Java 配置</h4><p>从 Spring 3.x 到现在，Spring 提供了 Java 配置的能力，使用 Java 配置可以让你更理解你配置的 Bean。我们目前刚好处于这个时代，Spring 4.x 和 Spring Boot 都推荐使用 Java 配置。</p><h3 id="（二）Spring-概述"><a href="#（二）Spring-概述" class="headerlink" title="（二）Spring 概述"></a>（二）Spring 概述</h3><p>Spring 框架是一个轻量级的企业级开发的一站式解决方案。所谓解决方案就是可以基于 Spring 解决 JavaEE 开发的所有问题。Spring 框架主要提供了<code>IoC</code>容器、AOP、数据访问、Web 开发、消息、测试等相关技术的支持。</p><p>Spring 使用简单的 POJO（<code>Plain Old Java Object</code>，即无任何限制的普通Java对象）来进行企业级开发。每一个被 Spring 管理的 Java 对象都被称之为 Bean；而 Spring 提供了一个 IoC 容器用来初始化对象，解决对象间的依赖管理和对象的使用。</p><h4 id="1-Spring-的模块"><a href="#1-Spring-的模块" class="headerlink" title="1. Spring 的模块"></a>1. Spring 的模块</h4><p>Spring 是模块化的，这意味着你可以只使用你需要的Spring的模块。如下图所示：</p><p><img src="http://static.blinkfox.com/spring_moudle.png" alt="Spring 模块"></p><p>图中的每个最小单元，Spring 都至少有一个对应的 jar 包。</p><h5 id="（1）核心容器（Core-Contariner）"><a href="#（1）核心容器（Core-Contariner）" class="headerlink" title="（1）核心容器（Core Contariner）"></a>（1）核心容器（Core Contariner）</h5><ul><li>Spring-Core：核心工具类，Spring 其他模块大量使用 Spring-Core</li><li>Spring-Beans：Spring 定义 Bean 的支持</li><li>Spring-Context：运行时 Spring 容器</li><li>Spring-Context-Support：容器对第三方包的集成支持</li><li>Spring-Expression：使用表达式语言在运行时查询和操作对象</li></ul><h5 id="（2）AOP"><a href="#（2）AOP" class="headerlink" title="（2）AOP"></a>（2）AOP</h5><ul><li>Spring-AOP：基于代理的 AOP 支持</li><li>Spring-Aspects：基于 AspectJ 的 AOP 支持</li></ul><h5 id="（3）消息（Messaging）"><a href="#（3）消息（Messaging）" class="headerlink" title="（3）消息（Messaging）"></a>（3）消息（Messaging）</h5><ul><li>Spring-Messaging：对消息架构和协议的支持</li></ul><h5 id="（4）Web"><a href="#（4）Web" class="headerlink" title="（4）Web"></a>（4）Web</h5><ul><li>Spring-Web：提供基础的 Web 集成的功能，在 Web 项目中提供 Spring 的容器</li><li>Spring-Webmvc：提供基于 Servlet 的 Spring MVC</li><li>Spring-WebSocket：提供 WebSocket 功能</li><li>Spring-Webmvc-Portlet：提供 Portlet 环境功能</li></ul><h5 id="（5）数据访问-集成（Data-Access-Integration）"><a href="#（5）数据访问-集成（Data-Access-Integration）" class="headerlink" title="（5）数据访问/集成（Data Access/Integration）"></a>（5）数据访问/集成（Data Access/Integration）</h5><ul><li>Spring-JDBC：提供以 JDBC 访问数据库的支持</li><li>Spring-TX：提供编程式和声明式的事务支持</li><li>Spring-ORM：提供对对象/关系映射技术的支持</li><li>Spring-OXM：提供对对象/xml 映射技术的支持</li><li>Spring-JMS：提供对 JMS 的支持</li></ul><h4 id="1-Spring-的生态"><a href="#1-Spring-的生态" class="headerlink" title="1. Spring 的生态"></a>1. Spring 的生态</h4><p>Spring 发展到现在已经不仅仅是 Spring 框架本身的内容，Spring 目前提供了大量的基于 Spring 的项目，可以用来更深入地降低我们的开发难度，提高开发效率。<br>目前 Spring 的生态里主要有以下项目，我们可以根据自己项目的需要来选择使用相应的项目。</p><ul><li>Spring Boot：使用默认开发配置来实现快速开发</li><li>Spring XD：用来简化大数据应用开发</li><li>Spring Cloud：为分布式系统开发提供工具集</li><li>Spring Data：对主流关系型和 NoSQL 数据库的支持</li><li>Spring Integration：通过消息机制对企业集成模式（EIP）的支持</li><li>Spring Batch：简化及优化大量数据的批处理操作</li><li>Spring Security：通过认证和授权保护应用</li><li>Spring HATEOAS：基于 HATEOAS 原则简化 REST 服务开发</li><li>Spring Social：与社交网络 API（如：Facebook、新浪微博等）的集成</li><li>Spring AMQP：对基于 AMQP 的消息的支持</li><li>Spring Mobile：提供对手机设备检测的功能，给不同的设备返回不同的页面的功能</li><li>Spring for Android：主要提供在 Android 上消费 RESTful API 的功能</li><li>Spring Web Flow：基于 SpringMVC 提供基于向导流程式的 Web 应用开发</li><li>Spring Web Services：提供了基于协议有限的 SOAP/Web 服务</li><li>Spring LDAP：简化使用 LDAP 开发</li><li>Spring Session：提供一个 API 及实现来管理用户会话信息</li></ul><h2 id="二、Spring-项目快速搭建"><a href="#二、Spring-项目快速搭建" class="headerlink" title="二、Spring 项目快速搭建"></a>二、Spring 项目快速搭建</h2><p>这里我们使用目前 Java 主流的项目构建工具<a href="http://maven.apache.org/" target="_blank" rel="noopener">Maven</a>来搭建项目。</p><h3 id="（一）Maven-介绍"><a href="#（一）Maven-介绍" class="headerlink" title="（一）Maven 介绍"></a>（一）Maven 介绍</h3><p>Apache Maven 是一个基于项目对象模型（Project Object Model，POM）的软件项目管理工具。Maven 可用来管理项目的依赖、编译、打包、文档等信息。使用 Maven 来管理项目时，项目依赖的 jar 包将不再包含在项目内，而是集中放置在用户目录下的 .m2 文件夹下。关于 Maven 的详细安装介绍可参考<a href="http://blinkfox.com/linux-debianxia-mavende-an-zhuang-he-shi-yong/" target="_blank" rel="noopener">这里</a>。</p><h3 id="（二）创建项目"><a href="#（二）创建项目" class="headerlink" title="（二）创建项目"></a>（二）创建项目</h3><p>在创建项目之前，须确保你的计算机上已经安装好有 Java 和 Maven 环境。然后，打开终端通过以下简单的命令就可以在你的当前目录下创建一个 Jave web 的项目结构：</p><pre class=" language-bash"><code class="language-bash">mvn archetype:generate -DgroupId<span class="token operator">=</span>com.blinkfox -DartifactId<span class="token operator">=</span>springdemo -DpackageName<span class="token operator">=</span>com.blinkfox.springdemo -DarchetypeArtifactId<span class="token operator">=</span>maven-archetype-webapp -DinteractiveMode<span class="token operator">=</span>false</code></pre><p>其中<code>-DgroupId=com.blinkfox</code>是组织名，<code>-DartifactId=springdemo</code>是该组织下的项目名称，<code>-DarchetypeArtifactId=maven-archetype-webapp</code>代表创建一个简单的 webapp 项目。</p><p>创建项目的时候，Maven会自动下载一些需要用到的 jar 包和 Maven 插件。如果顺利创建成功的话，就会在你的当前目录下看到名为 springdemo 的项目，其中包含<code>src</code>的文件夹和<code>pom.xml</code>文件。且在你的终端会看到如下输出：</p><p><img src="http://static.blinkfox.com/maven_build_project.png" alt="Maven创建项目成功"></p><h3 id="（三）添加-Spring-依赖"><a href="#（三）添加-Spring-依赖" class="headerlink" title="（三）添加 Spring 依赖"></a>（三）添加 Spring 依赖</h3><p>接下来需要通过修改 pom.xml 来添加 Spring 的依赖，添加编译插件，且将编译级别设置为1.7，pom.xml文件的修改如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.blinkfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springdemo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>war<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>springdemo Maven Webapp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://maven.apache.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.3.3.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>finalName</span><span class="token punctuation">></span></span>springdemo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>finalName</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 指定maven的默认操作为 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>defaultGoal</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>defaultGoal</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>${java.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>${java.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h2 id="三、Spring-基础配置"><a href="#三、Spring-基础配置" class="headerlink" title="三、Spring 基础配置"></a>三、Spring 基础配置</h2><p>Spring 框架本身有四大原则：</p><ul><li>使用 POJO 进行轻量级和最小侵入式开发</li><li>通过依赖注入和面向接口编程来实现松耦合</li><li>通过 AOP 和默认习惯进行声明式编程</li><li>使用 AOP 和模板(template)减少模式化代码</li></ul><p>Spring 的所有功能设计和实现都是基于此四大原则。</p><h3 id="（一）依赖注入"><a href="#（一）依赖注入" class="headerlink" title="（一）依赖注入"></a>（一）依赖注入</h3><h4 id="1-重点说明"><a href="#1-重点说明" class="headerlink" title="1. 重点说明"></a>1. 重点说明</h4><p>我们经常说的控制反转（Inversion of Control，IoC）和依赖注入（dependency injection，DI）在 Spring 环境下是等同的概念，控制反转是通过依赖注入实现的。所谓依赖注入指的是容器负责创建对象和维护对象间的依赖关系，而不是通过对象本身负责自己的创建和解决自己的依赖。</p><p>依赖注入的主要目的是为了解耦，体现了一种“组合”的理念。如果你希望你的类具备某项功能的时候，是继承自一个具有此功能的父类好呢？还是组合另外一个具有这个功能的类好呢？答案是不言而喻的，继承一个父类，之类将与父类耦合，组合另外一个类则使耦合度大大降低。</p><p>Spring IoC 容器（ApplicationContext）负责创建 Bean，并通过容器将功能类 Bean 注入到你需要的 Bean 中。Spring 提供使用 xml、注解、Java 配置、groovy 配置实现 Bean 的创建和注入。</p><p>无论是 xml 配置、注解配置还是 Java 配置，都被称为配置元数据，所谓元数据即描述数据的数据。元数据本身不具备任何可执行的能力，只能通过外界代码来对这些元数据行解析后进行一些有意义操作。Spring 容器解析这些配置元数据进行 Bean 初始化、配置和管理依赖。</p><p>声明 Bean 的注解：</p><ul><li><code>@Component</code>: 组件，没有明确角色</li><li><code>@Controller</code>: 在展现层（MVC -&gt; Spring MVC）使用</li><li><code>@Service</code>: 在业务逻辑层（service层）使用</li><li><code>@Repository</code>: 在数据访问层（dao层）使用</li></ul><p>注入 Bean 的注解，一般情况下通用：</p><ul><li><code>@Autowired</code>: Spring 提供的注解</li><li><code>@Inject</code>: JSR-330 提供的注解</li><li><code>@Resource</code>: JSR-250 提供的注解</li></ul><p><code>@Autowired</code>、<code>@Inject</code>、<code>@Resource</code>可注解在 set 方法上或者属性上，推荐注解在属性上，优点是代码更少、层次更清晰。</p><h4 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h4><p>（1）编写功能类的 Bean。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/27. */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FunctionService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello "</span> <span class="token operator">+</span> word <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 @Service 注解声明当前 FunctionService 类是 Spring 管理的一个 Bean。其中，使用 @Component、@Service、@Repository、@Controller 是等效的，可根据需要选用。</li></ol></blockquote><p>（2）使用功能类的 Bean。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/27. */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UseFunctionService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> FunctionService functionService<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> functionService<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 @Service 注解声明当前 UseFunctionService 类是 Spring 管理的一个 Bean。</li><li>使用 @Autowired 将 FunctionService 的实体 Bean 注入到 UseFunctionService 中，让 UseFunctionService 具备 FunctionService 的功能，此处使用 JSR-330 的 @Inject 注解或者 JSR-250 的 @Resource 注解是等效的。</li></ol></blockquote><p>（3）配置类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>config<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ComponentScan<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/27. */</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.blinkfox.service.impl"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DiConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 @Configuration 注解声明当前类是一个配置类。</li><li>使用 @ComponentScan 将 自动扫描包名下所有使用的 @Component、@Service、@Repository、@Controller 类，并注册为 Bean。</li></ol></blockquote><p>（4）运行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>maintest<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>config<span class="token punctuation">.</span>DiConfig<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UseFunctionService<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AnnotationConfigApplicationContext<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/27. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FunctionMain</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext context <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>DiConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        UseFunctionService useFunctionService <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>UseFunctionService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>useFunctionService<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"Spring"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 AnnotationConfigApplicationContext 作为 Spring 容器，接收使用一个配置类作为参数。</li><li>获得声明配置的 UseFunctionService 的 Bean。</li></ol></blockquote><h3 id="（二）Java-配置"><a href="#（二）Java-配置" class="headerlink" title="（二）Java 配置"></a>（二）Java 配置</h3><h4 id="1-重点说明-1"><a href="#1-重点说明-1" class="headerlink" title="1. 重点说明"></a>1. 重点说明</h4><p>Java 配置是 Spring4.x 推荐的配置方式，可以完全替代 xml 配置；Java 配置也是 Spring Boot 推荐的配置方式。</p><p>Java 配置是通过 @Configuration 和 @Bean 来实现的。</p><ul><li>@Configuration 声明当前类是一个配置类，相当于一个Spring配置的 xml 文件。</li><li>@Bean 注解在方法上，声明当前方法的返回值是一个 Bean。</li></ul><p>何时使用 Java 配置或者注解配置呢？我们主要的原则是：全局配置使用 Java 配置（如数据库相关配置、MVC相关配置），业务 Bean 的配置使用注解配置（@Service、@Component、@Repository、@Controller）。</p><h4 id="2-Java配置代码示例"><a href="#2-Java配置代码示例" class="headerlink" title="2. Java配置代码示例"></a>2. Java配置代码示例</h4><p>（1）编写功能类的 Bean</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/27. */</span><span class="token comment" spellcheck="true">// 1</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaConfigService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello "</span> <span class="token operator">+</span> word <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>此处没有使用 @Service 声明 Bean。</li></ol></blockquote><p>（2）使用功能类的 Bean</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/27. */</span><span class="token comment" spellcheck="true">// 1</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UseJavaConfigService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 2</span>    <span class="token keyword">private</span> JavaConfigService javaConfigService<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setJavaConfigService</span><span class="token punctuation">(</span>JavaConfigService javaConfigService<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>javaConfigService <span class="token operator">=</span> javaConfigService<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> javaConfigService<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>此处没有使用 @Service 声明 Bean。</li><li>此处没有使用 @Autowired 注解注入 Bean。</li></ol></blockquote><p>（3）Java 配置类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>config<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>JavaConfigService<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UseJavaConfigService<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/27. */</span><span class="token annotation punctuation">@Configuration</span> <span class="token comment" spellcheck="true">// 1</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>  <span class="token comment" spellcheck="true">// 2</span>    <span class="token keyword">public</span> JavaConfigService <span class="token function">javaConfigService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JavaConfigService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> UseJavaConfigService <span class="token function">useJavaConfigService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        UseJavaConfigService useJavaConfigService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UseJavaConfigService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        useJavaConfigService<span class="token punctuation">.</span><span class="token function">setJavaConfigService</span><span class="token punctuation">(</span><span class="token function">javaConfigService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>        <span class="token keyword">return</span> useJavaConfigService<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 @Configuration 注解表明当前类是一个配置类，这意味着这个类型里可能有0个或者多个 @Bean 注解，此处没有使用包扫描，是因为所有的 Bean 都在此类中定义了。</li><li>使用 @Bean 注解声明当前方法 JavaConfigService 的返回值是一个 Bean，Bean的名称是方法名。</li><li>注入 FunctionService 的 Bean 时候直接调用 javaConfigService()。</li></ol></blockquote><p>（4）运行</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>maintest<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>config<span class="token punctuation">.</span>JavaConfig<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UseJavaConfigService<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AnnotationConfigApplicationContext<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/27. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaConfigMain</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext context <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>JavaConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        UseJavaConfigService useJavaConfigService <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>UseJavaConfigService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>useJavaConfigService<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"Spring Java Config"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="（三）AOP"><a href="#（三）AOP" class="headerlink" title="（三）AOP"></a>（三）AOP</h3><h4 id="1-重点说明-2"><a href="#1-重点说明-2" class="headerlink" title="1. 重点说明"></a>1. 重点说明</h4><p>AOP：面向切面编程，是面向对象编程（OOP）的补充。</p><p>Spring 的 AOP 的存在目的是为了解耦。AOP 可以让一组类共享相同的行为。在 OOP 中只能通过继承和实现接口来共享相同的行为，从而使代码的耦合度增强，且类继承只能为单继承，阻碍更多行为添加到一组类上，AOP 弥补了 OOP 的不足。</p><p>Spring 支持 AspectJ 的注解式切面编程。</p><ul><li>使用 @AspectJ 声明是一个切面。</li><li>使用 @After、@Before、Around 定义通知（advice）类型，可直接将拦截规则（切点）作为参数。</li><li>其中 @After、@Before、Around 参数的拦截规则为切点（PointCut），为了使切点复用，可使用 @PointCut 专门定义拦截规则，然后在 @After、@Before、Around 的参数中调用。</li><li>其中符合条件的每一个拦截处为连接点（JoinPoint）。</li></ul><p>Spring本身在事务处理（@Transcational）和数据缓存（@Cacheable）等都使用注解拦截。下面示例将演示基于注解和方法规则的拦截方式，演示一种模拟记录操作的日志系统的实现。</p><h4 id="2-注解拦截代码示例"><a href="#2-注解拦截代码示例" class="headerlink" title="2. 注解拦截代码示例"></a>2. 注解拦截代码示例</h4><p>（1）添加 Spring aop 支持及 AspectJ 依赖。</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>aop<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">4.3</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">.</span>RELEASE<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>aspectj<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>aspectjrt<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.8</span><span class="token punctuation">.</span><span class="token number">9</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>aspectj<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>aspectjweaver<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.8</span><span class="token punctuation">.</span><span class="token number">9</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p>（2）编写拦截规则的注解。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>annotation<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/29. */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">LogAction</span> <span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"这是默认的操作名称"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>代码解释</strong>：<br>注解本身是没有功能的，就和 xml 一样。注解和 xml 都是一种元数据，元数据即解释数据的数据，这就是所谓的配置。注解的功能来自用这个注解的地方。</p></blockquote><p>（3）编写使用注解的被拦截类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>LogAction<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/29. */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoAnnotationService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@LogAction</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"注解式拦截的 add 操作"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（4）编写使用方法规则被拦截规类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/29. */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoMethodService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（5）编写切面。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>aop<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>LogAction<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>JoinPoint<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>After<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Aspect<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Pointcut<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>MethodSignature<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/29. */</span><span class="token annotation punctuation">@Aspect</span> <span class="token comment" spellcheck="true">// 1</span><span class="token annotation punctuation">@Component</span> <span class="token comment" spellcheck="true">// 2</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogAspect</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(com.blinkfox.annotation.LogAction)"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">annotationPointCut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"annotationPointCut()"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 4</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MethodSignature signature <span class="token operator">=</span> <span class="token punctuation">(</span>MethodSignature<span class="token punctuation">)</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method method <span class="token operator">=</span> signature<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LogAction logAction <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>LogAction<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---注解式拦截:"</span> <span class="token operator">+</span> logAction<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"execution(* com.blinkfox.service.impl.DemoMethodService.*(..))"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 6</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MethodSignature signature <span class="token operator">=</span> <span class="token punctuation">(</span>MethodSignature<span class="token punctuation">)</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method method <span class="token operator">=</span> signature<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---方法规则式拦截:"</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>通过 @Aspect 注解声明一个切面。</li><li>通过 @Component 让此切面成为 Spring 容器管理的Bean。</li><li>通过 @PointCut 注解声明切点。</li><li>通过 @After 注解声明一个通知类型，并使用 @PointCut定义的切点。</li><li>通过可获得注解上的属性，然后做日志记录相关的操作，下面相同。</li><li>通过 @Before 注解声明一个通知类型，此通知直接使用拦截规则作为参数。</li></ol></blockquote><p>（6）配置类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>config<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ComponentScan<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>EnableAspectJAutoProxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/29. */</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.blinkfox"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AopConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 @EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ的支持。</li></ol></blockquote><p>（6）运行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>maintest<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>config<span class="token punctuation">.</span>AopConfig<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>DemoAnnotationService<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>DemoMethodService<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AnnotationConfigApplicationContext<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by blinkfox on 2016/10/29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AopMain</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext context <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>AopConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DemoAnnotationService demoAnnotationService <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>DemoAnnotationService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DemoMethodService demoMethodService <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>DemoMethodService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demoAnnotationService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demoMethodService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之工厂方法模式</title>
      <link href="/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-gong-han-fang-fa-mo-shi/"/>
      <url>/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-gong-han-fang-fa-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><p>工厂方法模式(<code>Factory Method Pattern</code>)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>工厂方法模式包含如下角色：</p><ul><li><code>Product</code>：抽象产品</li><li><code>ConcreteProduct</code>：具体产品</li><li><code>Factory</code>：抽象工厂</li><li><code>ConcreteFactory</code>：具体工厂</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/FactoryMethod.jpg" alt="工厂方法模式结构图"></p><h3 id="3-时序图"><a href="#3-时序图" class="headerlink" title="3. 时序图"></a>3. 时序图</h3><p><img src="http://static.blinkfox.com/seq_FactoryMethod.jpg" alt="工厂方法模式时序图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是抽象的产品类和具体的产品类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象产品类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 产品类的公共方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是产品类的公共方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体产品类1 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct1</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteProduct1的method2方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体产品类2 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct2</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteProduct2的method2方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是抽象的工厂类和具体的工厂类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的工厂类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体生产产品的工厂类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式客户端场景类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Factory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>工厂方法模式的优点：</p><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>工厂方法模式的缺点：</p><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用工厂方法模式：</p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h2 id="五、模式扩展"><a href="#五、模式扩展" class="headerlink" title="五、模式扩展"></a>五、模式扩展</h2><p>工厂方法模式有很多扩展，而且与其他模式结合使用威力更大，下面介绍4种常用扩展。</p><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>我们这样考虑一个问题：一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了。因此去掉工厂类中继承的抽象类，把方法改成静态即可。通用代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 简单工厂模式中的工厂类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 简单工厂模式客户端场景类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product1 <span class="token operator">=</span> SimpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product2 <span class="token operator">=</span> SimpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果没有发生变化，但是类图简单了，调用者也比较简单，简单工厂模式是工厂方法模式的弱化，也叫做静态工厂模式。其缺点是工厂类的扩展比较困难，不符合“开闭原则”，但它仍然是一个非常实用的设计模式。</p><h3 id="2-多工厂类工厂方法模式"><a href="#2-多工厂类工厂方法模式" class="headerlink" title="2. 多工厂类工厂方法模式"></a>2. 多工厂类工厂方法模式</h3><p>当我们在一个比较复杂的项目时，经常会遇到初始化一个对象很耗费精力的情况，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为了让结构清晰，我们就为每类产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。多工厂模式的通用代码如下：</p><p>多工厂模式的抽象工厂类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成多个产品的抽象工厂类 * Created by blinkfox on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成某种产品的方法     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第一种产品的创建工厂实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成产品1的具体工厂类1 * Created by blinkfox on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成产品1的方法     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第二种产品的创建工厂实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成产品2的具体工厂类2 * Created by blinkfox on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成产品2的方法     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>多工厂模式的客户端场景类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 多工厂方法模式客户端场景类 * Created by blinkfox on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product concreteProduct1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product concreteProduct2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFactory2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-工厂方法的单例模式"><a href="#3-工厂方法的单例模式" class="headerlink" title="3. 工厂方法的单例模式"></a>3. 工厂方法的单例模式</h3><p>单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生成一个对象，从而实现单例的功能。</p><p>下面是单例类，其中定义了一个private的无参构造函数，目的是不允许通过new的方式创建对象，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式中的单例类 * Created by blinkfox on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 私有化构造方法，不允许new产生一个对象     */</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 工厂方法模式中的单例模式业务方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"工厂方法模式中的单例模式方法。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上单例类中不能通过正常的渠道建立一个对象，那单例的工厂类中如何建立一个单例对象呢？答案是通过反射方式创建，单例工厂类的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成单例的工厂类 * Created by blinkfox on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Class <span class="token class-name">c</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获得无参构造</span>            Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置无参构造是可访问的</span>            constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 产生一个实例对象</span>            singleton <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生成单例的工厂类方法中生成单例出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>zuihou        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后是工厂方法单例模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法单例模式客户端场景类 * Created by blinkfox on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Singleton singleton <span class="token operator">=</span> SingletonFactory<span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        singleton<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-工厂方法的延迟初始化"><a href="#4-工厂方法的延迟初始化" class="headerlink" title="4. 工厂方法的延迟初始化"></a>4. 工厂方法的延迟初始化</h3><p>何为延迟初始化？一个对象被消费完毕后，并不立即释放，工厂类保持其初始状态，等待再次使用。延迟初始化是工厂模式的一个扩展应用，其通用代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 延迟加载的工厂类 * Created by blinkfox on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span> lazyMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果map中已经有这个对象，则直接取出该对象即可，否则创建并放在缓存容器中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> lazyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 根据类型创建具体的产品对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 同时把对象放到缓存容器中</span>        lazyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面即为延迟加载的工厂类。代码比较简单，通过定义一个<code>map</code>容器来容纳所有产生的对象，如果在<code>map</code>容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到<code>map</code>容器中，以便下次调用。</p><p>延迟加载的工厂模式客户端场景类代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 延迟加载的工厂模式客户端场景类 * Created by blinkfox on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product1 <span class="token operator">=</span> LazyFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product11 <span class="token operator">=</span> LazyFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li><li>工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li><li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li><li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li><li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之装饰模式</title>
      <link href="/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhuang-shi-mo-shi/"/>
      <url>/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhuang-shi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li><strong>继承机制</strong>，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li><strong>关联机制</strong>，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li></ul><p><strong>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。<strong>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展</strong>。这就是装饰模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)</strong>，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p></blockquote><p>策略模式是一种<strong>对象结构型</strong>模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>装饰模式包含如下角色：</p><ul><li><code>Component</code>: 抽象构件</li><li><code>ConcreteComponent</code>: 具体构件</li><li><code>Decorator</code>: 抽象装饰类</li><li><code>ConcreteDecorator</code>: 具体装饰类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://static.blinkfox.com/Decorator.jpg" alt="装饰模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/seq_Decorator.jpg" alt="装饰模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个抽象构件接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象构件 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 接口方法</span>    <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后是具体构件实现类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体构件 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do Something..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接着是装饰角色：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰角色 * 维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Component component<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 委托给被修饰者执行     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面是具体的装饰类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的装饰类1 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator1</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator1</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 定义自己的修饰方法1     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method1修饰..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写父类的operate方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的装饰类2 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator2</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator2</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 定义自己的修饰方法2     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method2修饰..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写父类的operate方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后是客户端的场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰模式的客户端场景类 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Component component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第一修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator1</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第二修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator2</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 修饰后运行</span>        component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li><strong>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</strong>。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，<em>关联关系的缺点是比继承关系要创建更多的对象</em>。</li><li><strong>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任</strong>。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>装饰模式的优点：</p><ul><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>装饰模式的缺点：</p><ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用装饰模式：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>装饰模式的简化-需要注意的问题:</p><ul><li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。</li><li>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。</li><li>装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。</li><li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动 态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子 类的情况下，将对象的功能加以扩展。</li><li>装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li><li>装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。</li><li>装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之策略模式</title>
      <link href="/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ce-lue-mo-shi/"/>
      <url>/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ce-lue-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(<code>Hard Coding</code>)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</p><p>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p><p>为了解决这些问题，可以<strong>定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类</strong>。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)</strong>。</p></blockquote><p>策略模式是一种对象行为型模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>策略模式包含如下角色：</p><ul><li>Context: 环境类</li><li>Strategy: 抽象策略类</li><li>ConcreteStrategy: 具体策略类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://static.blinkfox.com/Strategy1.jpg" alt="策略模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/strategy2.jpg" alt="策略模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个策略接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 策略模式的运算法则     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后是具体的策略实现类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStrategy1</span> <span class="token keyword">implements</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略的策略方法1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStrategy2</span> <span class="token keyword">implements</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略的策略方法2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接着是封装角色的类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 抽象策略</span>    <span class="token keyword">private</span> IStrategy strategy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造函数设置具体策略     * @param strategy     */</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>IStrategy strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 封装后的策略方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后是客户端的调用策略类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 声明一个具体的策略</span>        IStrategy strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteStrategy1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 声明上下文对象</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行封装后的方法</span>        context<span class="token punctuation">.</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“<strong>准备一组算法，并将每一个算法封装起来，使得它们可以互换</strong>”。</li><li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li><li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>策略模式的优点：</p><ul><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基- 础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。</li><li>策略模式提供了可以替换继承关系的办法。</li><li>使用策略模式可以避免使用多重条件转移语句。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>策略模式的缺点：</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>策略模式与状态模式：</p><ul><li>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</li><li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</li><li>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</li><li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。</li><li>策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。</li><li>策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</li><li>策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。</li><li>策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript基础教程</title>
      <link href="/2018/09/14/qian-duan/javascript-ji-chu-jiao-cheng/"/>
      <url>/2018/09/14/qian-duan/javascript-ji-chu-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JavaScript介绍"><a href="#一、JavaScript介绍" class="headerlink" title="一、JavaScript介绍"></a>一、JavaScript介绍</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript</a>是目前所有主流浏览器上唯一支持的脚本语言，这也是早期<code>JavaScript</code>的唯一用途。其主要作用是在不与服务器交互的情况下修改<code>HTML</code>页面内容，因此其最关键的部分是<code>DOM</code>（文档对象模型），也就是<code>HTML</code>元素的结构。通过<code>Ajax</code>可以使<code>HTML</code>页面通过<code>JavaScript</code>，在不重新加载页面的情况下从服务器上获取数据并显示，大幅提高用户体验。通过<code>JavaScript</code>，使<code>Web</code>页面发展成胖客户端成为可能。</p><h3 id="语言的性质"><a href="#语言的性质" class="headerlink" title="语言的性质"></a>语言的性质</h3><p>本节对<code>JavaScript</code>的性质做简要介绍，以帮你理解一些疑问。</p><p><code>JavaScript</code>和<code>ECMAScript</code>（JavaScript versus ECMAScript）<br>编程语言称为<code>JavaScript</code>，语言标准被称为<code>ECMAScript</code>。他们有不同名字的原因是因为“Java”已经被注册为商标（属于Oracle）。目前，只有<code>Mozilla</code>被正式允许使用“JavaScript”名称，因为很久以前他们得到一份许可。因此，开放的语言标准拥有不同的名字。当前的<code>JavaScript</code>版本是<code>ECMAScript 6</code>，<code>ECMAScript 7</code>当前是开发版。</p><p><code>JavaScript</code>之父，<code>Brendan Eich</code><a href="http://yanhaijing.com/javascript/2013/06/22/javascript-designing-a-language-in-10-days/" target="_blank" rel="noopener">迅速了创建一门编程语言</a>。（否则，Netscape将使用其他技术）。他借鉴了几门其他语言的一些特性：</p><ul><li>JavaScript借鉴了Java的语法和如何区分原始值和对象。</li><li>JavaScript的函数设计受Scheme和AWK的启发——他们（的函数）都是第一类（first-class）对象，并且在语言中广泛使用。闭包使他们（函数）变成强大的工具。</li><li>Self影响了JavaScript独一无二的面向对象编程(OOP)风格。它的核心思想（在这里我们没有提到）非常优雅，基于此创建的语言非常少。但后面会提到一个简单的模式照顾大部分用例。JavaScript面向对象编程的杀手级特性是你可以直接创建对象。不需要先创建类或其他类似的东西。</li><li>Perl和Python影响了JavaScript字符串，数组和正则表达式的操作。</li></ul><p><code>JavaScript</code>在最初的时候并不是一个完善的语言，因此也导致<code>JavaScript</code>遗留了很多令人诟病的问题。在开发稍大规模的应用时会显得力不从心，但是由于<code>JavaScript</code>本身是一种非常灵活的语言，因此在它的基础上开发程序库比较容易，因此出现了一大批非常优秀的第三方库，如<a href="http://jquery.com/" target="_blank" rel="noopener">jQuery</a>，<a href="http://extjs.org.cn/" target="_blank" rel="noopener">ExtJS</a>，<a href="http://underscorejs.org/" target="_blank" rel="noopener">underscorejs</a>，<a href="http://backbonejs.org/" target="_blank" rel="noopener">backbone</a>等等，由于这些第三方库，<code>JavaScript</code>变得非常简单。其中<code>jQuery</code>的使用非常广泛，它大幅简化了<code>DOM</code>和<code>Ajax</code>，已经成为了很多网站的标配。<code>jQuery</code>虽然基于<code>JavaScript</code>，但它提供了另外一种编程范式，也就是逻辑式编程，与<code>SQL</code>和正则表达式类似。</p><h3 id="JavaScript能做什么"><a href="#JavaScript能做什么" class="headerlink" title="JavaScript能做什么"></a>JavaScript能做什么</h3><p><img src="http://static.blinkfox.com/js1.png" alt="JavaScript项目在Github所占比例"></p><p>如上图，<code>JavaScript</code>作为<a href="https://github.com/" target="_blank" rel="noopener">Github</a>上最流行、最火的编程语言，几乎无所不能。这里是<a href="https://segmentfault.com/u/puyart" target="_blank" rel="noopener">PuYart</a>的关于<a href="https://segmentfault.com/a/1190000003767058" target="_blank" rel="noopener"><code>JavaScript</code>就要统治世界了</a>的文章，可以让我们了解<code>JavaScript</code>到底能做什么的一些介绍。</p><ol><li>Web前端(各种前端工具类库、前端框架、动画效果、数据可视化等)</li><li>服务端开发(<a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a>)</li><li>移动应用或者<code>Hybrid App</code>(Cordova)</li><li>桌面应用(<a href="http://nwjs.io/" target="_blank" rel="noopener">NW.js</a>、<a href="http://electron.atom.io/" target="_blank" rel="noopener">Electron</a>)</li><li>游戏(<a href="http://unity3d.com/cn/" target="_blank" rel="noopener">Unity3D</a>、<a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/cocos2d-js/catalog/../1-about-cocos2d-js/1-1-a-brief-history/zh.md" target="_blank" rel="noopener">Cocos2d-js</a>、<a href="http://pomelo.netease.com/" target="_blank" rel="noopener">Pomelo</a>)</li><li>VR(<a href="https://www.phodal.com/blog/why-javascript-will-use-vr-world/" target="_blank" rel="noopener">JavaScript在VR世界的应用</a>)</li><li>硬件、嵌入式物联网等(<a href="http://blog.jobbole.com/46055/" target="_blank" rel="noopener">Tessel：用JavaScript做嵌入式开发</a>)</li><li>操作系统(<a href="http://node-os.com/" target="_blank" rel="noopener">NodeOS</a>)</li></ol><blockquote><p>Atwood’s Law: any application that can be written in JavaScript, will eventually be written in JavaScript.(Atwood定律：凡是能用JavaScript写出来的，最终都会用JavaScript写出来。)</p></blockquote><h2 id="二、-JavaScript语法"><a href="#二、-JavaScript语法" class="headerlink" title="二、 JavaScript语法"></a>二、 JavaScript语法</h2><h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><p>了解<code>JavaScript</code>的语法，先来了解两个主要的语法类型：语句和表达式。</p><ul><li>语句通常是“做某些事情”。程序是一组语句的序列。举个例子，下面声明（创建）一个变量 <code>foo</code>： </li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> foo<span class="token punctuation">;</span></code></pre><ul><li>表达式是产生“值”。他们通常位于赋值操作的右边、函数参数等。举个例子： </li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token number">3</span> <span class="token operator">*</span> <span class="token number">7</span></code></pre><p>语句和表达式之间的区别最好通过实例说明，<code>JavaScript</code>（像Java）有两种不同的方式实现<code>if-then-else</code>。一种是用语句：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> x<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    x <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    x <span class="token operator">=</span> <span class="token operator">-</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>另一种是表达式：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> y <span class="token punctuation">:</span> <span class="token operator">-</span>y<span class="token punctuation">;</span></code></pre><p>你可以将后者作为函数参数（但前者不行）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">myFunction</span><span class="token punctuation">(</span>y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> y <span class="token punctuation">:</span> <span class="token operator">-</span>y<span class="token punctuation">)</span></code></pre><p>最后，每当<code>JavaScript</code>期待一个语句，你也可以用一个表达式代替。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>foo(...);</code>是一个语句（也叫做表达式语句），<code>bar(7, 1)</code>则是一个表达式。他们都实现函数调用。</p><h3 id="流程控制语句和语句块"><a href="#流程控制语句和语句块" class="headerlink" title="流程控制语句和语句块"></a>流程控制语句和语句块</h3><p>流程控制语句，其语句体可以是单条语句。举两个例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> x<span class="token operator">--</span><span class="token punctuation">;</span></code></pre><p>然而，任何语句总能被语句块代替，花括号包含零或多条语句。因此，你也可以这样写：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    x<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>为便于程序的阅读和维护，推荐使用后一种方式，即语句块方式。</p><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p><code>JavaScript</code>中的分号是<a href="http://www.2ality.com/2011/05/semicolon-insertion.html" target="_blank" rel="noopener">可选的</a>。但省略（分号）可能会带来意想不到的结果，所以我建议还是写上分号。</p><p>正如上面所看到的，分号作为语句的结尾，但语句块不需要。仅有一种情况下你能看到语句块后面有分号——<strong>函数表达式后面的函数体块</strong>。<strong>表达式作为语句的结尾，后面是分号</strong>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>JavaScript</code>的注释有两种形式：单行注释和多行注释。单行注释以<code>//</code>开头，以换行符结尾：</p><pre class=" language-javascript"><code class="language-javascript">x<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 单行（single-line）注释</span></code></pre><p>多行注释用<code>/**/</code>包裹</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/*  这是多行注释 多行哦 */</span></code></pre><h2 id="三、变量和赋值"><a href="#三、变量和赋值" class="headerlink" title="三、变量和赋值"></a>三、变量和赋值</h2><p><code>JavaScript</code>中的变量在使用前必须先声明，否则会报错引用错误（Reference Error）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> foo<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 声明变量“foo”</span></code></pre><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>你可以在声明变量的同时为其赋值：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span></code></pre><p>你也可以给已经存在的变量重新赋值：</p><pre class=" language-javascript"><code class="language-javascript">foo <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 更改变量的值</span></code></pre><h3 id="复合赋值操作符"><a href="#复合赋值操作符" class="headerlink" title="复合赋值操作符"></a>复合赋值操作符</h3><p>有很多复合赋值操作符，例如+=。下面的两个赋值操作等价：</p><pre class=" language-javascript"><code class="language-javascript">x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><h3 id="标识符和变量名"><a href="#标识符和变量名" class="headerlink" title="标识符和变量名"></a>标识符和变量名</h3><p>标识符就是事物的名字，在<code>JavaScript</code>中他们扮演不同的语法角色。例如，变量的名称是一个标识符。</p><p>大体上，标识符的第一个字符可以是任何<code>Unicode</code>字符、美元标志符（$）或下划线（_）。后面可以是任意字符和数字。因此，下面全是合法的标识符：</p><pre class=" language-javascript"><code class="language-javascript">arg0_tmp$elemπ</code></pre><blockquote><p><strong>注意</strong>：首字符不能是数字，如果是数字的话，该如何区分是数字还是变量呢？</p></blockquote><p>一些标识符是“保留关键字”——他们是语法的一部分，不能用作变量名。从技术上讲，下面三个标识符不是保留字，但也不应该作为变量名：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">Infinity</span> <span class="token number">NaN</span> undefined</code></pre><h2 id="四、值"><a href="#四、值" class="headerlink" title="四、值"></a>四、值</h2><p><code>JavaScript</code>有所有我们期待的编程语言值类型：布尔，数字，字符串，数组等。<code>JavaScript</code>中的所有值都有属性。每个属性有一个键（或名字）和一个值。你可以使用点（.）操作符读取属性：</p><pre class=" language-javascript"><code class="language-javascript">value<span class="token punctuation">.</span>propKey</code></pre><p>举个例子：字符串<code>abc</code>有属性<code>lenght</code>（长度）</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 得到3</span></code></pre><p>上面的代码也可以写成下面这样：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'abc'</span><span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">// 得到3</span></code></pre><p>点操作符也可以用来给属性赋值：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 空对象</span>obj<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建属性“foo”，设置它为123</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 得到123</span></code></pre><p>你也可以通过它（.）调用方法：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'hello'</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 得到HELLO</span></code></pre><p>上面，我们在值<code>hello</code>上面调用方法<code>toUpperCase()</code>。</p><h3 id="原始类型值和对象"><a href="#原始类型值和对象" class="headerlink" title="原始类型值和对象"></a>原始类型值和对象</h3><p>JavaScript定义了不同值之间的区别：</p><ul><li>原始值包括：<code>boolean</code>，<code>number</code>，<code>string</code>，<code>null</code>和<code>undefined</code>。</li><li>所有其他的值都是对象。实际上对象被定义为——所有不为原始值的值。</li></ul><p>两者之间的主要区别在于他们是如何被比较的：每一个对象有一个独一无二的标志，并且仅和自己相等：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 一个空对象</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 另一个空对象</span>obj1 <span class="token operator">===</span> obj2   <span class="token comment" spellcheck="true">// false</span>obj1 <span class="token operator">===</span> obj1   <span class="token comment" spellcheck="true">// true</span></code></pre><p>相反，所有原始值只要编码值相同就被认为是相同的：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> prim1 <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">var</span> prim2 <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>prim1 <span class="token operator">===</span> prim2 <span class="token comment" spellcheck="true">// true</span></code></pre><h3 id="原始类型值"><a href="#原始类型值" class="headerlink" title="原始类型值"></a>原始类型值</h3><p>下面全是原始类型值（简称：原始值）：</p><ul><li>布尔类型：true，false</li><li>数字类型：1736，1.351</li><li>字符串类型: ‘abc’，”abc”</li><li><p>两个“无值（non-values）”：undefined，null<br>原始值的特征：</p></li><li><p><strong>值做比较时,“内容”做比较</strong>。</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token number">3</span> <span class="token operator">===</span> <span class="token number">3</span> <span class="token comment" spellcheck="true">// true</span><span class="token string">'abc'</span> <span class="token operator">===</span> <span class="token string">'abc'</span> <span class="token comment" spellcheck="true">// true</span></code></pre><ul><li><strong>无法更改</strong>：值的属性无法更改，无法添加和移除属性，获取未知属性总返回undefined。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// try to create property `foo` ⇒ no effect</span>str<span class="token punctuation">.</span>foo  <span class="token comment" spellcheck="true">// unknown property ⇒  undefined</span></code></pre><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象的类型"><a href="#对象的类型" class="headerlink" title="对象的类型"></a>对象的类型</h4><p>所有非原始值的值都是对象。最常见的几种对象类型是：</p><ul><li>简单对象（类型是<code>Object</code>）能通过对象字面量创建：</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>    firstName<span class="token punctuation">:</span> ‘Jane’<span class="token punctuation">,</span>     lastName<span class="token punctuation">:</span> ‘Doe’<span class="token punctuation">}</span></code></pre><p>上面的对象有两个属性：<code>firstName</code>属性的值是“Jane”，<code>lastName</code>属性的值是“Doe”。</p><ul><li>数组（类型是<code>Array</code>）能通过数组字面量创建：</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span> ‘apple’<span class="token punctuation">,</span> ‘banana’<span class="token punctuation">,</span> ‘cherry’ <span class="token punctuation">]</span></code></pre><p>上面的数组有三个元素，可以通过数字索引访问。例如“apple”的索引是0。</p><ul><li>正则表达式对象（类型是<code>RegExp</code>）能通过正则表达式字面量创建。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token regex">/^a+b+$/</span></code></pre><h4 id="对象的特征"><a href="#对象的特征" class="headerlink" title="对象的特征"></a>对象的特征</h4><ul><li><strong>比较的是引用</strong>：比较的是标识符，每个值有自己的标识符。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">===</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 两个不同的空对象, false</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> obj1<span class="token punctuation">;</span>obj1 <span class="token operator">===</span> obj2   <span class="token comment" spellcheck="true">// true</span></code></pre><ul><li><strong>默认可以更改</strong>。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>foo <span class="token comment" spellcheck="true">//123</span></code></pre><p>所有的数据结构（如数组）都是对象，但并不是所有的对象都是数据结构。例如：正则表达式是对象，但不是数据结构。</p><h3 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h3><p><code>JavaScript</code>有两个“无值）”：<code>undefined</code>和<code>null</code>。</p><p><code>undefined</code>的意思是“没有值”。未初始化的变量是<code>undefined</code>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> foo<span class="token punctuation">;</span>foo <span class="token comment" spellcheck="true">// undefined</span></code></pre><p>读取不存在的属性时，将返回<code>undefined</code>：</p><pre class=" language-javascript"><code class="language-javascript">  <span class="token operator">></span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 空对象</span>  <span class="token operator">></span> obj<span class="token punctuation">.</span>foo <span class="token comment" spellcheck="true">// undefined</span></code></pre><p>缺省的参数也是<code>undefined</code>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//undefined</span></code></pre><p><code>null</code>的意思是“没有对象”。它被用来表示对象的无值（参数，链上的对象等）。</p><p>通常情况下你应该把<code>undefined</code>和<code>null</code>看成是等价的，如果他们代表相同意义的无值的话。检查他们的一种方式是通过严格比较：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> undefined <span class="token operator">||</span> x <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token punctuation">}</span></code></pre><p>另一种在实际中使用的方法是认为undefined 和 null 都是false：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>警告</strong>：false，0，NaN 和 “” 都被当作false。</p></blockquote><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>对象类型的实例<code>Foo</code>（包括内建类型，例如Array和其他自定义类型）从对象<code>Foo.prototype</code>上获取方法。你可以通过读取这个方法的方式（不是调用）验证这点：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>push <span class="token operator">===</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push  <span class="token comment" spellcheck="true">// true</span></code></pre><p>相反，<strong>原始类型是没有类型的，所以每个原始类型有一个关联类型，称之为包装类型</strong>：</p><ul><li>布尔值的包装类型是 Boolean。布尔值从Boolean.prototype上获取方法：</li></ul><pre class=" language-javascript"><code class="language-javascript">  <span class="token operator">></span> <span class="token boolean">true</span><span class="token punctuation">.</span>toString <span class="token operator">===</span> Boolean<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString    <span class="token comment" spellcheck="true">//true</span></code></pre><blockquote><p>注意：包装类型名字的首字母是大写的B。如果在JavaScript中布尔值的类型可以访问，那么它可能会被转换为布尔对象。</p></blockquote><ul><li>数字值的包装类型是<code>Number</code>。</li><li>字符串值的包装类型是<code>String</code>。</li></ul><p>包装类型也有实例（他们的实例是对象），但不常用。相反，包装类型有其他用处：<strong>如果你将他们作为函数调用，他们可以将值转换为原始类型</strong>。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//123</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//'true'</span></code></pre><h3 id="通过typeof和instanceof将值分类"><a href="#通过typeof和instanceof将值分类" class="headerlink" title="通过typeof和instanceof将值分类"></a>通过typeof和instanceof将值分类</h3><p>有两个操作符可以用来将值分类：<code>typeof</code>主要用于原始值，<code>instanceof</code>主要用于对象。</p><h4 id="typeof-使用方法如下："><a href="#typeof-使用方法如下：" class="headerlink" title="typeof 使用方法如下："></a>typeof 使用方法如下：</h4><p><code>typeof «value»</code></p><p><code>typeof</code>返回描述<code>value</code>“类型”的一个字符串。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">//'boolean'</span><span class="token keyword">typeof</span> <span class="token string">'abc'</span> <span class="token comment" spellcheck="true">//'string'</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 空对象字面量,'object'</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 空数组字面量,'object'</span></code></pre><p>下面列出了<code>typeof</code>操作的所有结果：</p><pre><code>操作数 结果undefined    &#39;undefined&#39;null    &#39;object&#39;Boolean value    &#39;boolean&#39;Number value    &#39;number&#39;String value    &#39;string&#39;Function    &#39;function&#39;All other values    &#39;object&#39;</code></pre><p>有两个结果和我们上面说的的原始值与对象是矛盾的：</p><ul><li>函数的类型是<code>function</code>而不是<code>object</code>。因为函数（类型为“function”）是对象（类型是对象）的子类型，这不是一个错误。</li><li><code>null</code>的类型是<code>object</code>。这是一个bug，但从没被修复，因为修复后会破坏现有的代码。</li></ul><h4 id="instanceof使用方法如下："><a href="#instanceof使用方法如下：" class="headerlink" title="instanceof使用方法如下："></a>instanceof使用方法如下：</h4><p><code>«value» instanceof «Constr»</code></p><p>如果<code>value</code>是一个对象，并且<code>value</code> 是由构造函数<code>Constr</code>创建的（参考：类）。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 通过构造函数Bar创建对象</span>b <span class="token keyword">instanceof</span> <span class="token class-name">Bar</span>    <span class="token comment" spellcheck="true">//true</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span>    <span class="token comment" spellcheck="true">//true</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token comment" spellcheck="true">//true</span></code></pre><h3 id="深入阅读"><a href="#深入阅读" class="headerlink" title="深入阅读"></a>深入阅读</h3><ul><li><a href="http://yanhaijing.com/javascript/2014/01/05/exploring-the-abyss-of-null-and-undefined-in-javascript/" target="_blank" rel="noopener">探索JavaScript中Null和Undefined的深渊</a></li></ul><h2 id="五、布尔"><a href="#五、布尔" class="headerlink" title="五、布尔"></a>五、布尔</h2><p>布尔类型原始值包括<code>true</code>和<code>false</code>。下面的操作符会得到布尔值：</p><ul><li>二元逻辑运算符：&amp;&amp;（与），||（或）</li><li>前缀逻辑运算符：!（非）</li><li>等值运算符：=== !== == !=</li><li>比较运算符（字符串或数字）：&gt; &gt;= &lt; &lt;=</li></ul><h3 id="真值和假值"><a href="#真值和假值" class="headerlink" title="真值和假值"></a>真值和假值</h3><p>每当<code>JavaScript</code>希望一个布尔值时（例如：if语句的条件），可以使用任何值。它将被理解（转换）为<code>true</code>或<code>false</code>。下面的值被理解为<code>false</code>：</p><ul><li>undefined, null</li><li>布尔: false</li><li>数字: 0, NaN</li><li>字符串: ‘’</li></ul><p>所有其他值被认为<code>true</code>。被理解为<code>false</code>的值称为假值，被理解为<code>true</code>的值称为真值。可以使用<code>Boolean</code>作为函数，测试值被理解为什么。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">Boolean</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//false</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//true</span></code></pre><h3 id="二元逻辑运算符"><a href="#二元逻辑运算符" class="headerlink" title="二元逻辑运算符"></a>二元逻辑运算符</h3><p><code>JavaScript</code>中的<strong>二元逻辑运算符是短路运算</strong>——如果第一个操作数可以确定结果，第二个操作数将不被验证（运算）。例如，在下面的代码中，函数<code>foo()</code>永远不会被调用。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token boolean">true</span> <span class="token operator">||</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>此外，<strong>二元逻辑运算符会返回操作数中的一个</strong>，可能是一个布尔值，也可能不是。</p><ul><li><strong>与</strong>：如果第一个操作数是假值，返回第一个。否则返回第二个操作数。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token number">NaN</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'abc'</span>    <span class="token comment" spellcheck="true">//NaN</span><span class="token number">123</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'abc'</span>    <span class="token comment" spellcheck="true">//'abc'</span></code></pre><ul><li><strong>或</strong>：如果第一个操作数是真值，返回第一个。否则，返回第二个操作数。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'abc'</span> <span class="token operator">||</span> <span class="token number">123</span>    <span class="token comment" spellcheck="true">//'abc'</span><span class="token string">''</span> <span class="token operator">||</span> <span class="token number">123</span>   <span class="token comment" spellcheck="true">//123</span></code></pre><h3 id="等值运算符"><a href="#等值运算符" class="headerlink" title="等值运算符"></a>等值运算符</h3><p>在<code>JavaScript</code>中检测相等，你可以使用严格相等（<code>===</code>）和严格不等（<code>!==</code>）。或者你也可以使用非严格相等（<code>==</code>）和非严格不等（<code>!=</code>）。</p><blockquote><p><strong>经验规则：总是用严格运算符，假装非严格运算符不存在。严格相等更安全。</strong></p></blockquote><h3 id="深入阅读-1"><a href="#深入阅读-1" class="headerlink" title="深入阅读"></a>深入阅读</h3><ul><li><a href="http://yanhaijing.com/javascript/2014/04/25/strict-equality-exemptions/" target="_blank" rel="noopener">在JavaScript中什么时候使用==是正确的？</a></li></ul><h2 id="六、数字"><a href="#六、数字" class="headerlink" title="六、数字"></a>六、数字</h2><p><code>JavaScript</code>中的<strong>所有数字都是浮点型</strong>（虽然大部分的JavaScript引擎内部也使用整数）。至于为什么这样设计，查看这里（<a href="http://yanhaijing.com/javascript/2014/03/14/what-every-javascript-developer-should-know-about-floating-points" target="_blank" rel="noopener">每一个JavaScript开发者应该了解的浮点知识</a>）。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">1</span> <span class="token operator">===</span> <span class="token number">1.0</span>   <span class="token comment" spellcheck="true">//true</span></code></pre><p>特殊数字：</p><ul><li><code>NaN</code> (“不是一个数字 not a number”): 错误值。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'xyz'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 'xyz' 不能被转换为数字得到:NaN</span></code></pre><ul><li><code>Infinity</code>：也是最大错误值（无穷大）</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token number">3</span> <span class="token operator">/</span> <span class="token number">0</span>   <span class="token comment" spellcheck="true">//Infinity</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 数字太大了,得到Infinity</span></code></pre><p><code>Infinity</code>有时很有用，因为它比任何其他数字都大。同样，<code>-Infinity</code> 比其他任何数字都小。</p><ul><li><code>JavaScript</code>有两个零，<code>+0</code>和<code>-0</code>。它（js引擎）通常不让你看到，并简单将两个零都显示为0：</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">+</span><span class="token number">0</span>  <span class="token comment" spellcheck="true">//0</span><span class="token operator">-</span><span class="token number">0</span>  <span class="token comment" spellcheck="true">//0</span></code></pre><p>因此最好假装只有一个零（正如我们看到假值时所做的那样：<strong>-0 和 +0 都是假值</strong>）。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><code>JavaScript</code>中有下列算数运算符：</p><pre class=" language-javascript"><code class="language-javascript">加<span class="token punctuation">:</span> number1 <span class="token operator">+</span> number2减<span class="token punctuation">:</span> number1 <span class="token operator">-</span> number2乘<span class="token punctuation">:</span> number1 <span class="token operator">*</span> number2除<span class="token punctuation">:</span> number1 <span class="token operator">/</span> number2模<span class="token punctuation">:</span> number1 <span class="token operator">%</span> number2自增<span class="token punctuation">:</span> <span class="token operator">++</span>variable<span class="token punctuation">,</span> variable<span class="token operator">++</span>自减<span class="token punctuation">:</span> –variable<span class="token punctuation">,</span> variable–负值<span class="token punctuation">:</span> <span class="token operator">-</span>value正值（转换为数字）<span class="token punctuation">:</span> <span class="token operator">+</span>value</code></pre><p>全局对象<code>Math</code>通过函数提供更多算数运算操作。</p><p><code>JavaScript</code>中也有位运算符（例如：&amp;）。</p><h2 id="七、字符串"><a href="#七、字符串" class="headerlink" title="七、字符串"></a>七、字符串</h2><p>字符串可以直接通过字符串字面量创建。这些字面量被单引号或双引号包裹。反斜线（\）转义字符并且产生一些控制字符。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'abc'</span><span class="token string">"abc"</span><span class="token string">'Did she say "Hello"?'</span><span class="token string">"Did she say \"Hello\"?"</span><span class="token string">'That\'s nice!'</span><span class="token string">"That's nice!"</span><span class="token string">'Line 1\nLine 2'</span>  <span class="token comment" spellcheck="true">// 换行</span><span class="token string">'Backlash: \\'</span></code></pre><p>可以通过方括号访问单个字符：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">//'b'</span></code></pre><p><code>length</code>属性是字符串的字符数量。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'abc'</span><span class="token punctuation">.</span>length  <span class="token comment" spellcheck="true">//3</span></code></pre><blockquote><p><strong>提醒</strong>：字符串是不可变的，如果你想改变现有字符串，你需要创建一个新的字符串。</p></blockquote><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>字符串可以通过加号操作符（+）拼接，如果其中一个操作数为字符串，会将另一个操作数也转换为字符串。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> msgCount <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token string">'You have '</span><span class="token operator">+</span> msgCount <span class="token operator">+</span> <span class="token string">' messages'</span> <span class="token comment" spellcheck="true">//'You have 3 messages'</span></code></pre><p>连续执行拼接操作可以使用<code>+=</code>操作符：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>str <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'Multiple '</span><span class="token punctuation">;</span>str <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'pieces '</span><span class="token punctuation">;</span>str <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'are concatenated.'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//'Multiple pieces are concatenated.'</span></code></pre><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>字符串有许多有用的方法。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'abc'</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 复制子字符串,得到索引1及其之后的字符串，即：'bc'</span><span class="token string">'abc'</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//得到索引1和2之间的字符串，即：'b'</span><span class="token string">'\t xyz  '</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 移除空白字符，即：'xyz'</span><span class="token string">'mjölnir'</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//转成大写，即：'MJÖLNIR'</span><span class="token string">'abc'</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 查找第一个b的索引，即：1</span><span class="token string">'abc'</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//没有返回-1</span></code></pre><h2 id="八、语句"><a href="#八、语句" class="headerlink" title="八、语句"></a>八、语句</h2><h3 id="条件（Conditionals）"><a href="#条件（Conditionals）" class="headerlink" title="条件（Conditionals）"></a>条件（Conditionals）</h3><p><code>if</code>语句通过布尔条件决定执行那个分支：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>myvar <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// then</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>myvar <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// then</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// else</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>myvar <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// then</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>myvar <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// else-if</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>myvar <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// else-if</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// else</span><span class="token punctuation">}</span></code></pre><p>下面的<code>switch</code>语句，furit的值决定那个分支被执行。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">switch</span> <span class="token punctuation">(</span>fruit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">'banana'</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// ...</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token string">'apple'</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// ...</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">// 所有其他情况</span>        <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><h3 id="循环（Loops）"><a href="#循环（Loops）" class="headerlink" title="循环（Loops）"></a>循环（Loops）</h3><p>for 循环的格式如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span>初始化<span class="token punctuation">;</span> 当条件成立时循环<span class="token punctuation">;</span> 下一步操作<span class="token punctuation">)</span></code></pre><p>例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当条件成立时<code>while</code>循环继续循环它的循环体。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 和上面的for循环相等</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当条件成立时，<code>do-while</code>循环继续循环。由于条件位于循环体之后，所以循环体总是被至少至少执行一次。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">do</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span>条件<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在所有的循环中：</p><ul><li>break中断循环</li><li>continue开始一个新的循环迭代</li></ul><h2 id="九、函数"><a href="#九、函数" class="headerlink" title="九、函数"></a>九、函数</h2><p>定义函数的一种方法是通过函数声明：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>param1<span class="token punctuation">,</span> param2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> param1 <span class="token operator">+</span> param2<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的代码定义一个名称叫做<code>add</code>的函数，有两个参数<code>param1</code>和<code>param2</code>，并且返回参数的和。下面是如何调用这个函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//7</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//'ab'</span></code></pre><p>另一种定义<code>add()</code>函数的方法是通过函数表达式：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> add <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>param1<span class="token punctuation">,</span> param2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> param1 <span class="token operator">+</span> param2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>函数表达式产生一个值，因此可以直接将函数作为参数传递给其他函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">someOtherFunction</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h3><p>函数声明会被提升，他们全被移动到当前作用域开始之处。这允许你在函数声明之前调用它们：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 没问题，bar被提升</span>    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注意</strong>：虽然变量声明也会被提升，但赋值的过程不会被提升：</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 有问题，bar是undefined</span>    <span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="特殊变量参数"><a href="#特殊变量参数" class="headerlink" title="特殊变量参数"></a>特殊变量参数</h3><p><strong>在<code>JavaScript</code>中你可以调用任意函数并传递任意数量的参数</strong>——语言绝不会“抱怨”（参数检测）。都可以正常工作，然而，使所有参数可访问需要通过特殊变量<code>arguments</code>。<code>arguments</code>看起来像数组，但它没有数组的方法（称为类数组 array-like）。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> arguments <span class="token punctuation">}</span><span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>args<span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">//3</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">// 获取索引为0的元素,'a'</span></code></pre><h3 id="太多或太少参数"><a href="#太多或太少参数" class="headerlink" title="太多或太少参数"></a>太多或太少参数</h3><p>让我们通过下面的函数探索<code>JavaScript</code>中传递太多或太少参数时如何处理</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>多出的参数将被忽略（可以通过<code>arguments</code>访问）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">f</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//a b</span></code></pre><p>缺少的参数将会是<code>undefined</code>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">f</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//a undefined</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//undefined undefined</span></code></pre><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>下面是一个常见模式，给参数设置默认值：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">pair</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    x <span class="token operator">=</span> x <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (*)</span>    y <span class="token operator">=</span> y <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span> x<span class="token punctuation">,</span> y <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在<code>（*）</code>这行，如果x是真值（除了：<code>null</code>，<code>undefined</code> 等），         操作符返回x。否则，它返回第二个操作数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//[ 0, 0 ]</span><span class="token function">pair</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//[ 3, 0 ]</span><span class="token function">pair</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//[ 3, 5 ]</span></code></pre><h3 id="强制数量"><a href="#强制数量" class="headerlink" title="强制数量"></a>强制数量</h3><p>如果你想强制参数的数量，你可以检测<code>arguments.length</code>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">pair</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Need exactly 2 arguments'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span><span class="token punctuation">}</span></code></pre><h3 id="将arguments-转换为数组"><a href="#将arguments-转换为数组" class="headerlink" title="将arguments 转换为数组"></a>将arguments 转换为数组</h3><p><code>arguments</code>不是一个数组，它仅仅是类数组（array-like）：它有一个<code>length</code>属性，并且你可以通过方括号索引方式访问它的元素。然而，你不能移除元素，或在它上面调用任何数组方法。因此，有时你需要将其转换为数组。这就是下面函数的作用。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">toArray</span><span class="token punctuation">(</span>arrayLikeObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLikeObject<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="十、异常处理"><a href="#十、异常处理" class="headerlink" title="十、异常处理"></a>十、异常处理</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" target="_blank" rel="noopener">异常处理</a>最常见的方式像下面这样：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">throwException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Problem!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">throwException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 错误：信息</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 非标准，但大部分浏览器支持</span><span class="token punctuation">}</span></code></pre><p>try分支包裹易出错的代码，如果try分支内部抛出异常，catch分支将会执行。</p><h2 id="十一、严格模式"><a href="#十一、严格模式" class="headerlink" title="十一、严格模式"></a>十一、严格模式</h2><p>严格模式开启检测和一些其他措施，使<code>JavaScript</code>变成更整洁的语言。推荐使用严格模式。为了开启严格模式，只需在<code>JavaScript</code>文件或<code>script</code>标签第一行添加如下语句：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'use strict'</span><span class="token punctuation">;</span></code></pre><p>你也可以在每个函数上选择性开启严格模式，只需将上面的代码放在函数的开头：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">functionInStrictMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">'use strict'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>下面的两小节看下严格模式的三大好处。</p><h3 id="明确错误"><a href="#明确错误" class="headerlink" title="明确错误"></a>明确错误</h3><p>让我们看一个例子，严格模式给我们明确的错误，否则<code>JavaScript</code>总是静默失败：下面的函数<code>f()</code> 执行一些非法操作，它试图更改所有字符串都有的只读属性——<code>length</code>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">'abc'</span><span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当你调用上面的函数，它静默失败，赋值操作被简单忽略。让我们将<code>f()</code>在严格模式下运行：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f_strict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">'use strict'</span><span class="token punctuation">;</span>    <span class="token string">'abc'</span><span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>现在浏览器报给我们一些错误：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">f_strict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// TypeError: Cannot assign to read only property 'length' of abc</span></code></pre><h3 id="不是方法的函数中的this"><a href="#不是方法的函数中的this" class="headerlink" title="不是方法的函数中的this"></a>不是方法的函数中的this</h3><p>在严格模式下，不作为方法的函数中的<code>this</code>值是<code>undefined</code>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f_strict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">'use strict'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">f_strict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> undefined<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span></code></pre><p>在非严格模式下，<code>this</code>的值是被称作全局对象（<code>global object</code>）（在浏览器里是<code>window</code>）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> window<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span></code></pre><h3 id="不再自动创建全局变量"><a href="#不再自动创建全局变量" class="headerlink" title="不再自动创建全局变量"></a>不再自动创建全局变量</h3><p>在非严格模式下，如果你给不存在的变量赋值，<code>JavaScript</code>会自动创建一个全局变量：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> foo <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 不会报错</span>foo <span class="token comment" spellcheck="true">// 5</span></code></pre><p>在严格模式下，这会产生一个错误：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f_strict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token string">'use strict'</span><span class="token punctuation">;</span> foo2 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token function">f_strict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// ReferenceError: foo2 is not defined</span></code></pre><h3 id="深入阅读-2"><a href="#深入阅读-2" class="headerlink" title="深入阅读"></a>深入阅读</h3><ul><li><a href="http://yanhaijing.com/javascript/2013/12/28/demystifying-this-in-javascript" target="_blank" rel="noopener">揭秘javascript中谜一样的this</a></li><li><a href="http://yanhaijing.com/javascript/2014/04/30/javascript-this-keyword" target="_blank" rel="noopener">JavaScript中的this关键字</a></li></ul><h2 id="十二、变量作用域和闭包"><a href="#十二、变量作用域和闭包" class="headerlink" title="十二、变量作用域和闭包"></a>十二、变量作用域和闭包</h2><p>在<code>JavaScript</code>中，你必须使用变量之前，通过<code>var</code>声明变量：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> x<span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ReferenceError: y is not defined</span></code></pre><p>你可以用一条<code>var</code>语句声明和初始化多个变量：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><p>但我建议每个变量使用一条语句。因此，我将上面的语句重写为：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><p>由于提升（见下文），最好在函数顶部声明变量。</p><h3 id="变量和函数作用域"><a href="#变量和函数作用域" class="headerlink" title="变量和函数作用域"></a>变量和函数作用域</h3><p>变量的作用域总是整个函数（没有块级作用域）。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// (*)</span>        <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>        <span class="token operator">...</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 3</span><span class="token punctuation">}</span></code></pre><p>我们可以看到tmp变量不仅在（*）所在行的语句块存在，它在整个函数内都存在。</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>变量声明会被提升：声明会被移到函数的顶部，但赋值过程不会。举个例子，在下面的函数中<code>（*）</code>行位置声明了一个变量。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (*)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在内部，上面的函数被执行像下面这样：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> tmp<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// declaration is hoisted</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// assignment stays put</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>每个函数保持和函数体内部变量的连接，甚至离开创建它的作用域之后。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createIncrementor</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// (*)</span>        <span class="token keyword">return</span> start<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在<code>（*）</code>行开始的函数在它创建时保留上下文，并在内部保存一个<code>start</code>活动值：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> inc <span class="token operator">=</span> <span class="token function">createIncrementor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 5</span><span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 6</span><span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 7</span></code></pre><p>闭包是一个函数加上和其作用域链的链接。因此，<code>createIncrementor()</code>返回的是一个闭包。</p><h3 id="IIFE：模拟块级作用域"><a href="#IIFE：模拟块级作用域" class="headerlink" title="IIFE：模拟块级作用域"></a>IIFE：模拟块级作用域</h3><p>有时你想模拟一个块，例如你想将变量从全局作用域隔离。完成这个工作的模式叫做 <code>IIFE</code>(立即执行函数表达式(<code>Immediately Invoked Function Expression</code>))：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 块开始</span>    <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 非全局变量</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 块结束</span></code></pre><p>上面你会看到函数表达式被立即执行。外面的括号用来阻止它被解析成函数声明；只有函数表达式能被立即调用。函数体产生一个新的作用域并使<code>tmp</code>变为局部变量。</p><h3 id="闭包实现变量共享"><a href="#闭包实现变量共享" class="headerlink" title="闭包实现变量共享"></a>闭包实现变量共享</h3><p>下面是个经典问题，如果你不知道，会让你费尽思量。因此，先浏览下，对问题有个大概的了解。</p><p>闭包保持和外部变量的连接，有时可能和你想像的行为不一致：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (*)</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5 (不是 1)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5 (不是 3)</span></code></pre><p><code>(*)</code>行的返回值总是当前的i值，而不是当函数被创建时的i值。当循环结束后，i的值是5，这是为什么数组中的所有函数的返回值总是一样的。如果你想捕获当前变量的快照，你可以使用<code>IIFE</code>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>i2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i2 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 复制当前的i</span><span class="token punctuation">}</span></code></pre><p>深入阅读</p><ul><li><a href="http://yanhaijing.com/javascript/2013/08/30/understanding-scope-and-context-in-javascript" target="_blank" rel="noopener">认识javascript中的作用域和上下文</a></li><li><a href="http://yanhaijing.com/javascript/2014/04/30/JavaScript-Scoping-and-Hoisting" target="_blank" rel="noopener">JavaScript的作用域和提升机制</a></li><li><a href="http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript" target="_blank" rel="noopener">了解JavaScript的执行上下文</a></li></ul><h2 id="十三、对象和继承"><a href="#十三、对象和继承" class="headerlink" title="十三、对象和继承"></a>十三、对象和继承</h2><p>和所有的值类型一样，对象有属性。事实上，你可以将对象当作一组属性的集合，每个属性都是一对（键和值）。键是字符串，值可以是任意<code>JavaScript</code>值。到目前为止，我们仅仅见过键是标识符的属性，因为点操作符处理的键必须为标识符。在这节，你讲见到另一种访问属性的方法，能将任意字符串作为键。</p><h3 id="单个对象"><a href="#单个对象" class="headerlink" title="单个对象"></a>单个对象</h3><p>在<code>JavaScript</code>中，你可以直接创建对象，通过对象字面量：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> jane <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Jane'</span><span class="token punctuation">,</span>    describe<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token string">'use strict'</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">'Person named '</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>上面的对象有两个属性：<code>name</code>和<code>describe</code>。你能读（“get”）和 写（“set”）属性：</p><pre class=" language-javascript"><code class="language-javascript">jane<span class="token punctuation">.</span>name  <span class="token comment" spellcheck="true">// get，'Jane'</span>jane<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'John'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// set</span>jane<span class="token punctuation">.</span>newProperty <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 自动创建</span></code></pre><p>属性是函数如<code>describe</code>可以被当作方法调用。当调用他们时可以在它们内部通过this引用对象。</p><pre class=" language-javascript"><code class="language-javascript">jane<span class="token punctuation">.</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 调用方法,'Person named John'</span>jane<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Jane'</span><span class="token punctuation">;</span>jane<span class="token punctuation">.</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'Person named Jane'</span></code></pre><p><code>in</code>操作符用来检测一个属性是否存在：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'newProperty'</span> <span class="token keyword">in</span> jane   <span class="token comment" spellcheck="true">// true</span><span class="token string">'foo'</span> <span class="token keyword">in</span> jane   <span class="token comment" spellcheck="true">// false</span></code></pre><p>若读取一个不存在的属性，将会得到<code>undefined</code>值。因此上面的两个检查也可以像下面这样：</p><pre class=" language-javascript"><code class="language-javascript">jane<span class="token punctuation">.</span>newProperty <span class="token operator">!==</span> undefined  <span class="token comment" spellcheck="true">// true</span>jane<span class="token punctuation">.</span>foo <span class="token operator">!==</span> undefined  <span class="token comment" spellcheck="true">// false</span></code></pre><p><code>delete</code>操作符用来删除一个属性：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">delete</span> jane<span class="token punctuation">.</span>newProperty <span class="token comment" spellcheck="true">//true</span><span class="token string">'newProperty'</span> <span class="token keyword">in</span> jane   <span class="token comment" spellcheck="true">//false</span></code></pre><h3 id="任意键属性"><a href="#任意键属性" class="headerlink" title="任意键属性"></a>任意键属性</h3><p>属性的键可以是任意字符串。到目前为止，我们看到的对象字面量中的和点操作符后的属性关键字。按这种方法你只能使用标识符。如果你想用其他任意字符串作为键名，你必须在对象字面量里加上引号，并使用方括号获取和设置属性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'not an identifier'</span><span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">[</span><span class="token string">'not an identifier'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">//123</span>obj<span class="token punctuation">[</span><span class="token string">'not an identifier'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span></code></pre><p>方括号允许你动态计算属性关键字：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">'name'</span><span class="token punctuation">;</span>jane<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'Jane'</span>jane<span class="token punctuation">[</span><span class="token string">'na'</span><span class="token operator">+</span><span class="token string">'me'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'Jane'</span></code></pre><h3 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h3><p>如果你引用一个方法，它将失去和对象的连接。就其本身而言，函数不是方法，其中的<code>this</code>值为<code>undefined</code>（严格模式下）。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> func <span class="token operator">=</span> jane<span class="token punctuation">.</span>describe<span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// TypeError: Cannot read property 'name' of undefined</span></code></pre><p>解决办法是使用函数内置的<code>bind()</code>方法。它创建一个新函数，其<code>this</code>值固定为给定的值。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> func2 <span class="token operator">=</span> jane<span class="token punctuation">.</span>describe<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>jane<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'Person named Jane'</span></code></pre><h3 id="方法内部的函数"><a href="#方法内部的函数" class="headerlink" title="方法内部的函数"></a>方法内部的函数</h3><p>每个函数都有一个特殊变量<code>this</code>。如果你在方法内部嵌入函数是很不方便的，因为你不能从函数中访问方法的<code>this</code>。下面是一个例子，我们调用<code>forEach</code>循环一个数组：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> jane <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Jane'</span><span class="token punctuation">,</span>    friends<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'Tarzan'</span><span class="token punctuation">,</span> <span class="token string">'Cheeta'</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>    logHiToFriends<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token string">'use strict'</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>friend<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这里的“this”是undefined</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' says hi to '</span> <span class="token operator">+</span> friend<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>调用<code>logHiToFriends</code>会产生错误：</p><pre class=" language-javascript"><code class="language-javascript">jane<span class="token punctuation">.</span><span class="token function">logHiToFriends</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// TypeError: Cannot read property 'name' of undefined</span></code></pre><p>有两种方法修复这问题。</p><ul><li>将<code>this</code>存储在不同的变量。</li></ul><pre class=" language-javascript"><code class="language-javascript">logHiToFriends<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">'use strict'</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>friend<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' says hi to '</span> <span class="token operator">+</span> friend<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>forEach的第二个参数允许提供<code>this</code>值。</li></ul><pre class=" language-javascript"><code class="language-javascript">logHiToFriends<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">'use strict'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>friend<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' says hi to '</span> <span class="token operator">+</span> friend<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在<code>JavaScript</code>中函数表达式经常被用作函数参数。时刻小心函数表达式中的<code>this</code>。</p><h3 id="构造函数：对象工厂"><a href="#构造函数：对象工厂" class="headerlink" title="构造函数：对象工厂"></a>构造函数：对象工厂</h3><p>除了作为“真正”的函数和方法，函数还在JavaScript中扮演第三种角色：<strong>如果通过new操作符调用，他们会变为构造函数，对象的工厂</strong>。构造函数是对其他语言中的类的粗略模拟。约定俗成，构造函数的第一个字母大写。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 设置实例数据</span><span class="token keyword">function</span> <span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 方法</span>Point<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>dist <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>我们看到构造函数分为两部分：首先，<code>Point</code>函数设置实例数据。其次，<code>Point.prototype</code>属性包含对象的方法。前者的数据是每个实例私有的，后面的数据是所有实例共享的。</p><p>我们通过new操作符调用<code>Point</code>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span>x <span class="token comment" spellcheck="true">//3</span>p<span class="token punctuation">.</span><span class="token function">dist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//5.830951894845301</span></code></pre><p>p是<code>Point</code>的一个实例：</p><pre class=" language-javascript"><code class="language-javascript">p <span class="token keyword">instanceof</span> <span class="token class-name">Point</span>  <span class="token comment" spellcheck="true">//true</span><span class="token keyword">typeof</span> p    <span class="token comment" spellcheck="true">//'object'</span></code></pre><h3 id="深入阅读-3"><a href="#深入阅读-3" class="headerlink" title="深入阅读"></a>深入阅读</h3><ul><li><a href="http://yanhaijing.com/javascript/2013/08/23/javascript-inheritance-how-to-shoot-yourself-in-the-foot-with-prototypes" target="_blank" rel="noopener">Javascript继承 原型的陷阱</a></li><li><a href="http://yanhaijing.com/javascript/2013/08/30/encapsulation-of-javascript" target="_blank" rel="noopener">Javascript 封装问题</a></li></ul><h2 id="十四、数组"><a href="#十四、数组" class="headerlink" title="十四、数组"></a>十四、数组</h2><p>数组是数组元素的序列，能通过整数索引方法数组元素，数组索引从0开始。</p><h3 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h3><p>数组字面量创建数组很方便：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">></span> <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>上面的数组有三个元素：分别是字符串“a”，“b”， “c”。你可以通过整数索引访问它们：</p><pre class=" language-javascript"><code class="language-javascript">arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//'a'</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">;</span>arr<span class="token comment" spellcheck="true">// [ 'x', 'b', 'c' ]</span></code></pre><p><code>length</code>属性总表示一个数组有多少项元素。</p><pre class=" language-javascript"><code class="language-javascript">arr<span class="token punctuation">.</span>length    <span class="token comment" spellcheck="true">//3</span></code></pre><p>除此之外它也可以用来从数组上移除尾部元素：</p><pre class=" language-javascript"><code class="language-javascript">arr<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> arr <span class="token comment" spellcheck="true">// [ 'x', 'b' ]</span></code></pre><p><code>in</code>操作符也可以在数组上工作。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">1</span> <span class="token keyword">in</span> arr <span class="token comment" spellcheck="true">// arr在索引为1处是否有元素？,true</span><span class="token number">5</span> <span class="token keyword">in</span> arr <span class="token comment" spellcheck="true">// arr在索引为5处是否有元素？false</span></code></pre><p>值得注意的是数组是对象，因此可以有对象属性：</p><pre class=" language-javascript"><code class="language-javascript">arr<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span>foo   <span class="token comment" spellcheck="true">// 123</span></code></pre><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>数组有许多方法。举些例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 复制元素，[ 'b' ]</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// [ 'b', 'c' ]</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 在末尾添加一个元素，4</span>arr <span class="token comment" spellcheck="true">// [ 'a', 'b', 'c', 'x' ]</span>arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 移除最后一个元素，'x'</span>arr   <span class="token comment" spellcheck="true">// [ 'a', 'b', 'c' ]</span>arr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 移除第一个元素，'a'</span>arr <span class="token comment" spellcheck="true">// [ 'b', 'c' ]</span>arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 在前面添加一个元素，3</span>arr <span class="token comment" spellcheck="true">// [ 'x', 'b', 'c' ]</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 查找给定项在数组中的索引，若不存在返回-1，</span><span class="token comment" spellcheck="true">// 1</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// -1</span>arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 将元素拼接为一个字符串，'x-b-c'</span>arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 'xbc'</span>arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 'x,b,c'</span></code></pre><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>有几种方法可以遍历数组元素。其中两个最重要的是<code>forEach</code>和<code>map</code>。</p><p><code>forEach</code>遍历整个数组，并将当前元素和它的索引传递给一个函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span> <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>elem<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// (*)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token string">'. '</span> <span class="token operator">+</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码的输出</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">0</span><span class="token punctuation">.</span> a<span class="token number">1</span><span class="token punctuation">.</span> b<span class="token number">2</span><span class="token punctuation">.</span> c</code></pre><p>注意<code>（*）</code>行的函数参数是可省略的。例如：它可以只有一个参数<code>elem</code>。</p><p><code>map</code>创建一个新数组，通过给每个存在数组元素应用一个函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> x<span class="token operator">*</span>x <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [ 1, 4, 9 ]</span></code></pre><h3 id="深入阅读-4"><a href="#深入阅读-4" class="headerlink" title="深入阅读"></a>深入阅读</h3><ul><li><a href="http://yanhaijing.com/javascript/2014/01/17/fun-with-javascript-native-array-functions" target="_blank" rel="noopener">有趣的javascript原生数组函数</a></li></ul><h2 id="十五、正则表达式"><a href="#十五、正则表达式" class="headerlink" title="十五、正则表达式"></a>十五、正则表达式</h2><p><code>JavaScript</code>内建支持正则表达式。他们被双斜线分隔：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token regex">/^abc$/</span><span class="token regex">/[A-Za-z0-9]+/</span></code></pre><h3 id="方法-test-：测试是否匹配"><a href="#方法-test-：测试是否匹配" class="headerlink" title="方法 test()：测试是否匹配"></a>方法 test()：测试是否匹配</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token regex">/^a+b+$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'aaab'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// true</span><span class="token regex">/^a+b+$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'aaa'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// false</span></code></pre><h3 id="方法-exec-：匹配和捕获组"><a href="#方法-exec-：匹配和捕获组" class="headerlink" title="方法 exec()：匹配和捕获组"></a>方法 exec()：匹配和捕获组</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token regex">/a(b+)a/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'_abbba_aba_'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// [ 'abbba', 'bbb' ]</span></code></pre><p>返回的数组第一项（索引为0）是完整匹配，捕获的第一个分组在第二项（索引为1），等。有一种方法可以反复调用获取所有匹配。</p><h3 id="方法-replace-：搜索并替换"><a href="#方法-replace-：搜索并替换" class="headerlink" title="方法 replace()：搜索并替换"></a>方法 replace()：搜索并替换</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'&lt;a> &lt;bbb>'</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&lt;(.*?)>/g</span><span class="token punctuation">,</span> <span class="token string">'[$1]'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// '[a] [bbb]'</span></code></pre><p><code>replace</code>的第一个参数必须是正则表达式，并且开启全局搜索（<code>/g</code>标记），否则仅第一个匹配项会被替换。有一种方法使用一个函数来计算替换项。</p><h2 id="十六、数学"><a href="#十六、数学" class="headerlink" title="十六、数学"></a>十六、数学</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math" target="_blank" rel="noopener">Math</a>是一个有算数功能的对象。例如：</p><pre class=" language-javascript"><code class="language-javascript">Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3^2 = 9</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//5</span>Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">1.9</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2</span>Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span>PI<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 预定义常量π，-1</span></code></pre><h2 id="十七、标准库的其他功能"><a href="#十七、标准库的其他功能" class="headerlink" title="十七、标准库的其他功能"></a>十七、标准库的其他功能</h2><p><code>JavaScript</code>标准库相对简单，但有很多其他东西你可以使用：</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">Date</a>：日期构造函数，主要功能有转换和创建日期字符串，访问日期组成部分（年，小时等）。<br><a href="http://www.2ality.com/2011/08/json-api.html" target="_blank" rel="noopener">JSON</a>：一个对象，功能是转换和生成<code>JSON</code>数据。<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/console" target="_blank" rel="noopener">console.*</a>方法：浏览器的具体方法，不是语言成分的部分，但他们也可以在<a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a>中工作。</p><h2 id="十八、下一步学什么？"><a href="#十八、下一步学什么？" class="headerlink" title="十八、下一步学什么？"></a>十八、下一步学什么？</h2><p>在你学会了这篇文章的基础教程后，你可以转到大部分章节末尾提到的高级教程。此外，我建议你看下面的资源：</p><ul><li>Style guides: I have written <a href="http://www.2ality.com/2013/07/meta-style-guide.html" target="_blank" rel="noopener">a guide to style guides</a></li><li><a href="http://underscorejs.org/" target="_blank" rel="noopener">Underscore.js</a>: 一个弥补JavaScript标准库缺少的功能的库</li><li><a href="http://jsbooks.revolunet.com/" target="_blank" rel="noopener">JSbooks – free JavaScript books</a></li><li><a href="http://uptodate.frontendrescue.org/" target="_blank" rel="noopener">Frontend rescue: how to keep up to date on frontend technologies</a></li><li><a href="http://yanhaijing.com/" target="_blank" rel="noopener">http://yanhaijing.com</a> 当然还有我的博客也非常不错哦</li><li><a href="http://yanhaijing.com/es5" target="_blank" rel="noopener">http://yanhaijing.com/es5</a> 如果你想成为高手，我建议阅读<code>ecmascript</code>规范</li><li><a href="http://yanhaijing.com/javascript/2013/12/11/24-JavaScript-best-practices-for-beginners" target="_blank" rel="noopener">给javascript初学者的24条最佳实践</a></li><li><a href="http://yanhaijing.com/javascript/2014/04/23/seven-javascript-quirks-i-wish-id-known-about" target="_blank" rel="noopener">我希望我知道的七个JavaScript技巧</a></li></ul><p>参考自原文：<a href="http://www.2ality.com/2013/06/basic-javascript.html" target="_blank" rel="noopener">http://www.2ality.com/2013/06/basic-javascript.html</a><br>参考自译文：<a href="http://yanhaijing.com/basejs/" target="_blank" rel="noopener">http://yanhaijing.com/basejs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apache Commons Collections包和简介</title>
      <link href="/2018/09/13/hou-duan/java/commons/commons-collections-bao-he-jian-jie/"/>
      <url>/2018/09/13/hou-duan/java/commons/commons-collections-bao-he-jian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><a href="http://commons.apache.org/" target="_blank" rel="noopener">Apache Commons</a>是Apache软件基金会的项目，曾经隶属于<code>Jakarta</code>项目。<code>Commons</code>的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：<code>Proper</code>（是一些已发布的项目）、<code>Sandbox</code>（是一些正在开发的项目）和<code>Dormant</code>（是一些刚启动或者已经停止维护的项目）。</p><p><a href="http://commons.apache.org/proper/commons-collections/" target="_blank" rel="noopener">Commons Collections</a>包为Java标准的<code>Collections API</code>提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p><h2 id="一、包结构介绍"><a href="#一、包结构介绍" class="headerlink" title="一、包结构介绍"></a>一、包结构介绍</h2><blockquote><p>注意：Commons Collections的最新版是4.1，但由于工作中大多还是3.x的版本，这里就以3.x中的最后一个版本3.2.2作使用介绍。</p></blockquote><p>以下是Collections的包结构和简单介绍，如果你想了解更多的各个包下的接口和实现，请参考<a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/index.html" target="_blank" rel="noopener">Apache Commons Collections 3.2.2 API文档</a>。</p><ul><li><code>org.apache.commons.collections</code> – CommonsCollections自定义的一组公用的接口和工具类</li><li><code>org.apache.commons.collections.bag</code> – 实现Bag接口的一组类</li><li><code>org.apache.commons.collections.bidimap</code> – 实现BidiMap系列接口的一组类</li><li><code>org.apache.commons.collections.buffer</code> – 实现Buffer接口的一组类</li><li><code>org.apache.commons.collections.collection</code> –实现java.util.Collection接口的一组类</li><li><code>org.apache.commons.collections.comparators</code>– 实现java.util.Comparator接口的一组类</li><li><code>org.apache.commons.collections.functors</code> –Commons Collections自定义的一组功能类</li><li><code>org.apache.commons.collections.iterators</code> – 实现java.util.Iterator接口的一组类</li><li><code>org.apache.commons.collections.keyvalue</code> – 实现集合和键/值映射相关的一组类</li><li><code>org.apache.commons.collections.list</code> – 实现java.util.List接口的一组类</li><li><code>org.apache.commons.collections.map</code> – 实现Map系列接口的一组类</li><li><code>org.apache.commons.collections.set</code> – 实现Set系列接口的一组类</li></ul><h2 id="二、Map的一些介绍"><a href="#二、Map的一些介绍" class="headerlink" title="二、Map的一些介绍"></a>二、Map的一些介绍</h2><p><code>Collections</code>包中的“Map”是在<code>java.util.Map</code>的基础上扩展的接口和类。有如下常用的Map:</p><ul><li><strong>LinkedMap</strong>，可以维护条目顺序的map；</li><li><strong>BidiMap</strong>，即双向Map，可以通过key找到value，也可以通过value找到key。需要注意的是BidiMap中key和value都不可以重复；</li><li><strong>MultiMap</strong>，一个key指向的是一组对象，add()和remove()的时候跟普通的Map无异，只是在get()时返回一个Collection，实现了一对多；</li><li><strong>LazyMap</strong>，即Map中的键/值对一开始并不存在，当被调用到时才创建。</li></ul><h2 id="三、Collections中Map的使用示例"><a href="#三、Collections中Map的使用示例" class="headerlink" title="三、Collections中Map的使用示例"></a>三、Collections中Map的使用示例</h2><h3 id="1-Map迭代器之mapIterator"><a href="#1-Map迭代器之mapIterator" class="headerlink" title="1. Map迭代器之mapIterator"></a>1. Map迭代器之mapIterator</h3><p><code>jdk</code>中的<code>Map</code>接口很难进行迭代。<code>api</code>用户总是需要通过<code>entryset</code>或者<code>keyset</code>进行迭代。<code>commons-collectons</code>现在提供了一个新的接口 - <code>mapIterator</code>来允许对<code>maps</code>进行简单的迭代。示例如下：</p><p>(1)、构造Map初始数据的方法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 构建map初始数据 * @param map */</span><span class="token keyword">private</span> <span class="token keyword">static</span> Map <span class="token function">buildMap</span><span class="token punctuation">(</span>Map map<span class="token punctuation">)</span> <span class="token punctuation">{</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> map<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>(2)、使用MapIterator迭代数据的方法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * map迭代器 * 遍历打印map,使用map.mapIterator() * @param map * @param mapName */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">iteratorMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map map <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历map,使用MapIterator</span>    MapIterator it <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">mapIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object key <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object value <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"iterator map key:"</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">", value: "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-有序map之LinkedMap"><a href="#2-有序map之LinkedMap" class="headerlink" title="2. 有序map之LinkedMap"></a>2. 有序map之LinkedMap</h3><p><code>LinkedMap</code>是一个可以维护Map中条目顺序的Map实现，条目顺序由最初的数据插入时来决定。同时也增加上面所说的<code>MapIterator</code>功能和一些便利的方法，并允许进行双向迭代。相较于<code>JDK1.4</code>中的<code>LinkedHashMap</code>效率有所提高，它还实现了<code>OrderedMap</code>接口。此外，还提供了非接口方法通过索引来访问Map中的数据。<strong>需要注意的是LinkedMap不是同步的，不是线程安全的</strong>。如果你想使用<code>LinkedMap</code>的同时使用多个线程，您必须使用适当的同步操作。最简单的方法是使用<code>Collections.synchronizedMap(Map)</code>来包装<code>LinkedMap</code>。如果不使用同步操作，当并发线程访问这个类时可能会抛出异常。</p><p>LinkedMap的一些代码示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 有序map之LinkedMap */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">linkedMapTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    OrderedMap orderMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取map中相应的值</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LinkedMap firstKey:"</span> <span class="token operator">+</span> orderMap<span class="token punctuation">.</span><span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LinkedMap previous key:"</span> <span class="token operator">+</span> orderMap<span class="token punctuation">.</span><span class="token function">previousKey</span><span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LinkedMap next key:"</span> <span class="token operator">+</span> orderMap<span class="token punctuation">.</span><span class="token function">nextKey</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LinkedMap last key:"</span> <span class="token operator">+</span> orderMap<span class="token punctuation">.</span><span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LinkedMap map Size:"</span> <span class="token operator">+</span> orderMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-双向Map之BidiMap"><a href="#3-双向Map之BidiMap" class="headerlink" title="3. 双向Map之BidiMap"></a>3. 双向Map之BidiMap</h3><p>所谓<code>BidiMap</code>，直译就是双向<code>Map</code>，可以通过<code>key</code>找到<code>value</code>，也可以通过<code>value</code>找到<code>key</code>，这在我们日常的代码-名称匹配的时候很方便：因为我们除了需要通过代码找到名称之外，往往也需要处理用户输入的名称，然后获取其代码。需要注意的是BidiMap当中不光key不能重复，value也不可以重复。基本使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * BidiMap,是双向Map * 通过key得到value * 通过value得到key * 注意的是BidiMap,当中不光key不能重复，value也不可以。 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bidiMapTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    BidiMap bidiMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeBidiMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 有相同值的，只有最后一个生效</span>    bidiMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">loopMap</span><span class="token punctuation">(</span>bidiMap<span class="token punctuation">,</span> <span class="token string">"BidiMap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取map中相应的值</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"BidiMap getKey:"</span> <span class="token operator">+</span> bidiMap<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"BidiMap getMoreSameKey:"</span> <span class="token operator">+</span> bidiMap<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 移除map的value</span>    bidiMap<span class="token punctuation">.</span><span class="token function">removeValue</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"BidiMap getMoreSameKey2:"</span> <span class="token operator">+</span> bidiMap<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 交换map的key和value</span>    BidiMap inversMap <span class="token operator">=</span> bidiMap<span class="token punctuation">.</span><span class="token function">inverseBidiMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-多值Map之MultiMap"><a href="#4-多值Map之MultiMap" class="headerlink" title="4. 多值Map之MultiMap"></a>4. 多值Map之MultiMap</h3><p>所谓<code>MultiMap</code>，就是说单个<code>key</code>可以对应多个<code>value</code>,在<code>put</code>或<code>remove</code>时和普通<code>Map</code>没有区别,但当<code>get</code>时将返回多个<code>value</code>,所以返回一个<code>collections</code>,利用<code>MultiMap</code>，我们就可以很方便的往一个<code>key</code>上放数量不定的对象，也就实现了一对多。在3.2.1版本中<code>MultiHashMap</code>已被废除,请使用<code>MultiValueMap</code>。简单的使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">multiMapTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    MultiMap multiMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MultiValueMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    multiMap <span class="token operator">=</span> <span class="token function">multibuildMap</span><span class="token punctuation">(</span>multiMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    multiMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> multiMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 会打印: list:[3, 5]</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"list:"</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5-“懒加载”Map之LazyMap"><a href="#5-“懒加载”Map之LazyMap" class="headerlink" title="5. “懒加载”Map之LazyMap"></a>5. “懒加载”Map之LazyMap</h3><p>所谓<code>LazyMap</code>，意思就是这个<code>Map</code>中的键/值对一开始并不存在，当被调用到时才会创建，这样的解释初听上去是不是有点不可思议，这样的<code>LazyMap</code>有用吗？我们这样来理解：我们需要一个<code>Map</code>，但是由于创建成员的方法很“重”（比如数据库访问），或者我们只有在调用<code>get()</code>时才知道如何创建，或者<code>Map</code>中出现的可能性很多很多，我们无法在<code>get()</code>之前添加所有可能出现的键/值对，或者任何其它解释得通的原因，我们觉得没有必要去初始化一个<code>Map</code>而又希望它可以在必要时自动处理数据生成的话，<code>LazyMap</code>就变得很有用了。简单的使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * LazyMap.类似与Hibenrate的懒加载,在声明的时候并不会创建, * 而是在使用(get)的时候,才创建集合的内容,返回Factory的返回值 * 实现懒加载,当我们觉得没有必要去初始化一个Map而又希望它可以在必要时自动处理数据可以使用LazyMap * 有LazyList与LazyMap对应 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">lazyMapTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建一个工厂，实现create方法</span>    Factory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Object <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 创建的默认值</span>            <span class="token keyword">return</span> <span class="token string">"这是LazyMap get()不到时创建的默认值"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    Map lazyMap <span class="token operator">=</span> LazyMap<span class="token punctuation">.</span><span class="token function">decorate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"map:"</span> <span class="token operator">+</span> lazyMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//当此lazyMap调用get(key)时，如果无此key则返回varFactory里create方法返回的值</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"map:"</span> <span class="token operator">+</span> lazyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 有key对应的值时,返回123</span>    lazyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"map:"</span> <span class="token operator">+</span> lazyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>Apache Commons Collections</code>中的基本<code>map</code>的接口类型和使用方法，不仅有上面这些，还有很多细分的、拥有不同功能或者各功能会有交叉的<code>map</code>，等着我们在自己工作中去使用挖掘吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java8中关于日期和时间API的20个使用示例</title>
      <link href="/2018/09/13/hou-duan/java/java-8-zhong-guan-yu-ri-qi-he-shi-jian-api-de-20-ge-shi-yong-shi-li/"/>
      <url>/2018/09/13/hou-duan/java/java-8-zhong-guan-yu-ri-qi-he-shi-jian-api-de-20-ge-shi-yong-shi-li/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>随着<a href="http://javarevisited.blogspot.sg/2014/02/10-example-of-lambda-expressions-in-java8.html" target="_blank" rel="noopener"><code>lambda</code></a>表达式、<a href="http://java67.blogspot.sg/2014/04/java-8-stream-api-examples-filter-map.html" target="_blank" rel="noopener">streams</a>以及一系列小优化，Java8推出了全新的日期时间API，在一下的指南中我们将通过一些简单的示例来学习如何使用新API。Java处理日期、日历和时间的方式一直为社区所诟病，将<code>java.util.Date</code>设定为可变类型，以及<a href="http://javarevisited.blogspot.sg/2012/03/simpledateformat-in-java-is-not-thread.html" target="_blank" rel="noopener"><code>SimpleDateFormat</code>的非线程安全</a>使其应用非常受限。<code>Java</code>也意识到需要一个更好的<code>API</code>来满足社区中已经习惯了使用<code>JodaTime API</code>的人们。全新<code>API</code>的众多好处之一就是，明确了日期时间概念，例如：瞬时（instant）、期间（duration）、日期、时间、时区和周期。同时继承了<code>Joda</code>库按人类语言和计算机各自解析的时间处理方式。不同于老版本，新<code>API</code>基于ISO标准日历系统，<code>java.time</code>包下的所有类都是不可变类型而且线程安全。下面是新版API中<code>java.time</code>包里的一些关键类：</p><ul><li><code>Instant</code>：瞬时实例。</li><li><code>LocalDate</code>：本地日期，不包含具体时间。例如：<code>2014-01-14</code>可以用来记录生日、纪念日、加盟日等。</li><li><code>LocalTime</code>：本地时间，不包含日期。</li><li><code>LocalDateTime</code>：组合了日期和时间，但不包含时差和时区信息。</li><li><code>ZonedDateTime</code>：最完整的日期时间，包含时区和相对UTC或格林威治的时差。</li></ul><p>新API还引入了<code>ZoneOffSet</code>和<code>ZoneId</code>类，使得解决时区问题更为简便。<a href="http://javarevisited.blogspot.sg/2011/09/step-by-step-guide-to-convert-string-to.html" target="_blank" rel="noopener">解析和格式化时间</a>的<code>DateTimeFormatter</code>类也全部重新设计。<strong>注意，这篇文章是翻译自<a href="http://javarevisited.blogspot.sg/2015/03/20-examples-of-date-and-time-api-from-Java8.html" target="_blank" rel="noopener">Java 8 - 20 Examples of Date and Time API</a>，以下示例代码我做过一些简单的修改，当运行这些例子时会返回你当前的时间</strong>。</p><h2 id="二、在Java8中如何处理日期和时间"><a href="#二、在Java8中如何处理日期和时间" class="headerlink" title="二、在Java8中如何处理日期和时间"></a>二、在Java8中如何处理日期和时间</h2><p>常有人问我学习一个新库的最好方式是什么？我的答案是在实际项目中使用它。项目中有很多真正的需求驱使开发者去发掘并学习新库。简单得说就是任务驱动学习探索。这对Java8新日期时间<code>API</code>也不例外。我创建了20个基于任务的实例来学习Java8的新特性。从最简单创建当天的日期开始，然后创建时间及时区，接着模拟一个日期提醒应用中的任务——计算重要日期的到期天数，例如生日、纪念日、账单日、保费到期日、信用卡过期日等。</p><h3 id="示例-1、在Java8中获取今天的日期"><a href="#示例-1、在Java8中获取今天的日期" class="headerlink" title="示例 1、在Java8中获取今天的日期"></a>示例 1、在Java8中获取今天的日期</h3><p>Java8中的<code>LocalDate</code>用于表示当天日期。和<code>java.util.Date</code>不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今天的日期是："</span> <span class="token operator">+</span> today<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 今天的日期是：2016-04-18</span></code></pre><p>上面的代码创建了当天的日期，不含时间信息。打印出的日期格式非常友好，不像老的<code>Date</code>类打印出一堆没有格式化的信息。</p><h3 id="示例-2、在Java8中获取当前的年、月、日信息"><a href="#示例-2、在Java8中获取当前的年、月、日信息" class="headerlink" title="示例 2、在Java8中获取当前的年、月、日信息"></a>示例 2、在Java8中获取当前的年、月、日信息</h3><p><code>LocalDate</code>类提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息，不用像以前一样需要依赖<code>java.util.Calendar</code>类了。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> year <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> month <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getMonthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> day <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"当前的年 : %d  月 : %d  日 : %d%n"</span><span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前的年 : 2016  月 : 4  日 : 18</span></code></pre><p>看到了吧，在Java8中得到年、月、日信息是这么简单直观，想用就用，没什么需要记的。对比看看以前Java是怎么处理年月日信息的吧。</p><h3 id="示例-3、在Java8中获取特定日期"><a href="#示例-3、在Java8中获取特定日期" class="headerlink" title="示例 3、在Java8中获取特定日期"></a>示例 3、在Java8中获取特定日期</h3><p>在第一个例子里，我们通过静态工厂方法<code>now()</code>非常容易地创建了当天日期，你还可以调用另一个有用的工厂方法<code>LocalDate.of()</code>创建任意日期，该方法需要传入年、月、日做参数，返回对应的<code>LocalDate</code>实例。这个方法的好处是没再犯老<code>API</code>的设计错误，比如年度起始于1900，月份是从0开始等等。日期所见即所得，就像下面这个例子表示了1月14日，没有任何隐藏机关。</p><pre class=" language-java"><code class="language-java">LocalDate dateOfBirth <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你的出生日期是："</span> <span class="token operator">+</span> dateOfBirth<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 你的出生日期是：2016-04-18</span></code></pre><p>可以看到创建的日期完全符合预期，与你写入的2016年4月18日完全一致。</p><h3 id="示例-4、在Java8中判断两个日期是否相等"><a href="#示例-4、在Java8中判断两个日期是否相等" class="headerlink" title="示例 4、在Java8中判断两个日期是否相等"></a>示例 4、在Java8中判断两个日期是否相等</h3><p>现实生活中有一类时间处理就是判断两个日期是否相等。你常常会检查今天是不是个特殊的日子，比如生日、纪念日或非交易日。这时就需要把指定的日期与某个特定日期做比较，例如判断这一天是否是假期。下面这个例子会帮助你用Java8的方式去解决，你肯定已经想到了，<code>LocalDate</code>重载了<code>equal</code>方法，请看下面的例子：</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate date1 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>date1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"今天 %s 和 date1 %s 是同一天!%n"</span><span class="token punctuation">,</span> today<span class="token punctuation">,</span> date1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 今天 2016-04-18 和 date1 2016-04-18 是同一天!</span></code></pre><p>这个例子中我们比较的两个日期相同。注意，如果比较的日期是字符型的，需要先解析成日期对象再作判断。对比<a href="http://javarevisited.blogspot.sg/2012/02/3-example-to-compare-two-dates-in-java.html" target="_blank" rel="noopener"><code>Java</code>老的日期比较方式</a>，你会感到清风拂面。</p><h3 id="示例-5、在Java8中检查像生日这种周期性事件"><a href="#示例-5、在Java8中检查像生日这种周期性事件" class="headerlink" title="示例 5、在Java8中检查像生日这种周期性事件"></a>示例 5、在Java8中检查像生日这种周期性事件</h3><p><code>Java</code>中另一个日期时间的处理就是检查类似每月账单、结婚纪念日、EMI日或保险缴费日这些周期性事件。如果你在电子商务网站工作，那么一定会有一个模块用来在圣诞节、感恩节这种节日时向客户发送问候邮件。<code>Java</code>中如何检查这些节日或其它周期性事件呢？答案就是<code>MonthDay</code>类。这个类组合了月份和日，去掉了年，这意味着你可以用它判断每年都会发生事件。和这个类相似的还有一个<code>YearMonth</code>类。这些类也都是不可变并且线程安全的值类型。下面我们通过<code>MonthDay</code>来检查周期性事件：</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate dateOfBirth <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MonthDay birthday <span class="token operator">=</span> MonthDay<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>dateOfBirth<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dateOfBirth<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MonthDay currentMonthDay <span class="token operator">=</span> MonthDay<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>currentMonthDay<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>birthday<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"好高兴今天是您的生日!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对不起，今天不是您的生日!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 好高兴今天是您的生日!!</span></code></pre><p>只要当天的日期和生日匹配，无论是哪一年都会打印出祝贺信息。你可以把程序整合进系统时钟，看看生日时是否会受到提醒，或者写一个单元测试来检测代码是否运行正确。</p><h3 id="示例-6、在Java8中获取当前时间"><a href="#示例-6、在Java8中获取当前时间" class="headerlink" title="示例 6、在Java8中获取当前时间"></a>示例 6、在Java8中获取当前时间</h3><p>与Java8获取日期的例子很像，获取时间使用的是<code>LocalTime</code>类，一个只有时间没有日期的<code>LocalDate</code>的近亲。可以调用静态工厂方法<code>now()</code>来获取当前时间。默认的格式是<code>hh:mm:ss:nnn</code>。对比一下<a href="http://javarevisited.blogspot.sg/2012/01/get-current-date-timestamps-java.html" target="_blank" rel="noopener">Java8之前获取当前时间的方式</a>。</p><pre class=" language-java"><code class="language-java">LocalTime time <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间是:"</span> <span class="token operator">+</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前时间是:23:43:42.200</span></code></pre><p>可以看到当前时间就只包含时间信息，没有日期。</p><h3 id="示例-7、如何在现有的时间上增加小时"><a href="#示例-7、如何在现有的时间上增加小时" class="headerlink" title="示例 7、如何在现有的时间上增加小时"></a>示例 7、如何在现有的时间上增加小时</h3><p>通过增加小时、分、秒来计算将来的时间很常见。Java8除了不变类型和线程安全的好处之外，还提供了更好的<code>plusHours()</code>方法替换<code>add()</code>，并且是兼容的。注意，这些方法返回一个全新的<code>LocalTime</code>实例，由于其不可变性，返回后一定要用变量赋值。</p><pre class=" language-java"><code class="language-java">LocalTime time <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime newTime <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">plusHours</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 添加两小时</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间:"</span> <span class="token operator">+</span> time <span class="token operator">+</span> <span class="token string">",两小时后的时间: "</span> <span class="token operator">+</span>  newTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前时间:23:50:56.195,两小时后的时间: 01:50:56.195</span></code></pre><p>可以看到，新的时间在当前时间<code>23:50:56.195</code>的基础上增加了2个小时。和<a href="http://javarevisited.blogspot.sg/2012/12/how-to-add-subtract-days-months-years-to-date-time-java.html" target="_blank" rel="noopener">旧版<code>Java</code>的增减时间的处理方式</a>对比一下，看看哪种更好。</p><h3 id="示例-8、如何计算一周后的日期"><a href="#示例-8、如何计算一周后的日期" class="headerlink" title="示例 8、如何计算一周后的日期"></a>示例 8、如何计算一周后的日期</h3><p>和上个例子计算两小时以后的时间类似，这个例子会计算一周后的日期。<code>LocalDate</code>日期不包含时间信息，它的<code>plus()</code>方法用来增加天、周、月，<code>ChronoUnit</code>类声明了这些时间单位。由于<code>LocalDate</code>也是不变类型，返回后一定要用变量赋值。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate nextWeek <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>WEEKS<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今天是:"</span> <span class="token operator">+</span> today <span class="token operator">+</span> <span class="token string">",一周以后的日期: "</span> <span class="token operator">+</span> nextWeek<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 今天是:2016-04-18,一周以后的日期: 2016-04-25</span></code></pre><p>可以看到新日期离当天日期是7天，也就是一周。你可以用同样的方法增加1个月、1年、1小时、1分钟甚至一个世纪，更多选项可以查看<code>Java 8 API</code>中<code>的ChronoUnit</code>类。</p><h3 id="示例-9、计算一年前或一年后的日期"><a href="#示例-9、计算一年前或一年后的日期" class="headerlink" title="示例 9、计算一年前或一年后的日期"></a>示例 9、计算一年前或一年后的日期</h3><p>继续上面的例子，上个例子中我们通过<code>LocalDate</code>的<code>plus()</code>方法增加天数、周数或月数，这个例子我们利用<code>minus()</code>方法计算一年前的日期。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate preYear <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>YEARS<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate nextYear <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>YEARS<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今天是:"</span> <span class="token operator">+</span> today <span class="token operator">+</span> <span class="token string">",一年前的日期: "</span> <span class="token operator">+</span> preYear <span class="token operator">+</span> <span class="token string">",一年后的日期: "</span> <span class="token operator">+</span> nextYear<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 今天是:2016-04-18,一年前的日期: 2015-04-18,一年后的日期: 2017-04-18</span></code></pre><p>例子结果中得到了两个日期，一个2015年、一个2017年、分别是2016年的前一年和后一年。</p><h3 id="示例-10、使用Java8的Clock时钟类"><a href="#示例-10、使用Java8的Clock时钟类" class="headerlink" title="示例 10、使用Java8的Clock时钟类"></a>示例 10、使用Java8的Clock时钟类</h3><p>Java8增加了一个<code>Clock</code>时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到<code>System.currentTimeInMillis()</code>和<code>TimeZone.getDefault()</code>的地方都可用<code>Clock</code>替换。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 得到UTC的时区的日期时间clock对象</span>Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemUTC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Clock : "</span> <span class="token operator">+</span> clock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Clock : SystemClock[Z]</span><span class="token comment" spellcheck="true">// 得到基于当前时区的日期时间clock对象</span>Clock defaultClock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Clock : "</span> <span class="token operator">+</span> clock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Clock : SystemClock[Z]</span></code></pre><p>还可以针对clock时钟做比较，像下面这个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 依赖注入</span>    <span class="token keyword">private</span> Clock clock<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>LocalDate eventDate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventDate<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这种方式在不同时区下处理日期时会非常管用。</p><h3 id="示例-11、如何用Java判断日期是早于还是晚于另一个日期"><a href="#示例-11、如何用Java判断日期是早于还是晚于另一个日期" class="headerlink" title="示例 11、如何用Java判断日期是早于还是晚于另一个日期"></a>示例 11、如何用Java判断日期是早于还是晚于另一个日期</h3><p>另一个工作中常见的操作就是如何判断给定的一个日期是大于某天还是小于某天？在Java8中，<code>LocalDate</code>类有两类方法<code>isBefore()</code>和<code>isAfter()</code>用于比较日期。调用<code>isBefore()</code>方法时，如果给定日期小于当前日期则返回<code>true</code>。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate tomorrow <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tomorrow<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"明天晚于今天！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 明天晚于今天！</span>LocalDate yesterday <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>yesterday<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"昨天先于今天！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 昨天先于今天！</span></code></pre><p>在Java 8中比较日期非常方便，不需要使用额外的<code>Calendar</code>类来做这些基础工作了。</p><h3 id="示例-12、在Java8中处理时区"><a href="#示例-12、在Java8中处理时区" class="headerlink" title="示例 12、在Java8中处理时区"></a>示例 12、在Java8中处理时区</h3><p>Java8不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如<code>ZoneId</code>来处理特定时区，<code>ZoneDateTime</code>类来表示某时区下的时间。这在Java8以前都是<a href="http://javarevisited.blogspot.sg/2013/02/convert-xmlgregoriancalendar-to-date-xmlgregoriancalendar-java-example-tutorial.html" target="_blank" rel="noopener"><code>GregorianCalendar</code>类</a>来做的。下面这个例子展示了如何把本时区的时间转换成另一个时区的时间。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Java 8中某时区下的日期和时间</span>ZoneId america <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"America/New_York"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDateTime localtDateAndTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ZonedDateTime dateAndTimeInNewYork  <span class="token operator">=</span> ZonedDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>localtDateAndTime<span class="token punctuation">,</span> america <span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current date and time in a particular timezone : "</span> <span class="token operator">+</span> dateAndTimeInNewYork<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Current date and time in a particular timezone : 2016-04-19T23:10:09.251-04:00[America/New_York]</span></code></pre><p>和以前<a href="http://javarevisited.blogspot.sg/2012/04/how-to-convert-local-time-to-gmt-in.html" target="_blank" rel="noopener">使用<code>GMT</code>的方式转换本地时间</a>对比一下。注意，在Java8以前，一定要牢牢记住时区的名称，不然就会抛出下面的异常：</p><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>zone<span class="token punctuation">.</span>ZoneRulesException<span class="token operator">:</span> Unknown time<span class="token operator">-</span>zone ID<span class="token operator">:</span> ASIA<span class="token operator">/</span>Tokyo        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>zone<span class="token punctuation">.</span>ZoneRulesProvider<span class="token punctuation">.</span><span class="token function">getProvider</span><span class="token punctuation">(</span>ZoneRulesProvider<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">272</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>zone<span class="token punctuation">.</span>ZoneRulesProvider<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span>ZoneRulesProvider<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">227</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneRegion<span class="token punctuation">.</span><span class="token function">ofId</span><span class="token punctuation">(</span>ZoneRegion<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">120</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">403</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">351</span><span class="token punctuation">)</span></code></pre><h3 id="示例-13、如何表示信用卡到期这类固定日期，答案就在YearMonth"><a href="#示例-13、如何表示信用卡到期这类固定日期，答案就在YearMonth" class="headerlink" title="示例 13、如何表示信用卡到期这类固定日期，答案就在YearMonth"></a>示例 13、如何表示信用卡到期这类固定日期，答案就在<code>YearMonth</code></h3><p>与<code>MonthDay</code>检查重复事件的例子相似，<code>YearMonth</code>是另一个组合类，用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到当月共有多少天，<code>YearMonth</code>实例的<code>lengthOfMonth()</code>方法可以返回当月的天数，在判断2月有28天还是29天时非常有用。</p><pre class=" language-java"><code class="language-java">YearMonth currentYearMonth <span class="token operator">=</span> YearMonth<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"该月的天数 %s: %d%n"</span><span class="token punctuation">,</span> currentYearMonth<span class="token punctuation">,</span> currentYearMonth<span class="token punctuation">.</span><span class="token function">lengthOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 该月的天数 2016-04: 30</span>YearMonth creditCardExpiry <span class="token operator">=</span> YearMonth<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2018</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>FEBRUARY<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您的信用卡到期是： %s%n"</span><span class="token punctuation">,</span> creditCardExpiry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 您的信用卡到期是： 2018-02</span></code></pre><p>根据上述数据，你可以提醒客户信用卡快要到期了，个人认为这个类非常有用。</p><h3 id="示例-14、如何在Java8中检查闰年"><a href="#示例-14、如何在Java8中检查闰年" class="headerlink" title="示例 14、如何在Java8中检查闰年"></a>示例 14、如何在Java8中检查闰年</h3><p><code>LocalDate</code>类有一个很实用的方法<code>isLeapYear()</code>判断该实例是否是一个闰年，如果你还是想重新发明轮子，这有一个代码示例，纯<a href="http://java67.blogspot.sg/2012/12/how-to-check-leap-year-in-java-program.html" target="_blank" rel="noopener">Java逻辑编写的判断闰年</a>的程序。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>today<span class="token punctuation">.</span><span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今年是闰年！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今年不是闰年！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 今年是闰年！</span></code></pre><p>你可以多写几个日期来验证是否是闰年，最好是写<code>JUnit</code>单元测试做判断。</p><h3 id="示例-15、计算两个日期之间的天数和月数"><a href="#示例-15、计算两个日期之间的天数和月数" class="headerlink" title="示例 15、计算两个日期之间的天数和月数"></a>示例 15、计算两个日期之间的天数和月数</h3><p>有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java8中可以用<code>java.time.Period</code>类来做计算。下面这个例子中，我们计算了当天和将来某一天之间的月数。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate java8Release <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>APRIL<span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Period periodToNext <span class="token operator">=</span> Period<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>today<span class="token punctuation">,</span> java8Release<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2016年4月21日距离今天的天数："</span> <span class="token operator">+</span> periodToNext<span class="token punctuation">.</span><span class="token function">getDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2016年4月21日距离今天的天数：3</span></code></pre><p>从上面可以看到现在是一月，Java8的中计算的当前日期是4月18日，中间相隔3天。</p><h3 id="示例-16、包含时差信息的日期和时间"><a href="#示例-16、包含时差信息的日期和时间" class="headerlink" title="示例 16、包含时差信息的日期和时间"></a>示例 16、包含时差信息的日期和时间</h3><p>在Java8中，<code>ZoneOffset</code>类用来表示时区，举例来说印度与GMT或UTC标准时区相差<code>+05:30</code>，可以通过<code>ZoneOffset.of()</code>静态方法来 获取对应的时区。一旦得到了时差就可以通过传入<code>LocalDateTime</code>和<code>ZoneOffset</code>来创建一个<code>OffSetDateTime</code>对象。</p><pre class=" language-java"><code class="language-java">LocalDateTime datetime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>APRIL<span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ZoneOffset offset <span class="token operator">=</span> ZoneOffset<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"+05:30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>OffsetDateTime date <span class="token operator">=</span> OffsetDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>datetime<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"包含时差信息的日期和时间 : "</span> <span class="token operator">+</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含时差信息的日期和时间 : 2016-04-19T23:35+05:30</span></code></pre><p>现在的时间信息里已经包含了时区信息了。注意：<code>OffSetDateTime</code>是对计算机友好的，<code>ZoneDateTime</code>则对人更友好。</p><h3 id="示例-17、在Java8中获取当前的时间戳"><a href="#示例-17、在Java8中获取当前的时间戳" class="headerlink" title="示例 17、在Java8中获取当前的时间戳"></a>示例 17、在Java8中获取当前的时间戳</h3><p>如果你还记得Java8以前是如何获得当前时间戳，那么现在你终于解脱了。<code>Instant</code>类有一个静态工厂方法<code>now()</code>会返回当前的时间戳，如下所示：</p><pre class=" language-java"><code class="language-java">Instant timestamp <span class="token operator">=</span> Instant<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"时间戳是："</span> <span class="token operator">+</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 时间戳是：2016-04-18T15:41:06.876Z</span></code></pre><p>时间戳信息里同时包含了日期和时间，这和<code>java.util.Date</code>很像。实际上<code>Instant</code>类确实等同于Java8之前的<code>Date</code>类，你可以使用<code>Date</code>类和<code>Instant</code>类各自的转换方法互相转换，例如：<code>Date.from(Instant)</code> 将<code>Instant</code>转换成<code>java.util.Date</code>，<code>Date.toInstant()</code>则是将<code>Date</code>类转换成<code>Instant</code>类。</p><h3 id="示例-18、在Java8中如何使用预定义的格式化工具去解析或格式化日期"><a href="#示例-18、在Java8中如何使用预定义的格式化工具去解析或格式化日期" class="headerlink" title="示例 18、在Java8中如何使用预定义的格式化工具去解析或格式化日期"></a>示例 18、在Java8中如何使用预定义的格式化工具去解析或格式化日期</h3><p>在Java8以前的世界里，日期和时间的格式化非常诡异，唯一的帮助类<code>SimpleDateFormat</code>也是非线程安全的，而且用作局部变量解析和格式化日期时显得很笨重。幸好线程局部变量能使它在多线程环境中变得可用，不过这都是过去时了。Java8引入了全新的日期时间格式工具，线程安全而且使用方便。它自带了一些常用的内置格式化工具。下面这个例子使用了<code>BASIC_ISO_DATE</code>格式化工具将2016年4月18日格式化成20160418。</p><pre class=" language-java"><code class="language-java">String day <span class="token operator">=</span> <span class="token string">"20160418"</span><span class="token punctuation">;</span>LocalDate formatted <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>day<span class="token punctuation">,</span> DateTimeFormatter<span class="token punctuation">.</span>BASIC_ISO_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"从字符串中解析的日期: %s 是 %s %n"</span><span class="token punctuation">,</span> day<span class="token punctuation">,</span> formatted<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从字符串中解析的日期: 20160418 是 2016-04-18 </span></code></pre><p>很明显的看出得到的日期和给出的日期是同一天，但是格式不同。</p><h3 id="示例-19、如何在Java中使用自定义格式化工具解析日期"><a href="#示例-19、如何在Java中使用自定义格式化工具解析日期" class="headerlink" title="示例 19、如何在Java中使用自定义格式化工具解析日期"></a>示例 19、如何在Java中使用自定义格式化工具解析日期</h3><p>上个例子使用了<a href="http://java67.blogspot.sg/2014/12/string-to-date-example-in-java-multithreading.html" target="_blank" rel="noopener"><code>Java</code>内置的格式化工具</a>去解析日期字符串。尽管内置格式化工具很好用，有时还是需要定义特定的日期格式，下面这个例子展示了如何创建自定义日期格式化工具。例子中的日期格式是“MMM dd yyyy”。可以调用<code>DateTimeFormatter</code>的<code>ofPattern()</code>静态方法并传入任意格式返回其实例，格式中的字符和以前代表的一样，M代表月，m代表分。如果格式不规范会抛出<code>DateTimeParseException</code>异常，不过如果只是把M写成m这种逻辑错误是不会抛异常的。</p><pre class=" language-java"><code class="language-java">String day <span class="token operator">=</span> <span class="token string">"2016 04 18"</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    DateTimeFormatter formatter <span class="token operator">=</span> DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"yyyy MM dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDate holiday <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>day<span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"成功解析字符串：%s, 时间是：%s%n"</span><span class="token punctuation">,</span> day<span class="token punctuation">,</span> holiday<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">DateTimeParseException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s 解析失败!"</span><span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span>    ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 成功解析字符串：2016 04 18, 时间是：2016-04-18</span></code></pre><p>日期值与传入的字符串是匹配的，只是格式不同而已。</p><h3 id="示例-20、在Java8中如何把日期转换成字符串"><a href="#示例-20、在Java8中如何把日期转换成字符串" class="headerlink" title="示例 20、在Java8中如何把日期转换成字符串"></a>示例 20、在Java8中如何把日期转换成字符串</h3><p>上 两个例子都用到了<code>DateTimeFormatter</code>类，主要是从字符串解析日期。现在我们反过来，把<code>LocalDateTime</code>日期实例转换成特定格式的字符串。这是迄今为止<a href="http://java67.blogspot.sg/2013/01/how-to-format-date-in-java-simpledateformat-example.html" target="_blank" rel="noopener"><code>Java</code>日期转字符串最为简单的方式</a>了。下面的例子将返回一个代表日期的格式化字符串。和前面类似，还是需要创建<code>DateTimeFormatter</code>实例并传入格式，但这回调用的是<code>format()</code>方法，而非<code>parse()</code>方法。这个方法会把传入的日期转化成指定格式的字符串。</p><pre class=" language-java"><code class="language-java">LocalDateTime arrivalDate  <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    DateTimeFormatter format <span class="token operator">=</span> DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd yyyy  hh:mm a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String landing <span class="token operator">=</span> arrivalDate<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"格式化的日期时间:  %s %n"</span><span class="token punctuation">,</span> landing<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">DateTimeException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s 不能格式化!%n"</span><span class="token punctuation">,</span> arrivalDate<span class="token punctuation">)</span><span class="token punctuation">;</span>    ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 格式化的日期时间:  四月 19 2016  12:02 上午</span></code></pre><p>当前时间被指定的“MMM dd yyyy hh:mm a”格式格式化，格式包含3个代表月的字符串，时间后面带有AM和PM标记。</p><h2 id="Java-8日期时间API的重点"><a href="#Java-8日期时间API的重点" class="headerlink" title="Java 8日期时间API的重点"></a>Java 8日期时间API的重点</h2><p>通过这些例子，你肯定已经掌握了Java8日期时间API的新知识点。现在我们来回顾一下这个优雅<code>API</code>的使用要点：</p><ol><li>提供了<code>javax.time.ZoneId</code>获取时区。</li><li>提供了<code>LocalDate`</code>和LocalTime`类。</li><li>Java8的所有日期和时间<code>API</code>都是不可变类并且线程安全，而现有的<code>Date</code>和<code>Calendar</code> API中的<code>java.util.Date</code>和<code>SimpleDateFormat</code>是非线程安全的。</li><li>主包是<code>java.time</code>,包含了表示日期、时间、时间间隔的一些类。里面有两个子包<code>java.time.format</code>用于格式化， <code>java.time.temporal</code>用于更底层的操作。</li><li>时区代表了地球上某个区域内普遍使用的标准时间。每个时区都有一个代号，格式通常由区域/城市构成（Asia/Tokyo），在加上与格林威治或<code>UTC</code>的时差。例如：东京的时差是+09:00。</li><li><code>OffsetDateTime</code>类实际上组合了<code>LocalDateTime</code>类和<code>ZoneOffset</code>类。用来表示包含和格林威治或UTC时差的完整日期（年、月、日）和时间（时、分、秒、纳秒）信息。</li><li><code>DateTimeFormatter</code>类用来格式化和解析时间。与<code>SimpleDateFormat</code>不同，这个类不可变并且线程安全，需要时可以给静态常量赋值。<code>DateTimeFormatter</code>类提供了大量的内置格式化工具，同时也允许你自定义。在转换方面也提供了<code>parse()</code>将字符串解析成日期，如果解析出错会抛出<code>DateTimeParseException</code>。<code>DateTimeFormatter</code>类同时还有<code>format()</code>用来格式化日期，如果出错会抛出<code>DateTimeException</code>异常。</li><li>再补充一点，日期格式“MMM d yyyy”和“MMM dd yyyy”有一些微妙的不同，第一个格式可以解析“Jan 2 2014”和“Jan 14 2014”，而第二个在解析“Jan 2 2014”就会抛异常，因为第二个格式里要求日必须是两位的。如果想修正，你必须在日期只有个位数时在前面补零，就是说“Jan 2 2014”应该写成 “Jan 02 2014”。</li></ol><p>如何使用Java8的全新日期时间API就介绍到这了。这些简单的例子对帮助理解新API非常有用。由于这些例子都基于真实任务，你在做<code>Java</code>日期编程时不用再东张西望了。我们学会了如何创建并操作日期实例，学习了纯日期、以及包含时间信息和时差信息的日期、学会了怎样计算两个日期的间隔，这些在计算当天与某个特定日期间隔的例子中都有所展示。 我们还学到了在Java8中如何线程安全地解析和格式化日期，不用再使用蹩脚的线程局部变量技巧，也不用依赖<code>Joda Time</code>第三方库。新<code>API</code>可以作为处理日期时间操作的标准。</p><p>如果你喜欢这个教程并希望看到更多关于Java 8的教程，下面这些精彩的文章都值得一看：</p><ul><li>如何在Java8中用一行代码搞定文件读取？(<a href="http://javarevisited.blogspot.sg/2015/02/how-to-read-file-in-one-line-java-8.html" target="_blank" rel="noopener">示例</a>)</li><li>学习Java8的十大教程（<a href="http://java67.blogspot.sg/2014/09/top-10-java-8-tutorials-best-of-lot.html" target="_blank" rel="noopener">教程</a>）</li><li>免费的Java8教程和图书 （<a href="http://javarevisited.blogspot.sg/2013/11/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html" target="_blank" rel="noopener">资源</a>）</li><li>Java 8 <code>Comparator</code>例子 （<a href="http://java67.blogspot.com/2014/11/java-8-comparator-example-using-lambda-expression.html" target="_blank" rel="noopener">示例</a>）</li><li>如何使用Java8的<code>Map</code>函数（<a href="http://java67.blogspot.sg/2015/01/java-8-map-function-examples.html" target="_blank" rel="noopener">示例</a>）</li><li>你准备好学习Java8的认证了吗 （<a href="http://javarevisited.blogspot.sg/2014/09/latest-OCPJP-exam-java-8-certification-oracle-java-se-8.html" target="_blank" rel="noopener">更多</a>）</li><li>如何使用Java8的默认方法。（<a href="http://javarevisited.blogspot.sg/2014/07/default-defender-or-extension-method-of-Java8-example-tutorial.html" target="_blank" rel="noopener">看这里</a>）</li><li>开始Java8之前需要温习的十个<code>Java 7</code>特性（<a href="http://javarevisited.blogspot.sg/2014/04/10-jdk-7-features-to-revisit-before-you.html" target="_blank" rel="noopener">更多</a>）</li><li>Java8学习<code>Stream API</code>十例（<a href="http://javarevisited.blogspot.sg/2014/03/2-examples-of-streams-with-Java8-collections.html" target="_blank" rel="noopener">示例</a>）</li><li>如何在匿名类中使用<code>Lambda</code>表达式（<a href="http://javarevisited.blogspot.sg/2015/01/how-to-use-lambda-expression-in-place-anonymous-class-java8.html" target="_blank" rel="noopener">答案</a>）</li><li>如何使用Java8的<code>Predicates</code>类过滤<code>Collection</code>？（<a href="http://javarevisited.blogspot.sg/2015/02/how-to-filter-collections-in-java-8.html" target="_blank" rel="noopener">答案</a>）</li><li><code>Java</code>中如何随即访问文件？（<a href="http://javarevisited.blogspot.sg/2015/02/randomaccessfile-example-in-java-read-write-String.html" target="_blank" rel="noopener">答案</a>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我对我的部分同学非常失望！懒惰、愚蠢、耍小心机</title>
      <link href="/2018/09/02/xiang-ce/wo-dui-wo-de-bu-fen-tong-xue-fei-chang-shi-wang-lan-duo-yu-chun-shua-xiao-xin-ji/"/>
      <url>/2018/09/02/xiang-ce/wo-dui-wo-de-bu-fen-tong-xue-fei-chang-shi-wang-lan-duo-yu-chun-shua-xiao-xin-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687320-3fb16500-fb3c-11e8-83b1-c8c807cb4a89.png" alt="在这里插入图片描述"></p><p>我对我的部分同学非常失望！懒惰、愚蠢、耍小心机,他们竟然把学校学生会的那一套带到了公司，真的担心他们教坏学弟学妹！这群人只配做一些低级码农，全然没有珍惜时间的概念和大学生应有的活力和朝气。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>上周吃坏了肚子。</title>
      <link href="/2018/08/26/xiang-ce/shang-zhou-chi-pi-liao-du/"/>
      <url>/2018/08/26/xiang-ce/shang-zhou-chi-pi-liao-du/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687292-e0535500-fb3b-11e8-8191-84b5614c2f88.png" alt="在这里插入图片描述"></p><p>上周吃坏了肚子，疼死我了。重要的是公司的工资也没发，现在都不敢乱吃东西了。有时候甚至会想，到底是远方的理想重要还是手中的钱重要呢？</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>智慧布局人生，无惧小人</title>
      <link href="/2018/07/12/xiang-ce/jin-tian-wo-xuan-ze-liu-xia-xi-wang-bu-fu-shao-hua/"/>
      <url>/2018/07/12/xiang-ce/jin-tian-wo-xuan-ze-liu-xia-xi-wang-bu-fu-shao-hua/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687256-894d8000-fb3b-11e8-9f07-50ab6366d7cb.png" alt="在这里插入图片描述"></p><p>今天我选择留下，希望不负韶华！不过，拿着简历，凭实力怼hr还是很爽的，虽然这样做很不聪明，但还是在步入社会之初放肆一下吧，哈哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>API扫描工具类的实现</title>
      <link href="/2018/06/07/lao-bo-ke/api-sao-miao-gong-ju-lei-de-shi-xian/"/>
      <url>/2018/06/07/lao-bo-ke/api-sao-miao-gong-ju-lei-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>公司的架构师开发了一套接口扫描工具类，我想着，如果自己以后开公司了可能也用得着，所以研究了下，整理出了下面的开发思路和相关技术代码。<br>     API扫描工具类的主要开发思路如下：<br>     1、定义接口上的注解；<br>     2、引用注解<br>     3、扫描注解<br>     首先定义注解：</p><p>定义接口上的注解</p><pre><code>package com.fs.comment;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value = {ElementType.METHOD, ElementType.FIELD,ElementType.LOCAL_VARIABLE,ElementType.PARAMETER})public @interface PersistenceContext {    String unitName();}</code></pre><p>关于注解：请参照下面的文章：<br><a href="https://blog.csdn.net/forezp/article/details/78026146" target="_blank" rel="noopener">Java注解详解</a><br><a href="https://blog.csdn.net/limj625/article/details/70242773" target="_blank" rel="noopener">Java注解之Retention、Documented、Target介绍</a><br><a href="https://blog.csdn.net/shao_zhiqiang/article/details/51764296" target="_blank" rel="noopener">实用的java注解工具类</a><br>如果想要动态的修改注解的值【如动态切换数据源】，一般看来注解的值是不能动态修改的，但是借助特殊工具还是可以的，参照下面的文章：<br><a href="https://blog.csdn.net/jly4758/article/details/44774217" target="_blank" rel="noopener">JAVAssist—动态修改注解</a></p><p>引用注解</p><pre><code>package com.fs.model.model2.model3.model4.model5;import com.fs.comment.PersistenceContext;import com.fs.model.EntityManager;public class CollectionBase{      /**      * 注入实体单元      */      @PersistenceContext(unitName=&quot;collection-entity&quot;)      protected EntityManager em;      /**EntityManger      * 实例化      */    @PersistenceContext(unitName=&quot;collection-entity-01-01-01-01-01-01&quot;)      public EntityManager getEntityManager() {                  return this.em;      }      @PersistenceContext(unitName=&quot;collection-entity-01-02-02-01-01-01&quot;)    public EntityManager getEntityManager2() {                  return this.em;      }  } </code></pre><p>扫描注解<br>扫描注解的工具类是参考了别人的代码写出来的。</p><pre><code>package com.fs.commentUtils;import java.io.File;import java.io.FileFilter;import java.io.IOException;import java.lang.reflect.Method;import java.net.URL;import java.net.URLDecoder;import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import com.fs.comment.PersistenceContext;/** *  * 注解扫描工具类; * */public class CommentScanUtil {    /**           * getRequestMappingValue方法描述:         * 作者:JunJun       * 日期:2018年6月7日 下午5:41:00                * 异常对象:@param packageName       * 异常对象:@return     */        public static List&lt;String&gt; getRequestMappingValue(String packageName) {       // GetAnnotationValueUtil getAnnotationValueUtil = new GetAnnotationValueUtil();             //第一个class类的集合              List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;Class&lt;?&gt;&gt;();              //是否循环迭代              boolean recursive = true;              //获取包的名字 并进行替换              String packageDirName = packageName.replace(&#39;.&#39;, &#39;/&#39;);              //定义一个枚举的集合 并进行循环来处理这个目录下的文件             Enumeration&lt;URL&gt; dirs;            try {                  //读取指定package下的所有class                dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName);                 while (dirs.hasMoreElements()){                      URL url = dirs.nextElement();                      //得到协议的名称                      String protocol = url.getProtocol();                    //判断是否以文件的形式保存在服务器上                      if (&quot;file&quot;.equals(protocol)) {                        //获取包的物理路径                           String filePath = URLDecoder.decode(url.getFile(), &quot;UTF-8&quot;);                         filePath = filePath.substring(1);                        //以文件的方式扫描整个包下的文件 并添加到集合中                          findAndAddClassesInPackageByFile(packageName, filePath, recursive, classes);                    }                 }              } catch (IOException e) {                e.printStackTrace();              }             List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();            for (Class&lt;?&gt; clazz : classes) {                //循环获取所有的类                Class&lt;?&gt; c = clazz;                //获取类的所有方法                Method[] methods = c.getMethods();                for (Method method : methods) {                    //获取RequestMapping注解                    PersistenceContext annotation = method.getAnnotation(PersistenceContext.class);                    if (annotation != null) {                        //获取注解的value值                        String value = annotation.unitName();                        System.out.println(&quot;-------anoValue--------&quot;+value);                    }                }            }            return stringList;        }        /**             * findAndAddClassesInPackageByFile方法描述:           * 作者:JunJun         * 日期:2018年6月7日 下午5:41:12                  * 异常对象:@param packageName         * 异常对象:@param packagePath         * 异常对象:@param recursive         * 异常对象:@param classes          */        public static void findAndAddClassesInPackageByFile(String packageName, String packagePath, final boolean recursive, List&lt;Class&lt;?&gt;&gt; classes){              //packagePath = packagePath.trim().substring(1);            //获取此包的目录 建立一个File              File dir = new File(packagePath);            //如果不存在或者 也不是目录就直接返回              if (!dir.exists() || !dir.isDirectory()) {                return;              }              //如果存在 就获取包下的所有文件 包括目录              File[] dirfiles = dir.listFiles(new FileFilter() {                    //自定义过滤规则 如果可以循环(包含子目录) 或则是以.class结尾的文件(编译好的java类文件)                    public boolean accept(File file) {                     return (recursive &amp;&amp; file.isDirectory()) || (file.getName().endsWith(&quot;.class&quot;));                    }            });             //循环所有文件             for (File file : dirfiles) {                 //如果是目录 则继续扫描                  if (file.isDirectory()) {                    findAndAddClassesInPackageByFile(packageName + &quot;.&quot; + file.getName(),                                            file.getAbsolutePath(),                                            recursive,                                            classes);                }                  else {                      //如果是java类文件 去掉后面的.class 只留下类名                      String className = file.getName().substring(0, file.getName().length() - 6);                     try {                          //添加到集合中去                          classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + &quot;.&quot; + className));                      } catch (ClassNotFoundException e) {                          e.printStackTrace();                      }                  }              }         }}</code></pre><p>经过测试，证实这段代码对深层代码的递归扫描性能很高。测试的递归路径如下图所示：<br><img src="https://img-blog.csdn.net/20180607212933565?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqMjAxNDIyMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>另外在研究过程中尝试了自动解析API参数为JSON ，虽然最终以失败告终,失败的原因是写出来的代码无法适应参数中泛型以及泛型中属性名的动态匹配。下面是在尝试中总结出来的工具类：</p><p>扫描API中参数的类型工具类：</p><pre><code>package com.fs;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import com.fs.comment.NoNull;import com.fs.model.BlueChartProjectSearchFilter;import com.fs.model.ReqObject;import com.fs.model.ReqQuery;import com.fs.model.Student;import com.fs.model.Teacher;/** * 通过反射获取泛型信息 *  * @author Administrator * */public class Generic {    /**     * 方法一     *      * @param map     * @param list     */    public static void test01(@NoNull ReqObject&lt;ReqQuery&lt;BlueChartProjectSearchFilter&gt;&gt;  map, @NoNull List&lt;Student&gt; list,            @NoNull Teacher&lt;Student&gt; a) {        System.out.println(&quot;Generic.test01()&quot;);    }    public static void main(String[] args) {        try {            Method[] methods = Generic.class.getDeclaredMethods();            Class&lt;?&gt;[] parameterTypes2 = methods[1].getParameterTypes();            Method m = Generic.class.getMethod(&quot;test01&quot;, parameterTypes2);            Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();            for (Class&lt;?&gt; class1 : parameterTypes) {                System.out.println(&quot;---------&gt;&lt;&gt;&lt;&gt;&lt;&gt;&quot; + class1);            }            Type[] t = m.getGenericParameterTypes();// 获取参数泛型            for (Type paramType : t) {                System.out.println(&quot;#&quot; + paramType);                if (paramType instanceof ParameterizedType) {                    Type[] genericTypes = ((ParameterizedType) paramType).getActualTypeArguments();                    for (@SuppressWarnings(&quot;unused&quot;) Type genericType : genericTypes) {                        System.out.println(&quot;#&quot;+paramType);                    }                }            }        } catch (NoSuchMethodException e) {            e.printStackTrace();        } catch (SecurityException e) {            e.printStackTrace();        }    }}</code></pre><p>字符串转化为JAVA代码的工具类:</p><pre><code>package com.fs.commentUtils;import java.util.Map;import org.apache.commons.jexl2.Expression;import org.apache.commons.jexl2.JexlContext;import org.apache.commons.jexl2.JexlEngine;import org.apache.commons.jexl2.MapContext;import com.fs.model.BlueChartProjectSearchFilter;import com.fs.model.ReqObject;import com.fs.model.ReqQuery;import net.sf.json.JSONObject;/** * 字符串转化为代码; *  * @author xdsm * */public class StringToCode {    /**     *      * @author: Longjun     * @Description: 使用commons的jexl可实现将字符串变成可执行代码的功能     * @date:2016年3月21日 下午1:45:13     */    public static Object convertToCode(String jexlExp, Map&lt;String, Object&gt; map) {        JexlEngine jexl = new JexlEngine();        Expression e = jexl.createExpression(jexlExp);        JexlContext jc = new MapContext();        for (String key : map.keySet()) {            jc.set(key, map.get(key));        }        if (null == e.evaluate(jc)) {            return &quot;&quot;;        }        return e.evaluate(jc);    }    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {          /*ReqObject req = (ReqObject) Class.forName(&quot;com.fs.model.ReqObject&quot;).newInstance();        ReqQuery reqq = (ReqQuery) Class.forName(&quot;com.fs.model.ReqQuery&quot;).newInstance();        BlueChartProjectSearchFilter bcsf = (BlueChartProjectSearchFilter) Class.forName(&quot;com.fs.model.BlueChartProjectSearchFilter&quot;).newInstance();        reqq.setObj(bcsf);        req.setObj(reqq);        JSONObject json = JSONObject.fromObject(req);*/        /*Object req = Class.forName(&quot;com.fs.model.ReqObject&quot;).cast(Class.forName(&quot;com.fs.model.ReqObject&quot;).newInstance());        Object reqq = Class.forName(&quot;com.fs.model.ReqQuery&quot;).cast(Class.forName(&quot;com.fs.model.ReqQuery&quot;).newInstance());        Object bcsf = Class.forName(&quot;com.fs.model.BlueChartProjectSearchFilter&quot;).cast(Class.forName(&quot;com.fs.model.BlueChartProjectSearchFilter&quot;).newInstance());        Field[] fields = req.getClass().getDeclaredFields();        for (Field field : fields) {            String fieldStr = field.toString();            String[] fieldPreStrArray = fieldStr.split(&quot; &quot;);            String fieldType = fieldPreStrArray[1];            String fieldName = fieldPreStrArray[2].substring(fieldPreStrArray[2].lastIndexOf(&quot;.&quot;) + 1);            System.out.println(&quot;----fieldType----&quot;+fieldType);            System.out.println(&quot;//----fieldName----&quot;+fieldName);        }*/        ReqObject&lt;ReqQuery&lt;BlueChartProjectSearchFilter&gt;&gt; req = new ReqObject&lt;ReqQuery&lt;BlueChartProjectSearchFilter&gt;&gt;();        JSONObject json = JSONObject.fromObject(req);        System.out.println(json);        /*try {              Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;();               map.put(&quot;money&quot;,2100);                String expression=&quot;money&gt;=2000&amp;&amp;money&lt;=4000&quot;;            Object code = convertToCode(expression,map);            System.out.println(code);        } catch (Exception e) {              // TODO Auto-generated catch block              e.printStackTrace();          }  */    }  }</code></pre><p>参考文章：<a href="https://blog.csdn.net/junlong750/article/details/50945883" target="_blank" rel="noopener">java将字符串转换成可执行代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 老博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我想，我不能为了让别人喜欢我而变成我讨厌的样子吧?</title>
      <link href="/2018/06/02/xiang-ce/wo-xiang-wo-bu-neng-wei-liao-rang-bie-ren-xi-huan-wo-er-bian-cheng-wo-tao-yan-de-yang-zi-ba/"/>
      <url>/2018/06/02/xiang-ce/wo-xiang-wo-bu-neng-wei-liao-rang-bie-ren-xi-huan-wo-er-bian-cheng-wo-tao-yan-de-yang-zi-ba/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687228-49869880-fb3b-11e8-9caf-97b4df21fd8a.jpg" alt="在这里插入图片描述"></p><p>我想，我不能为了让别人喜欢我而变成我讨厌的样子吧？如果没有格局，内心还是会很空虚的</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>别人问我们俩咋认识的，你说你也不知道</title>
      <link href="/2018/05/27/xiang-ce/bie-ren-wen-wo-men-lia-zha-ren-shi-de-ni-shuo-ni-ye-bu-zhi-dao/"/>
      <url>/2018/05/27/xiang-ce/bie-ren-wen-wo-men-lia-zha-ren-shi-de-ni-shuo-ni-ye-bu-zhi-dao/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687212-eac11f00-fb3a-11e8-9e0b-42f490d81f13.png" alt="在这里插入图片描述"></p><p>别人问我们俩咋认识的，你说你也不知道，其实我也不知道，或许就是第一次见面感觉亲切我就主动接近你了吧。现在，你要去西安了，我也想去。但是有太多的无奈，或许等实现了梦想，我还可以远远的看看你吧。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>这个瓜娃子，竟然偷拍我。。。。。。</title>
      <link href="/2018/05/25/xiang-ce/zhe-ge-gua-wa-zi-jing-ran-tou-pai-wo/"/>
      <url>/2018/05/25/xiang-ce/zhe-ge-gua-wa-zi-jing-ran-tou-pai-wo/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687178-68d0f600-fb3a-11e8-87a0-39f8dd88fe33.jpg" alt="在这里插入图片描述"></p><p>这个瓜娃子，竟然偷拍我。。。。。。，祝前程似锦，无问西东。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>运行时异常RunTimeExcepption</title>
      <link href="/2018/04/19/lao-bo-ke/yun-xing-shi-yi-chang-runtimeexcepption/"/>
      <url>/2018/04/19/lao-bo-ke/yun-xing-shi-yi-chang-runtimeexcepption/</url>
      
        <content type="html"><![CDATA[<p>前几天写代码的时候，遇到一个需求，保存的时候如果重名则不执行保存，并抛出异常。但是当我抛出的不是运行时异常的时候，这个异常就需要一层层的捕获。就像下面这样：</p><pre><code>ExceptionTest .javapackage com.lz.utils;public class ExceptionTest {   public static void testRunTimeException() throws Exception {      //throw new MyRunTimeException(&quot;运行时的异常！&quot;);       throw new Exception();   }}Test.javapackage com.lz;import com.lz.utils.ExceptionTest;import com.lz.utils.GetDBPhysicDesignTxt;public class Test {public static void main(String[] args) throws Exception {    ExceptionTest.testRunTimeException();}}</code></pre><p>或者这样</p><pre><code>ExceptionTest.javapackage com.lz.utils;public class ExceptionTest {   public static void testRunTimeException() {      //throw new MyRunTimeException(&quot;运行时的异常！&quot;);       try {        throw new Exception();    } catch (Exception e) {        // TODO Auto-generated catch block        e.printStackTrace();    }   }}</code></pre><p>但是从一个程序员的角度，考虑，重名属于运行后进行操作才产生的异常，正常情况下应该抛出运行时异常，并且公司我最膜拜的架构师【据说是离神最近的男人】是已经封装好了异常，自定义运行时异常，因此就使用了运行时异常实现：<br>代码如下：</p><pre><code>MyRunTimeException.java自定义的运行时异常类：package com.lz.utils;public class MyRunTimeException extends RuntimeException {    public MyRunTimeException(String info) {        super(info);    }}ExceptionTest.javapackage com.lz.utils;public class ExceptionTest {   public static void testRunTimeException() {      throw new MyRunTimeException(&quot;运行时的异常！&quot;);   }}</code></pre><p>使用自定义运行时异常后，发现省事好多，异常并不需要一级一级的向上抛出或者在当前类捕获。</p><p>借助这个案例分析了下运行时异常的特点：</p><blockquote><ul><li>A: 运行时期异常的概述: <ul><li>RuntimeException和他的所有子类异常,都属于运行时期异常。<br>  NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常.</li></ul></li><li>B：运行时期异常的特点<ul><li>a：方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常。</li><li>b：运行时期异常一旦发生,需要程序人员修改源代码。<br>设计原因:<br>  运行异常,不能发生,但是如果发生了,程序人员停止程序修改源代码<br>  运行异常: 一旦发生,不要处理,请你修改源代码,运行异常一旦发生,后面的代码没有执行的意义</li></ul></li></ul></blockquote><hr><p>这就是运行时异常的总结，就问还有谁。</p>]]></content>
      
      
      <categories>
          
          <category> 老博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你曾是少年！</title>
      <link href="/2018/04/17/xiang-ce/ni-ceng-shi-shao-nian/"/>
      <url>/2018/04/17/xiang-ce/ni-ceng-shi-shao-nian/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687160-1f80a680-fb3a-11e8-93b1-b17cf69d32a0.jpg" alt="在这里插入图片描述"></p><p>你曾是少年！</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>智慧布局人生，无惧小人</title>
      <link href="/2018/03/17/xiang-ce/zhi-hui-bu-ju-ren-sheng-wu-ju-xiao-ren/"/>
      <url>/2018/03/17/xiang-ce/zhi-hui-bu-ju-ren-sheng-wu-ju-xiao-ren/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687141-cd3f8580-fb39-11e8-8764-a5cf3055d9c4.jpg" alt="在这里插入图片描述"></p><p>智慧布局人生，无惧小人</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生活不只远方的梦想，还有嘴里的油盐酱醋茶。</title>
      <link href="/2018/03/10/xiang-ce/sheng-huo-bu-zhi-yuan-fang-de-meng-xiang-huan-you-zui-li-de-you-yan-jiang-cu-cha/"/>
      <url>/2018/03/10/xiang-ce/sheng-huo-bu-zhi-yuan-fang-de-meng-xiang-huan-you-zui-li-de-you-yan-jiang-cu-cha/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687128-8ea9cb00-fb39-11e8-8d0c-e1238ef9d963.jpg" alt="在这里插入图片描述"></p><p>生活不只远方的梦想，还有嘴里的油盐酱醋茶。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>所谓的命运不过就是一个个选择的连线</title>
      <link href="/2018/02/09/xiang-ce/suo-wei-de-ming-yun-bu-guo-jiu-shi-yi-ge-ge-xuan-ze-de-lian-xian/"/>
      <url>/2018/02/09/xiang-ce/suo-wei-de-ming-yun-bu-guo-jiu-shi-yi-ge-ge-xuan-ze-de-lian-xian/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687094-f6abe180-fb38-11e8-9882-c82f0282302a.png" alt="在这里插入图片描述"></p><p>所谓的命运不过就是一个个选择的连线，抉择将至，有舍才有得。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>其实我遇到的社会人也挺好的</title>
      <link href="/2018/01/27/xiang-ce/qi-shi-wo-yu-dao-de-she-hui-ren-ye-ting-hao-de/"/>
      <url>/2018/01/27/xiang-ce/qi-shi-wo-yu-dao-de-she-hui-ren-ye-ting-hao-de/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687061-82713e00-fb38-11e8-8556-3b6a0bd82dea.jpg" alt="在这里插入图片描述"></p><p>其实我遇到的社会人也挺好的，不像老师说的那样不堪……。话说遇到一个好厉害的单身汪，我要跟着他好好学，哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>下雪了天很冷</title>
      <link href="/2018/01/24/xiang-ce/xia-xue-liao-tian-hen-leng/"/>
      <url>/2018/01/24/xiang-ce/xia-xue-liao-tian-hen-leng/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687031-10005e00-fb38-11e8-931d-15e9d59bb54a.jpg" alt="在这里插入图片描述"></p><p>下雪了，天很冷，远方的你还好吧，为什么要生气呢？不知不觉我的脚步越走越远，这是我实习的地方，下一站会是哪里呢？</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>总有人在想着你，年华似水，何不好好努力</title>
      <link href="/2017/12/31/xiang-ce/zong-you-ren-zai-xiang-zhao-ni-nian-hua-si-shui-he-bu-hao-hao-nu-li/"/>
      <url>/2017/12/31/xiang-ce/zong-you-ren-zai-xiang-zhao-ni-nian-hua-si-shui-he-bu-hao-hao-nu-li/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49687005-d3346700-fb37-11e8-92ea-e6f91346b7b7.jpg" alt="在这里插入图片描述"></p><p>总有人在想着你，年华似水，何不好好努力，不辜负你爱的人和爱你的人。话说本想送她一本书的，送啥好呢？</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react中flux框架部分底层原理的初步理解</title>
      <link href="/2017/12/24/lao-bo-ke/zi-ji-dui-react-zhong-flux-kuang-jia-bu-fen-di-ceng-yuan-li-de-li-jie/"/>
      <url>/2017/12/24/lao-bo-ke/zi-ji-dui-react-zhong-flux-kuang-jia-bu-fen-di-ceng-yuan-li-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p>这是我在学习react框架时的个人理解，包含个人总结和案例中代码的分析，对于react中部分与内存分配相关的原理还是不是很懂:<br>1.个人总结：</p><blockquote><p>flux架构的理解：<br>    flux架构中数据是单向流动的；<br>    view[components]经过出发产生action，action通过转发器dispatchet转发至store中，在store中action被注册在action中的回调函数接收和解析，通过计算store会更新store中的数据【存放组件状态的对象】，同时发送事件信号，发送的事件信号将被添加了事件监听对象的组件监听，<br>    当组件监听事件成功后会调用组件的this.setState()函数更新组件的状态,从而驱动组件的重新渲染过程.<br>flux中各种model推荐的构建的顺序:<br>    1.Dispatch在整个应用中是全局唯一的，可以通过 new Dispatcher()创建，用于转发action;<br>    2.创建每个组件【每类】组件对应的action,在action中接收来在组件的数据并创建action对象，通过dispatcher转发到store中，之后会调用在store中注册的回调函数，解析action更新storez中的相关数据;<br>    3.创建组件的store，在store中存储组件的初始状态，在store中完成的工作是生成新的数据并发送更新信号；<br>    4.创建对应的组件，在组件类中首先应该获取初始值，并添加监听函数，动作响应函数。<br>    以上flux构建项目的步骤只是本人总结归纳的，具体的步骤以实际开发为准;<br>A.flux中应该注意的问题：action为一个纯函数，多次引用在每个引用model的存储空间中初始化了多分实例，但是其产出只依赖于输入，所以无论整个应用中生成的实例是唯一的还是多个对整个应用功能的实现是不影响的;<br>B.Dispatcher对象在多次的引用过过程中不会生成多个实例，其底层只用的是单例模式实现的，因此在flxu应用中，我们使用的dispatcher对象是全局唯一并且是所有的模块共享的;只有这样我们才能保证在Action中调用了Dispatcher.dispatch(action);之后会去调用在store中注册的回调函数计算出新的数据[一般认为这个回调函数的调用时自动完成的]。<br>C：每个组件对应的store在全局范围内是唯一的，这样可以办证在不同的地方进行引用时可以获得同步的数据,这是通过浅复制的原理实现的;</p></blockquote><hr><p>2.案例代码分心<br><strong>action：</strong></p><pre><code>//action描述了组件发出的请求，包含了请求的类型和请求传递的数据;//action是一个纯函数，其产出只依赖与输入；//在实际的操作中，counterCasption相当于组件的ID,当组件产生动作的同时如果携带了数据，那么还可以添加对应的数据项；import * as ActionTypes from &#39;./ActionTypes.js&#39;;import AppDispatcher from &#39;../dispatchers/Appdispatcher.js&#39;;//定义action构造器;export const increment = (counterCaption)=&gt;{  AppDispatcher.dispatch(    {      type:ActionTypes.INCREMENT,      counterCaption:counterCaption    }  );};export const decrement = (counterCaption)=&gt;{  AppDispatcher.dispatch(    {      type:ActionTypes.DECREMENT,      counterCaption:counterCaption    }  );}</code></pre><p><strong>store</strong></p><pre><code>//CounterStore相当于一类组件的数据中心，它是单例的共享的；//Store中包含了组件是无状态model,其中包含了组件的初始状态值,以普通对象的形式存在;//一般在store中应该提供一个get方法，用于组件获取初始状态的值;//store中应该为Dispatcher注册状态计算函数，用于更新计算出新的数据，当组件同步这些数据后，组件的状态会更新，渲染被驱动进行;import AppDispatcher from &#39;../dispatchers/Appdispatcher.js&#39;;import * as ActionTypes from &#39;../actions/ActionTypes&#39;;import {EventEmitter} from &#39;events&#39;;//定义监听事件;const CHANGE_EVENT = &#39;changed&#39;;//定义组件的初始值，当组件加载的时候会在声明周期函数中同步这些值到组件的状态或者属性上去;const counterValues = {  &#39;First&#39;: 0,  &#39;Second&#39;: 10,  &#39;Third&#39;: 30};//定义组件的store对象;const CounterStore = Object.assign({},EventEmitter.prototype,{  //定义getter函数，方便数据的同步;  getCounterValues:function(){    return counterValues;  },  //定义事件发射函数,store中的数据发生改变的时候通知对应的组件更新数据[是否会造成所有监听到该事件的组件都去调用getter函数同步数据呢？//会不会造成应用运行效率的降低呢];emitChange:function(){  this.emit(CHANGE_EVENT);},//定义事件监听器添加函数，当组件挂载成功的时候添加监听函数;//callbacek函数由调用者传入，用于指明监听到事件后的行为，//通常callback函数的作用是更新组件的内部状态;addChangeListener:function(callback){  this.on(CHANGE_EVENT,callback);},//监听函数移除函数;removeChangeListener:function(callback){  this.removeListener(CHANGE_EVENT,callback);}});//为store注册回调函数;CounterStore.dispatchToken = AppDispatcher.register(  (action)=&gt;{    if(action.type===ActionTypes.INCREMENT){      counterValues[action.counterCaption]++;      CounterStore.emitChange();    }else if(action.type===ActionTypes.DECREMENT){      counterValues[action.counterCaption]--;      CounterStore.emitChange();    }  });//定义导出接口;export default CounterStore;</code></pre><p><strong>dispatcher</strong></p><pre><code>import {Dispatcher} from  &#39;flux&#39;;//创建flux中的dispatcher,由flux框架控制为单例模式的;export default new Dispatcher();</code></pre><p><strong>components</strong></p><pre><code>//定义组件;import React, {Component, PropTypes} from &#39;react&#39;;import * as Actions from &#39;../actions/Actions&#39;;import CounterStore from &#39;../stores/CounterStore&#39;;const buttonStyle = {  margin: &#39;10px&#39;};//定义组件的主体部分;class Counter extends Component {  constructor(props) {    super(props);    //绑定this到成员函数;    this.onChange = this.onChange.bind(this);    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);    //获取组件的初始状态;    this.state = {      count: CounterStore.getCounterValues()[props.caption]    }  }  //使用shouldComponentUpdate函数增加组件的渲染速度;  //因为当事件发射器发射事件后，所有监听该事件的组件中的主句或者状态将被更新，this.setState函数将被调用,采用shouldComponentUpdate  //函数进行判断可以提高组件的渲染效率;  shouldComponentUpdate(nextProps, nextState) {    return (nextProps.caption !== this.props.caption) || (nextState.count !== this.state.count);  }  //组件成功挂载到dom上之后添加事件的监听;  componentDidMount() {    CounterStore.addChangeListener(this.onChange);  }  //组件被移除后对应的监听也应该被移除;  componentWillUnmount(callback) {    CounterStore.removeChangeListener(this.onChange);  }  //更新组件的状态;  onChange() {    //同步store中的数据到组件中;    const newCount = CounterStore.getCounterValues()[this.props.caption];    this.setState({count: newCount});  }  onClickIncrementButton() {    Actions.increment(this.props.caption);  }  onClickDecrementButton() {    Actions.decrement(this.props.caption);  }  render() {    const {caption} = this.props;    return (&lt;div&gt;      &lt;span&gt;JunJun的计算器&lt;/span&gt;      &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;      &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;      &lt;span&gt;{caption}count:{this.state.count}&lt;/span&gt;    &lt;/div&gt;);  }}//约束组件的属性类型;Counter.propTypes = {  caption: PropTypes.string.isRequired};//声明组件的引用接口;export default Counter;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 老博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>会不会因为这个错过一段美好的爱情？</title>
      <link href="/2017/12/22/xiang-ce/hui-bu-hui-yin-wei-zhe-ge-cuo-guo-yi-duan-mei-hao-de-ai-qing/"/>
      <url>/2017/12/22/xiang-ce/hui-bu-hui-yin-wei-zhe-ge-cuo-guo-yi-duan-mei-hao-de-ai-qing/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49686961-20fc9f80-fb37-11e8-9c00-1d6e240cbf5a.jpg" alt="在这里插入图片描述"></p><p>会不会因为这个错过一段美好的爱情,如果不努力，有什么资格谈论爱情呢。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>今天平安夜，公司发了平安果，好贴心</title>
      <link href="/2017/12/22/xiang-ce/jin-tian-ping-an-ye-gong-si-fa-liao-ping-an-guo-hao-tie-xin/"/>
      <url>/2017/12/22/xiang-ce/jin-tian-ping-an-ye-gong-si-fa-liao-ping-an-guo-hao-tie-xin/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49686930-bfd4cc00-fb36-11e8-9a70-9cac84af3c93.png" alt="在这里插入图片描述"></p><p>今天平安夜，公司发了平安果，好贴心。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>好美的杜鹃花</title>
      <link href="/2017/11/15/xiang-ce/hao-mei-de-du-juan-hua/"/>
      <url>/2017/11/15/xiang-ce/hao-mei-de-du-juan-hua/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49686990-936d7f80-fb37-11e8-964a-248cf0b82912.jpg" alt="在这里插入图片描述"></p><p>好美的杜鹃花，看到这些花，突然想起了我的发小，121…027，她好像喜欢桃花，好久没联系了，不知道她怎么样了。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AOP中的概念通知、切点、切面</title>
      <link href="/2017/11/07/lao-bo-ke/aop-zhong-de-gai-nian-tong-zhi-qie-dian-qie-mian/"/>
      <url>/2017/11/07/lao-bo-ke/aop-zhong-de-gai-nian-tong-zhi-qie-dian-qie-mian/</url>
      
        <content type="html"><![CDATA[<p><strong><strong>通知、增强处理（Advice）</strong></strong></p><hr><p>通知、增强处理（Advice） 就是你想要的功能，也就是上说的安全、事物、日子等。你给先定义好，然后再想用的地方用一下。包含Aspect的一段处理代码</p><p><strong><em>连接点（JoinPoint）</em></strong></p><hr><p>连接点（JoinPoint） 这个就更好解释了，就是spring允许你是通知（Advice）的地方，那可就真多了，基本每个方法的钱、后（两者都有也行），或抛出异常是时都可以是连接点，spring只支持方法连接点。其他如AspectJ还可以让你在构造器或属性注入时都行，不过那不是咱们关注的，只要记住，和方法有关的前前后后都是连接点。</p><p><strong><em>切入点（Pointcut）</em></strong> </p><hr><p>切入点（Pointcut） 上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有十几个连接点了对吧，但是你并不想在所有方法附件都使用通知（使用叫织入，下面再说），你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。</p><p><strong><em>切面（Aspect）</em></strong></p><hr><p>切面（Aspect） 切面是通知和切入点的结合。现在发现了吧，没连接点什么事，链接点就是为了让你好理解切点搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的befor，after，around等就能知道），二切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p><hr><blockquote><p>引入（introduction）</p><p>引入（introduction） 允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗</p></blockquote><hr><blockquote><p>目标（target）</p><p>目标（target）<br>引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咋们织入切面。二自己专注于业务本身的逻辑。</p></blockquote><hr><blockquote><p>代理（proxy）</p><p>代理（proxy） 怎么实现整套AOP机制的，都是通过代理，这个一会儿给细说。</p></blockquote><hr><blockquote><p>织入（weaving）</p><p>织入（weaving） 把切面应用到目标对象来创建新的代理对象的过程。</p></blockquote><pre><code>目标对象 – 项目原始的Java组件。</code></pre><pre><code>AOP代理  – 由AOP框架生成java对象。</code></pre><pre><code>AOP代理方法 = advice +　目标对象的方法。</code></pre><p>example :</p><pre><code>&lt;!-- 通知 --&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;!-- 传播行为 --&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;            &lt;tx:method name=&quot;query*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- 切面 --&gt;    &lt;aop:config&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot;[具体的增强逻辑，此处是事物，上面已经定义好了]            pointcut=&quot;execution(* cn.itcast.ssm.service.*.*(..))&quot; [增强逻辑的具体作用位置]/&gt;    &lt;/aop:config&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 老博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>B/S和C/S的含义及其区别</title>
      <link href="/2017/09/10/lao-bo-ke/b-s-he-c-s-de-han-yi-ji-qi-qu-bie/"/>
      <url>/2017/09/10/lao-bo-ke/b-s-he-c-s-de-han-yi-ji-qi-qu-bie/</url>
      
        <content type="html"><![CDATA[<hr><p>B/S结构，即Browser/Server(浏览器/服务器)结构，是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现，节约了开发成本，便于软件维护。<br>区别</p><blockquote><p>1、C/S是建立在局域网的基础上的。B/S是建立在广域网的基础上的，但并不是说B/S结构不能在局域网上使用。<br>2、<strong>B/S业务扩展简单方便，通过增加页面即可增加服务器功能。C/S的客户端还需要安装专用的客户端软件，不利于扩展。</strong><br>3、<strong>B/S维护简单方便。开发、维护等几乎所有工作也都集中在服务器端，当企业对网络应用进行升级时，只需更新服务器端的软件就可以，这减轻了异地用户系统维护与升级的成本。</strong><br><strong>4、B/S响应速度不及C/S；</strong><br><strong>5、B/S用户体验效果不是很理想</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 老博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS 中 nginx 负载均衡和反向代理的搭建</title>
      <link href="/2017/09/07/lao-bo-ke/centos-zhong-nginx-fu-zai-jun-heng-he-fan-xiang-dai-li-de-da-jian/"/>
      <url>/2017/09/07/lao-bo-ke/centos-zhong-nginx-fu-zai-jun-heng-he-fan-xiang-dai-li-de-da-jian/</url>
      
        <content type="html"><![CDATA[<p>请参照博客：<br>      (1.) <a href="http://blog.csdn.net/zjx86320/article/details/51730388" target="_blank" rel="noopener">Nginx的好处和原理</a><br>       (2.)<a href="https://nginx.org/download/" target="_blank" rel="noopener">nginx下载</a><br>       (3.)<em><a href="https://juejin.im/entry/57763aa21532bc0060d96284" target="_blank" rel="noopener">CentOS 中 nginx 负载均衡和反向代理的搭建；</a></em><br>       (4.)<a href="https://junzhou2016.github.io/2017/09/05/Linux%20%E4%B8%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86%E6%AD%A5%E9%AA%A4%EF%BC%88CentOS%EF%BC%89/">修改hosts</a><br>       (5.)<a href="https://crossoverjie.top/2016/09/20/Linux-normal2/" target="_blank" rel="noopener">Linux（二）服务器运行环境配置 </a></p>]]></content>
      
      
      <categories>
          
          <category> 老博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA判断一个URL是否有效</title>
      <link href="/2017/08/29/lao-bo-ke/yong-java-pan-duan-yi-ge-url-shi-fou-you-xiao/"/>
      <url>/2017/08/29/lao-bo-ke/yong-java-pan-duan-yi-ge-url-shi-fou-you-xiao/</url>
      
        <content type="html"><![CDATA[<p>最近因项目需求，需要针对一些URL地址进行检测是否可用，使用Java.NET 下的类来实现，主要用到了 URL和HttpURLConnection 二个类 ，URL 是统一资源标识符的引用，一个URL实例代表着一个url的引用，开始使用了URL中的的openStream()方法，这样使用倒是可以，但是速度慢，代码如下：</p><hr><p>[java] view plain copy<br>try {<br>     url = new URL(“<a href="http://127.0.0.1/sj/user/getUser&quot;)" target="_blank" rel="noopener">http://127.0.0.1/sj/user/getUser&quot;)</a>;<br>     in = url.openStream();<br>} catch (Exception e1) {<br>     System.out.println(“连接打不开!”);<br>     url = null;<br>}  </p><p>下面判断url是不是null就可以了，速度慢<br>最后使用了HttpURLConnection 中的 getResponseCode（）；方法，HttpURLConnection ： 通常一个HttpURLConnection 的实例可以生成一个请求，它有个方法 getResponseCode（）；可以得到请求的响应状态，该方法返回一个 int 分别是 200 and 404 如无法从响应中识别任何代码则返回 -1，代码如下：</p><hr><p>[java] view plain copy<br>/** </p><ul><li>文件名称为：URLAvailability.java </li><li>文件功能简述： 描述一个URL地址是否有效 </li><li>@author Jason </li><li>@time   2010-9-14  </li><li>*/<br>public class URLAvailability {<br>private static URL url;<br>private static HttpURLConnection con;<br>private static int state = -1;  </li></ul><p>/** </p><ul><li>功能：检测当前URL是否可连接或是否有效, </li><li>描述：最多连接网络 5 次, 如果 5 次都不成功，视为该地址不可用 </li><li>@param urlStr 指定URL网络地址 </li><li>@return URL<br>*/<br>public synchronized URL isConnect(String urlStr) {<br>int counts = 0;<br>if (urlStr == null || urlStr.length() &lt;= 0) {<br>return null;<br>}<br>while (counts &lt; 5) {<br>try {<br>url = new URL(urlStr);<br>con = (HttpURLConnection) url.openConnection();<br>state = con.getResponseCode();<br>System.out.println(counts +”= “+state);<br>if (state == 200) {<br> System.out.println(“URL可用！”);<br>}<br>break;<br>}catch (Exception ex) {<br>counts++;<br>System.out.println(“URL不可用，连接第 “+counts+” 次”);<br>urlStr = null;<br>continue;<br>}<br>}<br>return url;<br>}<br>}  </li></ul><p>第二种方法速度很快，如果想返回json结果也是很容易的。</p>]]></content>
      
      
      <categories>
          
          <category> 老博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springmvc与struts2不同</title>
      <link href="/2017/08/29/lao-bo-ke/7.springmvc-yu-struts2-bu-tong/"/>
      <url>/2017/08/29/lao-bo-ke/7.springmvc-yu-struts2-bu-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="springmvc与struts2不同"><a href="#springmvc与struts2不同" class="headerlink" title="springmvc与struts2不同"></a>springmvc与struts2不同</h2><p>1、springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过滤器。</p><p>2、springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p><p>3.Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面。Jsp视图解析器默认使用jstl。</p>]]></content>
      
      
      <categories>
          
          <category> 老博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大学期间第一次出差</title>
      <link href="/2017/06/20/xiang-ce/da-xue-qi-jian-di-yi-ci-chu-chai/"/>
      <url>/2017/06/20/xiang-ce/da-xue-qi-jian-di-yi-ci-chu-chai/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/25767073/49686825-60c28780-fb35-11e8-8024-2798297d1aa1.png" alt="在这里插入图片描述"></p><p>大学期间第一次出差，去了新疆，好激动。晚上和老板吃饭的时候还遇到足浴店的川妹子，说实话，胖胖的还挺可爱的，冲我们招手，羞的我们跑开了。</p>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
